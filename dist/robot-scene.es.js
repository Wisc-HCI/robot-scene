import * as Or from "react";
import hh, { useReducer as v5, useRef as uo, useDebugValue as _N, useEffect as fh, useLayoutEffect as I3, useState as kb, useMemo as qb, createContext as OC, useContext as MM, forwardRef as a1, useCallback as Op, useImperativeHandle as g5, memo as QM, Suspense as y5 } from "react";
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const U0 = "143", ES = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, MS = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, bN = 0, BD = 1, wN = 2, x5 = 3, S5 = 0, B3 = 1, H3 = 2, Ib = 3, py = 0, uf = 1, Pp = 2, EN = 1, _5 = 2, cf = 0, L0 = 1, _C = 2, HD = 3, VD = 4, MN = 5, AS = 100, TN = 101, V3 = 102, GD = 103, WD = 104, CN = 200, RN = 201, AN = 202, DN = 203, UC = 204, zC = 205, LN = 206, PN = 207, ON = 208, UN = 209, zN = 210, NN = 0, FN = 1, kN = 2, bC = 3, IN = 4, BN = 5, HN = 6, VN = 7, ZM = 0, GN = 1, WN = 2, rg = 0, jN = 1, YN = 2, XN = 3, G3 = 4, qN = 5, NC = 300, t1 = 301, n1 = 302, TM = 303, CM = 304, dw = 306, Qb = 1e3, Wh = 1001, RM = 1002, co = 1003, wC = 1004, b5 = 1004, EC = 1005, w5 = 1005, Po = 1006, W3 = 1007, E5 = 1007, s1 = 1008, M5 = 1008, Gf = 1009, QN = 1010, ZN = 1011, j3 = 1012, JN = 1013, D0 = 1014, uy = 1015, GS = 1016, KN = 1017, $N = 1018, Kx = 1020, eF = 1021, tF = 1022, Sm = 1023, nF = 1024, rF = 1025, $x = 1026, r1 = 1027, iF = 1028, aF = 1029, sF = 1030, oF = 1031, lF = 1033, uC = 33776, cC = 33777, fC = 33778, dC = 33779, jD = 35840, YD = 35841, XD = 35842, qD = 35843, uF = 36196, QD = 37492, ZD = 37496, JD = 37808, KD = 37809, $D = 37810, e3 = 37811, t3 = 37812, n3 = 37813, r3 = 37814, i3 = 37815, a3 = 37816, s3 = 37817, o3 = 37818, l3 = 37819, u3 = 37820, c3 = 37821, f3 = 36492, cF = 2200, fF = 2201, dF = 2202, AM = 2300, DM = 2301, hC = 2302, LS = 2400, PS = 2401, LM = 2402, FC = 2500, Y3 = 2501, T5 = 0, C5 = 1, R5 = 2, yv = 3e3, Mi = 3001, o1 = 3200, Zb = 3201, qS = 0, hF = 1, A5 = "", sy = "srgb", Jx = "srgb-linear", D5 = 0, pC = 7680, L5 = 7681, P5 = 7682, O5 = 7683, U5 = 34055, z5 = 34056, N5 = 5386, F5 = 512, k5 = 513, I5 = 514, B5 = 515, H5 = 516, V5 = 517, G5 = 518, pF = 519, PM = 35044, W5 = 35048, j5 = 35040, Y5 = 35045, X5 = 35049, q5 = 35041, Q5 = 35046, Z5 = 35050, J5 = 35042, K5 = "100", d3 = "300 es", MC = 1035;
class Mm {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
      e.target = null;
    }
  }
}
const oh = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let AO = 1234567;
const NS = Math.PI / 180, OM = 180 / Math.PI;
function bm() {
  const a = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (oh[a & 255] + oh[a >> 8 & 255] + oh[a >> 16 & 255] + oh[a >> 24 & 255] + "-" + oh[e & 255] + oh[e >> 8 & 255] + "-" + oh[e >> 16 & 15 | 64] + oh[e >> 24 & 255] + "-" + oh[t & 63 | 128] + oh[t >> 8 & 255] + "-" + oh[t >> 16 & 255] + oh[t >> 24 & 255] + oh[r & 255] + oh[r >> 8 & 255] + oh[r >> 16 & 255] + oh[r >> 24 & 255]).toLowerCase();
}
function Qu(a, e, t) {
  return Math.max(e, Math.min(t, a));
}
function X3(a, e) {
  return (a % e + e) % e;
}
function $5(a, e, t, r, i) {
  return r + (a - e) * (i - r) / (t - e);
}
function eH(a, e, t) {
  return a !== e ? (t - a) / (e - a) : 0;
}
function yM(a, e, t) {
  return (1 - t) * a + t * e;
}
function tH(a, e, t, r) {
  return yM(a, e, 1 - Math.exp(-t * r));
}
function nH(a, e = 1) {
  return e - Math.abs(X3(a, e * 2) - e);
}
function rH(a, e, t) {
  return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * (3 - 2 * a));
}
function iH(a, e, t) {
  return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * a * (a * (a * 6 - 15) + 10));
}
function aH(a, e) {
  return a + Math.floor(Math.random() * (e - a + 1));
}
function sH(a, e) {
  return a + Math.random() * (e - a);
}
function oH(a) {
  return a * (0.5 - Math.random());
}
function lH(a) {
  a !== void 0 && (AO = a);
  let e = AO += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function uH(a) {
  return a * NS;
}
function cH(a) {
  return a * OM;
}
function h3(a) {
  return (a & a - 1) === 0 && a !== 0;
}
function mF(a) {
  return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
}
function TC(a) {
  return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
}
function fH(a, e, t, r, i) {
  const o = Math.cos, l = Math.sin, d = o(t / 2), h = l(t / 2), m = o((e + r) / 2), S = l((e + r) / 2), _ = o((e - r) / 2), T = l((e - r) / 2), C = o((r - e) / 2), D = l((r - e) / 2);
  switch (i) {
    case "XYX":
      a.set(d * S, h * _, h * T, d * m);
      break;
    case "YZY":
      a.set(h * T, d * S, h * _, d * m);
      break;
    case "ZXZ":
      a.set(h * _, h * T, d * S, d * m);
      break;
    case "XZX":
      a.set(d * S, h * D, h * C, d * m);
      break;
    case "YXY":
      a.set(h * C, d * S, h * D, d * m);
      break;
    case "ZYZ":
      a.set(h * D, h * C, d * S, d * m);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function dH(a, e) {
  switch (e.constructor) {
    case Float32Array:
      return a;
    case Uint16Array:
      return a / 65535;
    case Uint8Array:
      return a / 255;
    case Int16Array:
      return Math.max(a / 32767, -1);
    case Int8Array:
      return Math.max(a / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function hH(a, e) {
  switch (e.constructor) {
    case Float32Array:
      return a;
    case Uint16Array:
      return Math.round(a * 65535);
    case Uint8Array:
      return Math.round(a * 255);
    case Int16Array:
      return Math.round(a * 32767);
    case Int8Array:
      return Math.round(a * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var vF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD: NS,
  RAD2DEG: OM,
  generateUUID: bm,
  clamp: Qu,
  euclideanModulo: X3,
  mapLinear: $5,
  inverseLerp: eH,
  lerp: yM,
  damp: tH,
  pingpong: nH,
  smoothstep: rH,
  smootherstep: iH,
  randInt: aH,
  randFloat: sH,
  randFloatSpread: oH,
  seededRandom: lH,
  degToRad: uH,
  radToDeg: cH,
  isPowerOfTwo: h3,
  ceilPowerOfTwo: mF,
  floorPowerOfTwo: TC,
  setQuaternionFromProperEuler: fH,
  normalize: hH,
  denormalize: dH
});
class Ft {
  constructor(e = 0, t = 0) {
    Ft.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * r + i[6], this.y = i[1] * t + i[4] * r + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), i = Math.sin(t), o = this.x - e.x, l = this.y - e.y;
    return this.x = o * r - l * i + e.x, this.y = o * i + l * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class jh {
  constructor() {
    jh.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, r, i, o, l, d, h, m) {
    const S = this.elements;
    return S[0] = e, S[1] = i, S[2] = d, S[3] = t, S[4] = o, S[5] = h, S[6] = r, S[7] = l, S[8] = m, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, o = this.elements, l = r[0], d = r[3], h = r[6], m = r[1], S = r[4], _ = r[7], T = r[2], C = r[5], D = r[8], P = i[0], U = i[3], B = i[6], k = i[1], V = i[4], I = i[7], X = i[2], J = i[5], $ = i[8];
    return o[0] = l * P + d * k + h * X, o[3] = l * U + d * V + h * J, o[6] = l * B + d * I + h * $, o[1] = m * P + S * k + _ * X, o[4] = m * U + S * V + _ * J, o[7] = m * B + S * I + _ * $, o[2] = T * P + C * k + D * X, o[5] = T * U + C * V + D * J, o[8] = T * B + C * I + D * $, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], l = e[4], d = e[5], h = e[6], m = e[7], S = e[8];
    return t * l * S - t * d * m - r * o * S + r * d * h + i * o * m - i * l * h;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], l = e[4], d = e[5], h = e[6], m = e[7], S = e[8], _ = S * l - d * m, T = d * h - S * o, C = m * o - l * h, D = t * _ + r * T + i * C;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / D;
    return e[0] = _ * P, e[1] = (i * m - S * r) * P, e[2] = (d * r - i * l) * P, e[3] = T * P, e[4] = (S * t - i * h) * P, e[5] = (i * o - d * t) * P, e[6] = C * P, e[7] = (r * h - m * t) * P, e[8] = (l * t - r * o) * P, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, i, o, l, d) {
    const h = Math.cos(o), m = Math.sin(o);
    return this.set(
      r * h,
      r * m,
      -r * (h * l + m * d) + l + e,
      -i * m,
      i * h,
      -i * (-m * l + h * d) + d + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const r = this.elements;
    return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), r = Math.sin(e), i = this.elements, o = i[0], l = i[3], d = i[6], h = i[1], m = i[4], S = i[7];
    return i[0] = t * o + r * h, i[3] = t * l + r * m, i[6] = t * d + r * S, i[1] = -r * o + t * h, i[4] = -r * l + t * m, i[7] = -r * d + t * S, this;
  }
  translate(e, t) {
    const r = this.elements;
    return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== r[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function gF(a) {
  for (let e = a.length - 1; e >= 0; --e)
    if (a[e] > 65535)
      return !0;
  return !1;
}
const pH = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Bb(a, e) {
  return new pH[a](e);
}
function UM(a) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", a);
}
function FS(a) {
  return a < 0.04045 ? a * 0.0773993808 : Math.pow(a * 0.9478672986 + 0.0521327014, 2.4);
}
function mC(a) {
  return a < 31308e-7 ? a * 12.92 : 1.055 * Math.pow(a, 0.41666) - 0.055;
}
const wA = {
  [sy]: { [Jx]: FS },
  [Jx]: { [sy]: mC }
}, vv = {
  legacyMode: !0,
  get workingColorSpace() {
    return Jx;
  },
  set workingColorSpace(a) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(a, e, t) {
    if (this.legacyMode || e === t || !e || !t)
      return a;
    if (wA[e] && wA[e][t] !== void 0) {
      const r = wA[e][t];
      return a.r = r(a.r), a.g = r(a.g), a.b = r(a.b), a;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(a, e) {
    return this.convert(a, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(a, e) {
    return this.convert(a, e, this.workingColorSpace);
  }
}, yF = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, lf = { r: 0, g: 0, b: 0 }, Kv = { h: 0, s: 0, l: 0 }, o2 = { h: 0, s: 0, l: 0 };
function EA(a, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? a + (e - a) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? a + (e - a) * 6 * (2 / 3 - t) : a;
}
function l2(a, e) {
  return e.r = a.r, e.g = a.g, e.b = a.b, e;
}
class Pn {
  constructor(e, t, r) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = sy) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, vv.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, r, i = Jx) {
    return this.r = e, this.g = t, this.b = r, vv.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, r, i = Jx) {
    if (e = X3(e, 1), t = Qu(t, 0, 1), r = Qu(r, 0, 1), t === 0)
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + t) : r + t - r * t, l = 2 * r - o;
      this.r = EA(l, o, e + 1 / 3), this.g = EA(l, o, e), this.b = EA(l, o, e - 1 / 3);
    }
    return vv.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = sy) {
    function r(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let o;
      const l = i[1], d = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
            return this.r = Math.min(255, parseInt(o[1], 10)) / 255, this.g = Math.min(255, parseInt(o[2], 10)) / 255, this.b = Math.min(255, parseInt(o[3], 10)) / 255, vv.toWorkingColorSpace(this, t), r(o[4]), this;
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
            return this.r = Math.min(100, parseInt(o[1], 10)) / 100, this.g = Math.min(100, parseInt(o[2], 10)) / 100, this.b = Math.min(100, parseInt(o[3], 10)) / 100, vv.toWorkingColorSpace(this, t), r(o[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d)) {
            const h = parseFloat(o[1]) / 360, m = parseInt(o[2], 10) / 100, S = parseInt(o[3], 10) / 100;
            return r(o[4]), this.setHSL(h, m, S, t);
          }
          break;
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = i[1], l = o.length;
      if (l === 3)
        return this.r = parseInt(o.charAt(0) + o.charAt(0), 16) / 255, this.g = parseInt(o.charAt(1) + o.charAt(1), 16) / 255, this.b = parseInt(o.charAt(2) + o.charAt(2), 16) / 255, vv.toWorkingColorSpace(this, t), this;
      if (l === 6)
        return this.r = parseInt(o.charAt(0) + o.charAt(1), 16) / 255, this.g = parseInt(o.charAt(2) + o.charAt(3), 16) / 255, this.b = parseInt(o.charAt(4) + o.charAt(5), 16) / 255, vv.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = sy) {
    const r = yF[e.toLowerCase()];
    return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = FS(e.r), this.g = FS(e.g), this.b = FS(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = mC(e.r), this.g = mC(e.g), this.b = mC(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = sy) {
    return vv.fromWorkingColorSpace(l2(this, lf), e), Qu(lf.r * 255, 0, 255) << 16 ^ Qu(lf.g * 255, 0, 255) << 8 ^ Qu(lf.b * 255, 0, 255) << 0;
  }
  getHexString(e = sy) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Jx) {
    vv.fromWorkingColorSpace(l2(this, lf), t);
    const r = lf.r, i = lf.g, o = lf.b, l = Math.max(r, i, o), d = Math.min(r, i, o);
    let h, m;
    const S = (d + l) / 2;
    if (d === l)
      h = 0, m = 0;
    else {
      const _ = l - d;
      switch (m = S <= 0.5 ? _ / (l + d) : _ / (2 - l - d), l) {
        case r:
          h = (i - o) / _ + (i < o ? 6 : 0);
          break;
        case i:
          h = (o - r) / _ + 2;
          break;
        case o:
          h = (r - i) / _ + 4;
          break;
      }
      h /= 6;
    }
    return e.h = h, e.s = m, e.l = S, e;
  }
  getRGB(e, t = Jx) {
    return vv.fromWorkingColorSpace(l2(this, lf), t), e.r = lf.r, e.g = lf.g, e.b = lf.b, e;
  }
  getStyle(e = sy) {
    return vv.fromWorkingColorSpace(l2(this, lf), e), e !== sy ? `color(${e} ${lf.r} ${lf.g} ${lf.b})` : `rgb(${lf.r * 255 | 0},${lf.g * 255 | 0},${lf.b * 255 | 0})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Kv), Kv.h += e, Kv.s += t, Kv.l += r, this.setHSL(Kv.h, Kv.s, Kv.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, r) {
    return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Kv), e.getHSL(o2);
    const r = yM(Kv.h, o2.h, t), i = yM(Kv.s, o2.s, t), o = yM(Kv.l, o2.l, t);
    return this.setHSL(r, i, o), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
Pn.NAMES = yF;
let vb;
class q3 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      vb === void 0 && (vb = UM("canvas")), vb.width = e.width, vb.height = e.height;
      const r = vb.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = vb;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = UM("canvas");
      t.width = e.width, t.height = e.height;
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height), o = i.data;
      for (let l = 0; l < o.length; l++)
        o[l] = FS(o[l] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(FS(t[r] / 255) * 255) : t[r] = FS(t[r]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class OS {
  constructor(e = null) {
    this.isSource = !0, this.uuid = bm(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const r = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let l = 0, d = i.length; l < d; l++)
          i[l].isDataTexture ? o.push(MA(i[l].image)) : o.push(MA(i[l]));
      } else
        o = MA(i);
      r.url = o;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function MA(a) {
  return typeof HTMLImageElement < "u" && a instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && a instanceof ImageBitmap ? q3.getDataURL(a) : a.data ? {
    data: Array.from(a.data),
    width: a.width,
    height: a.height,
    type: a.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let mH = 0;
class iu extends Mm {
  constructor(e = iu.DEFAULT_IMAGE, t = iu.DEFAULT_MAPPING, r = Wh, i = Wh, o = Po, l = s1, d = Sm, h = Gf, m = 1, S = yv) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: mH++ }), this.uuid = bm(), this.name = "", this.source = new OS(e), this.mipmaps = [], this.mapping = t, this.wrapS = r, this.wrapT = i, this.magFilter = o, this.minFilter = l, this.anisotropy = m, this.format = d, this.internalFormat = null, this.type = h, this.offset = new Ft(0, 0), this.repeat = new Ft(1, 1), this.center = new Ft(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new jh(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = S, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const r = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== NC)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Qb:
          e.x = e.x - Math.floor(e.x);
          break;
        case Wh:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case RM:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Qb:
          e.y = e.y - Math.floor(e.y);
          break;
        case Wh:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case RM:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
iu.DEFAULT_IMAGE = null;
iu.DEFAULT_MAPPING = NC;
class la {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    la.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return this.x = e, this.y = t, this.z = r, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, o = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * r + l[8] * i + l[12] * o, this.y = l[1] * t + l[5] * r + l[9] * i + l[13] * o, this.z = l[2] * t + l[6] * r + l[10] * i + l[14] * o, this.w = l[3] * t + l[7] * r + l[11] * i + l[15] * o, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, o;
    const h = e.elements, m = h[0], S = h[4], _ = h[8], T = h[1], C = h[5], D = h[9], P = h[2], U = h[6], B = h[10];
    if (Math.abs(S - T) < 0.01 && Math.abs(_ - P) < 0.01 && Math.abs(D - U) < 0.01) {
      if (Math.abs(S + T) < 0.1 && Math.abs(_ + P) < 0.1 && Math.abs(D + U) < 0.1 && Math.abs(m + C + B - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const V = (m + 1) / 2, I = (C + 1) / 2, X = (B + 1) / 2, J = (S + T) / 4, $ = (_ + P) / 4, W = (D + U) / 4;
      return V > I && V > X ? V < 0.01 ? (r = 0, i = 0.707106781, o = 0.707106781) : (r = Math.sqrt(V), i = J / r, o = $ / r) : I > X ? I < 0.01 ? (r = 0.707106781, i = 0, o = 0.707106781) : (i = Math.sqrt(I), r = J / i, o = W / i) : X < 0.01 ? (r = 0.707106781, i = 0.707106781, o = 0) : (o = Math.sqrt(X), r = $ / o, i = W / o), this.set(r, i, o, t), this;
    }
    let k = Math.sqrt((U - D) * (U - D) + (_ - P) * (_ - P) + (T - S) * (T - S));
    return Math.abs(k) < 1e-3 && (k = 1), this.x = (U - D) / k, this.y = (_ - P) / k, this.z = (T - S) / k, this.w = Math.acos((m + C + B - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class po extends Mm {
  constructor(e, t, r = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new la(0, 0, e, t), this.scissorTest = !1, this.viewport = new la(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    this.texture = new iu(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : Po, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0;
  }
  setSize(e, t, r = 1) {
    (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new OS(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class JM extends iu {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = co, this.minFilter = co, this.wrapR = Wh, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class vH extends po {
  constructor(e, t, r) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new JM(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class kC extends iu {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = co, this.minFilter = co, this.wrapR = Wh, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class gH extends po {
  constructor(e, t, r) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new kC(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class yH extends po {
  constructor(e, t, r, i = {}) {
    super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
    const o = this.texture;
    this.texture = [];
    for (let l = 0; l < r; l++)
      this.texture[l] = o.clone(), this.texture[l].isRenderTargetTexture = !0;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      this.width = e, this.height = t, this.depth = r;
      for (let i = 0, o = this.texture.length; i < o; i++)
        this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = r;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, r = e.texture.length; t < r; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Ko {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = i;
  }
  static slerpFlat(e, t, r, i, o, l, d) {
    let h = r[i + 0], m = r[i + 1], S = r[i + 2], _ = r[i + 3];
    const T = o[l + 0], C = o[l + 1], D = o[l + 2], P = o[l + 3];
    if (d === 0) {
      e[t + 0] = h, e[t + 1] = m, e[t + 2] = S, e[t + 3] = _;
      return;
    }
    if (d === 1) {
      e[t + 0] = T, e[t + 1] = C, e[t + 2] = D, e[t + 3] = P;
      return;
    }
    if (_ !== P || h !== T || m !== C || S !== D) {
      let U = 1 - d;
      const B = h * T + m * C + S * D + _ * P, k = B >= 0 ? 1 : -1, V = 1 - B * B;
      if (V > Number.EPSILON) {
        const X = Math.sqrt(V), J = Math.atan2(X, B * k);
        U = Math.sin(U * J) / X, d = Math.sin(d * J) / X;
      }
      const I = d * k;
      if (h = h * U + T * I, m = m * U + C * I, S = S * U + D * I, _ = _ * U + P * I, U === 1 - d) {
        const X = 1 / Math.sqrt(h * h + m * m + S * S + _ * _);
        h *= X, m *= X, S *= X, _ *= X;
      }
    }
    e[t] = h, e[t + 1] = m, e[t + 2] = S, e[t + 3] = _;
  }
  static multiplyQuaternionsFlat(e, t, r, i, o, l) {
    const d = r[i], h = r[i + 1], m = r[i + 2], S = r[i + 3], _ = o[l], T = o[l + 1], C = o[l + 2], D = o[l + 3];
    return e[t] = d * D + S * _ + h * C - m * T, e[t + 1] = h * D + S * T + m * _ - d * C, e[t + 2] = m * D + S * C + d * T - h * _, e[t + 3] = S * D - d * _ - h * T - m * C, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, i) {
    return this._x = e, this._y = t, this._z = r, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const r = e._x, i = e._y, o = e._z, l = e._order, d = Math.cos, h = Math.sin, m = d(r / 2), S = d(i / 2), _ = d(o / 2), T = h(r / 2), C = h(i / 2), D = h(o / 2);
    switch (l) {
      case "XYZ":
        this._x = T * S * _ + m * C * D, this._y = m * C * _ - T * S * D, this._z = m * S * D + T * C * _, this._w = m * S * _ - T * C * D;
        break;
      case "YXZ":
        this._x = T * S * _ + m * C * D, this._y = m * C * _ - T * S * D, this._z = m * S * D - T * C * _, this._w = m * S * _ + T * C * D;
        break;
      case "ZXY":
        this._x = T * S * _ - m * C * D, this._y = m * C * _ + T * S * D, this._z = m * S * D + T * C * _, this._w = m * S * _ - T * C * D;
        break;
      case "ZYX":
        this._x = T * S * _ - m * C * D, this._y = m * C * _ + T * S * D, this._z = m * S * D - T * C * _, this._w = m * S * _ + T * C * D;
        break;
      case "YZX":
        this._x = T * S * _ + m * C * D, this._y = m * C * _ + T * S * D, this._z = m * S * D - T * C * _, this._w = m * S * _ - T * C * D;
        break;
      case "XZY":
        this._x = T * S * _ - m * C * D, this._y = m * C * _ - T * S * D, this._z = m * S * D + T * C * _, this._w = m * S * _ + T * C * D;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, i = Math.sin(r);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], i = t[4], o = t[8], l = t[1], d = t[5], h = t[9], m = t[2], S = t[6], _ = t[10], T = r + d + _;
    if (T > 0) {
      const C = 0.5 / Math.sqrt(T + 1);
      this._w = 0.25 / C, this._x = (S - h) * C, this._y = (o - m) * C, this._z = (l - i) * C;
    } else if (r > d && r > _) {
      const C = 2 * Math.sqrt(1 + r - d - _);
      this._w = (S - h) / C, this._x = 0.25 * C, this._y = (i + l) / C, this._z = (o + m) / C;
    } else if (d > _) {
      const C = 2 * Math.sqrt(1 + d - r - _);
      this._w = (o - m) / C, this._x = (i + l) / C, this._y = 0.25 * C, this._z = (h + S) / C;
    } else {
      const C = 2 * Math.sqrt(1 + _ - r - d);
      this._w = (l - i) / C, this._x = (o + m) / C, this._y = (h + S) / C, this._z = 0.25 * C;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Qu(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, i = e._y, o = e._z, l = e._w, d = t._x, h = t._y, m = t._z, S = t._w;
    return this._x = r * S + l * d + i * m - o * h, this._y = i * S + l * h + o * d - r * m, this._z = o * S + l * m + r * h - i * d, this._w = l * S - r * d - i * h - o * m, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, i = this._y, o = this._z, l = this._w;
    let d = l * e._w + r * e._x + i * e._y + o * e._z;
    if (d < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, d = -d) : this.copy(e), d >= 1)
      return this._w = l, this._x = r, this._y = i, this._z = o, this;
    const h = 1 - d * d;
    if (h <= Number.EPSILON) {
      const C = 1 - t;
      return this._w = C * l + t * this._w, this._x = C * r + t * this._x, this._y = C * i + t * this._y, this._z = C * o + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const m = Math.sqrt(h), S = Math.atan2(m, d), _ = Math.sin((1 - t) * S) / m, T = Math.sin(t * S) / m;
    return this._w = l * _ + this._w * T, this._x = r * _ + this._x * T, this._y = i * _ + this._y * T, this._z = o * _ + this._z * T, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), i = 2 * Math.PI * Math.random(), o = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      r * Math.sin(o),
      r * Math.cos(o),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ge {
  constructor(e = 0, t = 0, r = 0) {
    ge.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(DO.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(DO.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[3] * r + o[6] * i, this.y = o[1] * t + o[4] * r + o[7] * i, this.z = o[2] * t + o[5] * r + o[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, o = e.elements, l = 1 / (o[3] * t + o[7] * r + o[11] * i + o[15]);
    return this.x = (o[0] * t + o[4] * r + o[8] * i + o[12]) * l, this.y = (o[1] * t + o[5] * r + o[9] * i + o[13]) * l, this.z = (o[2] * t + o[6] * r + o[10] * i + o[14]) * l, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, i = this.z, o = e.x, l = e.y, d = e.z, h = e.w, m = h * t + l * i - d * r, S = h * r + d * t - o * i, _ = h * i + o * r - l * t, T = -o * t - l * r - d * i;
    return this.x = m * h + T * -o + S * -d - _ * -l, this.y = S * h + T * -l + _ * -o - m * -d, this.z = _ * h + T * -d + m * -l - S * -o, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[4] * r + o[8] * i, this.y = o[1] * t + o[5] * r + o[9] * i, this.z = o[2] * t + o[6] * r + o[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, i = e.y, o = e.z, l = t.x, d = t.y, h = t.z;
    return this.x = i * h - o * d, this.y = o * l - r * h, this.z = r * d - i * l, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return TA.copy(this).projectOnVector(e), this.sub(TA);
  }
  reflect(e) {
    return this.sub(TA.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Qu(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(r), this.y = Math.cos(t) * e, this.z = i * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const TA = /* @__PURE__ */ new ge(), DO = /* @__PURE__ */ new Ko();
class sg {
  constructor(e = new ge(1 / 0, 1 / 0, 1 / 0), t = new ge(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, r = 1 / 0, i = 1 / 0, o = -1 / 0, l = -1 / 0, d = -1 / 0;
    for (let h = 0, m = e.length; h < m; h += 3) {
      const S = e[h], _ = e[h + 1], T = e[h + 2];
      S < t && (t = S), _ < r && (r = _), T < i && (i = T), S > o && (o = S), _ > l && (l = _), T > d && (d = T);
    }
    return this.min.set(t, r, i), this.max.set(o, l, d), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, r = 1 / 0, i = 1 / 0, o = -1 / 0, l = -1 / 0, d = -1 / 0;
    for (let h = 0, m = e.count; h < m; h++) {
      const S = e.getX(h), _ = e.getY(h), T = e.getZ(h);
      S < t && (t = S), _ < r && (r = _), T < i && (i = T), S > o && (o = S), _ > l && (l = _), T > d && (d = T);
    }
    return this.min.set(t, r, i), this.max.set(o, l, d), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = pS.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0)
      if (t && r.attributes != null && r.attributes.position !== void 0) {
        const o = r.attributes.position;
        for (let l = 0, d = o.count; l < d; l++)
          pS.fromBufferAttribute(o, l).applyMatrix4(e.matrixWorld), this.expandByPoint(pS);
      } else
        r.boundingBox === null && r.computeBoundingBox(), CA.copy(r.boundingBox), CA.applyMatrix4(e.matrixWorld), this.union(CA);
    const i = e.children;
    for (let o = 0, l = i.length; o < l; o++)
      this.expandByObject(i[o], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, pS), pS.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ZE), u2.subVectors(this.max, ZE), gb.subVectors(e.a, ZE), yb.subVectors(e.b, ZE), xb.subVectors(e.c, ZE), kx.subVectors(yb, gb), Ix.subVectors(xb, yb), mS.subVectors(gb, xb);
    let t = [
      0,
      -kx.z,
      kx.y,
      0,
      -Ix.z,
      Ix.y,
      0,
      -mS.z,
      mS.y,
      kx.z,
      0,
      -kx.x,
      Ix.z,
      0,
      -Ix.x,
      mS.z,
      0,
      -mS.x,
      -kx.y,
      kx.x,
      0,
      -Ix.y,
      Ix.x,
      0,
      -mS.y,
      mS.x,
      0
    ];
    return !RA(t, gb, yb, xb, u2) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !RA(t, gb, yb, xb, u2)) ? !1 : (c2.crossVectors(kx, Ix), t = [c2.x, c2.y, c2.z], RA(t, gb, yb, xb, u2));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return pS.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(pS).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (S0[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), S0[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), S0[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), S0[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), S0[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), S0[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), S0[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), S0[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(S0), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const S0 = [
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge()
], pS = /* @__PURE__ */ new ge(), CA = /* @__PURE__ */ new sg(), gb = /* @__PURE__ */ new ge(), yb = /* @__PURE__ */ new ge(), xb = /* @__PURE__ */ new ge(), kx = /* @__PURE__ */ new ge(), Ix = /* @__PURE__ */ new ge(), mS = /* @__PURE__ */ new ge(), ZE = /* @__PURE__ */ new ge(), u2 = /* @__PURE__ */ new ge(), c2 = /* @__PURE__ */ new ge(), vS = /* @__PURE__ */ new ge();
function RA(a, e, t, r, i) {
  for (let o = 0, l = a.length - 3; o <= l; o += 3) {
    vS.fromArray(a, o);
    const d = i.x * Math.abs(vS.x) + i.y * Math.abs(vS.y) + i.z * Math.abs(vS.z), h = e.dot(vS), m = t.dot(vS), S = r.dot(vS);
    if (Math.max(-Math.max(h, m, S), Math.min(h, m, S)) > d)
      return !1;
  }
  return !0;
}
const xH = /* @__PURE__ */ new sg(), LO = /* @__PURE__ */ new ge(), f2 = /* @__PURE__ */ new ge(), AA = /* @__PURE__ */ new ge();
class vy {
  constructor(e = new ge(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : xH.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, l = e.length; o < l; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    AA.subVectors(e, this.center);
    const t = AA.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), i = (r - this.radius) * 0.5;
      this.center.add(AA.multiplyScalar(i / r)), this.radius += i;
    }
    return this;
  }
  union(e) {
    return this.center.equals(e.center) === !0 ? f2.set(0, 0, 1).multiplyScalar(e.radius) : f2.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(LO.copy(e.center).add(f2)), this.expandByPoint(LO.copy(e.center).sub(f2)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _0 = /* @__PURE__ */ new ge(), DA = /* @__PURE__ */ new ge(), d2 = /* @__PURE__ */ new ge(), Bx = /* @__PURE__ */ new ge(), LA = /* @__PURE__ */ new ge(), h2 = /* @__PURE__ */ new ge(), PA = /* @__PURE__ */ new ge();
class KM {
  constructor(e = new ge(), t = new ge(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, _0)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = _0.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (_0.copy(this.direction).multiplyScalar(t).add(this.origin), _0.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    DA.copy(e).add(t).multiplyScalar(0.5), d2.copy(t).sub(e).normalize(), Bx.copy(this.origin).sub(DA);
    const o = e.distanceTo(t) * 0.5, l = -this.direction.dot(d2), d = Bx.dot(this.direction), h = -Bx.dot(d2), m = Bx.lengthSq(), S = Math.abs(1 - l * l);
    let _, T, C, D;
    if (S > 0)
      if (_ = l * h - d, T = l * d - h, D = o * S, _ >= 0)
        if (T >= -D)
          if (T <= D) {
            const P = 1 / S;
            _ *= P, T *= P, C = _ * (_ + l * T + 2 * d) + T * (l * _ + T + 2 * h) + m;
          } else
            T = o, _ = Math.max(0, -(l * T + d)), C = -_ * _ + T * (T + 2 * h) + m;
        else
          T = -o, _ = Math.max(0, -(l * T + d)), C = -_ * _ + T * (T + 2 * h) + m;
      else
        T <= -D ? (_ = Math.max(0, -(-l * o + d)), T = _ > 0 ? -o : Math.min(Math.max(-o, -h), o), C = -_ * _ + T * (T + 2 * h) + m) : T <= D ? (_ = 0, T = Math.min(Math.max(-o, -h), o), C = T * (T + 2 * h) + m) : (_ = Math.max(0, -(l * o + d)), T = _ > 0 ? o : Math.min(Math.max(-o, -h), o), C = -_ * _ + T * (T + 2 * h) + m);
    else
      T = l > 0 ? -o : o, _ = Math.max(0, -(l * T + d)), C = -_ * _ + T * (T + 2 * h) + m;
    return r && r.copy(this.direction).multiplyScalar(_).add(this.origin), i && i.copy(d2).multiplyScalar(T).add(DA), C;
  }
  intersectSphere(e, t) {
    _0.subVectors(e.center, this.origin);
    const r = _0.dot(this.direction), i = _0.dot(_0) - r * r, o = e.radius * e.radius;
    if (i > o)
      return null;
    const l = Math.sqrt(o - i), d = r - l, h = r + l;
    return d < 0 && h < 0 ? null : d < 0 ? this.at(h, t) : this.at(d, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, o, l, d, h;
    const m = 1 / this.direction.x, S = 1 / this.direction.y, _ = 1 / this.direction.z, T = this.origin;
    return m >= 0 ? (r = (e.min.x - T.x) * m, i = (e.max.x - T.x) * m) : (r = (e.max.x - T.x) * m, i = (e.min.x - T.x) * m), S >= 0 ? (o = (e.min.y - T.y) * S, l = (e.max.y - T.y) * S) : (o = (e.max.y - T.y) * S, l = (e.min.y - T.y) * S), r > l || o > i || ((o > r || r !== r) && (r = o), (l < i || i !== i) && (i = l), _ >= 0 ? (d = (e.min.z - T.z) * _, h = (e.max.z - T.z) * _) : (d = (e.max.z - T.z) * _, h = (e.min.z - T.z) * _), r > h || d > i) || ((d > r || r !== r) && (r = d), (h < i || i !== i) && (i = h), i < 0) ? null : this.at(r >= 0 ? r : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, _0) !== null;
  }
  intersectTriangle(e, t, r, i, o) {
    LA.subVectors(t, e), h2.subVectors(r, e), PA.crossVectors(LA, h2);
    let l = this.direction.dot(PA), d;
    if (l > 0) {
      if (i)
        return null;
      d = 1;
    } else if (l < 0)
      d = -1, l = -l;
    else
      return null;
    Bx.subVectors(this.origin, e);
    const h = d * this.direction.dot(h2.crossVectors(Bx, h2));
    if (h < 0)
      return null;
    const m = d * this.direction.dot(LA.cross(Bx));
    if (m < 0 || h + m > l)
      return null;
    const S = -d * Bx.dot(PA);
    return S < 0 ? null : this.at(S / l, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class si {
  constructor() {
    si.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, r, i, o, l, d, h, m, S, _, T, C, D, P, U) {
    const B = this.elements;
    return B[0] = e, B[4] = t, B[8] = r, B[12] = i, B[1] = o, B[5] = l, B[9] = d, B[13] = h, B[2] = m, B[6] = S, B[10] = _, B[14] = T, B[3] = C, B[7] = D, B[11] = P, B[15] = U, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new si().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, i = 1 / Sb.setFromMatrixColumn(e, 0).length(), o = 1 / Sb.setFromMatrixColumn(e, 1).length(), l = 1 / Sb.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * i, t[1] = r[1] * i, t[2] = r[2] * i, t[3] = 0, t[4] = r[4] * o, t[5] = r[5] * o, t[6] = r[6] * o, t[7] = 0, t[8] = r[8] * l, t[9] = r[9] * l, t[10] = r[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, i = e.y, o = e.z, l = Math.cos(r), d = Math.sin(r), h = Math.cos(i), m = Math.sin(i), S = Math.cos(o), _ = Math.sin(o);
    if (e.order === "XYZ") {
      const T = l * S, C = l * _, D = d * S, P = d * _;
      t[0] = h * S, t[4] = -h * _, t[8] = m, t[1] = C + D * m, t[5] = T - P * m, t[9] = -d * h, t[2] = P - T * m, t[6] = D + C * m, t[10] = l * h;
    } else if (e.order === "YXZ") {
      const T = h * S, C = h * _, D = m * S, P = m * _;
      t[0] = T + P * d, t[4] = D * d - C, t[8] = l * m, t[1] = l * _, t[5] = l * S, t[9] = -d, t[2] = C * d - D, t[6] = P + T * d, t[10] = l * h;
    } else if (e.order === "ZXY") {
      const T = h * S, C = h * _, D = m * S, P = m * _;
      t[0] = T - P * d, t[4] = -l * _, t[8] = D + C * d, t[1] = C + D * d, t[5] = l * S, t[9] = P - T * d, t[2] = -l * m, t[6] = d, t[10] = l * h;
    } else if (e.order === "ZYX") {
      const T = l * S, C = l * _, D = d * S, P = d * _;
      t[0] = h * S, t[4] = D * m - C, t[8] = T * m + P, t[1] = h * _, t[5] = P * m + T, t[9] = C * m - D, t[2] = -m, t[6] = d * h, t[10] = l * h;
    } else if (e.order === "YZX") {
      const T = l * h, C = l * m, D = d * h, P = d * m;
      t[0] = h * S, t[4] = P - T * _, t[8] = D * _ + C, t[1] = _, t[5] = l * S, t[9] = -d * S, t[2] = -m * S, t[6] = C * _ + D, t[10] = T - P * _;
    } else if (e.order === "XZY") {
      const T = l * h, C = l * m, D = d * h, P = d * m;
      t[0] = h * S, t[4] = -_, t[8] = m * S, t[1] = T * _ + P, t[5] = l * S, t[9] = C * _ - D, t[2] = D * _ - C, t[6] = d * S, t[10] = P * _ + T;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(SH, e, _H);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return gm.subVectors(e, t), gm.lengthSq() === 0 && (gm.z = 1), gm.normalize(), Hx.crossVectors(r, gm), Hx.lengthSq() === 0 && (Math.abs(r.z) === 1 ? gm.x += 1e-4 : gm.z += 1e-4, gm.normalize(), Hx.crossVectors(r, gm)), Hx.normalize(), p2.crossVectors(gm, Hx), i[0] = Hx.x, i[4] = p2.x, i[8] = gm.x, i[1] = Hx.y, i[5] = p2.y, i[9] = gm.y, i[2] = Hx.z, i[6] = p2.z, i[10] = gm.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, o = this.elements, l = r[0], d = r[4], h = r[8], m = r[12], S = r[1], _ = r[5], T = r[9], C = r[13], D = r[2], P = r[6], U = r[10], B = r[14], k = r[3], V = r[7], I = r[11], X = r[15], J = i[0], $ = i[4], W = i[8], ee = i[12], ie = i[1], pe = i[5], ce = i[9], Ee = i[13], de = i[2], Fe = i[6], Ce = i[10], Be = i[14], he = i[3], fe = i[7], ue = i[11], ye = i[15];
    return o[0] = l * J + d * ie + h * de + m * he, o[4] = l * $ + d * pe + h * Fe + m * fe, o[8] = l * W + d * ce + h * Ce + m * ue, o[12] = l * ee + d * Ee + h * Be + m * ye, o[1] = S * J + _ * ie + T * de + C * he, o[5] = S * $ + _ * pe + T * Fe + C * fe, o[9] = S * W + _ * ce + T * Ce + C * ue, o[13] = S * ee + _ * Ee + T * Be + C * ye, o[2] = D * J + P * ie + U * de + B * he, o[6] = D * $ + P * pe + U * Fe + B * fe, o[10] = D * W + P * ce + U * Ce + B * ue, o[14] = D * ee + P * Ee + U * Be + B * ye, o[3] = k * J + V * ie + I * de + X * he, o[7] = k * $ + V * pe + I * Fe + X * fe, o[11] = k * W + V * ce + I * Ce + X * ue, o[15] = k * ee + V * Ee + I * Be + X * ye, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], i = e[8], o = e[12], l = e[1], d = e[5], h = e[9], m = e[13], S = e[2], _ = e[6], T = e[10], C = e[14], D = e[3], P = e[7], U = e[11], B = e[15];
    return D * (+o * h * _ - i * m * _ - o * d * T + r * m * T + i * d * C - r * h * C) + P * (+t * h * C - t * m * T + o * l * T - i * l * C + i * m * S - o * h * S) + U * (+t * m * _ - t * d * C - o * l * _ + r * l * C + o * d * S - r * m * S) + B * (-i * d * S - t * h * _ + t * d * T + i * l * _ - r * l * T + r * h * S);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], o = e[3], l = e[4], d = e[5], h = e[6], m = e[7], S = e[8], _ = e[9], T = e[10], C = e[11], D = e[12], P = e[13], U = e[14], B = e[15], k = _ * U * m - P * T * m + P * h * C - d * U * C - _ * h * B + d * T * B, V = D * T * m - S * U * m - D * h * C + l * U * C + S * h * B - l * T * B, I = S * P * m - D * _ * m + D * d * C - l * P * C - S * d * B + l * _ * B, X = D * _ * h - S * P * h - D * d * T + l * P * T + S * d * U - l * _ * U, J = t * k + r * V + i * I + o * X;
    if (J === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const $ = 1 / J;
    return e[0] = k * $, e[1] = (P * T * o - _ * U * o - P * i * C + r * U * C + _ * i * B - r * T * B) * $, e[2] = (d * U * o - P * h * o + P * i * m - r * U * m - d * i * B + r * h * B) * $, e[3] = (_ * h * o - d * T * o - _ * i * m + r * T * m + d * i * C - r * h * C) * $, e[4] = V * $, e[5] = (S * U * o - D * T * o + D * i * C - t * U * C - S * i * B + t * T * B) * $, e[6] = (D * h * o - l * U * o - D * i * m + t * U * m + l * i * B - t * h * B) * $, e[7] = (l * T * o - S * h * o + S * i * m - t * T * m - l * i * C + t * h * C) * $, e[8] = I * $, e[9] = (D * _ * o - S * P * o - D * r * C + t * P * C + S * r * B - t * _ * B) * $, e[10] = (l * P * o - D * d * o + D * r * m - t * P * m - l * r * B + t * d * B) * $, e[11] = (S * d * o - l * _ * o - S * r * m + t * _ * m + l * r * C - t * d * C) * $, e[12] = X * $, e[13] = (S * P * i - D * _ * i + D * r * T - t * P * T - S * r * U + t * _ * U) * $, e[14] = (D * d * i - l * P * i - D * r * h + t * P * h + l * r * U - t * d * U) * $, e[15] = (l * _ * i - S * d * i + S * r * h - t * _ * h - l * r * T + t * d * T) * $, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, i = e.y, o = e.z;
    return t[0] *= r, t[4] *= i, t[8] *= o, t[1] *= r, t[5] *= i, t[9] *= o, t[2] *= r, t[6] *= i, t[10] *= o, t[3] *= r, t[7] *= i, t[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), i = Math.sin(t), o = 1 - r, l = e.x, d = e.y, h = e.z, m = o * l, S = o * d;
    return this.set(
      m * l + r,
      m * d - i * h,
      m * h + i * d,
      0,
      m * d + i * h,
      S * d + r,
      S * h - i * l,
      0,
      m * h - i * d,
      S * h + i * l,
      o * h * h + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, i, o, l) {
    return this.set(
      1,
      r,
      o,
      0,
      e,
      1,
      l,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const i = this.elements, o = t._x, l = t._y, d = t._z, h = t._w, m = o + o, S = l + l, _ = d + d, T = o * m, C = o * S, D = o * _, P = l * S, U = l * _, B = d * _, k = h * m, V = h * S, I = h * _, X = r.x, J = r.y, $ = r.z;
    return i[0] = (1 - (P + B)) * X, i[1] = (C + I) * X, i[2] = (D - V) * X, i[3] = 0, i[4] = (C - I) * J, i[5] = (1 - (T + B)) * J, i[6] = (U + k) * J, i[7] = 0, i[8] = (D + V) * $, i[9] = (U - k) * $, i[10] = (1 - (T + P)) * $, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, r) {
    const i = this.elements;
    let o = Sb.set(i[0], i[1], i[2]).length();
    const l = Sb.set(i[4], i[5], i[6]).length(), d = Sb.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), e.x = i[12], e.y = i[13], e.z = i[14], $v.copy(this);
    const m = 1 / o, S = 1 / l, _ = 1 / d;
    return $v.elements[0] *= m, $v.elements[1] *= m, $v.elements[2] *= m, $v.elements[4] *= S, $v.elements[5] *= S, $v.elements[6] *= S, $v.elements[8] *= _, $v.elements[9] *= _, $v.elements[10] *= _, t.setFromRotationMatrix($v), r.x = o, r.y = l, r.z = d, this;
  }
  makePerspective(e, t, r, i, o, l) {
    const d = this.elements, h = 2 * o / (t - e), m = 2 * o / (r - i), S = (t + e) / (t - e), _ = (r + i) / (r - i), T = -(l + o) / (l - o), C = -2 * l * o / (l - o);
    return d[0] = h, d[4] = 0, d[8] = S, d[12] = 0, d[1] = 0, d[5] = m, d[9] = _, d[13] = 0, d[2] = 0, d[6] = 0, d[10] = T, d[14] = C, d[3] = 0, d[7] = 0, d[11] = -1, d[15] = 0, this;
  }
  makeOrthographic(e, t, r, i, o, l) {
    const d = this.elements, h = 1 / (t - e), m = 1 / (r - i), S = 1 / (l - o), _ = (t + e) * h, T = (r + i) * m, C = (l + o) * S;
    return d[0] = 2 * h, d[4] = 0, d[8] = 0, d[12] = -_, d[1] = 0, d[5] = 2 * m, d[9] = 0, d[13] = -T, d[2] = 0, d[6] = 0, d[10] = -2 * S, d[14] = -C, d[3] = 0, d[7] = 0, d[11] = 0, d[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== r[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const Sb = /* @__PURE__ */ new ge(), $v = /* @__PURE__ */ new si(), SH = /* @__PURE__ */ new ge(0, 0, 0), _H = /* @__PURE__ */ new ge(1, 1, 1), Hx = /* @__PURE__ */ new ge(), p2 = /* @__PURE__ */ new ge(), gm = /* @__PURE__ */ new ge(), PO = /* @__PURE__ */ new si(), OO = /* @__PURE__ */ new Ko();
class QS {
  constructor(e = 0, t = 0, r = 0, i = QS.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements, o = i[0], l = i[4], d = i[8], h = i[1], m = i[5], S = i[9], _ = i[2], T = i[6], C = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Qu(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(-S, C), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(T, m), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Qu(S, -1, 1)), Math.abs(S) < 0.9999999 ? (this._y = Math.atan2(d, C), this._z = Math.atan2(h, m)) : (this._y = Math.atan2(-_, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Qu(T, -1, 1)), Math.abs(T) < 0.9999999 ? (this._y = Math.atan2(-_, C), this._z = Math.atan2(-l, m)) : (this._y = 0, this._z = Math.atan2(h, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Qu(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._x = Math.atan2(T, C), this._z = Math.atan2(h, o)) : (this._x = 0, this._z = Math.atan2(-l, m));
        break;
      case "YZX":
        this._z = Math.asin(Qu(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-S, m), this._y = Math.atan2(-_, o)) : (this._x = 0, this._y = Math.atan2(d, C));
        break;
      case "XZY":
        this._z = Math.asin(-Qu(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(T, m), this._y = Math.atan2(d, o)) : (this._x = Math.atan2(-S, C), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return PO.makeRotationFromQuaternion(e), this.setFromRotationMatrix(PO, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return OO.setFromEuler(this), this.setFromQuaternion(OO, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
QS.DefaultOrder = "XYZ";
QS.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class kS {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let bH = 0;
const UO = /* @__PURE__ */ new ge(), _b = /* @__PURE__ */ new Ko(), b0 = /* @__PURE__ */ new si(), m2 = /* @__PURE__ */ new ge(), JE = /* @__PURE__ */ new ge(), wH = /* @__PURE__ */ new ge(), EH = /* @__PURE__ */ new Ko(), zO = /* @__PURE__ */ new ge(1, 0, 0), NO = /* @__PURE__ */ new ge(0, 1, 0), FO = /* @__PURE__ */ new ge(0, 0, 1), MH = { type: "added" }, kO = { type: "removed" };
class Xa extends Mm {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: bH++ }), this.uuid = bm(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Xa.DefaultUp.clone();
    const e = new ge(), t = new QS(), r = new Ko(), i = new ge(1, 1, 1);
    function o() {
      r.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(o), r._onChange(l), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new si()
      },
      normalMatrix: {
        value: new jh()
      }
    }), this.matrix = new si(), this.matrixWorld = new si(), this.matrixAutoUpdate = Xa.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new kS(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return _b.setFromAxisAngle(e, t), this.quaternion.multiply(_b), this;
  }
  rotateOnWorldAxis(e, t) {
    return _b.setFromAxisAngle(e, t), this.quaternion.premultiply(_b), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(zO, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(NO, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(FO, e);
  }
  translateOnAxis(e, t) {
    return UO.copy(e).applyQuaternion(this.quaternion), this.position.add(UO.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(zO, e);
  }
  translateY(e) {
    return this.translateOnAxis(NO, e);
  }
  translateZ(e) {
    return this.translateOnAxis(FO, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(b0.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? m2.copy(e) : m2.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), JE.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? b0.lookAt(JE, m2, this.up) : b0.lookAt(m2, JE, this.up), this.quaternion.setFromRotationMatrix(b0), i && (b0.extractRotation(i.matrixWorld), _b.setFromRotationMatrix(b0), this.quaternion.premultiply(_b.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(MH)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(kO)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(kO);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), b0.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), b0.multiply(e.parent.matrixWorld)), e.applyMatrix4(b0), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const l = this.children[r].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(JE, e, wH), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(JE, EH, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let o = 0, l = i.length; o < l; o++)
        i[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
    function o(d, h) {
      return d[h.uuid] === void 0 && (d[h.uuid] = h.toJSON(e)), h.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const d = this.geometry.parameters;
      if (d !== void 0 && d.shapes !== void 0) {
        const h = d.shapes;
        if (Array.isArray(h))
          for (let m = 0, S = h.length; m < S; m++) {
            const _ = h[m];
            o(e.shapes, _);
          }
        else
          o(e.shapes, h);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const d = [];
        for (let h = 0, m = this.material.length; h < m; h++)
          d.push(o(e.materials, this.material[h]));
        i.material = d;
      } else
        i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let d = 0; d < this.children.length; d++)
        i.children.push(this.children[d].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let d = 0; d < this.animations.length; d++) {
        const h = this.animations[d];
        i.animations.push(o(e.animations, h));
      }
    }
    if (t) {
      const d = l(e.geometries), h = l(e.materials), m = l(e.textures), S = l(e.images), _ = l(e.shapes), T = l(e.skeletons), C = l(e.animations), D = l(e.nodes);
      d.length > 0 && (r.geometries = d), h.length > 0 && (r.materials = h), m.length > 0 && (r.textures = m), S.length > 0 && (r.images = S), _.length > 0 && (r.shapes = _), T.length > 0 && (r.skeletons = T), C.length > 0 && (r.animations = C), D.length > 0 && (r.nodes = D);
    }
    return r.object = i, r;
    function l(d) {
      const h = [];
      for (const m in d) {
        const S = d[m];
        delete S.metadata, h.push(S);
      }
      return h;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
Xa.DefaultUp = /* @__PURE__ */ new ge(0, 1, 0);
Xa.DefaultMatrixAutoUpdate = !0;
const eg = /* @__PURE__ */ new ge(), w0 = /* @__PURE__ */ new ge(), OA = /* @__PURE__ */ new ge(), E0 = /* @__PURE__ */ new ge(), bb = /* @__PURE__ */ new ge(), wb = /* @__PURE__ */ new ge(), IO = /* @__PURE__ */ new ge(), UA = /* @__PURE__ */ new ge(), zA = /* @__PURE__ */ new ge(), NA = /* @__PURE__ */ new ge();
class xm {
  constructor(e = new ge(), t = new ge(), r = new ge()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), eg.subVectors(e, t), i.cross(eg);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, o) {
    eg.subVectors(i, t), w0.subVectors(r, t), OA.subVectors(e, t);
    const l = eg.dot(eg), d = eg.dot(w0), h = eg.dot(OA), m = w0.dot(w0), S = w0.dot(OA), _ = l * m - d * d;
    if (_ === 0)
      return o.set(-2, -1, -1);
    const T = 1 / _, C = (m * h - d * S) * T, D = (l * S - d * h) * T;
    return o.set(1 - C - D, D, C);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, E0), E0.x >= 0 && E0.y >= 0 && E0.x + E0.y <= 1;
  }
  static getUV(e, t, r, i, o, l, d, h) {
    return this.getBarycoord(e, t, r, i, E0), h.set(0, 0), h.addScaledVector(o, E0.x), h.addScaledVector(l, E0.y), h.addScaledVector(d, E0.z), h;
  }
  static isFrontFacing(e, t, r, i) {
    return eg.subVectors(r, t), w0.subVectors(e, t), eg.cross(w0).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return eg.subVectors(this.c, this.b), w0.subVectors(this.a, this.b), eg.cross(w0).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return xm.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return xm.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, i, o) {
    return xm.getUV(e, this.a, this.b, this.c, t, r, i, o);
  }
  containsPoint(e) {
    return xm.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return xm.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, i = this.b, o = this.c;
    let l, d;
    bb.subVectors(i, r), wb.subVectors(o, r), UA.subVectors(e, r);
    const h = bb.dot(UA), m = wb.dot(UA);
    if (h <= 0 && m <= 0)
      return t.copy(r);
    zA.subVectors(e, i);
    const S = bb.dot(zA), _ = wb.dot(zA);
    if (S >= 0 && _ <= S)
      return t.copy(i);
    const T = h * _ - S * m;
    if (T <= 0 && h >= 0 && S <= 0)
      return l = h / (h - S), t.copy(r).addScaledVector(bb, l);
    NA.subVectors(e, o);
    const C = bb.dot(NA), D = wb.dot(NA);
    if (D >= 0 && C <= D)
      return t.copy(o);
    const P = C * m - h * D;
    if (P <= 0 && m >= 0 && D <= 0)
      return d = m / (m - D), t.copy(r).addScaledVector(wb, d);
    const U = S * D - C * _;
    if (U <= 0 && _ - S >= 0 && C - D >= 0)
      return IO.subVectors(o, i), d = (_ - S) / (_ - S + (C - D)), t.copy(i).addScaledVector(IO, d);
    const B = 1 / (U + P + T);
    return l = P * B, d = T * B, t.copy(r).addScaledVector(bb, l).addScaledVector(wb, d);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let TH = 0;
class ff extends Mm {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: TH++ }), this.uuid = bm(), this.name = "", this.type = "Material", this.blending = L0, this.side = py, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = UC, this.blendDst = zC, this.blendEquation = AS, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = bC, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = pF, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = pC, this.stencilZFail = pC, this.stencilZPass = pC, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r === EN;
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const r = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== L0 && (r.blending = this.blending), this.side !== py && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData);
    function i(o) {
      const l = [];
      for (const d in o) {
        const h = o[d];
        delete h.metadata, l.push(h);
      }
      return l;
    }
    if (t) {
      const o = i(e.textures), l = i(e.images);
      o.length > 0 && (r.textures = o), l.length > 0 && (r.images = l);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o)
        r[o] = t[o].clone();
    }
    return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class og extends ff {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Pn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ZM, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const xc = /* @__PURE__ */ new ge(), v2 = /* @__PURE__ */ new Ft();
class os {
  constructor(e, t, r) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r === !0, this.usage = PM, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, o = e.length; i < o; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), l = new Pn()), t[r++] = l.r, t[r++] = l.g, t[r++] = l.b;
    }
    return this;
  }
  copyVector2sArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, o = e.length; i < o; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), l = new Ft()), t[r++] = l.x, t[r++] = l.y;
    }
    return this;
  }
  copyVector3sArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, o = e.length; i < o; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), l = new ge()), t[r++] = l.x, t[r++] = l.y, t[r++] = l.z;
    }
    return this;
  }
  copyVector4sArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, o = e.length; i < o; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), l = new la()), t[r++] = l.x, t[r++] = l.y, t[r++] = l.z, t[r++] = l.w;
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        v2.fromBufferAttribute(this, t), v2.applyMatrix3(e), this.setXY(t, v2.x, v2.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        xc.fromBufferAttribute(this, t), xc.applyMatrix3(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xc.fromBufferAttribute(this, t), xc.applyMatrix4(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xc.fromBufferAttribute(this, t), xc.applyNormalMatrix(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xc.fromBufferAttribute(this, t), xc.transformDirection(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, t) {
    return this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, o) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== PM && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class CH extends os {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class RH extends os {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class AH extends os {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class DH extends os {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class Q3 extends os {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class LH extends os {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class Z3 extends os {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class PH extends os {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0;
  }
}
class sr extends os {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
class OH extends os {
  constructor(e, t, r) {
    super(new Float64Array(e), t, r);
  }
}
let UH = 0;
const pv = /* @__PURE__ */ new si(), FA = /* @__PURE__ */ new Xa(), Eb = /* @__PURE__ */ new ge(), ym = /* @__PURE__ */ new sg(), KE = /* @__PURE__ */ new sg(), Vf = /* @__PURE__ */ new ge();
class ui extends Mm {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: UH++ }), this.uuid = bm(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (gF(e) ? Z3 : Q3)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new jh().getNormalMatrix(e);
      r.applyNormalMatrix(o), r.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return pv.makeRotationFromQuaternion(e), this.applyMatrix4(pv), this;
  }
  rotateX(e) {
    return pv.makeRotationX(e), this.applyMatrix4(pv), this;
  }
  rotateY(e) {
    return pv.makeRotationY(e), this.applyMatrix4(pv), this;
  }
  rotateZ(e) {
    return pv.makeRotationZ(e), this.applyMatrix4(pv), this;
  }
  translate(e, t, r) {
    return pv.makeTranslation(e, t, r), this.applyMatrix4(pv), this;
  }
  scale(e, t, r) {
    return pv.makeScale(e, t, r), this.applyMatrix4(pv), this;
  }
  lookAt(e) {
    return FA.lookAt(e), FA.updateMatrix(), this.applyMatrix4(FA.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Eb).negate(), this.translate(Eb.x, Eb.y, Eb.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new sr(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sg());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new ge(-1 / 0, -1 / 0, -1 / 0),
        new ge(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, i = t.length; r < i; r++) {
          const o = t[r];
          ym.setFromBufferAttribute(o), this.morphTargetsRelative ? (Vf.addVectors(this.boundingBox.min, ym.min), this.boundingBox.expandByPoint(Vf), Vf.addVectors(this.boundingBox.max, ym.max), this.boundingBox.expandByPoint(Vf)) : (this.boundingBox.expandByPoint(ym.min), this.boundingBox.expandByPoint(ym.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new vy());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new ge(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (ym.setFromBufferAttribute(e), t)
        for (let o = 0, l = t.length; o < l; o++) {
          const d = t[o];
          KE.setFromBufferAttribute(d), this.morphTargetsRelative ? (Vf.addVectors(ym.min, KE.min), ym.expandByPoint(Vf), Vf.addVectors(ym.max, KE.max), ym.expandByPoint(Vf)) : (ym.expandByPoint(KE.min), ym.expandByPoint(KE.max));
        }
      ym.getCenter(r);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        Vf.fromBufferAttribute(e, o), i = Math.max(i, r.distanceToSquared(Vf));
      if (t)
        for (let o = 0, l = t.length; o < l; o++) {
          const d = t[o], h = this.morphTargetsRelative;
          for (let m = 0, S = d.count; m < S; m++)
            Vf.fromBufferAttribute(d, m), h && (Eb.fromBufferAttribute(e, m), Vf.add(Eb)), i = Math.max(i, r.distanceToSquared(Vf));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, i = t.position.array, o = t.normal.array, l = t.uv.array, d = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new os(new Float32Array(4 * d), 4));
    const h = this.getAttribute("tangent").array, m = [], S = [];
    for (let ie = 0; ie < d; ie++)
      m[ie] = new ge(), S[ie] = new ge();
    const _ = new ge(), T = new ge(), C = new ge(), D = new Ft(), P = new Ft(), U = new Ft(), B = new ge(), k = new ge();
    function V(ie, pe, ce) {
      _.fromArray(i, ie * 3), T.fromArray(i, pe * 3), C.fromArray(i, ce * 3), D.fromArray(l, ie * 2), P.fromArray(l, pe * 2), U.fromArray(l, ce * 2), T.sub(_), C.sub(_), P.sub(D), U.sub(D);
      const Ee = 1 / (P.x * U.y - U.x * P.y);
      !isFinite(Ee) || (B.copy(T).multiplyScalar(U.y).addScaledVector(C, -P.y).multiplyScalar(Ee), k.copy(C).multiplyScalar(P.x).addScaledVector(T, -U.x).multiplyScalar(Ee), m[ie].add(B), m[pe].add(B), m[ce].add(B), S[ie].add(k), S[pe].add(k), S[ce].add(k));
    }
    let I = this.groups;
    I.length === 0 && (I = [{
      start: 0,
      count: r.length
    }]);
    for (let ie = 0, pe = I.length; ie < pe; ++ie) {
      const ce = I[ie], Ee = ce.start, de = ce.count;
      for (let Fe = Ee, Ce = Ee + de; Fe < Ce; Fe += 3)
        V(
          r[Fe + 0],
          r[Fe + 1],
          r[Fe + 2]
        );
    }
    const X = new ge(), J = new ge(), $ = new ge(), W = new ge();
    function ee(ie) {
      $.fromArray(o, ie * 3), W.copy($);
      const pe = m[ie];
      X.copy(pe), X.sub($.multiplyScalar($.dot(pe))).normalize(), J.crossVectors(W, pe);
      const Ee = J.dot(S[ie]) < 0 ? -1 : 1;
      h[ie * 4] = X.x, h[ie * 4 + 1] = X.y, h[ie * 4 + 2] = X.z, h[ie * 4 + 3] = Ee;
    }
    for (let ie = 0, pe = I.length; ie < pe; ++ie) {
      const ce = I[ie], Ee = ce.start, de = ce.count;
      for (let Fe = Ee, Ce = Ee + de; Fe < Ce; Fe += 3)
        ee(r[Fe + 0]), ee(r[Fe + 1]), ee(r[Fe + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new os(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let T = 0, C = r.count; T < C; T++)
          r.setXYZ(T, 0, 0, 0);
      const i = new ge(), o = new ge(), l = new ge(), d = new ge(), h = new ge(), m = new ge(), S = new ge(), _ = new ge();
      if (e)
        for (let T = 0, C = e.count; T < C; T += 3) {
          const D = e.getX(T + 0), P = e.getX(T + 1), U = e.getX(T + 2);
          i.fromBufferAttribute(t, D), o.fromBufferAttribute(t, P), l.fromBufferAttribute(t, U), S.subVectors(l, o), _.subVectors(i, o), S.cross(_), d.fromBufferAttribute(r, D), h.fromBufferAttribute(r, P), m.fromBufferAttribute(r, U), d.add(S), h.add(S), m.add(S), r.setXYZ(D, d.x, d.y, d.z), r.setXYZ(P, h.x, h.y, h.z), r.setXYZ(U, m.x, m.y, m.z);
        }
      else
        for (let T = 0, C = t.count; T < C; T += 3)
          i.fromBufferAttribute(t, T + 0), o.fromBufferAttribute(t, T + 1), l.fromBufferAttribute(t, T + 2), S.subVectors(l, o), _.subVectors(i, o), S.cross(_), r.setXYZ(T + 0, S.x, S.y, S.z), r.setXYZ(T + 1, S.x, S.y, S.z), r.setXYZ(T + 2, S.x, S.y, S.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  merge(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const r = this.attributes;
    for (const i in r) {
      if (e.attributes[i] === void 0)
        continue;
      const l = r[i].array, d = e.attributes[i], h = d.array, m = d.itemSize * t, S = Math.min(h.length, l.length - m);
      for (let _ = 0, T = m; _ < S; _++, T++)
        l[T] = h[_];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      Vf.fromBufferAttribute(e, t), Vf.normalize(), e.setXYZ(t, Vf.x, Vf.y, Vf.z);
  }
  toNonIndexed() {
    function e(d, h) {
      const m = d.array, S = d.itemSize, _ = d.normalized, T = new m.constructor(h.length * S);
      let C = 0, D = 0;
      for (let P = 0, U = h.length; P < U; P++) {
        d.isInterleavedBufferAttribute ? C = h[P] * d.data.stride + d.offset : C = h[P] * S;
        for (let B = 0; B < S; B++)
          T[D++] = m[C++];
      }
      return new os(T, S, _);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new ui(), r = this.index.array, i = this.attributes;
    for (const d in i) {
      const h = i[d], m = e(h, r);
      t.setAttribute(d, m);
    }
    const o = this.morphAttributes;
    for (const d in o) {
      const h = [], m = o[d];
      for (let S = 0, _ = m.length; S < _; S++) {
        const T = m[S], C = e(T, r);
        h.push(C);
      }
      t.morphAttributes[d] = h;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let d = 0, h = l.length; d < h; d++) {
      const m = l[d];
      t.addGroup(m.start, m.count, m.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const h = this.parameters;
      for (const m in h)
        h[m] !== void 0 && (e[m] = h[m]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const h in r) {
      const m = r[h];
      e.data.attributes[h] = m.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const h in this.morphAttributes) {
      const m = this.morphAttributes[h], S = [];
      for (let _ = 0, T = m.length; _ < T; _++) {
        const C = m[_];
        S.push(C.toJSON(e.data));
      }
      S.length > 0 && (i[h] = S, o = !0);
    }
    o && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const d = this.boundingSphere;
    return d !== null && (e.data.boundingSphere = {
      center: d.center.toArray(),
      radius: d.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const m in i) {
      const S = i[m];
      this.setAttribute(m, S.clone(t));
    }
    const o = e.morphAttributes;
    for (const m in o) {
      const S = [], _ = o[m];
      for (let T = 0, C = _.length; T < C; T++)
        S.push(_[T].clone(t));
      this.morphAttributes[m] = S;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let m = 0, S = l.length; m < S; m++) {
      const _ = l[m];
      this.addGroup(_.start, _.count, _.materialIndex);
    }
    const d = e.boundingBox;
    d !== null && (this.boundingBox = d.clone());
    const h = e.boundingSphere;
    return h !== null && (this.boundingSphere = h.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const BO = /* @__PURE__ */ new si(), Mb = /* @__PURE__ */ new KM(), kA = /* @__PURE__ */ new vy(), Vx = /* @__PURE__ */ new ge(), Gx = /* @__PURE__ */ new ge(), Wx = /* @__PURE__ */ new ge(), IA = /* @__PURE__ */ new ge(), BA = /* @__PURE__ */ new ge(), HA = /* @__PURE__ */ new ge(), g2 = /* @__PURE__ */ new ge(), y2 = /* @__PURE__ */ new ge(), x2 = /* @__PURE__ */ new ge(), S2 = /* @__PURE__ */ new Ft(), _2 = /* @__PURE__ */ new Ft(), b2 = /* @__PURE__ */ new Ft(), VA = /* @__PURE__ */ new ge(), w2 = /* @__PURE__ */ new ge();
class zn extends Xa {
  constructor(e = new ui(), t = new og()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const d = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = o;
        }
      }
    }
  }
  raycast(e, t) {
    const r = this.geometry, i = this.material, o = this.matrixWorld;
    if (i === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(), kA.copy(r.boundingSphere), kA.applyMatrix4(o), e.ray.intersectsSphere(kA) === !1) || (BO.copy(o).invert(), Mb.copy(e.ray).applyMatrix4(BO), r.boundingBox !== null && Mb.intersectsBox(r.boundingBox) === !1))
      return;
    let l;
    const d = r.index, h = r.attributes.position, m = r.morphAttributes.position, S = r.morphTargetsRelative, _ = r.attributes.uv, T = r.attributes.uv2, C = r.groups, D = r.drawRange;
    if (d !== null)
      if (Array.isArray(i))
        for (let P = 0, U = C.length; P < U; P++) {
          const B = C[P], k = i[B.materialIndex], V = Math.max(B.start, D.start), I = Math.min(d.count, Math.min(B.start + B.count, D.start + D.count));
          for (let X = V, J = I; X < J; X += 3) {
            const $ = d.getX(X), W = d.getX(X + 1), ee = d.getX(X + 2);
            l = E2(this, k, e, Mb, h, m, S, _, T, $, W, ee), l && (l.faceIndex = Math.floor(X / 3), l.face.materialIndex = B.materialIndex, t.push(l));
          }
        }
      else {
        const P = Math.max(0, D.start), U = Math.min(d.count, D.start + D.count);
        for (let B = P, k = U; B < k; B += 3) {
          const V = d.getX(B), I = d.getX(B + 1), X = d.getX(B + 2);
          l = E2(this, i, e, Mb, h, m, S, _, T, V, I, X), l && (l.faceIndex = Math.floor(B / 3), t.push(l));
        }
      }
    else if (h !== void 0)
      if (Array.isArray(i))
        for (let P = 0, U = C.length; P < U; P++) {
          const B = C[P], k = i[B.materialIndex], V = Math.max(B.start, D.start), I = Math.min(h.count, Math.min(B.start + B.count, D.start + D.count));
          for (let X = V, J = I; X < J; X += 3) {
            const $ = X, W = X + 1, ee = X + 2;
            l = E2(this, k, e, Mb, h, m, S, _, T, $, W, ee), l && (l.faceIndex = Math.floor(X / 3), l.face.materialIndex = B.materialIndex, t.push(l));
          }
        }
      else {
        const P = Math.max(0, D.start), U = Math.min(h.count, D.start + D.count);
        for (let B = P, k = U; B < k; B += 3) {
          const V = B, I = B + 1, X = B + 2;
          l = E2(this, i, e, Mb, h, m, S, _, T, V, I, X), l && (l.faceIndex = Math.floor(B / 3), t.push(l));
        }
      }
  }
}
function zH(a, e, t, r, i, o, l, d) {
  let h;
  if (e.side === uf ? h = r.intersectTriangle(l, o, i, !0, d) : h = r.intersectTriangle(i, o, l, e.side !== Pp, d), h === null)
    return null;
  w2.copy(d), w2.applyMatrix4(a.matrixWorld);
  const m = t.ray.origin.distanceTo(w2);
  return m < t.near || m > t.far ? null : {
    distance: m,
    point: w2.clone(),
    object: a
  };
}
function E2(a, e, t, r, i, o, l, d, h, m, S, _) {
  Vx.fromBufferAttribute(i, m), Gx.fromBufferAttribute(i, S), Wx.fromBufferAttribute(i, _);
  const T = a.morphTargetInfluences;
  if (o && T) {
    g2.set(0, 0, 0), y2.set(0, 0, 0), x2.set(0, 0, 0);
    for (let D = 0, P = o.length; D < P; D++) {
      const U = T[D], B = o[D];
      U !== 0 && (IA.fromBufferAttribute(B, m), BA.fromBufferAttribute(B, S), HA.fromBufferAttribute(B, _), l ? (g2.addScaledVector(IA, U), y2.addScaledVector(BA, U), x2.addScaledVector(HA, U)) : (g2.addScaledVector(IA.sub(Vx), U), y2.addScaledVector(BA.sub(Gx), U), x2.addScaledVector(HA.sub(Wx), U)));
    }
    Vx.add(g2), Gx.add(y2), Wx.add(x2);
  }
  a.isSkinnedMesh && (a.boneTransform(m, Vx), a.boneTransform(S, Gx), a.boneTransform(_, Wx));
  const C = zH(a, e, t, r, Vx, Gx, Wx, VA);
  if (C) {
    d && (S2.fromBufferAttribute(d, m), _2.fromBufferAttribute(d, S), b2.fromBufferAttribute(d, _), C.uv = xm.getUV(VA, Vx, Gx, Wx, S2, _2, b2, new Ft())), h && (S2.fromBufferAttribute(h, m), _2.fromBufferAttribute(h, S), b2.fromBufferAttribute(h, _), C.uv2 = xm.getUV(VA, Vx, Gx, Wx, S2, _2, b2, new Ft()));
    const D = {
      a: m,
      b: S,
      c: _,
      normal: new ge(),
      materialIndex: 0
    };
    xm.getNormal(Vx, Gx, Wx, D.normal), C.face = D;
  }
  return C;
}
class cl extends ui {
  constructor(e = 1, t = 1, r = 1, i = 1, o = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: i,
      heightSegments: o,
      depthSegments: l
    };
    const d = this;
    i = Math.floor(i), o = Math.floor(o), l = Math.floor(l);
    const h = [], m = [], S = [], _ = [];
    let T = 0, C = 0;
    D("z", "y", "x", -1, -1, r, t, e, l, o, 0), D("z", "y", "x", 1, -1, r, t, -e, l, o, 1), D("x", "z", "y", 1, 1, e, r, t, i, l, 2), D("x", "z", "y", 1, -1, e, r, -t, i, l, 3), D("x", "y", "z", 1, -1, e, t, r, i, o, 4), D("x", "y", "z", -1, -1, e, t, -r, i, o, 5), this.setIndex(h), this.setAttribute("position", new sr(m, 3)), this.setAttribute("normal", new sr(S, 3)), this.setAttribute("uv", new sr(_, 2));
    function D(P, U, B, k, V, I, X, J, $, W, ee) {
      const ie = I / $, pe = X / W, ce = I / 2, Ee = X / 2, de = J / 2, Fe = $ + 1, Ce = W + 1;
      let Be = 0, he = 0;
      const fe = new ge();
      for (let ue = 0; ue < Ce; ue++) {
        const ye = ue * pe - Ee;
        for (let we = 0; we < Fe; we++) {
          const Xe = we * ie - ce;
          fe[P] = Xe * k, fe[U] = ye * V, fe[B] = de, m.push(fe.x, fe.y, fe.z), fe[P] = 0, fe[U] = 0, fe[B] = J > 0 ? 1 : -1, S.push(fe.x, fe.y, fe.z), _.push(we / $), _.push(1 - ue / W), Be += 1;
        }
      }
      for (let ue = 0; ue < W; ue++)
        for (let ye = 0; ye < $; ye++) {
          const we = T + ye + Fe * ue, Xe = T + ye + Fe * (ue + 1), Je = T + (ye + 1) + Fe * (ue + 1), st = T + (ye + 1) + Fe * ue;
          h.push(we, Xe, st), h.push(Xe, Je, st), he += 6;
        }
      d.addGroup(C, he, ee), C += he, T += Be;
    }
  }
  static fromJSON(e) {
    return new cl(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Jb(a) {
  const e = {};
  for (const t in a) {
    e[t] = {};
    for (const r in a[t]) {
      const i = a[t][r];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i;
    }
  }
  return e;
}
function lh(a) {
  const e = {};
  for (let t = 0; t < a.length; t++) {
    const r = Jb(a[t]);
    for (const i in r)
      e[i] = r[i];
  }
  return e;
}
function NH(a) {
  const e = [];
  for (let t = 0; t < a.length; t++)
    e.push(a[t].clone());
  return e;
}
const $M = { clone: Jb, merge: lh };
var FH = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, kH = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class wu extends ff {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = FH, this.fragmentShader = kH, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Jb(e.uniforms), this.uniformsGroups = NH(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture ? t.uniforms[i] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[i] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[i] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const r = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class hw extends Xa {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new si(), this.projectionMatrix = new si(), this.projectionMatrixInverse = new si();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class fo extends hw {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = OM * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(NS * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return OM * 2 * Math.atan(
      Math.tan(NS * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, r, i, o, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(NS * 0.5 * this.fov) / this.zoom, r = 2 * t, i = this.aspect * r, o = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const h = l.fullWidth, m = l.fullHeight;
      o += l.offsetX * i / h, t -= l.offsetY * r / m, i *= l.width / h, r *= l.height / m;
    }
    const d = this.filmOffset;
    d !== 0 && (o += e * d / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, t, t - r, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Tb = 90, Cb = 1;
class xF extends Xa {
  constructor(e, t, r) {
    if (super(), this.type = "CubeCamera", r.isWebGLCubeRenderTarget !== !0) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = r;
    const i = new fo(Tb, Cb, e, t);
    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ge(1, 0, 0)), this.add(i);
    const o = new fo(Tb, Cb, e, t);
    o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new ge(-1, 0, 0)), this.add(o);
    const l = new fo(Tb, Cb, e, t);
    l.layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new ge(0, 1, 0)), this.add(l);
    const d = new fo(Tb, Cb, e, t);
    d.layers = this.layers, d.up.set(0, 0, -1), d.lookAt(new ge(0, -1, 0)), this.add(d);
    const h = new fo(Tb, Cb, e, t);
    h.layers = this.layers, h.up.set(0, -1, 0), h.lookAt(new ge(0, 0, 1)), this.add(h);
    const m = new fo(Tb, Cb, e, t);
    m.layers = this.layers, m.up.set(0, -1, 0), m.lookAt(new ge(0, 0, -1)), this.add(m);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const r = this.renderTarget, [i, o, l, d, h, m] = this.children, S = e.getRenderTarget(), _ = e.toneMapping, T = e.xr.enabled;
    e.toneMapping = rg, e.xr.enabled = !1;
    const C = r.texture.generateMipmaps;
    r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, i), e.setRenderTarget(r, 1), e.render(t, o), e.setRenderTarget(r, 2), e.render(t, l), e.setRenderTarget(r, 3), e.render(t, d), e.setRenderTarget(r, 4), e.render(t, h), r.texture.generateMipmaps = C, e.setRenderTarget(r, 5), e.render(t, m), e.setRenderTarget(S), e.toneMapping = _, e.xr.enabled = T, r.texture.needsPMREMUpdate = !0;
  }
}
class eT extends iu {
  constructor(e, t, r, i, o, l, d, h, m, S) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : t1, super(e, t, r, i, o, l, d, h, m, S), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class SF extends po {
  constructor(e, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r];
    this.texture = new eT(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Po;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const r = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    }, i = new cl(5, 5, 5), o = new wu({
      name: "CubemapFromEquirect",
      uniforms: Jb(r.uniforms),
      vertexShader: r.vertexShader,
      fragmentShader: r.fragmentShader,
      side: uf,
      blending: cf
    });
    o.uniforms.tEquirect.value = t;
    const l = new zn(i, o), d = t.minFilter;
    return t.minFilter === s1 && (t.minFilter = Po), new xF(1, 10, this).update(e, l), t.minFilter = d, l.geometry.dispose(), l.material.dispose(), this;
  }
  clear(e, t, r, i) {
    const o = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, r, i);
    e.setRenderTarget(o);
  }
}
const GA = /* @__PURE__ */ new ge(), IH = /* @__PURE__ */ new ge(), BH = /* @__PURE__ */ new jh();
class C0 {
  constructor(e = new ge(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = GA.subVectors(r, t).cross(IH.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const r = e.delta(GA), i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(r).multiplyScalar(o).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || BH.getNormalMatrix(e), i = this.coplanarPoint(GA).applyMatrix4(e), o = this.normal.applyMatrix3(r).normalize();
    return this.constant = -i.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Rb = /* @__PURE__ */ new vy(), M2 = /* @__PURE__ */ new ge();
class IC {
  constructor(e = new C0(), t = new C0(), r = new C0(), i = new C0(), o = new C0(), l = new C0()) {
    this.planes = [e, t, r, i, o, l];
  }
  set(e, t, r, i, o, l) {
    const d = this.planes;
    return d[0].copy(e), d[1].copy(t), d[2].copy(r), d[3].copy(i), d[4].copy(o), d[5].copy(l), this;
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, r = e.elements, i = r[0], o = r[1], l = r[2], d = r[3], h = r[4], m = r[5], S = r[6], _ = r[7], T = r[8], C = r[9], D = r[10], P = r[11], U = r[12], B = r[13], k = r[14], V = r[15];
    return t[0].setComponents(d - i, _ - h, P - T, V - U).normalize(), t[1].setComponents(d + i, _ + h, P + T, V + U).normalize(), t[2].setComponents(d + o, _ + m, P + C, V + B).normalize(), t[3].setComponents(d - o, _ - m, P - C, V - B).normalize(), t[4].setComponents(d - l, _ - S, P - D, V - k).normalize(), t[5].setComponents(d + l, _ + S, P + D, V + k).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), Rb.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Rb);
  }
  intersectsSprite(e) {
    return Rb.center.set(0, 0, 0), Rb.radius = 0.7071067811865476, Rb.applyMatrix4(e.matrixWorld), this.intersectsSphere(Rb);
  }
  intersectsSphere(e) {
    const t = this.planes, r = e.center, i = -e.radius;
    for (let o = 0; o < 6; o++)
      if (t[o].distanceToPoint(r) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (M2.x = i.normal.x > 0 ? e.max.x : e.min.x, M2.y = i.normal.y > 0 ? e.max.y : e.min.y, M2.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(M2) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function _F() {
  let a = null, e = !1, t = null, r = null;
  function i(o, l) {
    t(o, l), r = a.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (r = a.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      a.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(o) {
      t = o;
    },
    setContext: function(o) {
      a = o;
    }
  };
}
function HH(a, e) {
  const t = e.isWebGL2, r = /* @__PURE__ */ new WeakMap();
  function i(m, S) {
    const _ = m.array, T = m.usage, C = a.createBuffer();
    a.bindBuffer(S, C), a.bufferData(S, _, T), m.onUploadCallback();
    let D;
    if (_ instanceof Float32Array)
      D = 5126;
    else if (_ instanceof Uint16Array)
      if (m.isFloat16BufferAttribute)
        if (t)
          D = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        D = 5123;
    else if (_ instanceof Int16Array)
      D = 5122;
    else if (_ instanceof Uint32Array)
      D = 5125;
    else if (_ instanceof Int32Array)
      D = 5124;
    else if (_ instanceof Int8Array)
      D = 5120;
    else if (_ instanceof Uint8Array)
      D = 5121;
    else if (_ instanceof Uint8ClampedArray)
      D = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + _);
    return {
      buffer: C,
      type: D,
      bytesPerElement: _.BYTES_PER_ELEMENT,
      version: m.version
    };
  }
  function o(m, S, _) {
    const T = S.array, C = S.updateRange;
    a.bindBuffer(_, m), C.count === -1 ? a.bufferSubData(_, 0, T) : (t ? a.bufferSubData(
      _,
      C.offset * T.BYTES_PER_ELEMENT,
      T,
      C.offset,
      C.count
    ) : a.bufferSubData(
      _,
      C.offset * T.BYTES_PER_ELEMENT,
      T.subarray(C.offset, C.offset + C.count)
    ), C.count = -1);
  }
  function l(m) {
    return m.isInterleavedBufferAttribute && (m = m.data), r.get(m);
  }
  function d(m) {
    m.isInterleavedBufferAttribute && (m = m.data);
    const S = r.get(m);
    S && (a.deleteBuffer(S.buffer), r.delete(m));
  }
  function h(m, S) {
    if (m.isGLBufferAttribute) {
      const T = r.get(m);
      (!T || T.version < m.version) && r.set(m, {
        buffer: m.buffer,
        type: m.type,
        bytesPerElement: m.elementSize,
        version: m.version
      });
      return;
    }
    m.isInterleavedBufferAttribute && (m = m.data);
    const _ = r.get(m);
    _ === void 0 ? r.set(m, i(m, S)) : _.version < m.version && (o(_.buffer, m, S), _.version = m.version);
  }
  return {
    get: l,
    remove: d,
    update: h
  };
}
class ig extends ui {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: i
    };
    const o = e / 2, l = t / 2, d = Math.floor(r), h = Math.floor(i), m = d + 1, S = h + 1, _ = e / d, T = t / h, C = [], D = [], P = [], U = [];
    for (let B = 0; B < S; B++) {
      const k = B * T - l;
      for (let V = 0; V < m; V++) {
        const I = V * _ - o;
        D.push(I, -k, 0), P.push(0, 0, 1), U.push(V / d), U.push(1 - B / h);
      }
    }
    for (let B = 0; B < h; B++)
      for (let k = 0; k < d; k++) {
        const V = k + m * B, I = k + m * (B + 1), X = k + 1 + m * (B + 1), J = k + 1 + m * B;
        C.push(V, I, J), C.push(I, X, J);
      }
    this.setIndex(C), this.setAttribute("position", new sr(D, 3)), this.setAttribute("normal", new sr(P, 3)), this.setAttribute("uv", new sr(U, 2));
  }
  static fromJSON(e) {
    return new ig(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var VH = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, GH = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, WH = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, jH = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, YH = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, XH = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, qH = "vec3 transformed = vec3( position );", QH = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, ZH = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, JH = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, KH = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, $H = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, e6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, t6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, n6 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, r6 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, i6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, a6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, s6 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, o6 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, l6 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, u6 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, c6 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, f6 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, d6 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, h6 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, p6 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", m6 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, v6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, g6 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, y6 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, x6 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, S6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, _6 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, b6 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, w6 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, E6 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, M6 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, T6 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, C6 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, R6 = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`, A6 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, D6 = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, L6 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, P6 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, O6 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, U6 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, z6 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, N6 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, F6 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, k6 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, I6 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, B6 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, H6 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, V6 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, G6 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, W6 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, j6 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Y6 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, X6 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, q6 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Q6 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Z6 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, J6 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, K6 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, $6 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, eV = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, tV = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, nV = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, rV = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, iV = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, aV = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, sV = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, oV = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, lV = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, uV = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, cV = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, fV = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, dV = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, hV = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, pV = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, mV = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, vV = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, gV = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, yV = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, xV = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, SV = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, _V = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, bV = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, wV = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, EV = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, MV = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, TV = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, CV = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, RV = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, AV = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, DV = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`, LV = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, PV = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, OV = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, UV = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, zV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, NV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, FV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, kV = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const IV = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, BV = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, HV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, VV = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, GV = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, WV = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, jV = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, YV = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, XV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, qV = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, QV = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, ZV = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, JV = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, KV = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, $V = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, eG = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, tG = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, nG = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rG = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, iG = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, aG = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sG = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, oG = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, lG = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, uG = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, cG = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, fG = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, dG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, hG = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, pG = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, mG = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, vG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, na = {
  alphamap_fragment: VH,
  alphamap_pars_fragment: GH,
  alphatest_fragment: WH,
  alphatest_pars_fragment: jH,
  aomap_fragment: YH,
  aomap_pars_fragment: XH,
  begin_vertex: qH,
  beginnormal_vertex: QH,
  bsdfs: ZH,
  iridescence_fragment: JH,
  bumpmap_pars_fragment: KH,
  clipping_planes_fragment: $H,
  clipping_planes_pars_fragment: e6,
  clipping_planes_pars_vertex: t6,
  clipping_planes_vertex: n6,
  color_fragment: r6,
  color_pars_fragment: i6,
  color_pars_vertex: a6,
  color_vertex: s6,
  common: o6,
  cube_uv_reflection_fragment: l6,
  defaultnormal_vertex: u6,
  displacementmap_pars_vertex: c6,
  displacementmap_vertex: f6,
  emissivemap_fragment: d6,
  emissivemap_pars_fragment: h6,
  encodings_fragment: p6,
  encodings_pars_fragment: m6,
  envmap_fragment: v6,
  envmap_common_pars_fragment: g6,
  envmap_pars_fragment: y6,
  envmap_pars_vertex: x6,
  envmap_physical_pars_fragment: D6,
  envmap_vertex: S6,
  fog_vertex: _6,
  fog_pars_vertex: b6,
  fog_fragment: w6,
  fog_pars_fragment: E6,
  gradientmap_pars_fragment: M6,
  lightmap_fragment: T6,
  lightmap_pars_fragment: C6,
  lights_lambert_vertex: R6,
  lights_pars_begin: A6,
  lights_toon_fragment: L6,
  lights_toon_pars_fragment: P6,
  lights_phong_fragment: O6,
  lights_phong_pars_fragment: U6,
  lights_physical_fragment: z6,
  lights_physical_pars_fragment: N6,
  lights_fragment_begin: F6,
  lights_fragment_maps: k6,
  lights_fragment_end: I6,
  logdepthbuf_fragment: B6,
  logdepthbuf_pars_fragment: H6,
  logdepthbuf_pars_vertex: V6,
  logdepthbuf_vertex: G6,
  map_fragment: W6,
  map_pars_fragment: j6,
  map_particle_fragment: Y6,
  map_particle_pars_fragment: X6,
  metalnessmap_fragment: q6,
  metalnessmap_pars_fragment: Q6,
  morphcolor_vertex: Z6,
  morphnormal_vertex: J6,
  morphtarget_pars_vertex: K6,
  morphtarget_vertex: $6,
  normal_fragment_begin: eV,
  normal_fragment_maps: tV,
  normal_pars_fragment: nV,
  normal_pars_vertex: rV,
  normal_vertex: iV,
  normalmap_pars_fragment: aV,
  clearcoat_normal_fragment_begin: sV,
  clearcoat_normal_fragment_maps: oV,
  clearcoat_pars_fragment: lV,
  iridescence_pars_fragment: uV,
  output_fragment: cV,
  packing: fV,
  premultiplied_alpha_fragment: dV,
  project_vertex: hV,
  dithering_fragment: pV,
  dithering_pars_fragment: mV,
  roughnessmap_fragment: vV,
  roughnessmap_pars_fragment: gV,
  shadowmap_pars_fragment: yV,
  shadowmap_pars_vertex: xV,
  shadowmap_vertex: SV,
  shadowmask_pars_fragment: _V,
  skinbase_vertex: bV,
  skinning_pars_vertex: wV,
  skinning_vertex: EV,
  skinnormal_vertex: MV,
  specularmap_fragment: TV,
  specularmap_pars_fragment: CV,
  tonemapping_fragment: RV,
  tonemapping_pars_fragment: AV,
  transmission_fragment: DV,
  transmission_pars_fragment: LV,
  uv_pars_fragment: PV,
  uv_pars_vertex: OV,
  uv_vertex: UV,
  uv2_pars_fragment: zV,
  uv2_pars_vertex: NV,
  uv2_vertex: FV,
  worldpos_vertex: kV,
  background_vert: IV,
  background_frag: BV,
  cube_vert: HV,
  cube_frag: VV,
  depth_vert: GV,
  depth_frag: WV,
  distanceRGBA_vert: jV,
  distanceRGBA_frag: YV,
  equirect_vert: XV,
  equirect_frag: qV,
  linedashed_vert: QV,
  linedashed_frag: ZV,
  meshbasic_vert: JV,
  meshbasic_frag: KV,
  meshlambert_vert: $V,
  meshlambert_frag: eG,
  meshmatcap_vert: tG,
  meshmatcap_frag: nG,
  meshnormal_vert: rG,
  meshnormal_frag: iG,
  meshphong_vert: aG,
  meshphong_frag: sG,
  meshphysical_vert: oG,
  meshphysical_frag: lG,
  meshtoon_vert: uG,
  meshtoon_frag: cG,
  points_vert: fG,
  points_frag: dG,
  shadow_vert: hG,
  shadow_frag: pG,
  sprite_vert: mG,
  sprite_frag: vG
}, Fn = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Pn(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new jh() },
    uv2Transform: { value: /* @__PURE__ */ new jh() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new Ft(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Pn(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Pn(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new jh() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Pn(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ft(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new jh() }
  }
}, Gh = {
  basic: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.specularmap,
      Fn.envmap,
      Fn.aomap,
      Fn.lightmap,
      Fn.fog
    ]),
    vertexShader: na.meshbasic_vert,
    fragmentShader: na.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.specularmap,
      Fn.envmap,
      Fn.aomap,
      Fn.lightmap,
      Fn.emissivemap,
      Fn.fog,
      Fn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pn(0) }
      }
    ]),
    vertexShader: na.meshlambert_vert,
    fragmentShader: na.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.specularmap,
      Fn.envmap,
      Fn.aomap,
      Fn.lightmap,
      Fn.emissivemap,
      Fn.bumpmap,
      Fn.normalmap,
      Fn.displacementmap,
      Fn.fog,
      Fn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pn(0) },
        specular: { value: /* @__PURE__ */ new Pn(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: na.meshphong_vert,
    fragmentShader: na.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.envmap,
      Fn.aomap,
      Fn.lightmap,
      Fn.emissivemap,
      Fn.bumpmap,
      Fn.normalmap,
      Fn.displacementmap,
      Fn.roughnessmap,
      Fn.metalnessmap,
      Fn.fog,
      Fn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pn(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: na.meshphysical_vert,
    fragmentShader: na.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.aomap,
      Fn.lightmap,
      Fn.emissivemap,
      Fn.bumpmap,
      Fn.normalmap,
      Fn.displacementmap,
      Fn.gradientmap,
      Fn.fog,
      Fn.lights,
      {
        emissive: { value: /* @__PURE__ */ new Pn(0) }
      }
    ]),
    vertexShader: na.meshtoon_vert,
    fragmentShader: na.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.bumpmap,
      Fn.normalmap,
      Fn.displacementmap,
      Fn.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: na.meshmatcap_vert,
    fragmentShader: na.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ lh([
      Fn.points,
      Fn.fog
    ]),
    vertexShader: na.points_vert,
    fragmentShader: na.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: na.linedashed_vert,
    fragmentShader: na.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.displacementmap
    ]),
    vertexShader: na.depth_vert,
    fragmentShader: na.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.bumpmap,
      Fn.normalmap,
      Fn.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: na.meshnormal_vert,
    fragmentShader: na.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ lh([
      Fn.sprite,
      Fn.fog
    ]),
    vertexShader: na.sprite_vert,
    fragmentShader: na.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new jh() },
      t2D: { value: null }
    },
    vertexShader: na.background_vert,
    fragmentShader: na.background_frag
  },
  cube: {
    uniforms: /* @__PURE__ */ lh([
      Fn.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: na.cube_vert,
    fragmentShader: na.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: na.equirect_vert,
    fragmentShader: na.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ lh([
      Fn.common,
      Fn.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new ge() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: na.distanceRGBA_vert,
    fragmentShader: na.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ lh([
      Fn.lights,
      Fn.fog,
      {
        color: { value: /* @__PURE__ */ new Pn(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: na.shadow_vert,
    fragmentShader: na.shadow_frag
  }
};
Gh.physical = {
  uniforms: /* @__PURE__ */ lh([
    Gh.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ft(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Pn(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ft() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Pn(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new Pn(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: na.meshphysical_vert,
  fragmentShader: na.meshphysical_frag
};
function gG(a, e, t, r, i, o) {
  const l = new Pn(0);
  let d = i === !0 ? 0 : 1, h, m, S = null, _ = 0, T = null;
  function C(P, U) {
    let B = !1, k = U.isScene === !0 ? U.background : null;
    k && k.isTexture && (k = e.get(k));
    const V = a.xr, I = V.getSession && V.getSession();
    I && I.environmentBlendMode === "additive" && (k = null), k === null ? D(l, d) : k && k.isColor && (D(k, 1), B = !0), (a.autoClear || B) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), k && (k.isCubeTexture || k.mapping === dw) ? (m === void 0 && (m = new zn(
      new cl(1, 1, 1),
      new wu({
        name: "BackgroundCubeMaterial",
        uniforms: Jb(Gh.cube.uniforms),
        vertexShader: Gh.cube.vertexShader,
        fragmentShader: Gh.cube.fragmentShader,
        side: uf,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), m.geometry.deleteAttribute("normal"), m.geometry.deleteAttribute("uv"), m.onBeforeRender = function(X, J, $) {
      this.matrixWorld.copyPosition($.matrixWorld);
    }, Object.defineProperty(m.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(m)), m.material.uniforms.envMap.value = k, m.material.uniforms.flipEnvMap.value = k.isCubeTexture && k.isRenderTargetTexture === !1 ? -1 : 1, (S !== k || _ !== k.version || T !== a.toneMapping) && (m.material.needsUpdate = !0, S = k, _ = k.version, T = a.toneMapping), m.layers.enableAll(), P.unshift(m, m.geometry, m.material, 0, 0, null)) : k && k.isTexture && (h === void 0 && (h = new zn(
      new ig(2, 2),
      new wu({
        name: "BackgroundMaterial",
        uniforms: Jb(Gh.background.uniforms),
        vertexShader: Gh.background.vertexShader,
        fragmentShader: Gh.background.fragmentShader,
        side: py,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(h)), h.material.uniforms.t2D.value = k, k.matrixAutoUpdate === !0 && k.updateMatrix(), h.material.uniforms.uvTransform.value.copy(k.matrix), (S !== k || _ !== k.version || T !== a.toneMapping) && (h.material.needsUpdate = !0, S = k, _ = k.version, T = a.toneMapping), h.layers.enableAll(), P.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function D(P, U) {
    t.buffers.color.setClear(P.r, P.g, P.b, U, o);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(P, U = 1) {
      l.set(P), d = U, D(l, d);
    },
    getClearAlpha: function() {
      return d;
    },
    setClearAlpha: function(P) {
      d = P, D(l, d);
    },
    render: C
  };
}
function yG(a, e, t, r) {
  const i = a.getParameter(34921), o = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), l = r.isWebGL2 || o !== null, d = {}, h = U(null);
  let m = h, S = !1;
  function _(de, Fe, Ce, Be, he) {
    let fe = !1;
    if (l) {
      const ue = P(Be, Ce, Fe);
      m !== ue && (m = ue, C(m.object)), fe = B(de, Be, Ce, he), fe && k(de, Be, Ce, he);
    } else {
      const ue = Fe.wireframe === !0;
      (m.geometry !== Be.id || m.program !== Ce.id || m.wireframe !== ue) && (m.geometry = Be.id, m.program = Ce.id, m.wireframe = ue, fe = !0);
    }
    he !== null && t.update(he, 34963), (fe || S) && (S = !1, W(de, Fe, Ce, Be), he !== null && a.bindBuffer(34963, t.get(he).buffer));
  }
  function T() {
    return r.isWebGL2 ? a.createVertexArray() : o.createVertexArrayOES();
  }
  function C(de) {
    return r.isWebGL2 ? a.bindVertexArray(de) : o.bindVertexArrayOES(de);
  }
  function D(de) {
    return r.isWebGL2 ? a.deleteVertexArray(de) : o.deleteVertexArrayOES(de);
  }
  function P(de, Fe, Ce) {
    const Be = Ce.wireframe === !0;
    let he = d[de.id];
    he === void 0 && (he = {}, d[de.id] = he);
    let fe = he[Fe.id];
    fe === void 0 && (fe = {}, he[Fe.id] = fe);
    let ue = fe[Be];
    return ue === void 0 && (ue = U(T()), fe[Be] = ue), ue;
  }
  function U(de) {
    const Fe = [], Ce = [], Be = [];
    for (let he = 0; he < i; he++)
      Fe[he] = 0, Ce[he] = 0, Be[he] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Fe,
      enabledAttributes: Ce,
      attributeDivisors: Be,
      object: de,
      attributes: {},
      index: null
    };
  }
  function B(de, Fe, Ce, Be) {
    const he = m.attributes, fe = Fe.attributes;
    let ue = 0;
    const ye = Ce.getAttributes();
    for (const we in ye)
      if (ye[we].location >= 0) {
        const Je = he[we];
        let st = fe[we];
        if (st === void 0 && (we === "instanceMatrix" && de.instanceMatrix && (st = de.instanceMatrix), we === "instanceColor" && de.instanceColor && (st = de.instanceColor)), Je === void 0 || Je.attribute !== st || st && Je.data !== st.data)
          return !0;
        ue++;
      }
    return m.attributesNum !== ue || m.index !== Be;
  }
  function k(de, Fe, Ce, Be) {
    const he = {}, fe = Fe.attributes;
    let ue = 0;
    const ye = Ce.getAttributes();
    for (const we in ye)
      if (ye[we].location >= 0) {
        let Je = fe[we];
        Je === void 0 && (we === "instanceMatrix" && de.instanceMatrix && (Je = de.instanceMatrix), we === "instanceColor" && de.instanceColor && (Je = de.instanceColor));
        const st = {};
        st.attribute = Je, Je && Je.data && (st.data = Je.data), he[we] = st, ue++;
      }
    m.attributes = he, m.attributesNum = ue, m.index = Be;
  }
  function V() {
    const de = m.newAttributes;
    for (let Fe = 0, Ce = de.length; Fe < Ce; Fe++)
      de[Fe] = 0;
  }
  function I(de) {
    X(de, 0);
  }
  function X(de, Fe) {
    const Ce = m.newAttributes, Be = m.enabledAttributes, he = m.attributeDivisors;
    Ce[de] = 1, Be[de] === 0 && (a.enableVertexAttribArray(de), Be[de] = 1), he[de] !== Fe && ((r.isWebGL2 ? a : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](de, Fe), he[de] = Fe);
  }
  function J() {
    const de = m.newAttributes, Fe = m.enabledAttributes;
    for (let Ce = 0, Be = Fe.length; Ce < Be; Ce++)
      Fe[Ce] !== de[Ce] && (a.disableVertexAttribArray(Ce), Fe[Ce] = 0);
  }
  function $(de, Fe, Ce, Be, he, fe) {
    r.isWebGL2 === !0 && (Ce === 5124 || Ce === 5125) ? a.vertexAttribIPointer(de, Fe, Ce, he, fe) : a.vertexAttribPointer(de, Fe, Ce, Be, he, fe);
  }
  function W(de, Fe, Ce, Be) {
    if (r.isWebGL2 === !1 && (de.isInstancedMesh || Be.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    V();
    const he = Be.attributes, fe = Ce.getAttributes(), ue = Fe.defaultAttributeValues;
    for (const ye in fe) {
      const we = fe[ye];
      if (we.location >= 0) {
        let Xe = he[ye];
        if (Xe === void 0 && (ye === "instanceMatrix" && de.instanceMatrix && (Xe = de.instanceMatrix), ye === "instanceColor" && de.instanceColor && (Xe = de.instanceColor)), Xe !== void 0) {
          const Je = Xe.normalized, st = Xe.itemSize, Ue = t.get(Xe);
          if (Ue === void 0)
            continue;
          const ot = Ue.buffer, rt = Ue.type, _t = Ue.bytesPerElement;
          if (Xe.isInterleavedBufferAttribute) {
            const Rt = Xe.data, Ot = Rt.stride, He = Xe.offset;
            if (Rt.isInstancedInterleavedBuffer) {
              for (let et = 0; et < we.locationSize; et++)
                X(we.location + et, Rt.meshPerAttribute);
              de.isInstancedMesh !== !0 && Be._maxInstanceCount === void 0 && (Be._maxInstanceCount = Rt.meshPerAttribute * Rt.count);
            } else
              for (let et = 0; et < we.locationSize; et++)
                I(we.location + et);
            a.bindBuffer(34962, ot);
            for (let et = 0; et < we.locationSize; et++)
              $(
                we.location + et,
                st / we.locationSize,
                rt,
                Je,
                Ot * _t,
                (He + st / we.locationSize * et) * _t
              );
          } else {
            if (Xe.isInstancedBufferAttribute) {
              for (let Rt = 0; Rt < we.locationSize; Rt++)
                X(we.location + Rt, Xe.meshPerAttribute);
              de.isInstancedMesh !== !0 && Be._maxInstanceCount === void 0 && (Be._maxInstanceCount = Xe.meshPerAttribute * Xe.count);
            } else
              for (let Rt = 0; Rt < we.locationSize; Rt++)
                I(we.location + Rt);
            a.bindBuffer(34962, ot);
            for (let Rt = 0; Rt < we.locationSize; Rt++)
              $(
                we.location + Rt,
                st / we.locationSize,
                rt,
                Je,
                st * _t,
                st / we.locationSize * Rt * _t
              );
          }
        } else if (ue !== void 0) {
          const Je = ue[ye];
          if (Je !== void 0)
            switch (Je.length) {
              case 2:
                a.vertexAttrib2fv(we.location, Je);
                break;
              case 3:
                a.vertexAttrib3fv(we.location, Je);
                break;
              case 4:
                a.vertexAttrib4fv(we.location, Je);
                break;
              default:
                a.vertexAttrib1fv(we.location, Je);
            }
        }
      }
    }
    J();
  }
  function ee() {
    ce();
    for (const de in d) {
      const Fe = d[de];
      for (const Ce in Fe) {
        const Be = Fe[Ce];
        for (const he in Be)
          D(Be[he].object), delete Be[he];
        delete Fe[Ce];
      }
      delete d[de];
    }
  }
  function ie(de) {
    if (d[de.id] === void 0)
      return;
    const Fe = d[de.id];
    for (const Ce in Fe) {
      const Be = Fe[Ce];
      for (const he in Be)
        D(Be[he].object), delete Be[he];
      delete Fe[Ce];
    }
    delete d[de.id];
  }
  function pe(de) {
    for (const Fe in d) {
      const Ce = d[Fe];
      if (Ce[de.id] === void 0)
        continue;
      const Be = Ce[de.id];
      for (const he in Be)
        D(Be[he].object), delete Be[he];
      delete Ce[de.id];
    }
  }
  function ce() {
    Ee(), S = !0, m !== h && (m = h, C(m.object));
  }
  function Ee() {
    h.geometry = null, h.program = null, h.wireframe = !1;
  }
  return {
    setup: _,
    reset: ce,
    resetDefaultState: Ee,
    dispose: ee,
    releaseStatesOfGeometry: ie,
    releaseStatesOfProgram: pe,
    initAttributes: V,
    enableAttribute: I,
    disableUnusedAttributes: J
  };
}
function xG(a, e, t, r) {
  const i = r.isWebGL2;
  let o;
  function l(m) {
    o = m;
  }
  function d(m, S) {
    a.drawArrays(o, m, S), t.update(S, o, 1);
  }
  function h(m, S, _) {
    if (_ === 0)
      return;
    let T, C;
    if (i)
      T = a, C = "drawArraysInstanced";
    else if (T = e.get("ANGLE_instanced_arrays"), C = "drawArraysInstancedANGLE", T === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    T[C](o, m, S, _), t.update(S, o, _);
  }
  this.setMode = l, this.render = d, this.renderInstances = h;
}
function SG(a, e, t) {
  let r;
  function i() {
    if (r !== void 0)
      return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const $ = e.get("EXT_texture_filter_anisotropic");
      r = a.getParameter($.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function o($) {
    if ($ === "highp") {
      if (a.getShaderPrecisionFormat(35633, 36338).precision > 0 && a.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      $ = "mediump";
    }
    return $ === "mediump" && a.getShaderPrecisionFormat(35633, 36337).precision > 0 && a.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const l = typeof WebGL2RenderingContext < "u" && a instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && a instanceof WebGL2ComputeRenderingContext;
  let d = t.precision !== void 0 ? t.precision : "highp";
  const h = o(d);
  h !== d && (console.warn("THREE.WebGLRenderer:", d, "not supported, using", h, "instead."), d = h);
  const m = l || e.has("WEBGL_draw_buffers"), S = t.logarithmicDepthBuffer === !0, _ = a.getParameter(34930), T = a.getParameter(35660), C = a.getParameter(3379), D = a.getParameter(34076), P = a.getParameter(34921), U = a.getParameter(36347), B = a.getParameter(36348), k = a.getParameter(36349), V = T > 0, I = l || e.has("OES_texture_float"), X = V && I, J = l ? a.getParameter(36183) : 0;
  return {
    isWebGL2: l,
    drawBuffers: m,
    getMaxAnisotropy: i,
    getMaxPrecision: o,
    precision: d,
    logarithmicDepthBuffer: S,
    maxTextures: _,
    maxVertexTextures: T,
    maxTextureSize: C,
    maxCubemapSize: D,
    maxAttributes: P,
    maxVertexUniforms: U,
    maxVaryings: B,
    maxFragmentUniforms: k,
    vertexTextures: V,
    floatFragmentTextures: I,
    floatVertexTextures: X,
    maxSamples: J
  };
}
function _G(a) {
  const e = this;
  let t = null, r = 0, i = !1, o = !1;
  const l = new C0(), d = new jh(), h = { value: null, needsUpdate: !1 };
  this.uniform = h, this.numPlanes = 0, this.numIntersection = 0, this.init = function(_, T, C) {
    const D = _.length !== 0 || T || r !== 0 || i;
    return i = T, t = S(_, C, 0), r = _.length, D;
  }, this.beginShadows = function() {
    o = !0, S(null);
  }, this.endShadows = function() {
    o = !1, m();
  }, this.setState = function(_, T, C) {
    const D = _.clippingPlanes, P = _.clipIntersection, U = _.clipShadows, B = a.get(_);
    if (!i || D === null || D.length === 0 || o && !U)
      o ? S(null) : m();
    else {
      const k = o ? 0 : r, V = k * 4;
      let I = B.clippingState || null;
      h.value = I, I = S(D, T, V, C);
      for (let X = 0; X !== V; ++X)
        I[X] = t[X];
      B.clippingState = I, this.numIntersection = P ? this.numPlanes : 0, this.numPlanes += k;
    }
  };
  function m() {
    h.value !== t && (h.value = t, h.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function S(_, T, C, D) {
    const P = _ !== null ? _.length : 0;
    let U = null;
    if (P !== 0) {
      if (U = h.value, D !== !0 || U === null) {
        const B = C + P * 4, k = T.matrixWorldInverse;
        d.getNormalMatrix(k), (U === null || U.length < B) && (U = new Float32Array(B));
        for (let V = 0, I = C; V !== P; ++V, I += 4)
          l.copy(_[V]).applyMatrix4(k, d), l.normal.toArray(U, I), U[I + 3] = l.constant;
      }
      h.value = U, h.needsUpdate = !0;
    }
    return e.numPlanes = P, e.numIntersection = 0, U;
  }
}
function bG(a) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(l, d) {
    return d === TM ? l.mapping = t1 : d === CM && (l.mapping = n1), l;
  }
  function r(l) {
    if (l && l.isTexture && l.isRenderTargetTexture === !1) {
      const d = l.mapping;
      if (d === TM || d === CM)
        if (e.has(l)) {
          const h = e.get(l).texture;
          return t(h, l.mapping);
        } else {
          const h = l.image;
          if (h && h.height > 0) {
            const m = new SF(h.height / 2);
            return m.fromEquirectangularTexture(a, l), e.set(l, m), l.addEventListener("dispose", i), t(m.texture, l.mapping);
          } else
            return null;
        }
    }
    return l;
  }
  function i(l) {
    const d = l.target;
    d.removeEventListener("dispose", i);
    const h = e.get(d);
    h !== void 0 && (e.delete(d), h.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: o
  };
}
class cy extends hw {
  constructor(e = -1, t = 1, r = 1, i = -1, o = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = i, this.near = o, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, r, i, o, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let o = r - e, l = r + e, d = i + t, h = i - t;
    if (this.view !== null && this.view.enabled) {
      const m = (this.right - this.left) / this.view.fullWidth / this.zoom, S = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += m * this.view.offsetX, l = o + m * this.view.width, d -= S * this.view.offsetY, h = d - S * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, l, d, h, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Hb = 4, HO = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], DS = 20, WA = /* @__PURE__ */ new cy(), VO = /* @__PURE__ */ new Pn();
let jA = null;
const TS = (1 + Math.sqrt(5)) / 2, Ab = 1 / TS, GO = [
  /* @__PURE__ */ new ge(1, 1, 1),
  /* @__PURE__ */ new ge(-1, 1, 1),
  /* @__PURE__ */ new ge(1, 1, -1),
  /* @__PURE__ */ new ge(-1, 1, -1),
  /* @__PURE__ */ new ge(0, TS, Ab),
  /* @__PURE__ */ new ge(0, TS, -Ab),
  /* @__PURE__ */ new ge(Ab, 0, TS),
  /* @__PURE__ */ new ge(-Ab, 0, TS),
  /* @__PURE__ */ new ge(TS, Ab, 0),
  /* @__PURE__ */ new ge(-TS, Ab, 0)
];
class p3 {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    jA = this._renderer.getRenderTarget(), this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, r, i, o), t > 0 && this._blur(o, 0, 0, t), this._applyPMREM(o), this._cleanup(o), o;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = YO(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = jO(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(jA), e.scissorTest = !1, T2(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === t1 || e.mapping === n1 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), jA = this._renderer.getRenderTarget();
    const r = t || this._allocateTargets();
    return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = {
      magFilter: Po,
      minFilter: Po,
      generateMipmaps: !1,
      type: GS,
      format: Sm,
      encoding: yv,
      depthBuffer: !1
    }, i = WO(e, t, r);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = WO(e, t, r);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = wG(o)), this._blurMaterial = EG(o, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new zn(this._lodPlanes[0], e);
    this._renderer.compile(t, WA);
  }
  _sceneToCubeUV(e, t, r, i) {
    const d = new fo(90, 1, t, r), h = [1, -1, 1, 1, 1, 1], m = [1, 1, 1, -1, -1, -1], S = this._renderer, _ = S.autoClear, T = S.toneMapping;
    S.getClearColor(VO), S.toneMapping = rg, S.autoClear = !1;
    const C = new og({
      name: "PMREM.Background",
      side: uf,
      depthWrite: !1,
      depthTest: !1
    }), D = new zn(new cl(), C);
    let P = !1;
    const U = e.background;
    U ? U.isColor && (C.color.copy(U), e.background = null, P = !0) : (C.color.copy(VO), P = !0);
    for (let B = 0; B < 6; B++) {
      const k = B % 3;
      k === 0 ? (d.up.set(0, h[B], 0), d.lookAt(m[B], 0, 0)) : k === 1 ? (d.up.set(0, 0, h[B]), d.lookAt(0, m[B], 0)) : (d.up.set(0, h[B], 0), d.lookAt(0, 0, m[B]));
      const V = this._cubeSize;
      T2(i, k * V, B > 2 ? V : 0, V, V), S.setRenderTarget(i), P && S.render(D, d), S.render(e, d);
    }
    D.geometry.dispose(), D.material.dispose(), S.toneMapping = T, S.autoClear = _, e.background = U;
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer, i = e.mapping === t1 || e.mapping === n1;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = YO()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = jO());
    const o = i ? this._cubemapMaterial : this._equirectMaterial, l = new zn(this._lodPlanes[0], o), d = o.uniforms;
    d.envMap.value = e;
    const h = this._cubeSize;
    T2(t, 0, 0, 3 * h, 2 * h), r.setRenderTarget(t), r.render(l, WA);
  }
  _applyPMREM(e) {
    const t = this._renderer, r = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const o = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), l = GO[(i - 1) % GO.length];
      this._blur(e, i - 1, i, o, l);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, o) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      r,
      i,
      "latitudinal",
      o
    ), this._halfBlur(
      l,
      e,
      r,
      r,
      i,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, t, r, i, o, l, d) {
    const h = this._renderer, m = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const S = 3, _ = new zn(this._lodPlanes[i], m), T = m.uniforms, C = this._sizeLods[r] - 1, D = isFinite(o) ? Math.PI / (2 * C) : 2 * Math.PI / (2 * DS - 1), P = o / D, U = isFinite(o) ? 1 + Math.floor(S * P) : DS;
    U > DS && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${U} samples when the maximum is set to ${DS}`);
    const B = [];
    let k = 0;
    for (let $ = 0; $ < DS; ++$) {
      const W = $ / P, ee = Math.exp(-W * W / 2);
      B.push(ee), $ === 0 ? k += ee : $ < U && (k += 2 * ee);
    }
    for (let $ = 0; $ < B.length; $++)
      B[$] = B[$] / k;
    T.envMap.value = e.texture, T.samples.value = U, T.weights.value = B, T.latitudinal.value = l === "latitudinal", d && (T.poleAxis.value = d);
    const { _lodMax: V } = this;
    T.dTheta.value = D, T.mipInt.value = V - r;
    const I = this._sizeLods[i], X = 3 * I * (i > V - Hb ? i - V + Hb : 0), J = 4 * (this._cubeSize - I);
    T2(t, X, J, 3 * I, 2 * I), h.setRenderTarget(t), h.render(_, WA);
  }
}
function wG(a) {
  const e = [], t = [], r = [];
  let i = a;
  const o = a - Hb + 1 + HO.length;
  for (let l = 0; l < o; l++) {
    const d = Math.pow(2, i);
    t.push(d);
    let h = 1 / d;
    l > a - Hb ? h = HO[l - a + Hb - 1] : l === 0 && (h = 0), r.push(h);
    const m = 1 / (d - 2), S = -m, _ = 1 + m, T = [S, S, _, S, _, _, S, S, _, _, S, _], C = 6, D = 6, P = 3, U = 2, B = 1, k = new Float32Array(P * D * C), V = new Float32Array(U * D * C), I = new Float32Array(B * D * C);
    for (let J = 0; J < C; J++) {
      const $ = J % 3 * 2 / 3 - 1, W = J > 2 ? 0 : -1, ee = [
        $,
        W,
        0,
        $ + 2 / 3,
        W,
        0,
        $ + 2 / 3,
        W + 1,
        0,
        $,
        W,
        0,
        $ + 2 / 3,
        W + 1,
        0,
        $,
        W + 1,
        0
      ];
      k.set(ee, P * D * J), V.set(T, U * D * J);
      const ie = [J, J, J, J, J, J];
      I.set(ie, B * D * J);
    }
    const X = new ui();
    X.setAttribute("position", new os(k, P)), X.setAttribute("uv", new os(V, U)), X.setAttribute("faceIndex", new os(I, B)), e.push(X), i > Hb && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function WO(a, e, t) {
  const r = new po(a, e, t);
  return r.texture.mapping = dw, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
}
function T2(a, e, t, r, i) {
  a.viewport.set(e, t, r, i), a.scissor.set(e, t, r, i);
}
function EG(a, e, t) {
  const r = new Float32Array(DS), i = new ge(0, 1, 0);
  return new wu({
    name: "SphericalGaussianBlur",
    defines: {
      n: DS,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${a}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: J3(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: cf,
    depthTest: !1,
    depthWrite: !1
  });
}
function jO() {
  return new wu({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: J3(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: cf,
    depthTest: !1,
    depthWrite: !1
  });
}
function YO() {
  return new wu({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: J3(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: cf,
    depthTest: !1,
    depthWrite: !1
  });
}
function J3() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function MG(a) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function r(d) {
    if (d && d.isTexture) {
      const h = d.mapping, m = h === TM || h === CM, S = h === t1 || h === n1;
      if (m || S)
        if (d.isRenderTargetTexture && d.needsPMREMUpdate === !0) {
          d.needsPMREMUpdate = !1;
          let _ = e.get(d);
          return t === null && (t = new p3(a)), _ = m ? t.fromEquirectangular(d, _) : t.fromCubemap(d, _), e.set(d, _), _.texture;
        } else {
          if (e.has(d))
            return e.get(d).texture;
          {
            const _ = d.image;
            if (m && _ && _.height > 0 || S && _ && i(_)) {
              t === null && (t = new p3(a));
              const T = m ? t.fromEquirectangular(d) : t.fromCubemap(d);
              return e.set(d, T), d.addEventListener("dispose", o), T.texture;
            } else
              return null;
          }
        }
    }
    return d;
  }
  function i(d) {
    let h = 0;
    const m = 6;
    for (let S = 0; S < m; S++)
      d[S] !== void 0 && h++;
    return h === m;
  }
  function o(d) {
    const h = d.target;
    h.removeEventListener("dispose", o);
    const m = e.get(h);
    m !== void 0 && (e.delete(h), m.dispose());
  }
  function l() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: r,
    dispose: l
  };
}
function TG(a) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0)
      return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = a.getExtension(r);
    }
    return e[r] = i, i;
  }
  return {
    has: function(r) {
      return t(r) !== null;
    },
    init: function(r) {
      r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(r) {
      const i = t(r);
      return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i;
    }
  };
}
function CG(a, e, t, r) {
  const i = {}, o = /* @__PURE__ */ new WeakMap();
  function l(_) {
    const T = _.target;
    T.index !== null && e.remove(T.index);
    for (const D in T.attributes)
      e.remove(T.attributes[D]);
    T.removeEventListener("dispose", l), delete i[T.id];
    const C = o.get(T);
    C && (e.remove(C), o.delete(T)), r.releaseStatesOfGeometry(T), T.isInstancedBufferGeometry === !0 && delete T._maxInstanceCount, t.memory.geometries--;
  }
  function d(_, T) {
    return i[T.id] === !0 || (T.addEventListener("dispose", l), i[T.id] = !0, t.memory.geometries++), T;
  }
  function h(_) {
    const T = _.attributes;
    for (const D in T)
      e.update(T[D], 34962);
    const C = _.morphAttributes;
    for (const D in C) {
      const P = C[D];
      for (let U = 0, B = P.length; U < B; U++)
        e.update(P[U], 34962);
    }
  }
  function m(_) {
    const T = [], C = _.index, D = _.attributes.position;
    let P = 0;
    if (C !== null) {
      const k = C.array;
      P = C.version;
      for (let V = 0, I = k.length; V < I; V += 3) {
        const X = k[V + 0], J = k[V + 1], $ = k[V + 2];
        T.push(X, J, J, $, $, X);
      }
    } else {
      const k = D.array;
      P = D.version;
      for (let V = 0, I = k.length / 3 - 1; V < I; V += 3) {
        const X = V + 0, J = V + 1, $ = V + 2;
        T.push(X, J, J, $, $, X);
      }
    }
    const U = new (gF(T) ? Z3 : Q3)(T, 1);
    U.version = P;
    const B = o.get(_);
    B && e.remove(B), o.set(_, U);
  }
  function S(_) {
    const T = o.get(_);
    if (T) {
      const C = _.index;
      C !== null && T.version < C.version && m(_);
    } else
      m(_);
    return o.get(_);
  }
  return {
    get: d,
    update: h,
    getWireframeAttribute: S
  };
}
function RG(a, e, t, r) {
  const i = r.isWebGL2;
  let o;
  function l(T) {
    o = T;
  }
  let d, h;
  function m(T) {
    d = T.type, h = T.bytesPerElement;
  }
  function S(T, C) {
    a.drawElements(o, C, d, T * h), t.update(C, o, 1);
  }
  function _(T, C, D) {
    if (D === 0)
      return;
    let P, U;
    if (i)
      P = a, U = "drawElementsInstanced";
    else if (P = e.get("ANGLE_instanced_arrays"), U = "drawElementsInstancedANGLE", P === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    P[U](o, C, d, T * h, D), t.update(C, o, D);
  }
  this.setMode = l, this.setIndex = m, this.render = S, this.renderInstances = _;
}
function AG(a) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(o, l, d) {
    switch (t.calls++, l) {
      case 4:
        t.triangles += d * (o / 3);
        break;
      case 1:
        t.lines += d * (o / 2);
        break;
      case 3:
        t.lines += d * (o - 1);
        break;
      case 2:
        t.lines += d * o;
        break;
      case 0:
        t.points += d * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function i() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r
  };
}
function DG(a, e) {
  return a[0] - e[0];
}
function LG(a, e) {
  return Math.abs(e[1]) - Math.abs(a[1]);
}
function YA(a, e) {
  let t = 1;
  const r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  r instanceof Int8Array ? t = 127 : r instanceof Uint8Array ? t = 255 : r instanceof Uint16Array ? t = 65535 : r instanceof Int16Array ? t = 32767 : r instanceof Int32Array ? t = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), a.divideScalar(t);
}
function PG(a, e, t) {
  const r = {}, i = new Float32Array(8), o = /* @__PURE__ */ new WeakMap(), l = new la(), d = [];
  for (let m = 0; m < 8; m++)
    d[m] = [m, 0];
  function h(m, S, _, T) {
    const C = m.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const D = S.morphAttributes.position || S.morphAttributes.normal || S.morphAttributes.color, P = D !== void 0 ? D.length : 0;
      let U = o.get(S);
      if (U === void 0 || U.count !== P) {
        let Fe = function() {
          Ee.dispose(), o.delete(S), S.removeEventListener("dispose", Fe);
        };
        U !== void 0 && U.texture.dispose();
        const V = S.morphAttributes.position !== void 0, I = S.morphAttributes.normal !== void 0, X = S.morphAttributes.color !== void 0, J = S.morphAttributes.position || [], $ = S.morphAttributes.normal || [], W = S.morphAttributes.color || [];
        let ee = 0;
        V === !0 && (ee = 1), I === !0 && (ee = 2), X === !0 && (ee = 3);
        let ie = S.attributes.position.count * ee, pe = 1;
        ie > e.maxTextureSize && (pe = Math.ceil(ie / e.maxTextureSize), ie = e.maxTextureSize);
        const ce = new Float32Array(ie * pe * 4 * P), Ee = new JM(ce, ie, pe, P);
        Ee.type = uy, Ee.needsUpdate = !0;
        const de = ee * 4;
        for (let Ce = 0; Ce < P; Ce++) {
          const Be = J[Ce], he = $[Ce], fe = W[Ce], ue = ie * pe * 4 * Ce;
          for (let ye = 0; ye < Be.count; ye++) {
            const we = ye * de;
            V === !0 && (l.fromBufferAttribute(Be, ye), Be.normalized === !0 && YA(l, Be), ce[ue + we + 0] = l.x, ce[ue + we + 1] = l.y, ce[ue + we + 2] = l.z, ce[ue + we + 3] = 0), I === !0 && (l.fromBufferAttribute(he, ye), he.normalized === !0 && YA(l, he), ce[ue + we + 4] = l.x, ce[ue + we + 5] = l.y, ce[ue + we + 6] = l.z, ce[ue + we + 7] = 0), X === !0 && (l.fromBufferAttribute(fe, ye), fe.normalized === !0 && YA(l, fe), ce[ue + we + 8] = l.x, ce[ue + we + 9] = l.y, ce[ue + we + 10] = l.z, ce[ue + we + 11] = fe.itemSize === 4 ? l.w : 1);
          }
        }
        U = {
          count: P,
          texture: Ee,
          size: new Ft(ie, pe)
        }, o.set(S, U), S.addEventListener("dispose", Fe);
      }
      let B = 0;
      for (let V = 0; V < C.length; V++)
        B += C[V];
      const k = S.morphTargetsRelative ? 1 : 1 - B;
      T.getUniforms().setValue(a, "morphTargetBaseInfluence", k), T.getUniforms().setValue(a, "morphTargetInfluences", C), T.getUniforms().setValue(a, "morphTargetsTexture", U.texture, t), T.getUniforms().setValue(a, "morphTargetsTextureSize", U.size);
    } else {
      const D = C === void 0 ? 0 : C.length;
      let P = r[S.id];
      if (P === void 0 || P.length !== D) {
        P = [];
        for (let I = 0; I < D; I++)
          P[I] = [I, 0];
        r[S.id] = P;
      }
      for (let I = 0; I < D; I++) {
        const X = P[I];
        X[0] = I, X[1] = C[I];
      }
      P.sort(LG);
      for (let I = 0; I < 8; I++)
        I < D && P[I][1] ? (d[I][0] = P[I][0], d[I][1] = P[I][1]) : (d[I][0] = Number.MAX_SAFE_INTEGER, d[I][1] = 0);
      d.sort(DG);
      const U = S.morphAttributes.position, B = S.morphAttributes.normal;
      let k = 0;
      for (let I = 0; I < 8; I++) {
        const X = d[I], J = X[0], $ = X[1];
        J !== Number.MAX_SAFE_INTEGER && $ ? (U && S.getAttribute("morphTarget" + I) !== U[J] && S.setAttribute("morphTarget" + I, U[J]), B && S.getAttribute("morphNormal" + I) !== B[J] && S.setAttribute("morphNormal" + I, B[J]), i[I] = $, k += $) : (U && S.hasAttribute("morphTarget" + I) === !0 && S.deleteAttribute("morphTarget" + I), B && S.hasAttribute("morphNormal" + I) === !0 && S.deleteAttribute("morphNormal" + I), i[I] = 0);
      }
      const V = S.morphTargetsRelative ? 1 : 1 - k;
      T.getUniforms().setValue(a, "morphTargetBaseInfluence", V), T.getUniforms().setValue(a, "morphTargetInfluences", i);
    }
  }
  return {
    update: h
  };
}
function OG(a, e, t, r) {
  let i = /* @__PURE__ */ new WeakMap();
  function o(h) {
    const m = r.render.frame, S = h.geometry, _ = e.get(h, S);
    return i.get(_) !== m && (e.update(_), i.set(_, m)), h.isInstancedMesh && (h.hasEventListener("dispose", d) === !1 && h.addEventListener("dispose", d), t.update(h.instanceMatrix, 34962), h.instanceColor !== null && t.update(h.instanceColor, 34962)), _;
  }
  function l() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function d(h) {
    const m = h.target;
    m.removeEventListener("dispose", d), t.remove(m.instanceMatrix), m.instanceColor !== null && t.remove(m.instanceColor);
  }
  return {
    update: o,
    dispose: l
  };
}
const bF = /* @__PURE__ */ new iu(), wF = /* @__PURE__ */ new JM(), EF = /* @__PURE__ */ new kC(), MF = /* @__PURE__ */ new eT(), XO = [], qO = [], QO = new Float32Array(16), ZO = new Float32Array(9), JO = new Float32Array(4);
function pw(a, e, t) {
  const r = a[0];
  if (r <= 0 || r > 0)
    return a;
  const i = e * t;
  let o = XO[i];
  if (o === void 0 && (o = new Float32Array(i), XO[i] = o), e !== 0) {
    r.toArray(o, 0);
    for (let l = 1, d = 0; l !== e; ++l)
      d += t, a[l].toArray(o, d);
  }
  return o;
}
function Yh(a, e) {
  if (a.length !== e.length)
    return !1;
  for (let t = 0, r = a.length; t < r; t++)
    if (a[t] !== e[t])
      return !1;
  return !0;
}
function Xh(a, e) {
  for (let t = 0, r = e.length; t < r; t++)
    a[t] = e[t];
}
function BC(a, e) {
  let t = qO[e];
  t === void 0 && (t = new Int32Array(e), qO[e] = t);
  for (let r = 0; r !== e; ++r)
    t[r] = a.allocateTextureUnit();
  return t;
}
function UG(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1f(this.addr, e), t[0] = e);
}
function zG(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (a.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Yh(t, e))
      return;
    a.uniform2fv(this.addr, e), Xh(t, e);
  }
}
function NG(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (a.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Yh(t, e))
      return;
    a.uniform3fv(this.addr, e), Xh(t, e);
  }
}
function FG(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Yh(t, e))
      return;
    a.uniform4fv(this.addr, e), Xh(t, e);
  }
}
function kG(a, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Yh(t, e))
      return;
    a.uniformMatrix2fv(this.addr, !1, e), Xh(t, e);
  } else {
    if (Yh(t, r))
      return;
    JO.set(r), a.uniformMatrix2fv(this.addr, !1, JO), Xh(t, r);
  }
}
function IG(a, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Yh(t, e))
      return;
    a.uniformMatrix3fv(this.addr, !1, e), Xh(t, e);
  } else {
    if (Yh(t, r))
      return;
    ZO.set(r), a.uniformMatrix3fv(this.addr, !1, ZO), Xh(t, r);
  }
}
function BG(a, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Yh(t, e))
      return;
    a.uniformMatrix4fv(this.addr, !1, e), Xh(t, e);
  } else {
    if (Yh(t, r))
      return;
    QO.set(r), a.uniformMatrix4fv(this.addr, !1, QO), Xh(t, r);
  }
}
function HG(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1i(this.addr, e), t[0] = e);
}
function VG(a, e) {
  const t = this.cache;
  Yh(t, e) || (a.uniform2iv(this.addr, e), Xh(t, e));
}
function GG(a, e) {
  const t = this.cache;
  Yh(t, e) || (a.uniform3iv(this.addr, e), Xh(t, e));
}
function WG(a, e) {
  const t = this.cache;
  Yh(t, e) || (a.uniform4iv(this.addr, e), Xh(t, e));
}
function jG(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1ui(this.addr, e), t[0] = e);
}
function YG(a, e) {
  const t = this.cache;
  Yh(t, e) || (a.uniform2uiv(this.addr, e), Xh(t, e));
}
function XG(a, e) {
  const t = this.cache;
  Yh(t, e) || (a.uniform3uiv(this.addr, e), Xh(t, e));
}
function qG(a, e) {
  const t = this.cache;
  Yh(t, e) || (a.uniform4uiv(this.addr, e), Xh(t, e));
}
function QG(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTexture2D(e || bF, i);
}
function ZG(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTexture3D(e || EF, i);
}
function JG(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTextureCube(e || MF, i);
}
function KG(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTexture2DArray(e || wF, i);
}
function $G(a) {
  switch (a) {
    case 5126:
      return UG;
    case 35664:
      return zG;
    case 35665:
      return NG;
    case 35666:
      return FG;
    case 35674:
      return kG;
    case 35675:
      return IG;
    case 35676:
      return BG;
    case 5124:
    case 35670:
      return HG;
    case 35667:
    case 35671:
      return VG;
    case 35668:
    case 35672:
      return GG;
    case 35669:
    case 35673:
      return WG;
    case 5125:
      return jG;
    case 36294:
      return YG;
    case 36295:
      return XG;
    case 36296:
      return qG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return QG;
    case 35679:
    case 36299:
    case 36307:
      return ZG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return JG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return KG;
  }
}
function e8(a, e) {
  a.uniform1fv(this.addr, e);
}
function t8(a, e) {
  const t = pw(e, this.size, 2);
  a.uniform2fv(this.addr, t);
}
function n8(a, e) {
  const t = pw(e, this.size, 3);
  a.uniform3fv(this.addr, t);
}
function r8(a, e) {
  const t = pw(e, this.size, 4);
  a.uniform4fv(this.addr, t);
}
function i8(a, e) {
  const t = pw(e, this.size, 4);
  a.uniformMatrix2fv(this.addr, !1, t);
}
function a8(a, e) {
  const t = pw(e, this.size, 9);
  a.uniformMatrix3fv(this.addr, !1, t);
}
function s8(a, e) {
  const t = pw(e, this.size, 16);
  a.uniformMatrix4fv(this.addr, !1, t);
}
function o8(a, e) {
  a.uniform1iv(this.addr, e);
}
function l8(a, e) {
  a.uniform2iv(this.addr, e);
}
function u8(a, e) {
  a.uniform3iv(this.addr, e);
}
function c8(a, e) {
  a.uniform4iv(this.addr, e);
}
function f8(a, e) {
  a.uniform1uiv(this.addr, e);
}
function d8(a, e) {
  a.uniform2uiv(this.addr, e);
}
function h8(a, e) {
  a.uniform3uiv(this.addr, e);
}
function p8(a, e) {
  a.uniform4uiv(this.addr, e);
}
function m8(a, e, t) {
  const r = e.length, i = BC(t, r);
  a.uniform1iv(this.addr, i);
  for (let o = 0; o !== r; ++o)
    t.setTexture2D(e[o] || bF, i[o]);
}
function v8(a, e, t) {
  const r = e.length, i = BC(t, r);
  a.uniform1iv(this.addr, i);
  for (let o = 0; o !== r; ++o)
    t.setTexture3D(e[o] || EF, i[o]);
}
function g8(a, e, t) {
  const r = e.length, i = BC(t, r);
  a.uniform1iv(this.addr, i);
  for (let o = 0; o !== r; ++o)
    t.setTextureCube(e[o] || MF, i[o]);
}
function y8(a, e, t) {
  const r = e.length, i = BC(t, r);
  a.uniform1iv(this.addr, i);
  for (let o = 0; o !== r; ++o)
    t.setTexture2DArray(e[o] || wF, i[o]);
}
function x8(a) {
  switch (a) {
    case 5126:
      return e8;
    case 35664:
      return t8;
    case 35665:
      return n8;
    case 35666:
      return r8;
    case 35674:
      return i8;
    case 35675:
      return a8;
    case 35676:
      return s8;
    case 5124:
    case 35670:
      return o8;
    case 35667:
    case 35671:
      return l8;
    case 35668:
    case 35672:
      return u8;
    case 35669:
    case 35673:
      return c8;
    case 5125:
      return f8;
    case 36294:
      return d8;
    case 36295:
      return h8;
    case 36296:
      return p8;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return m8;
    case 35679:
    case 36299:
    case 36307:
      return v8;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return g8;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return y8;
  }
}
class S8 {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.setValue = $G(t.type);
  }
}
class _8 {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = x8(t.type);
  }
}
class b8 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let o = 0, l = i.length; o !== l; ++o) {
      const d = i[o];
      d.setValue(e, t[d.id], r);
    }
  }
}
const XA = /(\w+)(\])?(\[|\.)?/g;
function KO(a, e) {
  a.seq.push(e), a.map[e.id] = e;
}
function w8(a, e, t) {
  const r = a.name, i = r.length;
  for (XA.lastIndex = 0; ; ) {
    const o = XA.exec(r), l = XA.lastIndex;
    let d = o[1];
    const h = o[2] === "]", m = o[3];
    if (h && (d = d | 0), m === void 0 || m === "[" && l + 2 === i) {
      KO(t, m === void 0 ? new S8(d, a, e) : new _8(d, a, e));
      break;
    } else {
      let _ = t.map[d];
      _ === void 0 && (_ = new b8(d), KO(t, _)), t = _;
    }
  }
}
class vC {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const r = e.getProgramParameter(t, 35718);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(t, i), l = e.getUniformLocation(t, o.name);
      w8(o, l, this);
    }
  }
  setValue(e, t, r, i) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let o = 0, l = t.length; o !== l; ++o) {
      const d = t[o], h = r[d.id];
      h.needsUpdate !== !1 && d.setValue(e, h.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const l = e[i];
      l.id in t && r.push(l);
    }
    return r;
  }
}
function $O(a, e, t) {
  const r = a.createShader(e);
  return a.shaderSource(r, t), a.compileShader(r), r;
}
let E8 = 0;
function M8(a, e) {
  const t = a.split(`
`), r = [], i = Math.max(e - 6, 0), o = Math.min(e + 6, t.length);
  for (let l = i; l < o; l++) {
    const d = l + 1;
    r.push(`${d === e ? ">" : " "} ${d}: ${t[l]}`);
  }
  return r.join(`
`);
}
function T8(a) {
  switch (a) {
    case yv:
      return ["Linear", "( value )"];
    case Mi:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", a), ["Linear", "( value )"];
  }
}
function eU(a, e, t) {
  const r = a.getShaderParameter(e, 35713), i = a.getShaderInfoLog(e).trim();
  if (r && i === "")
    return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const l = parseInt(o[1]);
    return t.toUpperCase() + `

` + i + `

` + M8(a.getShaderSource(e), l);
  } else
    return i;
}
function C8(a, e) {
  const t = T8(e);
  return "vec4 " + a + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function R8(a, e) {
  let t;
  switch (e) {
    case jN:
      t = "Linear";
      break;
    case YN:
      t = "Reinhard";
      break;
    case XN:
      t = "OptimizedCineon";
      break;
    case G3:
      t = "ACESFilmic";
      break;
    case qN:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + a + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function A8(a) {
  return [
    a.extensionDerivatives || !!a.envMapCubeUVHeight || a.bumpMap || a.tangentSpaceNormalMap || a.clearcoatNormalMap || a.flatShading || a.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (a.extensionFragDepth || a.logarithmicDepthBuffer) && a.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    a.extensionDrawBuffers && a.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (a.extensionShaderTextureLOD || a.envMap || a.transmission) && a.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(pM).join(`
`);
}
function D8(a) {
  const e = [];
  for (const t in a) {
    const r = a[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function L8(a, e) {
  const t = {}, r = a.getProgramParameter(e, 35721);
  for (let i = 0; i < r; i++) {
    const o = a.getActiveAttrib(e, i), l = o.name;
    let d = 1;
    o.type === 35674 && (d = 2), o.type === 35675 && (d = 3), o.type === 35676 && (d = 4), t[l] = {
      type: o.type,
      location: a.getAttribLocation(e, l),
      locationSize: d
    };
  }
  return t;
}
function pM(a) {
  return a !== "";
}
function tU(a, e) {
  return a.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function nU(a, e) {
  return a.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const P8 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function m3(a) {
  return a.replace(P8, O8);
}
function O8(a, e) {
  const t = na[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return m3(t);
}
const U8 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, z8 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function rU(a) {
  return a.replace(z8, TF).replace(U8, N8);
}
function N8(a, e, t, r) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), TF(a, e, t, r);
}
function TF(a, e, t, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    i += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function iU(a) {
  let e = "precision " + a.precision + ` float;
precision ` + a.precision + " int;";
  return a.precision === "highp" ? e += `
#define HIGH_PRECISION` : a.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : a.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function F8(a) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return a.shadowMapType === B3 ? e = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === H3 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : a.shadowMapType === Ib && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function k8(a) {
  let e = "ENVMAP_TYPE_CUBE";
  if (a.envMap)
    switch (a.envMapMode) {
      case t1:
      case n1:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case dw:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function I8(a) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (a.envMap)
    switch (a.envMapMode) {
      case n1:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function B8(a) {
  let e = "ENVMAP_BLENDING_NONE";
  if (a.envMap)
    switch (a.combine) {
      case ZM:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case GN:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case WN:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function H8(a) {
  const e = a.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, r = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t };
}
function V8(a, e, t, r) {
  const i = a.getContext(), o = t.defines;
  let l = t.vertexShader, d = t.fragmentShader;
  const h = F8(t), m = k8(t), S = I8(t), _ = B8(t), T = H8(t), C = t.isWebGL2 ? "" : A8(t), D = D8(o), P = i.createProgram();
  let U, B, k = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (U = [
    D
  ].filter(pM).join(`
`), U.length > 0 && (U += `
`), B = [
    C,
    D
  ].filter(pM).join(`
`), B.length > 0 && (B += `
`)) : (U = [
    iU(t),
    "#define SHADER_NAME " + t.shaderName,
    D,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + S : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + h : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(pM).join(`
`), B = [
    C,
    iU(t),
    "#define SHADER_NAME " + t.shaderName,
    D,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + m : "",
    t.envMap ? "#define " + S : "",
    t.envMap ? "#define " + _ : "",
    T ? "#define CUBEUV_TEXEL_WIDTH " + T.texelWidth : "",
    T ? "#define CUBEUV_TEXEL_HEIGHT " + T.texelHeight : "",
    T ? "#define CUBEUV_MAX_MIP " + T.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + h : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== rg ? "#define TONE_MAPPING" : "",
    t.toneMapping !== rg ? na.tonemapping_pars_fragment : "",
    t.toneMapping !== rg ? R8("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    na.encodings_pars_fragment,
    C8("linearToOutputTexel", t.outputEncoding),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(pM).join(`
`)), l = m3(l), l = tU(l, t), l = nU(l, t), d = m3(d), d = tU(d, t), d = nU(d, t), l = rU(l), d = rU(d), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (k = `#version 300 es
`, U = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + U, B = [
    "#define varying in",
    t.glslVersion === d3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === d3 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + B);
  const V = k + U + l, I = k + B + d, X = $O(i, 35633, V), J = $O(i, 35632, I);
  if (i.attachShader(P, X), i.attachShader(P, J), t.index0AttributeName !== void 0 ? i.bindAttribLocation(P, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(P, 0, "position"), i.linkProgram(P), a.debug.checkShaderErrors) {
    const ee = i.getProgramInfoLog(P).trim(), ie = i.getShaderInfoLog(X).trim(), pe = i.getShaderInfoLog(J).trim();
    let ce = !0, Ee = !0;
    if (i.getProgramParameter(P, 35714) === !1) {
      ce = !1;
      const de = eU(i, X, "vertex"), Fe = eU(i, J, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(P, 35715) + `

Program Info Log: ` + ee + `
` + de + `
` + Fe
      );
    } else
      ee !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", ee) : (ie === "" || pe === "") && (Ee = !1);
    Ee && (this.diagnostics = {
      runnable: ce,
      programLog: ee,
      vertexShader: {
        log: ie,
        prefix: U
      },
      fragmentShader: {
        log: pe,
        prefix: B
      }
    });
  }
  i.deleteShader(X), i.deleteShader(J);
  let $;
  this.getUniforms = function() {
    return $ === void 0 && ($ = new vC(i, P)), $;
  };
  let W;
  return this.getAttributes = function() {
    return W === void 0 && (W = L8(i, P)), W;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), i.deleteProgram(P), this.program = void 0;
  }, this.name = t.shaderName, this.id = E8++, this.cacheKey = e, this.usedTimes = 1, this.program = P, this.vertexShader = X, this.fragmentShader = J, this;
}
let G8 = 0;
class W8 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(t), o = this._getShaderStage(r), l = this._getShaderCacheForMaterial(e);
    return l.has(i) === !1 && (l.add(i), i.usedTimes++), l.has(o) === !1 && (l.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    return t.has(e) === !1 && t.set(e, /* @__PURE__ */ new Set()), t.get(e);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    if (t.has(e) === !1) {
      const r = new j8(e);
      t.set(e, r);
    }
    return t.get(e);
  }
}
class j8 {
  constructor(e) {
    this.id = G8++, this.code = e, this.usedTimes = 0;
  }
}
function Y8(a, e, t, r, i, o, l) {
  const d = new kS(), h = new W8(), m = [], S = i.isWebGL2, _ = i.logarithmicDepthBuffer, T = i.vertexTextures;
  let C = i.precision;
  const D = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function P(W, ee, ie, pe, ce) {
    const Ee = pe.fog, de = ce.geometry, Fe = W.isMeshStandardMaterial ? pe.environment : null, Ce = (W.isMeshStandardMaterial ? t : e).get(W.envMap || Fe), Be = !!Ce && Ce.mapping === dw ? Ce.image.height : null, he = D[W.type];
    W.precision !== null && (C = i.getMaxPrecision(W.precision), C !== W.precision && console.warn("THREE.WebGLProgram.getParameters:", W.precision, "not supported, using", C, "instead."));
    const fe = de.morphAttributes.position || de.morphAttributes.normal || de.morphAttributes.color, ue = fe !== void 0 ? fe.length : 0;
    let ye = 0;
    de.morphAttributes.position !== void 0 && (ye = 1), de.morphAttributes.normal !== void 0 && (ye = 2), de.morphAttributes.color !== void 0 && (ye = 3);
    let we, Xe, Je, st;
    if (he) {
      const Ot = Gh[he];
      we = Ot.vertexShader, Xe = Ot.fragmentShader;
    } else
      we = W.vertexShader, Xe = W.fragmentShader, h.update(W), Je = h.getVertexShaderID(W), st = h.getFragmentShaderID(W);
    const Ue = a.getRenderTarget(), ot = W.alphaTest > 0, rt = W.clearcoat > 0, _t = W.iridescence > 0;
    return {
      isWebGL2: S,
      shaderID: he,
      shaderName: W.type,
      vertexShader: we,
      fragmentShader: Xe,
      defines: W.defines,
      customVertexShaderID: Je,
      customFragmentShaderID: st,
      isRawShaderMaterial: W.isRawShaderMaterial === !0,
      glslVersion: W.glslVersion,
      precision: C,
      instancing: ce.isInstancedMesh === !0,
      instancingColor: ce.isInstancedMesh === !0 && ce.instanceColor !== null,
      supportsVertexTextures: T,
      outputEncoding: Ue === null ? a.outputEncoding : Ue.isXRRenderTarget === !0 ? Ue.texture.encoding : yv,
      map: !!W.map,
      matcap: !!W.matcap,
      envMap: !!Ce,
      envMapMode: Ce && Ce.mapping,
      envMapCubeUVHeight: Be,
      lightMap: !!W.lightMap,
      aoMap: !!W.aoMap,
      emissiveMap: !!W.emissiveMap,
      bumpMap: !!W.bumpMap,
      normalMap: !!W.normalMap,
      objectSpaceNormalMap: W.normalMapType === hF,
      tangentSpaceNormalMap: W.normalMapType === qS,
      decodeVideoTexture: !!W.map && W.map.isVideoTexture === !0 && W.map.encoding === Mi,
      clearcoat: rt,
      clearcoatMap: rt && !!W.clearcoatMap,
      clearcoatRoughnessMap: rt && !!W.clearcoatRoughnessMap,
      clearcoatNormalMap: rt && !!W.clearcoatNormalMap,
      iridescence: _t,
      iridescenceMap: _t && !!W.iridescenceMap,
      iridescenceThicknessMap: _t && !!W.iridescenceThicknessMap,
      displacementMap: !!W.displacementMap,
      roughnessMap: !!W.roughnessMap,
      metalnessMap: !!W.metalnessMap,
      specularMap: !!W.specularMap,
      specularIntensityMap: !!W.specularIntensityMap,
      specularColorMap: !!W.specularColorMap,
      opaque: W.transparent === !1 && W.blending === L0,
      alphaMap: !!W.alphaMap,
      alphaTest: ot,
      gradientMap: !!W.gradientMap,
      sheen: W.sheen > 0,
      sheenColorMap: !!W.sheenColorMap,
      sheenRoughnessMap: !!W.sheenRoughnessMap,
      transmission: W.transmission > 0,
      transmissionMap: !!W.transmissionMap,
      thicknessMap: !!W.thicknessMap,
      combine: W.combine,
      vertexTangents: !!W.normalMap && !!de.attributes.tangent,
      vertexColors: W.vertexColors,
      vertexAlphas: W.vertexColors === !0 && !!de.attributes.color && de.attributes.color.itemSize === 4,
      vertexUvs: !!W.map || !!W.bumpMap || !!W.normalMap || !!W.specularMap || !!W.alphaMap || !!W.emissiveMap || !!W.roughnessMap || !!W.metalnessMap || !!W.clearcoatMap || !!W.clearcoatRoughnessMap || !!W.clearcoatNormalMap || !!W.iridescenceMap || !!W.iridescenceThicknessMap || !!W.displacementMap || !!W.transmissionMap || !!W.thicknessMap || !!W.specularIntensityMap || !!W.specularColorMap || !!W.sheenColorMap || !!W.sheenRoughnessMap,
      uvsVertexOnly: !(!!W.map || !!W.bumpMap || !!W.normalMap || !!W.specularMap || !!W.alphaMap || !!W.emissiveMap || !!W.roughnessMap || !!W.metalnessMap || !!W.clearcoatNormalMap || !!W.iridescenceMap || !!W.iridescenceThicknessMap || W.transmission > 0 || !!W.transmissionMap || !!W.thicknessMap || !!W.specularIntensityMap || !!W.specularColorMap || W.sheen > 0 || !!W.sheenColorMap || !!W.sheenRoughnessMap) && !!W.displacementMap,
      fog: !!Ee,
      useFog: W.fog === !0,
      fogExp2: Ee && Ee.isFogExp2,
      flatShading: !!W.flatShading,
      sizeAttenuation: W.sizeAttenuation,
      logarithmicDepthBuffer: _,
      skinning: ce.isSkinnedMesh === !0,
      morphTargets: de.morphAttributes.position !== void 0,
      morphNormals: de.morphAttributes.normal !== void 0,
      morphColors: de.morphAttributes.color !== void 0,
      morphTargetsCount: ue,
      morphTextureStride: ye,
      numDirLights: ee.directional.length,
      numPointLights: ee.point.length,
      numSpotLights: ee.spot.length,
      numRectAreaLights: ee.rectArea.length,
      numHemiLights: ee.hemi.length,
      numDirLightShadows: ee.directionalShadowMap.length,
      numPointLightShadows: ee.pointShadowMap.length,
      numSpotLightShadows: ee.spotShadowMap.length,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: W.dithering,
      shadowMapEnabled: a.shadowMap.enabled && ie.length > 0,
      shadowMapType: a.shadowMap.type,
      toneMapping: W.toneMapped ? a.toneMapping : rg,
      physicallyCorrectLights: a.physicallyCorrectLights,
      premultipliedAlpha: W.premultipliedAlpha,
      doubleSided: W.side === Pp,
      flipSided: W.side === uf,
      useDepthPacking: !!W.depthPacking,
      depthPacking: W.depthPacking || 0,
      index0AttributeName: W.index0AttributeName,
      extensionDerivatives: W.extensions && W.extensions.derivatives,
      extensionFragDepth: W.extensions && W.extensions.fragDepth,
      extensionDrawBuffers: W.extensions && W.extensions.drawBuffers,
      extensionShaderTextureLOD: W.extensions && W.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: S || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: S || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: S || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: W.customProgramCacheKey()
    };
  }
  function U(W) {
    const ee = [];
    if (W.shaderID ? ee.push(W.shaderID) : (ee.push(W.customVertexShaderID), ee.push(W.customFragmentShaderID)), W.defines !== void 0)
      for (const ie in W.defines)
        ee.push(ie), ee.push(W.defines[ie]);
    return W.isRawShaderMaterial === !1 && (B(ee, W), k(ee, W), ee.push(a.outputEncoding)), ee.push(W.customProgramCacheKey), ee.join();
  }
  function B(W, ee) {
    W.push(ee.precision), W.push(ee.outputEncoding), W.push(ee.envMapMode), W.push(ee.envMapCubeUVHeight), W.push(ee.combine), W.push(ee.vertexUvs), W.push(ee.fogExp2), W.push(ee.sizeAttenuation), W.push(ee.morphTargetsCount), W.push(ee.morphAttributeCount), W.push(ee.numDirLights), W.push(ee.numPointLights), W.push(ee.numSpotLights), W.push(ee.numHemiLights), W.push(ee.numRectAreaLights), W.push(ee.numDirLightShadows), W.push(ee.numPointLightShadows), W.push(ee.numSpotLightShadows), W.push(ee.shadowMapType), W.push(ee.toneMapping), W.push(ee.numClippingPlanes), W.push(ee.numClipIntersection), W.push(ee.depthPacking);
  }
  function k(W, ee) {
    d.disableAll(), ee.isWebGL2 && d.enable(0), ee.supportsVertexTextures && d.enable(1), ee.instancing && d.enable(2), ee.instancingColor && d.enable(3), ee.map && d.enable(4), ee.matcap && d.enable(5), ee.envMap && d.enable(6), ee.lightMap && d.enable(7), ee.aoMap && d.enable(8), ee.emissiveMap && d.enable(9), ee.bumpMap && d.enable(10), ee.normalMap && d.enable(11), ee.objectSpaceNormalMap && d.enable(12), ee.tangentSpaceNormalMap && d.enable(13), ee.clearcoat && d.enable(14), ee.clearcoatMap && d.enable(15), ee.clearcoatRoughnessMap && d.enable(16), ee.clearcoatNormalMap && d.enable(17), ee.iridescence && d.enable(18), ee.iridescenceMap && d.enable(19), ee.iridescenceThicknessMap && d.enable(20), ee.displacementMap && d.enable(21), ee.specularMap && d.enable(22), ee.roughnessMap && d.enable(23), ee.metalnessMap && d.enable(24), ee.gradientMap && d.enable(25), ee.alphaMap && d.enable(26), ee.alphaTest && d.enable(27), ee.vertexColors && d.enable(28), ee.vertexAlphas && d.enable(29), ee.vertexUvs && d.enable(30), ee.vertexTangents && d.enable(31), ee.uvsVertexOnly && d.enable(32), ee.fog && d.enable(33), W.push(d.mask), d.disableAll(), ee.useFog && d.enable(0), ee.flatShading && d.enable(1), ee.logarithmicDepthBuffer && d.enable(2), ee.skinning && d.enable(3), ee.morphTargets && d.enable(4), ee.morphNormals && d.enable(5), ee.morphColors && d.enable(6), ee.premultipliedAlpha && d.enable(7), ee.shadowMapEnabled && d.enable(8), ee.physicallyCorrectLights && d.enable(9), ee.doubleSided && d.enable(10), ee.flipSided && d.enable(11), ee.useDepthPacking && d.enable(12), ee.dithering && d.enable(13), ee.specularIntensityMap && d.enable(14), ee.specularColorMap && d.enable(15), ee.transmission && d.enable(16), ee.transmissionMap && d.enable(17), ee.thicknessMap && d.enable(18), ee.sheen && d.enable(19), ee.sheenColorMap && d.enable(20), ee.sheenRoughnessMap && d.enable(21), ee.decodeVideoTexture && d.enable(22), ee.opaque && d.enable(23), W.push(d.mask);
  }
  function V(W) {
    const ee = D[W.type];
    let ie;
    if (ee) {
      const pe = Gh[ee];
      ie = $M.clone(pe.uniforms);
    } else
      ie = W.uniforms;
    return ie;
  }
  function I(W, ee) {
    let ie;
    for (let pe = 0, ce = m.length; pe < ce; pe++) {
      const Ee = m[pe];
      if (Ee.cacheKey === ee) {
        ie = Ee, ++ie.usedTimes;
        break;
      }
    }
    return ie === void 0 && (ie = new V8(a, ee, W, o), m.push(ie)), ie;
  }
  function X(W) {
    if (--W.usedTimes === 0) {
      const ee = m.indexOf(W);
      m[ee] = m[m.length - 1], m.pop(), W.destroy();
    }
  }
  function J(W) {
    h.remove(W);
  }
  function $() {
    h.dispose();
  }
  return {
    getParameters: P,
    getProgramCacheKey: U,
    getUniforms: V,
    acquireProgram: I,
    releaseProgram: X,
    releaseShaderCache: J,
    programs: m,
    dispose: $
  };
}
function X8() {
  let a = /* @__PURE__ */ new WeakMap();
  function e(o) {
    let l = a.get(o);
    return l === void 0 && (l = {}, a.set(o, l)), l;
  }
  function t(o) {
    a.delete(o);
  }
  function r(o, l, d) {
    a.get(o)[l] = d;
  }
  function i() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: r,
    dispose: i
  };
}
function q8(a, e) {
  return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.material.id !== e.material.id ? a.material.id - e.material.id : a.z !== e.z ? a.z - e.z : a.id - e.id;
}
function aU(a, e) {
  return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.z !== e.z ? e.z - a.z : a.id - e.id;
}
function sU() {
  const a = [];
  let e = 0;
  const t = [], r = [], i = [];
  function o() {
    e = 0, t.length = 0, r.length = 0, i.length = 0;
  }
  function l(_, T, C, D, P, U) {
    let B = a[e];
    return B === void 0 ? (B = {
      id: _.id,
      object: _,
      geometry: T,
      material: C,
      groupOrder: D,
      renderOrder: _.renderOrder,
      z: P,
      group: U
    }, a[e] = B) : (B.id = _.id, B.object = _, B.geometry = T, B.material = C, B.groupOrder = D, B.renderOrder = _.renderOrder, B.z = P, B.group = U), e++, B;
  }
  function d(_, T, C, D, P, U) {
    const B = l(_, T, C, D, P, U);
    C.transmission > 0 ? r.push(B) : C.transparent === !0 ? i.push(B) : t.push(B);
  }
  function h(_, T, C, D, P, U) {
    const B = l(_, T, C, D, P, U);
    C.transmission > 0 ? r.unshift(B) : C.transparent === !0 ? i.unshift(B) : t.unshift(B);
  }
  function m(_, T) {
    t.length > 1 && t.sort(_ || q8), r.length > 1 && r.sort(T || aU), i.length > 1 && i.sort(T || aU);
  }
  function S() {
    for (let _ = e, T = a.length; _ < T; _++) {
      const C = a[_];
      if (C.id === null)
        break;
      C.id = null, C.object = null, C.geometry = null, C.material = null, C.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: o,
    push: d,
    unshift: h,
    finish: S,
    sort: m
  };
}
function Q8() {
  let a = /* @__PURE__ */ new WeakMap();
  function e(r, i) {
    let o;
    return a.has(r) === !1 ? (o = new sU(), a.set(r, [o])) : i >= a.get(r).length ? (o = new sU(), a.get(r).push(o)) : o = a.get(r)[i], o;
  }
  function t() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function Z8() {
  const a = {};
  return {
    get: function(e) {
      if (a[e.id] !== void 0)
        return a[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new ge(),
            color: new Pn()
          };
          break;
        case "SpotLight":
          t = {
            position: new ge(),
            direction: new ge(),
            color: new Pn(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new ge(),
            color: new Pn(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new ge(),
            skyColor: new Pn(),
            groundColor: new Pn()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Pn(),
            position: new ge(),
            halfWidth: new ge(),
            halfHeight: new ge()
          };
          break;
      }
      return a[e.id] = t, t;
    }
  };
}
function J8() {
  const a = {};
  return {
    get: function(e) {
      if (a[e.id] !== void 0)
        return a[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ft()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ft()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ft(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return a[e.id] = t, t;
    }
  };
}
let K8 = 0;
function $8(a, e) {
  return (e.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0);
}
function eW(a, e) {
  const t = new Z8(), r = J8(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let S = 0; S < 9; S++)
    i.probe.push(new ge());
  const o = new ge(), l = new si(), d = new si();
  function h(S, _) {
    let T = 0, C = 0, D = 0;
    for (let ee = 0; ee < 9; ee++)
      i.probe[ee].set(0, 0, 0);
    let P = 0, U = 0, B = 0, k = 0, V = 0, I = 0, X = 0, J = 0;
    S.sort($8);
    const $ = _ !== !0 ? Math.PI : 1;
    for (let ee = 0, ie = S.length; ee < ie; ee++) {
      const pe = S[ee], ce = pe.color, Ee = pe.intensity, de = pe.distance, Fe = pe.shadow && pe.shadow.map ? pe.shadow.map.texture : null;
      if (pe.isAmbientLight)
        T += ce.r * Ee * $, C += ce.g * Ee * $, D += ce.b * Ee * $;
      else if (pe.isLightProbe)
        for (let Ce = 0; Ce < 9; Ce++)
          i.probe[Ce].addScaledVector(pe.sh.coefficients[Ce], Ee);
      else if (pe.isDirectionalLight) {
        const Ce = t.get(pe);
        if (Ce.color.copy(pe.color).multiplyScalar(pe.intensity * $), pe.castShadow) {
          const Be = pe.shadow, he = r.get(pe);
          he.shadowBias = Be.bias, he.shadowNormalBias = Be.normalBias, he.shadowRadius = Be.radius, he.shadowMapSize = Be.mapSize, i.directionalShadow[P] = he, i.directionalShadowMap[P] = Fe, i.directionalShadowMatrix[P] = pe.shadow.matrix, I++;
        }
        i.directional[P] = Ce, P++;
      } else if (pe.isSpotLight) {
        const Ce = t.get(pe);
        if (Ce.position.setFromMatrixPosition(pe.matrixWorld), Ce.color.copy(ce).multiplyScalar(Ee * $), Ce.distance = de, Ce.coneCos = Math.cos(pe.angle), Ce.penumbraCos = Math.cos(pe.angle * (1 - pe.penumbra)), Ce.decay = pe.decay, pe.castShadow) {
          const Be = pe.shadow, he = r.get(pe);
          he.shadowBias = Be.bias, he.shadowNormalBias = Be.normalBias, he.shadowRadius = Be.radius, he.shadowMapSize = Be.mapSize, i.spotShadow[B] = he, i.spotShadowMap[B] = Fe, i.spotShadowMatrix[B] = pe.shadow.matrix, J++;
        }
        i.spot[B] = Ce, B++;
      } else if (pe.isRectAreaLight) {
        const Ce = t.get(pe);
        Ce.color.copy(ce).multiplyScalar(Ee), Ce.halfWidth.set(pe.width * 0.5, 0, 0), Ce.halfHeight.set(0, pe.height * 0.5, 0), i.rectArea[k] = Ce, k++;
      } else if (pe.isPointLight) {
        const Ce = t.get(pe);
        if (Ce.color.copy(pe.color).multiplyScalar(pe.intensity * $), Ce.distance = pe.distance, Ce.decay = pe.decay, pe.castShadow) {
          const Be = pe.shadow, he = r.get(pe);
          he.shadowBias = Be.bias, he.shadowNormalBias = Be.normalBias, he.shadowRadius = Be.radius, he.shadowMapSize = Be.mapSize, he.shadowCameraNear = Be.camera.near, he.shadowCameraFar = Be.camera.far, i.pointShadow[U] = he, i.pointShadowMap[U] = Fe, i.pointShadowMatrix[U] = pe.shadow.matrix, X++;
        }
        i.point[U] = Ce, U++;
      } else if (pe.isHemisphereLight) {
        const Ce = t.get(pe);
        Ce.skyColor.copy(pe.color).multiplyScalar(Ee * $), Ce.groundColor.copy(pe.groundColor).multiplyScalar(Ee * $), i.hemi[V] = Ce, V++;
      }
    }
    k > 0 && (e.isWebGL2 || a.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Fn.LTC_FLOAT_1, i.rectAreaLTC2 = Fn.LTC_FLOAT_2) : a.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Fn.LTC_HALF_1, i.rectAreaLTC2 = Fn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = T, i.ambient[1] = C, i.ambient[2] = D;
    const W = i.hash;
    (W.directionalLength !== P || W.pointLength !== U || W.spotLength !== B || W.rectAreaLength !== k || W.hemiLength !== V || W.numDirectionalShadows !== I || W.numPointShadows !== X || W.numSpotShadows !== J) && (i.directional.length = P, i.spot.length = B, i.rectArea.length = k, i.point.length = U, i.hemi.length = V, i.directionalShadow.length = I, i.directionalShadowMap.length = I, i.pointShadow.length = X, i.pointShadowMap.length = X, i.spotShadow.length = J, i.spotShadowMap.length = J, i.directionalShadowMatrix.length = I, i.pointShadowMatrix.length = X, i.spotShadowMatrix.length = J, W.directionalLength = P, W.pointLength = U, W.spotLength = B, W.rectAreaLength = k, W.hemiLength = V, W.numDirectionalShadows = I, W.numPointShadows = X, W.numSpotShadows = J, i.version = K8++);
  }
  function m(S, _) {
    let T = 0, C = 0, D = 0, P = 0, U = 0;
    const B = _.matrixWorldInverse;
    for (let k = 0, V = S.length; k < V; k++) {
      const I = S[k];
      if (I.isDirectionalLight) {
        const X = i.directional[T];
        X.direction.setFromMatrixPosition(I.matrixWorld), o.setFromMatrixPosition(I.target.matrixWorld), X.direction.sub(o), X.direction.transformDirection(B), T++;
      } else if (I.isSpotLight) {
        const X = i.spot[D];
        X.position.setFromMatrixPosition(I.matrixWorld), X.position.applyMatrix4(B), X.direction.setFromMatrixPosition(I.matrixWorld), o.setFromMatrixPosition(I.target.matrixWorld), X.direction.sub(o), X.direction.transformDirection(B), D++;
      } else if (I.isRectAreaLight) {
        const X = i.rectArea[P];
        X.position.setFromMatrixPosition(I.matrixWorld), X.position.applyMatrix4(B), d.identity(), l.copy(I.matrixWorld), l.premultiply(B), d.extractRotation(l), X.halfWidth.set(I.width * 0.5, 0, 0), X.halfHeight.set(0, I.height * 0.5, 0), X.halfWidth.applyMatrix4(d), X.halfHeight.applyMatrix4(d), P++;
      } else if (I.isPointLight) {
        const X = i.point[C];
        X.position.setFromMatrixPosition(I.matrixWorld), X.position.applyMatrix4(B), C++;
      } else if (I.isHemisphereLight) {
        const X = i.hemi[U];
        X.direction.setFromMatrixPosition(I.matrixWorld), X.direction.transformDirection(B), U++;
      }
    }
  }
  return {
    setup: h,
    setupView: m,
    state: i
  };
}
function oU(a, e) {
  const t = new eW(a, e), r = [], i = [];
  function o() {
    r.length = 0, i.length = 0;
  }
  function l(_) {
    r.push(_);
  }
  function d(_) {
    i.push(_);
  }
  function h(_) {
    t.setup(r, _);
  }
  function m(_) {
    t.setupView(r, _);
  }
  return {
    init: o,
    state: {
      lightsArray: r,
      shadowsArray: i,
      lights: t
    },
    setupLights: h,
    setupLightsView: m,
    pushLight: l,
    pushShadow: d
  };
}
function tW(a, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function r(o, l = 0) {
    let d;
    return t.has(o) === !1 ? (d = new oU(a, e), t.set(o, [d])) : l >= t.get(o).length ? (d = new oU(a, e), t.get(o).push(d)) : d = t.get(o)[l], d;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: i
  };
}
class tT extends ff {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = o1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class HC extends ff {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new ge(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const nW = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, rW = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function iW(a, e, t) {
  let r = new IC();
  const i = new Ft(), o = new Ft(), l = new la(), d = new tT({ depthPacking: Zb }), h = new HC(), m = {}, S = t.maxTextureSize, _ = { 0: uf, 1: py, 2: Pp }, T = new wu({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ft() },
      radius: { value: 4 }
    },
    vertexShader: nW,
    fragmentShader: rW
  }), C = T.clone();
  C.defines.HORIZONTAL_PASS = 1;
  const D = new ui();
  D.setAttribute(
    "position",
    new os(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const P = new zn(D, T), U = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = B3, this.render = function(I, X, J) {
    if (U.enabled === !1 || U.autoUpdate === !1 && U.needsUpdate === !1 || I.length === 0)
      return;
    const $ = a.getRenderTarget(), W = a.getActiveCubeFace(), ee = a.getActiveMipmapLevel(), ie = a.state;
    ie.setBlending(cf), ie.buffers.color.setClear(1, 1, 1, 1), ie.buffers.depth.setTest(!0), ie.setScissorTest(!1);
    for (let pe = 0, ce = I.length; pe < ce; pe++) {
      const Ee = I[pe], de = Ee.shadow;
      if (de === void 0) {
        console.warn("THREE.WebGLShadowMap:", Ee, "has no shadow.");
        continue;
      }
      if (de.autoUpdate === !1 && de.needsUpdate === !1)
        continue;
      i.copy(de.mapSize);
      const Fe = de.getFrameExtents();
      if (i.multiply(Fe), o.copy(de.mapSize), (i.x > S || i.y > S) && (i.x > S && (o.x = Math.floor(S / Fe.x), i.x = o.x * Fe.x, de.mapSize.x = o.x), i.y > S && (o.y = Math.floor(S / Fe.y), i.y = o.y * Fe.y, de.mapSize.y = o.y)), de.map === null) {
        const Be = this.type !== Ib ? { minFilter: co, magFilter: co } : {};
        de.map = new po(i.x, i.y, Be), de.map.texture.name = Ee.name + ".shadowMap", de.camera.updateProjectionMatrix();
      }
      a.setRenderTarget(de.map), a.clear();
      const Ce = de.getViewportCount();
      for (let Be = 0; Be < Ce; Be++) {
        const he = de.getViewport(Be);
        l.set(
          o.x * he.x,
          o.y * he.y,
          o.x * he.z,
          o.y * he.w
        ), ie.viewport(l), de.updateMatrices(Ee, Be), r = de.getFrustum(), V(X, J, de.camera, Ee, this.type);
      }
      de.isPointLightShadow !== !0 && this.type === Ib && B(de, J), de.needsUpdate = !1;
    }
    U.needsUpdate = !1, a.setRenderTarget($, W, ee);
  };
  function B(I, X) {
    const J = e.update(P);
    T.defines.VSM_SAMPLES !== I.blurSamples && (T.defines.VSM_SAMPLES = I.blurSamples, C.defines.VSM_SAMPLES = I.blurSamples, T.needsUpdate = !0, C.needsUpdate = !0), I.mapPass === null && (I.mapPass = new po(i.x, i.y)), T.uniforms.shadow_pass.value = I.map.texture, T.uniforms.resolution.value = I.mapSize, T.uniforms.radius.value = I.radius, a.setRenderTarget(I.mapPass), a.clear(), a.renderBufferDirect(X, null, J, T, P, null), C.uniforms.shadow_pass.value = I.mapPass.texture, C.uniforms.resolution.value = I.mapSize, C.uniforms.radius.value = I.radius, a.setRenderTarget(I.map), a.clear(), a.renderBufferDirect(X, null, J, C, P, null);
  }
  function k(I, X, J, $, W, ee) {
    let ie = null;
    const pe = J.isPointLight === !0 ? I.customDistanceMaterial : I.customDepthMaterial;
    if (pe !== void 0 ? ie = pe : ie = J.isPointLight === !0 ? h : d, a.localClippingEnabled && X.clipShadows === !0 && Array.isArray(X.clippingPlanes) && X.clippingPlanes.length !== 0 || X.displacementMap && X.displacementScale !== 0 || X.alphaMap && X.alphaTest > 0) {
      const ce = ie.uuid, Ee = X.uuid;
      let de = m[ce];
      de === void 0 && (de = {}, m[ce] = de);
      let Fe = de[Ee];
      Fe === void 0 && (Fe = ie.clone(), de[Ee] = Fe), ie = Fe;
    }
    return ie.visible = X.visible, ie.wireframe = X.wireframe, ee === Ib ? ie.side = X.shadowSide !== null ? X.shadowSide : X.side : ie.side = X.shadowSide !== null ? X.shadowSide : _[X.side], ie.alphaMap = X.alphaMap, ie.alphaTest = X.alphaTest, ie.clipShadows = X.clipShadows, ie.clippingPlanes = X.clippingPlanes, ie.clipIntersection = X.clipIntersection, ie.displacementMap = X.displacementMap, ie.displacementScale = X.displacementScale, ie.displacementBias = X.displacementBias, ie.wireframeLinewidth = X.wireframeLinewidth, ie.linewidth = X.linewidth, J.isPointLight === !0 && ie.isMeshDistanceMaterial === !0 && (ie.referencePosition.setFromMatrixPosition(J.matrixWorld), ie.nearDistance = $, ie.farDistance = W), ie;
  }
  function V(I, X, J, $, W) {
    if (I.visible === !1)
      return;
    if (I.layers.test(X.layers) && (I.isMesh || I.isLine || I.isPoints) && (I.castShadow || I.receiveShadow && W === Ib) && (!I.frustumCulled || r.intersectsObject(I))) {
      I.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, I.matrixWorld);
      const pe = e.update(I), ce = I.material;
      if (Array.isArray(ce)) {
        const Ee = pe.groups;
        for (let de = 0, Fe = Ee.length; de < Fe; de++) {
          const Ce = Ee[de], Be = ce[Ce.materialIndex];
          if (Be && Be.visible) {
            const he = k(I, Be, $, J.near, J.far, W);
            a.renderBufferDirect(J, null, pe, he, I, Ce);
          }
        }
      } else if (ce.visible) {
        const Ee = k(I, ce, $, J.near, J.far, W);
        a.renderBufferDirect(J, null, pe, Ee, I, null);
      }
    }
    const ie = I.children;
    for (let pe = 0, ce = ie.length; pe < ce; pe++)
      V(ie[pe], X, J, $, W);
  }
}
function aW(a, e, t) {
  const r = t.isWebGL2;
  function i() {
    let De = !1;
    const Tt = new la();
    let Ne = null;
    const Gt = new la(0, 0, 0, 0);
    return {
      setMask: function(Pt) {
        Ne !== Pt && !De && (a.colorMask(Pt, Pt, Pt, Pt), Ne = Pt);
      },
      setLocked: function(Pt) {
        De = Pt;
      },
      setClear: function(Pt, fn, Gr, Wr, Ur) {
        Ur === !0 && (Pt *= Wr, fn *= Wr, Gr *= Wr), Tt.set(Pt, fn, Gr, Wr), Gt.equals(Tt) === !1 && (a.clearColor(Pt, fn, Gr, Wr), Gt.copy(Tt));
      },
      reset: function() {
        De = !1, Ne = null, Gt.set(-1, 0, 0, 0);
      }
    };
  }
  function o() {
    let De = !1, Tt = null, Ne = null, Gt = null;
    return {
      setTest: function(Pt) {
        Pt ? ot(2929) : rt(2929);
      },
      setMask: function(Pt) {
        Tt !== Pt && !De && (a.depthMask(Pt), Tt = Pt);
      },
      setFunc: function(Pt) {
        if (Ne !== Pt) {
          if (Pt)
            switch (Pt) {
              case NN:
                a.depthFunc(512);
                break;
              case FN:
                a.depthFunc(519);
                break;
              case kN:
                a.depthFunc(513);
                break;
              case bC:
                a.depthFunc(515);
                break;
              case IN:
                a.depthFunc(514);
                break;
              case BN:
                a.depthFunc(518);
                break;
              case HN:
                a.depthFunc(516);
                break;
              case VN:
                a.depthFunc(517);
                break;
              default:
                a.depthFunc(515);
            }
          else
            a.depthFunc(515);
          Ne = Pt;
        }
      },
      setLocked: function(Pt) {
        De = Pt;
      },
      setClear: function(Pt) {
        Gt !== Pt && (a.clearDepth(Pt), Gt = Pt);
      },
      reset: function() {
        De = !1, Tt = null, Ne = null, Gt = null;
      }
    };
  }
  function l() {
    let De = !1, Tt = null, Ne = null, Gt = null, Pt = null, fn = null, Gr = null, Wr = null, Ur = null;
    return {
      setTest: function(ir) {
        De || (ir ? ot(2960) : rt(2960));
      },
      setMask: function(ir) {
        Tt !== ir && !De && (a.stencilMask(ir), Tt = ir);
      },
      setFunc: function(ir, Vn, jr) {
        (Ne !== ir || Gt !== Vn || Pt !== jr) && (a.stencilFunc(ir, Vn, jr), Ne = ir, Gt = Vn, Pt = jr);
      },
      setOp: function(ir, Vn, jr) {
        (fn !== ir || Gr !== Vn || Wr !== jr) && (a.stencilOp(ir, Vn, jr), fn = ir, Gr = Vn, Wr = jr);
      },
      setLocked: function(ir) {
        De = ir;
      },
      setClear: function(ir) {
        Ur !== ir && (a.clearStencil(ir), Ur = ir);
      },
      reset: function() {
        De = !1, Tt = null, Ne = null, Gt = null, Pt = null, fn = null, Gr = null, Wr = null, Ur = null;
      }
    };
  }
  const d = new i(), h = new o(), m = new l(), S = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
  let T = {}, C = {}, D = /* @__PURE__ */ new WeakMap(), P = [], U = null, B = !1, k = null, V = null, I = null, X = null, J = null, $ = null, W = null, ee = !1, ie = null, pe = null, ce = null, Ee = null, de = null;
  const Fe = a.getParameter(35661);
  let Ce = !1, Be = 0;
  const he = a.getParameter(7938);
  he.indexOf("WebGL") !== -1 ? (Be = parseFloat(/^WebGL (\d)/.exec(he)[1]), Ce = Be >= 1) : he.indexOf("OpenGL ES") !== -1 && (Be = parseFloat(/^OpenGL ES (\d)/.exec(he)[1]), Ce = Be >= 2);
  let fe = null, ue = {};
  const ye = a.getParameter(3088), we = a.getParameter(2978), Xe = new la().fromArray(ye), Je = new la().fromArray(we);
  function st(De, Tt, Ne) {
    const Gt = new Uint8Array(4), Pt = a.createTexture();
    a.bindTexture(De, Pt), a.texParameteri(De, 10241, 9728), a.texParameteri(De, 10240, 9728);
    for (let fn = 0; fn < Ne; fn++)
      a.texImage2D(Tt + fn, 0, 6408, 1, 1, 0, 6408, 5121, Gt);
    return Pt;
  }
  const Ue = {};
  Ue[3553] = st(3553, 3553, 1), Ue[34067] = st(34067, 34069, 6), d.setClear(0, 0, 0, 1), h.setClear(1), m.setClear(0), ot(2929), h.setFunc(bC), bt(!1), Qt(BD), ot(2884), mt(cf);
  function ot(De) {
    T[De] !== !0 && (a.enable(De), T[De] = !0);
  }
  function rt(De) {
    T[De] !== !1 && (a.disable(De), T[De] = !1);
  }
  function _t(De, Tt) {
    return C[De] !== Tt ? (a.bindFramebuffer(De, Tt), C[De] = Tt, r && (De === 36009 && (C[36160] = Tt), De === 36160 && (C[36009] = Tt)), !0) : !1;
  }
  function Rt(De, Tt) {
    let Ne = P, Gt = !1;
    if (De)
      if (Ne = D.get(Tt), Ne === void 0 && (Ne = [], D.set(Tt, Ne)), De.isWebGLMultipleRenderTargets) {
        const Pt = De.texture;
        if (Ne.length !== Pt.length || Ne[0] !== 36064) {
          for (let fn = 0, Gr = Pt.length; fn < Gr; fn++)
            Ne[fn] = 36064 + fn;
          Ne.length = Pt.length, Gt = !0;
        }
      } else
        Ne[0] !== 36064 && (Ne[0] = 36064, Gt = !0);
    else
      Ne[0] !== 1029 && (Ne[0] = 1029, Gt = !0);
    Gt && (t.isWebGL2 ? a.drawBuffers(Ne) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ne));
  }
  function Ot(De) {
    return U !== De ? (a.useProgram(De), U = De, !0) : !1;
  }
  const He = {
    [AS]: 32774,
    [TN]: 32778,
    [V3]: 32779
  };
  if (r)
    He[GD] = 32775, He[WD] = 32776;
  else {
    const De = e.get("EXT_blend_minmax");
    De !== null && (He[GD] = De.MIN_EXT, He[WD] = De.MAX_EXT);
  }
  const et = {
    [CN]: 0,
    [RN]: 1,
    [AN]: 768,
    [UC]: 770,
    [zN]: 776,
    [ON]: 774,
    [LN]: 772,
    [DN]: 769,
    [zC]: 771,
    [UN]: 775,
    [PN]: 773
  };
  function mt(De, Tt, Ne, Gt, Pt, fn, Gr, Wr) {
    if (De === cf) {
      B === !0 && (rt(3042), B = !1);
      return;
    }
    if (B === !1 && (ot(3042), B = !0), De !== MN) {
      if (De !== k || Wr !== ee) {
        if ((V !== AS || J !== AS) && (a.blendEquation(32774), V = AS, J = AS), Wr)
          switch (De) {
            case L0:
              a.blendFuncSeparate(1, 771, 1, 771);
              break;
            case _C:
              a.blendFunc(1, 1);
              break;
            case HD:
              a.blendFuncSeparate(0, 769, 0, 1);
              break;
            case VD:
              a.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", De);
              break;
          }
        else
          switch (De) {
            case L0:
              a.blendFuncSeparate(770, 771, 1, 771);
              break;
            case _C:
              a.blendFunc(770, 1);
              break;
            case HD:
              a.blendFuncSeparate(0, 769, 0, 1);
              break;
            case VD:
              a.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", De);
              break;
          }
        I = null, X = null, $ = null, W = null, k = De, ee = Wr;
      }
      return;
    }
    Pt = Pt || Tt, fn = fn || Ne, Gr = Gr || Gt, (Tt !== V || Pt !== J) && (a.blendEquationSeparate(He[Tt], He[Pt]), V = Tt, J = Pt), (Ne !== I || Gt !== X || fn !== $ || Gr !== W) && (a.blendFuncSeparate(et[Ne], et[Gt], et[fn], et[Gr]), I = Ne, X = Gt, $ = fn, W = Gr), k = De, ee = null;
  }
  function vt(De, Tt) {
    De.side === Pp ? rt(2884) : ot(2884);
    let Ne = De.side === uf;
    Tt && (Ne = !Ne), bt(Ne), De.blending === L0 && De.transparent === !1 ? mt(cf) : mt(De.blending, De.blendEquation, De.blendSrc, De.blendDst, De.blendEquationAlpha, De.blendSrcAlpha, De.blendDstAlpha, De.premultipliedAlpha), h.setFunc(De.depthFunc), h.setTest(De.depthTest), h.setMask(De.depthWrite), d.setMask(De.colorWrite);
    const Gt = De.stencilWrite;
    m.setTest(Gt), Gt && (m.setMask(De.stencilWriteMask), m.setFunc(De.stencilFunc, De.stencilRef, De.stencilFuncMask), m.setOp(De.stencilFail, De.stencilZFail, De.stencilZPass)), Vt(De.polygonOffset, De.polygonOffsetFactor, De.polygonOffsetUnits), De.alphaToCoverage === !0 ? ot(32926) : rt(32926);
  }
  function bt(De) {
    ie !== De && (De ? a.frontFace(2304) : a.frontFace(2305), ie = De);
  }
  function Qt(De) {
    De !== bN ? (ot(2884), De !== pe && (De === BD ? a.cullFace(1029) : De === wN ? a.cullFace(1028) : a.cullFace(1032))) : rt(2884), pe = De;
  }
  function ft(De) {
    De !== ce && (Ce && a.lineWidth(De), ce = De);
  }
  function Vt(De, Tt, Ne) {
    De ? (ot(32823), (Ee !== Tt || de !== Ne) && (a.polygonOffset(Tt, Ne), Ee = Tt, de = Ne)) : rt(32823);
  }
  function Jt(De) {
    De ? ot(3089) : rt(3089);
  }
  function Mt(De) {
    De === void 0 && (De = 33984 + Fe - 1), fe !== De && (a.activeTexture(De), fe = De);
  }
  function Me(De, Tt) {
    fe === null && Mt();
    let Ne = ue[fe];
    Ne === void 0 && (Ne = { type: void 0, texture: void 0 }, ue[fe] = Ne), (Ne.type !== De || Ne.texture !== Tt) && (a.bindTexture(De, Tt || Ue[De]), Ne.type = De, Ne.texture = Tt);
  }
  function oe() {
    const De = ue[fe];
    De !== void 0 && De.type !== void 0 && (a.bindTexture(De.type, null), De.type = void 0, De.texture = void 0);
  }
  function je() {
    try {
      a.compressedTexImage2D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function lt() {
    try {
      a.texSubImage2D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function zt() {
    try {
      a.texSubImage3D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function Nt() {
    try {
      a.compressedTexSubImage2D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function Ut() {
    try {
      a.texStorage2D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function tt() {
    try {
      a.texStorage3D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function rn() {
    try {
      a.texImage2D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function ze() {
    try {
      a.texImage3D.apply(a, arguments);
    } catch (De) {
      console.error("THREE.WebGLState:", De);
    }
  }
  function xe(De) {
    Xe.equals(De) === !1 && (a.scissor(De.x, De.y, De.z, De.w), Xe.copy(De));
  }
  function Ie(De) {
    Je.equals(De) === !1 && (a.viewport(De.x, De.y, De.z, De.w), Je.copy(De));
  }
  function it(De, Tt) {
    let Ne = _.get(Tt);
    Ne === void 0 && (Ne = /* @__PURE__ */ new WeakMap(), _.set(Tt, Ne));
    let Gt = Ne.get(De);
    Gt === void 0 && (Gt = a.getUniformBlockIndex(Tt, De.name), Ne.set(De, Gt));
  }
  function at(De, Tt) {
    const Gt = _.get(Tt).get(De);
    S.get(De) !== Gt && (a.uniformBlockBinding(Tt, Gt, De.__bindingPointIndex), S.set(De, Gt));
  }
  function hn() {
    a.disable(3042), a.disable(2884), a.disable(2929), a.disable(32823), a.disable(3089), a.disable(2960), a.disable(32926), a.blendEquation(32774), a.blendFunc(1, 0), a.blendFuncSeparate(1, 0, 1, 0), a.colorMask(!0, !0, !0, !0), a.clearColor(0, 0, 0, 0), a.depthMask(!0), a.depthFunc(513), a.clearDepth(1), a.stencilMask(4294967295), a.stencilFunc(519, 0, 4294967295), a.stencilOp(7680, 7680, 7680), a.clearStencil(0), a.cullFace(1029), a.frontFace(2305), a.polygonOffset(0, 0), a.activeTexture(33984), a.bindFramebuffer(36160, null), r === !0 && (a.bindFramebuffer(36009, null), a.bindFramebuffer(36008, null)), a.useProgram(null), a.lineWidth(1), a.scissor(0, 0, a.canvas.width, a.canvas.height), a.viewport(0, 0, a.canvas.width, a.canvas.height), T = {}, fe = null, ue = {}, C = {}, D = /* @__PURE__ */ new WeakMap(), P = [], U = null, B = !1, k = null, V = null, I = null, X = null, J = null, $ = null, W = null, ee = !1, ie = null, pe = null, ce = null, Ee = null, de = null, Xe.set(0, 0, a.canvas.width, a.canvas.height), Je.set(0, 0, a.canvas.width, a.canvas.height), d.reset(), h.reset(), m.reset();
  }
  return {
    buffers: {
      color: d,
      depth: h,
      stencil: m
    },
    enable: ot,
    disable: rt,
    bindFramebuffer: _t,
    drawBuffers: Rt,
    useProgram: Ot,
    setBlending: mt,
    setMaterial: vt,
    setFlipSided: bt,
    setCullFace: Qt,
    setLineWidth: ft,
    setPolygonOffset: Vt,
    setScissorTest: Jt,
    activeTexture: Mt,
    bindTexture: Me,
    unbindTexture: oe,
    compressedTexImage2D: je,
    texImage2D: rn,
    texImage3D: ze,
    updateUBOMapping: it,
    uniformBlockBinding: at,
    texStorage2D: Ut,
    texStorage3D: tt,
    texSubImage2D: lt,
    texSubImage3D: zt,
    compressedTexSubImage2D: Nt,
    scissor: xe,
    viewport: Ie,
    reset: hn
  };
}
function sW(a, e, t, r, i, o, l) {
  const d = i.isWebGL2, h = i.maxTextures, m = i.maxCubemapSize, S = i.maxTextureSize, _ = i.maxSamples, T = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, C = /OculusBrowser/g.test(navigator.userAgent), D = /* @__PURE__ */ new WeakMap();
  let P;
  const U = /* @__PURE__ */ new WeakMap();
  let B = !1;
  try {
    B = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function k(Me, oe) {
    return B ? new OffscreenCanvas(Me, oe) : UM("canvas");
  }
  function V(Me, oe, je, lt) {
    let zt = 1;
    if ((Me.width > lt || Me.height > lt) && (zt = lt / Math.max(Me.width, Me.height)), zt < 1 || oe === !0)
      if (typeof HTMLImageElement < "u" && Me instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Me instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Me instanceof ImageBitmap) {
        const Nt = oe ? TC : Math.floor, Ut = Nt(zt * Me.width), tt = Nt(zt * Me.height);
        P === void 0 && (P = k(Ut, tt));
        const rn = je ? k(Ut, tt) : P;
        return rn.width = Ut, rn.height = tt, rn.getContext("2d").drawImage(Me, 0, 0, Ut, tt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Me.width + "x" + Me.height + ") to (" + Ut + "x" + tt + ")."), rn;
      } else
        return "data" in Me && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Me.width + "x" + Me.height + ")."), Me;
    return Me;
  }
  function I(Me) {
    return h3(Me.width) && h3(Me.height);
  }
  function X(Me) {
    return d ? !1 : Me.wrapS !== Wh || Me.wrapT !== Wh || Me.minFilter !== co && Me.minFilter !== Po;
  }
  function J(Me, oe) {
    return Me.generateMipmaps && oe && Me.minFilter !== co && Me.minFilter !== Po;
  }
  function $(Me) {
    a.generateMipmap(Me);
  }
  function W(Me, oe, je, lt, zt = !1) {
    if (d === !1)
      return oe;
    if (Me !== null) {
      if (a[Me] !== void 0)
        return a[Me];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Me + "'");
    }
    let Nt = oe;
    return oe === 6403 && (je === 5126 && (Nt = 33326), je === 5131 && (Nt = 33325), je === 5121 && (Nt = 33321)), oe === 33319 && (je === 5126 && (Nt = 33328), je === 5131 && (Nt = 33327), je === 5121 && (Nt = 33323)), oe === 6408 && (je === 5126 && (Nt = 34836), je === 5131 && (Nt = 34842), je === 5121 && (Nt = lt === Mi && zt === !1 ? 35907 : 32856), je === 32819 && (Nt = 32854), je === 32820 && (Nt = 32855)), (Nt === 33325 || Nt === 33326 || Nt === 33327 || Nt === 33328 || Nt === 34842 || Nt === 34836) && e.get("EXT_color_buffer_float"), Nt;
  }
  function ee(Me, oe, je) {
    return J(Me, je) === !0 || Me.isFramebufferTexture && Me.minFilter !== co && Me.minFilter !== Po ? Math.log2(Math.max(oe.width, oe.height)) + 1 : Me.mipmaps !== void 0 && Me.mipmaps.length > 0 ? Me.mipmaps.length : Me.isCompressedTexture && Array.isArray(Me.image) ? oe.mipmaps.length : 1;
  }
  function ie(Me) {
    return Me === co || Me === wC || Me === EC ? 9728 : 9729;
  }
  function pe(Me) {
    const oe = Me.target;
    oe.removeEventListener("dispose", pe), Ee(oe), oe.isVideoTexture && D.delete(oe);
  }
  function ce(Me) {
    const oe = Me.target;
    oe.removeEventListener("dispose", ce), Fe(oe);
  }
  function Ee(Me) {
    const oe = r.get(Me);
    if (oe.__webglInit === void 0)
      return;
    const je = Me.source, lt = U.get(je);
    if (lt) {
      const zt = lt[oe.__cacheKey];
      zt.usedTimes--, zt.usedTimes === 0 && de(Me), Object.keys(lt).length === 0 && U.delete(je);
    }
    r.remove(Me);
  }
  function de(Me) {
    const oe = r.get(Me);
    a.deleteTexture(oe.__webglTexture);
    const je = Me.source, lt = U.get(je);
    delete lt[oe.__cacheKey], l.memory.textures--;
  }
  function Fe(Me) {
    const oe = Me.texture, je = r.get(Me), lt = r.get(oe);
    if (lt.__webglTexture !== void 0 && (a.deleteTexture(lt.__webglTexture), l.memory.textures--), Me.depthTexture && Me.depthTexture.dispose(), Me.isWebGLCubeRenderTarget)
      for (let zt = 0; zt < 6; zt++)
        a.deleteFramebuffer(je.__webglFramebuffer[zt]), je.__webglDepthbuffer && a.deleteRenderbuffer(je.__webglDepthbuffer[zt]);
    else {
      if (a.deleteFramebuffer(je.__webglFramebuffer), je.__webglDepthbuffer && a.deleteRenderbuffer(je.__webglDepthbuffer), je.__webglMultisampledFramebuffer && a.deleteFramebuffer(je.__webglMultisampledFramebuffer), je.__webglColorRenderbuffer)
        for (let zt = 0; zt < je.__webglColorRenderbuffer.length; zt++)
          je.__webglColorRenderbuffer[zt] && a.deleteRenderbuffer(je.__webglColorRenderbuffer[zt]);
      je.__webglDepthRenderbuffer && a.deleteRenderbuffer(je.__webglDepthRenderbuffer);
    }
    if (Me.isWebGLMultipleRenderTargets)
      for (let zt = 0, Nt = oe.length; zt < Nt; zt++) {
        const Ut = r.get(oe[zt]);
        Ut.__webglTexture && (a.deleteTexture(Ut.__webglTexture), l.memory.textures--), r.remove(oe[zt]);
      }
    r.remove(oe), r.remove(Me);
  }
  let Ce = 0;
  function Be() {
    Ce = 0;
  }
  function he() {
    const Me = Ce;
    return Me >= h && console.warn("THREE.WebGLTextures: Trying to use " + Me + " texture units while this GPU supports only " + h), Ce += 1, Me;
  }
  function fe(Me) {
    const oe = [];
    return oe.push(Me.wrapS), oe.push(Me.wrapT), oe.push(Me.magFilter), oe.push(Me.minFilter), oe.push(Me.anisotropy), oe.push(Me.internalFormat), oe.push(Me.format), oe.push(Me.type), oe.push(Me.generateMipmaps), oe.push(Me.premultiplyAlpha), oe.push(Me.flipY), oe.push(Me.unpackAlignment), oe.push(Me.encoding), oe.join();
  }
  function ue(Me, oe) {
    const je = r.get(Me);
    if (Me.isVideoTexture && Jt(Me), Me.isRenderTargetTexture === !1 && Me.version > 0 && je.__version !== Me.version) {
      const lt = Me.image;
      if (lt === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (lt.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        rt(je, Me, oe);
        return;
      }
    }
    t.activeTexture(33984 + oe), t.bindTexture(3553, je.__webglTexture);
  }
  function ye(Me, oe) {
    const je = r.get(Me);
    if (Me.version > 0 && je.__version !== Me.version) {
      rt(je, Me, oe);
      return;
    }
    t.activeTexture(33984 + oe), t.bindTexture(35866, je.__webglTexture);
  }
  function we(Me, oe) {
    const je = r.get(Me);
    if (Me.version > 0 && je.__version !== Me.version) {
      rt(je, Me, oe);
      return;
    }
    t.activeTexture(33984 + oe), t.bindTexture(32879, je.__webglTexture);
  }
  function Xe(Me, oe) {
    const je = r.get(Me);
    if (Me.version > 0 && je.__version !== Me.version) {
      _t(je, Me, oe);
      return;
    }
    t.activeTexture(33984 + oe), t.bindTexture(34067, je.__webglTexture);
  }
  const Je = {
    [Qb]: 10497,
    [Wh]: 33071,
    [RM]: 33648
  }, st = {
    [co]: 9728,
    [wC]: 9984,
    [EC]: 9986,
    [Po]: 9729,
    [W3]: 9985,
    [s1]: 9987
  };
  function Ue(Me, oe, je) {
    if (je ? (a.texParameteri(Me, 10242, Je[oe.wrapS]), a.texParameteri(Me, 10243, Je[oe.wrapT]), (Me === 32879 || Me === 35866) && a.texParameteri(Me, 32882, Je[oe.wrapR]), a.texParameteri(Me, 10240, st[oe.magFilter]), a.texParameteri(Me, 10241, st[oe.minFilter])) : (a.texParameteri(Me, 10242, 33071), a.texParameteri(Me, 10243, 33071), (Me === 32879 || Me === 35866) && a.texParameteri(Me, 32882, 33071), (oe.wrapS !== Wh || oe.wrapT !== Wh) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(Me, 10240, ie(oe.magFilter)), a.texParameteri(Me, 10241, ie(oe.minFilter)), oe.minFilter !== co && oe.minFilter !== Po && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const lt = e.get("EXT_texture_filter_anisotropic");
      if (oe.type === uy && e.has("OES_texture_float_linear") === !1 || d === !1 && oe.type === GS && e.has("OES_texture_half_float_linear") === !1)
        return;
      (oe.anisotropy > 1 || r.get(oe).__currentAnisotropy) && (a.texParameterf(Me, lt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(oe.anisotropy, i.getMaxAnisotropy())), r.get(oe).__currentAnisotropy = oe.anisotropy);
    }
  }
  function ot(Me, oe) {
    let je = !1;
    Me.__webglInit === void 0 && (Me.__webglInit = !0, oe.addEventListener("dispose", pe));
    const lt = oe.source;
    let zt = U.get(lt);
    zt === void 0 && (zt = {}, U.set(lt, zt));
    const Nt = fe(oe);
    if (Nt !== Me.__cacheKey) {
      zt[Nt] === void 0 && (zt[Nt] = {
        texture: a.createTexture(),
        usedTimes: 0
      }, l.memory.textures++, je = !0), zt[Nt].usedTimes++;
      const Ut = zt[Me.__cacheKey];
      Ut !== void 0 && (zt[Me.__cacheKey].usedTimes--, Ut.usedTimes === 0 && de(oe)), Me.__cacheKey = Nt, Me.__webglTexture = zt[Nt].texture;
    }
    return je;
  }
  function rt(Me, oe, je) {
    let lt = 3553;
    oe.isDataArrayTexture && (lt = 35866), oe.isData3DTexture && (lt = 32879);
    const zt = ot(Me, oe), Nt = oe.source;
    if (t.activeTexture(33984 + je), t.bindTexture(lt, Me.__webglTexture), Nt.version !== Nt.__currentVersion || zt === !0) {
      a.pixelStorei(37440, oe.flipY), a.pixelStorei(37441, oe.premultiplyAlpha), a.pixelStorei(3317, oe.unpackAlignment), a.pixelStorei(37443, 0);
      const Ut = X(oe) && I(oe.image) === !1;
      let tt = V(oe.image, Ut, !1, S);
      tt = Mt(oe, tt);
      const rn = I(tt) || d, ze = o.convert(oe.format, oe.encoding);
      let xe = o.convert(oe.type), Ie = W(oe.internalFormat, ze, xe, oe.encoding, oe.isVideoTexture);
      Ue(lt, oe, rn);
      let it;
      const at = oe.mipmaps, hn = d && oe.isVideoTexture !== !0, De = Nt.__currentVersion === void 0 || zt === !0, Tt = ee(oe, tt, rn);
      if (oe.isDepthTexture)
        Ie = 6402, d ? oe.type === uy ? Ie = 36012 : oe.type === D0 ? Ie = 33190 : oe.type === Kx ? Ie = 35056 : Ie = 33189 : oe.type === uy && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), oe.format === $x && Ie === 6402 && oe.type !== j3 && oe.type !== D0 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), oe.type = D0, xe = o.convert(oe.type)), oe.format === r1 && Ie === 6402 && (Ie = 34041, oe.type !== Kx && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), oe.type = Kx, xe = o.convert(oe.type))), De && (hn ? t.texStorage2D(3553, 1, Ie, tt.width, tt.height) : t.texImage2D(3553, 0, Ie, tt.width, tt.height, 0, ze, xe, null));
      else if (oe.isDataTexture)
        if (at.length > 0 && rn) {
          hn && De && t.texStorage2D(3553, Tt, Ie, at[0].width, at[0].height);
          for (let Ne = 0, Gt = at.length; Ne < Gt; Ne++)
            it = at[Ne], hn ? t.texSubImage2D(3553, Ne, 0, 0, it.width, it.height, ze, xe, it.data) : t.texImage2D(3553, Ne, Ie, it.width, it.height, 0, ze, xe, it.data);
          oe.generateMipmaps = !1;
        } else
          hn ? (De && t.texStorage2D(3553, Tt, Ie, tt.width, tt.height), t.texSubImage2D(3553, 0, 0, 0, tt.width, tt.height, ze, xe, tt.data)) : t.texImage2D(3553, 0, Ie, tt.width, tt.height, 0, ze, xe, tt.data);
      else if (oe.isCompressedTexture) {
        hn && De && t.texStorage2D(3553, Tt, Ie, at[0].width, at[0].height);
        for (let Ne = 0, Gt = at.length; Ne < Gt; Ne++)
          it = at[Ne], oe.format !== Sm ? ze !== null ? hn ? t.compressedTexSubImage2D(3553, Ne, 0, 0, it.width, it.height, ze, it.data) : t.compressedTexImage2D(3553, Ne, Ie, it.width, it.height, 0, it.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : hn ? t.texSubImage2D(3553, Ne, 0, 0, it.width, it.height, ze, xe, it.data) : t.texImage2D(3553, Ne, Ie, it.width, it.height, 0, ze, xe, it.data);
      } else if (oe.isDataArrayTexture)
        hn ? (De && t.texStorage3D(35866, Tt, Ie, tt.width, tt.height, tt.depth), t.texSubImage3D(35866, 0, 0, 0, 0, tt.width, tt.height, tt.depth, ze, xe, tt.data)) : t.texImage3D(35866, 0, Ie, tt.width, tt.height, tt.depth, 0, ze, xe, tt.data);
      else if (oe.isData3DTexture)
        hn ? (De && t.texStorage3D(32879, Tt, Ie, tt.width, tt.height, tt.depth), t.texSubImage3D(32879, 0, 0, 0, 0, tt.width, tt.height, tt.depth, ze, xe, tt.data)) : t.texImage3D(32879, 0, Ie, tt.width, tt.height, tt.depth, 0, ze, xe, tt.data);
      else if (oe.isFramebufferTexture) {
        if (De)
          if (hn)
            t.texStorage2D(3553, Tt, Ie, tt.width, tt.height);
          else {
            let Ne = tt.width, Gt = tt.height;
            for (let Pt = 0; Pt < Tt; Pt++)
              t.texImage2D(3553, Pt, Ie, Ne, Gt, 0, ze, xe, null), Ne >>= 1, Gt >>= 1;
          }
      } else if (at.length > 0 && rn) {
        hn && De && t.texStorage2D(3553, Tt, Ie, at[0].width, at[0].height);
        for (let Ne = 0, Gt = at.length; Ne < Gt; Ne++)
          it = at[Ne], hn ? t.texSubImage2D(3553, Ne, 0, 0, ze, xe, it) : t.texImage2D(3553, Ne, Ie, ze, xe, it);
        oe.generateMipmaps = !1;
      } else
        hn ? (De && t.texStorage2D(3553, Tt, Ie, tt.width, tt.height), t.texSubImage2D(3553, 0, 0, 0, ze, xe, tt)) : t.texImage2D(3553, 0, Ie, ze, xe, tt);
      J(oe, rn) && $(lt), Nt.__currentVersion = Nt.version, oe.onUpdate && oe.onUpdate(oe);
    }
    Me.__version = oe.version;
  }
  function _t(Me, oe, je) {
    if (oe.image.length !== 6)
      return;
    const lt = ot(Me, oe), zt = oe.source;
    if (t.activeTexture(33984 + je), t.bindTexture(34067, Me.__webglTexture), zt.version !== zt.__currentVersion || lt === !0) {
      a.pixelStorei(37440, oe.flipY), a.pixelStorei(37441, oe.premultiplyAlpha), a.pixelStorei(3317, oe.unpackAlignment), a.pixelStorei(37443, 0);
      const Nt = oe.isCompressedTexture || oe.image[0].isCompressedTexture, Ut = oe.image[0] && oe.image[0].isDataTexture, tt = [];
      for (let Ne = 0; Ne < 6; Ne++)
        !Nt && !Ut ? tt[Ne] = V(oe.image[Ne], !1, !0, m) : tt[Ne] = Ut ? oe.image[Ne].image : oe.image[Ne], tt[Ne] = Mt(oe, tt[Ne]);
      const rn = tt[0], ze = I(rn) || d, xe = o.convert(oe.format, oe.encoding), Ie = o.convert(oe.type), it = W(oe.internalFormat, xe, Ie, oe.encoding), at = d && oe.isVideoTexture !== !0, hn = zt.__currentVersion === void 0 || lt === !0;
      let De = ee(oe, rn, ze);
      Ue(34067, oe, ze);
      let Tt;
      if (Nt) {
        at && hn && t.texStorage2D(34067, De, it, rn.width, rn.height);
        for (let Ne = 0; Ne < 6; Ne++) {
          Tt = tt[Ne].mipmaps;
          for (let Gt = 0; Gt < Tt.length; Gt++) {
            const Pt = Tt[Gt];
            oe.format !== Sm ? xe !== null ? at ? t.compressedTexSubImage2D(34069 + Ne, Gt, 0, 0, Pt.width, Pt.height, xe, Pt.data) : t.compressedTexImage2D(34069 + Ne, Gt, it, Pt.width, Pt.height, 0, Pt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : at ? t.texSubImage2D(34069 + Ne, Gt, 0, 0, Pt.width, Pt.height, xe, Ie, Pt.data) : t.texImage2D(34069 + Ne, Gt, it, Pt.width, Pt.height, 0, xe, Ie, Pt.data);
          }
        }
      } else {
        Tt = oe.mipmaps, at && hn && (Tt.length > 0 && De++, t.texStorage2D(34067, De, it, tt[0].width, tt[0].height));
        for (let Ne = 0; Ne < 6; Ne++)
          if (Ut) {
            at ? t.texSubImage2D(34069 + Ne, 0, 0, 0, tt[Ne].width, tt[Ne].height, xe, Ie, tt[Ne].data) : t.texImage2D(34069 + Ne, 0, it, tt[Ne].width, tt[Ne].height, 0, xe, Ie, tt[Ne].data);
            for (let Gt = 0; Gt < Tt.length; Gt++) {
              const fn = Tt[Gt].image[Ne].image;
              at ? t.texSubImage2D(34069 + Ne, Gt + 1, 0, 0, fn.width, fn.height, xe, Ie, fn.data) : t.texImage2D(34069 + Ne, Gt + 1, it, fn.width, fn.height, 0, xe, Ie, fn.data);
            }
          } else {
            at ? t.texSubImage2D(34069 + Ne, 0, 0, 0, xe, Ie, tt[Ne]) : t.texImage2D(34069 + Ne, 0, it, xe, Ie, tt[Ne]);
            for (let Gt = 0; Gt < Tt.length; Gt++) {
              const Pt = Tt[Gt];
              at ? t.texSubImage2D(34069 + Ne, Gt + 1, 0, 0, xe, Ie, Pt.image[Ne]) : t.texImage2D(34069 + Ne, Gt + 1, it, xe, Ie, Pt.image[Ne]);
            }
          }
      }
      J(oe, ze) && $(34067), zt.__currentVersion = zt.version, oe.onUpdate && oe.onUpdate(oe);
    }
    Me.__version = oe.version;
  }
  function Rt(Me, oe, je, lt, zt) {
    const Nt = o.convert(je.format, je.encoding), Ut = o.convert(je.type), tt = W(je.internalFormat, Nt, Ut, je.encoding);
    r.get(oe).__hasExternalTextures || (zt === 32879 || zt === 35866 ? t.texImage3D(zt, 0, tt, oe.width, oe.height, oe.depth, 0, Nt, Ut, null) : t.texImage2D(zt, 0, tt, oe.width, oe.height, 0, Nt, Ut, null)), t.bindFramebuffer(36160, Me), Vt(oe) ? T.framebufferTexture2DMultisampleEXT(36160, lt, zt, r.get(je).__webglTexture, 0, ft(oe)) : a.framebufferTexture2D(36160, lt, zt, r.get(je).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function Ot(Me, oe, je) {
    if (a.bindRenderbuffer(36161, Me), oe.depthBuffer && !oe.stencilBuffer) {
      let lt = 33189;
      if (je || Vt(oe)) {
        const zt = oe.depthTexture;
        zt && zt.isDepthTexture && (zt.type === uy ? lt = 36012 : zt.type === D0 && (lt = 33190));
        const Nt = ft(oe);
        Vt(oe) ? T.renderbufferStorageMultisampleEXT(36161, Nt, lt, oe.width, oe.height) : a.renderbufferStorageMultisample(36161, Nt, lt, oe.width, oe.height);
      } else
        a.renderbufferStorage(36161, lt, oe.width, oe.height);
      a.framebufferRenderbuffer(36160, 36096, 36161, Me);
    } else if (oe.depthBuffer && oe.stencilBuffer) {
      const lt = ft(oe);
      je && Vt(oe) === !1 ? a.renderbufferStorageMultisample(36161, lt, 35056, oe.width, oe.height) : Vt(oe) ? T.renderbufferStorageMultisampleEXT(36161, lt, 35056, oe.width, oe.height) : a.renderbufferStorage(36161, 34041, oe.width, oe.height), a.framebufferRenderbuffer(36160, 33306, 36161, Me);
    } else {
      const lt = oe.isWebGLMultipleRenderTargets === !0 ? oe.texture : [oe.texture];
      for (let zt = 0; zt < lt.length; zt++) {
        const Nt = lt[zt], Ut = o.convert(Nt.format, Nt.encoding), tt = o.convert(Nt.type), rn = W(Nt.internalFormat, Ut, tt, Nt.encoding), ze = ft(oe);
        je && Vt(oe) === !1 ? a.renderbufferStorageMultisample(36161, ze, rn, oe.width, oe.height) : Vt(oe) ? T.renderbufferStorageMultisampleEXT(36161, ze, rn, oe.width, oe.height) : a.renderbufferStorage(36161, rn, oe.width, oe.height);
      }
    }
    a.bindRenderbuffer(36161, null);
  }
  function He(Me, oe) {
    if (oe && oe.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, Me), !(oe.depthTexture && oe.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(oe.depthTexture).__webglTexture || oe.depthTexture.image.width !== oe.width || oe.depthTexture.image.height !== oe.height) && (oe.depthTexture.image.width = oe.width, oe.depthTexture.image.height = oe.height, oe.depthTexture.needsUpdate = !0), ue(oe.depthTexture, 0);
    const lt = r.get(oe.depthTexture).__webglTexture, zt = ft(oe);
    if (oe.depthTexture.format === $x)
      Vt(oe) ? T.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, lt, 0, zt) : a.framebufferTexture2D(36160, 36096, 3553, lt, 0);
    else if (oe.depthTexture.format === r1)
      Vt(oe) ? T.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, lt, 0, zt) : a.framebufferTexture2D(36160, 33306, 3553, lt, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function et(Me) {
    const oe = r.get(Me), je = Me.isWebGLCubeRenderTarget === !0;
    if (Me.depthTexture && !oe.__autoAllocateDepthBuffer) {
      if (je)
        throw new Error("target.depthTexture not supported in Cube render targets");
      He(oe.__webglFramebuffer, Me);
    } else if (je) {
      oe.__webglDepthbuffer = [];
      for (let lt = 0; lt < 6; lt++)
        t.bindFramebuffer(36160, oe.__webglFramebuffer[lt]), oe.__webglDepthbuffer[lt] = a.createRenderbuffer(), Ot(oe.__webglDepthbuffer[lt], Me, !1);
    } else
      t.bindFramebuffer(36160, oe.__webglFramebuffer), oe.__webglDepthbuffer = a.createRenderbuffer(), Ot(oe.__webglDepthbuffer, Me, !1);
    t.bindFramebuffer(36160, null);
  }
  function mt(Me, oe, je) {
    const lt = r.get(Me);
    oe !== void 0 && Rt(lt.__webglFramebuffer, Me, Me.texture, 36064, 3553), je !== void 0 && et(Me);
  }
  function vt(Me) {
    const oe = Me.texture, je = r.get(Me), lt = r.get(oe);
    Me.addEventListener("dispose", ce), Me.isWebGLMultipleRenderTargets !== !0 && (lt.__webglTexture === void 0 && (lt.__webglTexture = a.createTexture()), lt.__version = oe.version, l.memory.textures++);
    const zt = Me.isWebGLCubeRenderTarget === !0, Nt = Me.isWebGLMultipleRenderTargets === !0, Ut = I(Me) || d;
    if (zt) {
      je.__webglFramebuffer = [];
      for (let tt = 0; tt < 6; tt++)
        je.__webglFramebuffer[tt] = a.createFramebuffer();
    } else {
      if (je.__webglFramebuffer = a.createFramebuffer(), Nt)
        if (i.drawBuffers) {
          const tt = Me.texture;
          for (let rn = 0, ze = tt.length; rn < ze; rn++) {
            const xe = r.get(tt[rn]);
            xe.__webglTexture === void 0 && (xe.__webglTexture = a.createTexture(), l.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (d && Me.samples > 0 && Vt(Me) === !1) {
        const tt = Nt ? oe : [oe];
        je.__webglMultisampledFramebuffer = a.createFramebuffer(), je.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, je.__webglMultisampledFramebuffer);
        for (let rn = 0; rn < tt.length; rn++) {
          const ze = tt[rn];
          je.__webglColorRenderbuffer[rn] = a.createRenderbuffer(), a.bindRenderbuffer(36161, je.__webglColorRenderbuffer[rn]);
          const xe = o.convert(ze.format, ze.encoding), Ie = o.convert(ze.type), it = W(ze.internalFormat, xe, Ie, ze.encoding), at = ft(Me);
          a.renderbufferStorageMultisample(36161, at, it, Me.width, Me.height), a.framebufferRenderbuffer(36160, 36064 + rn, 36161, je.__webglColorRenderbuffer[rn]);
        }
        a.bindRenderbuffer(36161, null), Me.depthBuffer && (je.__webglDepthRenderbuffer = a.createRenderbuffer(), Ot(je.__webglDepthRenderbuffer, Me, !0)), t.bindFramebuffer(36160, null);
      }
    }
    if (zt) {
      t.bindTexture(34067, lt.__webglTexture), Ue(34067, oe, Ut);
      for (let tt = 0; tt < 6; tt++)
        Rt(je.__webglFramebuffer[tt], Me, oe, 36064, 34069 + tt);
      J(oe, Ut) && $(34067), t.unbindTexture();
    } else if (Nt) {
      const tt = Me.texture;
      for (let rn = 0, ze = tt.length; rn < ze; rn++) {
        const xe = tt[rn], Ie = r.get(xe);
        t.bindTexture(3553, Ie.__webglTexture), Ue(3553, xe, Ut), Rt(je.__webglFramebuffer, Me, xe, 36064 + rn, 3553), J(xe, Ut) && $(3553);
      }
      t.unbindTexture();
    } else {
      let tt = 3553;
      (Me.isWebGL3DRenderTarget || Me.isWebGLArrayRenderTarget) && (d ? tt = Me.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(tt, lt.__webglTexture), Ue(tt, oe, Ut), Rt(je.__webglFramebuffer, Me, oe, 36064, tt), J(oe, Ut) && $(tt), t.unbindTexture();
    }
    Me.depthBuffer && et(Me);
  }
  function bt(Me) {
    const oe = I(Me) || d, je = Me.isWebGLMultipleRenderTargets === !0 ? Me.texture : [Me.texture];
    for (let lt = 0, zt = je.length; lt < zt; lt++) {
      const Nt = je[lt];
      if (J(Nt, oe)) {
        const Ut = Me.isWebGLCubeRenderTarget ? 34067 : 3553, tt = r.get(Nt).__webglTexture;
        t.bindTexture(Ut, tt), $(Ut), t.unbindTexture();
      }
    }
  }
  function Qt(Me) {
    if (d && Me.samples > 0 && Vt(Me) === !1) {
      const oe = Me.isWebGLMultipleRenderTargets ? Me.texture : [Me.texture], je = Me.width, lt = Me.height;
      let zt = 16384;
      const Nt = [], Ut = Me.stencilBuffer ? 33306 : 36096, tt = r.get(Me), rn = Me.isWebGLMultipleRenderTargets === !0;
      if (rn)
        for (let ze = 0; ze < oe.length; ze++)
          t.bindFramebuffer(36160, tt.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(36160, 36064 + ze, 36161, null), t.bindFramebuffer(36160, tt.__webglFramebuffer), a.framebufferTexture2D(36009, 36064 + ze, 3553, null, 0);
      t.bindFramebuffer(36008, tt.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, tt.__webglFramebuffer);
      for (let ze = 0; ze < oe.length; ze++) {
        Nt.push(36064 + ze), Me.depthBuffer && Nt.push(Ut);
        const xe = tt.__ignoreDepthValues !== void 0 ? tt.__ignoreDepthValues : !1;
        if (xe === !1 && (Me.depthBuffer && (zt |= 256), Me.stencilBuffer && (zt |= 1024)), rn && a.framebufferRenderbuffer(36008, 36064, 36161, tt.__webglColorRenderbuffer[ze]), xe === !0 && (a.invalidateFramebuffer(36008, [Ut]), a.invalidateFramebuffer(36009, [Ut])), rn) {
          const Ie = r.get(oe[ze]).__webglTexture;
          a.framebufferTexture2D(36009, 36064, 3553, Ie, 0);
        }
        a.blitFramebuffer(0, 0, je, lt, 0, 0, je, lt, zt, 9728), C && a.invalidateFramebuffer(36008, Nt);
      }
      if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), rn)
        for (let ze = 0; ze < oe.length; ze++) {
          t.bindFramebuffer(36160, tt.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(36160, 36064 + ze, 36161, tt.__webglColorRenderbuffer[ze]);
          const xe = r.get(oe[ze]).__webglTexture;
          t.bindFramebuffer(36160, tt.__webglFramebuffer), a.framebufferTexture2D(36009, 36064 + ze, 3553, xe, 0);
        }
      t.bindFramebuffer(36009, tt.__webglMultisampledFramebuffer);
    }
  }
  function ft(Me) {
    return Math.min(_, Me.samples);
  }
  function Vt(Me) {
    const oe = r.get(Me);
    return d && Me.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && oe.__useRenderToTexture !== !1;
  }
  function Jt(Me) {
    const oe = l.render.frame;
    D.get(Me) !== oe && (D.set(Me, oe), Me.update());
  }
  function Mt(Me, oe) {
    const je = Me.encoding, lt = Me.format, zt = Me.type;
    return Me.isCompressedTexture === !0 || Me.isVideoTexture === !0 || Me.format === MC || je !== yv && (je === Mi ? d === !1 ? e.has("EXT_sRGB") === !0 && lt === Sm ? (Me.format = MC, Me.minFilter = Po, Me.generateMipmaps = !1) : oe = q3.sRGBToLinear(oe) : (lt !== Sm || zt !== Gf) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", je)), oe;
  }
  this.allocateTextureUnit = he, this.resetTextureUnits = Be, this.setTexture2D = ue, this.setTexture2DArray = ye, this.setTexture3D = we, this.setTextureCube = Xe, this.rebindTextures = mt, this.setupRenderTarget = vt, this.updateRenderTargetMipmap = bt, this.updateMultisampleRenderTarget = Qt, this.setupDepthRenderbuffer = et, this.setupFrameBufferTexture = Rt, this.useMultisampledRTT = Vt;
}
function CF(a, e, t) {
  const r = t.isWebGL2;
  function i(o, l = null) {
    let d;
    if (o === Gf)
      return 5121;
    if (o === KN)
      return 32819;
    if (o === $N)
      return 32820;
    if (o === QN)
      return 5120;
    if (o === ZN)
      return 5122;
    if (o === j3)
      return 5123;
    if (o === JN)
      return 5124;
    if (o === D0)
      return 5125;
    if (o === uy)
      return 5126;
    if (o === GS)
      return r ? 5131 : (d = e.get("OES_texture_half_float"), d !== null ? d.HALF_FLOAT_OES : null);
    if (o === eF)
      return 6406;
    if (o === Sm)
      return 6408;
    if (o === nF)
      return 6409;
    if (o === rF)
      return 6410;
    if (o === $x)
      return 6402;
    if (o === r1)
      return 34041;
    if (o === iF)
      return 6403;
    if (o === tF)
      return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (o === MC)
      return d = e.get("EXT_sRGB"), d !== null ? d.SRGB_ALPHA_EXT : null;
    if (o === aF)
      return 36244;
    if (o === sF)
      return 33319;
    if (o === oF)
      return 33320;
    if (o === lF)
      return 36249;
    if (o === uC || o === cC || o === fC || o === dC)
      if (l === Mi)
        if (d = e.get("WEBGL_compressed_texture_s3tc_srgb"), d !== null) {
          if (o === uC)
            return d.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (o === cC)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (o === fC)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (o === dC)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (d = e.get("WEBGL_compressed_texture_s3tc"), d !== null) {
        if (o === uC)
          return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === cC)
          return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === fC)
          return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === dC)
          return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (o === jD || o === YD || o === XD || o === qD)
      if (d = e.get("WEBGL_compressed_texture_pvrtc"), d !== null) {
        if (o === jD)
          return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === YD)
          return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === XD)
          return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === qD)
          return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (o === uF)
      return d = e.get("WEBGL_compressed_texture_etc1"), d !== null ? d.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (o === QD || o === ZD)
      if (d = e.get("WEBGL_compressed_texture_etc"), d !== null) {
        if (o === QD)
          return l === Mi ? d.COMPRESSED_SRGB8_ETC2 : d.COMPRESSED_RGB8_ETC2;
        if (o === ZD)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : d.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (o === JD || o === KD || o === $D || o === e3 || o === t3 || o === n3 || o === r3 || o === i3 || o === a3 || o === s3 || o === o3 || o === l3 || o === u3 || o === c3)
      if (d = e.get("WEBGL_compressed_texture_astc"), d !== null) {
        if (o === JD)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : d.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (o === KD)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : d.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (o === $D)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : d.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (o === e3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : d.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (o === t3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : d.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (o === n3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : d.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (o === r3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : d.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (o === i3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : d.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (o === a3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : d.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (o === s3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : d.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (o === o3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : d.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (o === l3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : d.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (o === u3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : d.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (o === c3)
          return l === Mi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : d.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (o === f3)
      if (d = e.get("EXT_texture_compression_bptc"), d !== null) {
        if (o === f3)
          return l === Mi ? d.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : d.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    return o === Kx ? r ? 34042 : (d = e.get("WEBGL_depth_texture"), d !== null ? d.UNSIGNED_INT_24_8_WEBGL : null) : a[o] !== void 0 ? a[o] : null;
  }
  return { convert: i };
}
class RF extends fo {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Vb extends Xa {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const oW = { type: "move" };
class qA {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Vb(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Vb(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ge(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ge()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Vb(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ge(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ge()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, r) {
    let i = null, o = null, l = null;
    const d = this._targetRay, h = this._grip, m = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (m && e.hand) {
        l = !0;
        for (const P of e.hand.values()) {
          const U = t.getJointPose(P, r);
          if (m.joints[P.jointName] === void 0) {
            const k = new Vb();
            k.matrixAutoUpdate = !1, k.visible = !1, m.joints[P.jointName] = k, m.add(k);
          }
          const B = m.joints[P.jointName];
          U !== null && (B.matrix.fromArray(U.transform.matrix), B.matrix.decompose(B.position, B.rotation, B.scale), B.jointRadius = U.radius), B.visible = U !== null;
        }
        const S = m.joints["index-finger-tip"], _ = m.joints["thumb-tip"], T = S.position.distanceTo(_.position), C = 0.02, D = 5e-3;
        m.inputState.pinching && T > C + D ? (m.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !m.inputState.pinching && T <= C - D && (m.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        h !== null && e.gripSpace && (o = t.getPose(e.gripSpace, r), o !== null && (h.matrix.fromArray(o.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), o.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(o.linearVelocity)) : h.hasLinearVelocity = !1, o.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(o.angularVelocity)) : h.hasAngularVelocity = !1));
      d !== null && (i = t.getPose(e.targetRaySpace, r), i === null && o !== null && (i = o), i !== null && (d.matrix.fromArray(i.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), i.linearVelocity ? (d.hasLinearVelocity = !0, d.linearVelocity.copy(i.linearVelocity)) : d.hasLinearVelocity = !1, i.angularVelocity ? (d.hasAngularVelocity = !0, d.angularVelocity.copy(i.angularVelocity)) : d.hasAngularVelocity = !1, this.dispatchEvent(oW)));
    }
    return d !== null && (d.visible = i !== null), h !== null && (h.visible = o !== null), m !== null && (m.visible = l !== null), this;
  }
}
class K3 extends iu {
  constructor(e, t, r, i, o, l, d, h, m, S) {
    if (S = S !== void 0 ? S : $x, S !== $x && S !== r1)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    r === void 0 && S === $x && (r = D0), r === void 0 && S === r1 && (r = Kx), super(null, i, o, l, d, h, S, r, m), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = d !== void 0 ? d : co, this.minFilter = h !== void 0 ? h : co, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class lW extends Mm {
  constructor(e, t) {
    super();
    const r = this;
    let i = null, o = 1, l = null, d = "local-floor", h = null, m = null, S = null, _ = null, T = null, C = null;
    const D = t.getContextAttributes();
    let P = null, U = null;
    const B = [], k = [], V = new fo();
    V.layers.enable(1), V.viewport = new la();
    const I = new fo();
    I.layers.enable(2), I.viewport = new la();
    const X = [V, I], J = new RF();
    J.layers.enable(1), J.layers.enable(2);
    let $ = null, W = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(fe) {
      let ue = B[fe];
      return ue === void 0 && (ue = new qA(), B[fe] = ue), ue.getTargetRaySpace();
    }, this.getControllerGrip = function(fe) {
      let ue = B[fe];
      return ue === void 0 && (ue = new qA(), B[fe] = ue), ue.getGripSpace();
    }, this.getHand = function(fe) {
      let ue = B[fe];
      return ue === void 0 && (ue = new qA(), B[fe] = ue), ue.getHandSpace();
    };
    function ee(fe) {
      const ue = k.indexOf(fe.inputSource);
      if (ue === -1)
        return;
      const ye = B[ue];
      ye !== void 0 && ye.dispatchEvent({ type: fe.type, data: fe.inputSource });
    }
    function ie() {
      i.removeEventListener("select", ee), i.removeEventListener("selectstart", ee), i.removeEventListener("selectend", ee), i.removeEventListener("squeeze", ee), i.removeEventListener("squeezestart", ee), i.removeEventListener("squeezeend", ee), i.removeEventListener("end", ie), i.removeEventListener("inputsourceschange", pe);
      for (let fe = 0; fe < B.length; fe++) {
        const ue = k[fe];
        ue !== null && (k[fe] = null, B[fe].disconnect(ue));
      }
      $ = null, W = null, e.setRenderTarget(P), T = null, _ = null, S = null, i = null, U = null, he.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(fe) {
      o = fe, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(fe) {
      d = fe, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return h || l;
    }, this.setReferenceSpace = function(fe) {
      h = fe;
    }, this.getBaseLayer = function() {
      return _ !== null ? _ : T;
    }, this.getBinding = function() {
      return S;
    }, this.getFrame = function() {
      return C;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(fe) {
      if (i = fe, i !== null) {
        if (P = e.getRenderTarget(), i.addEventListener("select", ee), i.addEventListener("selectstart", ee), i.addEventListener("selectend", ee), i.addEventListener("squeeze", ee), i.addEventListener("squeezestart", ee), i.addEventListener("squeezeend", ee), i.addEventListener("end", ie), i.addEventListener("inputsourceschange", pe), D.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const ue = {
            antialias: i.renderState.layers === void 0 ? D.antialias : !0,
            alpha: D.alpha,
            depth: D.depth,
            stencil: D.stencil,
            framebufferScaleFactor: o
          };
          T = new XRWebGLLayer(i, t, ue), i.updateRenderState({ baseLayer: T }), U = new po(
            T.framebufferWidth,
            T.framebufferHeight,
            {
              format: Sm,
              type: Gf,
              encoding: e.outputEncoding
            }
          );
        } else {
          let ue = null, ye = null, we = null;
          D.depth && (we = D.stencil ? 35056 : 33190, ue = D.stencil ? r1 : $x, ye = D.stencil ? Kx : D0);
          const Xe = {
            colorFormat: 32856,
            depthFormat: we,
            scaleFactor: o
          };
          S = new XRWebGLBinding(i, t), _ = S.createProjectionLayer(Xe), i.updateRenderState({ layers: [_] }), U = new po(
            _.textureWidth,
            _.textureHeight,
            {
              format: Sm,
              type: Gf,
              depthTexture: new K3(_.textureWidth, _.textureHeight, ye, void 0, void 0, void 0, void 0, void 0, void 0, ue),
              stencilBuffer: D.stencil,
              encoding: e.outputEncoding,
              samples: D.antialias ? 4 : 0
            }
          );
          const Je = e.properties.get(U);
          Je.__ignoreDepthValues = _.ignoreDepthValues;
        }
        U.isXRRenderTarget = !0, this.setFoveation(1), h = null, l = await i.requestReferenceSpace(d), he.setContext(i), he.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
      }
    };
    function pe(fe) {
      for (let ue = 0; ue < fe.removed.length; ue++) {
        const ye = fe.removed[ue], we = k.indexOf(ye);
        we >= 0 && (k[we] = null, B[we].dispatchEvent({ type: "disconnected", data: ye }));
      }
      for (let ue = 0; ue < fe.added.length; ue++) {
        const ye = fe.added[ue];
        let we = k.indexOf(ye);
        if (we === -1) {
          for (let Je = 0; Je < B.length; Je++)
            if (Je >= k.length) {
              k.push(ye), we = Je;
              break;
            } else if (k[Je] === null) {
              k[Je] = ye, we = Je;
              break;
            }
          if (we === -1)
            break;
        }
        const Xe = B[we];
        Xe && Xe.dispatchEvent({ type: "connected", data: ye });
      }
    }
    const ce = new ge(), Ee = new ge();
    function de(fe, ue, ye) {
      ce.setFromMatrixPosition(ue.matrixWorld), Ee.setFromMatrixPosition(ye.matrixWorld);
      const we = ce.distanceTo(Ee), Xe = ue.projectionMatrix.elements, Je = ye.projectionMatrix.elements, st = Xe[14] / (Xe[10] - 1), Ue = Xe[14] / (Xe[10] + 1), ot = (Xe[9] + 1) / Xe[5], rt = (Xe[9] - 1) / Xe[5], _t = (Xe[8] - 1) / Xe[0], Rt = (Je[8] + 1) / Je[0], Ot = st * _t, He = st * Rt, et = we / (-_t + Rt), mt = et * -_t;
      ue.matrixWorld.decompose(fe.position, fe.quaternion, fe.scale), fe.translateX(mt), fe.translateZ(et), fe.matrixWorld.compose(fe.position, fe.quaternion, fe.scale), fe.matrixWorldInverse.copy(fe.matrixWorld).invert();
      const vt = st + et, bt = Ue + et, Qt = Ot - mt, ft = He + (we - mt), Vt = ot * Ue / bt * vt, Jt = rt * Ue / bt * vt;
      fe.projectionMatrix.makePerspective(Qt, ft, Vt, Jt, vt, bt);
    }
    function Fe(fe, ue) {
      ue === null ? fe.matrixWorld.copy(fe.matrix) : fe.matrixWorld.multiplyMatrices(ue.matrixWorld, fe.matrix), fe.matrixWorldInverse.copy(fe.matrixWorld).invert();
    }
    this.updateCamera = function(fe) {
      if (i === null)
        return;
      J.near = I.near = V.near = fe.near, J.far = I.far = V.far = fe.far, ($ !== J.near || W !== J.far) && (i.updateRenderState({
        depthNear: J.near,
        depthFar: J.far
      }), $ = J.near, W = J.far);
      const ue = fe.parent, ye = J.cameras;
      Fe(J, ue);
      for (let Xe = 0; Xe < ye.length; Xe++)
        Fe(ye[Xe], ue);
      J.matrixWorld.decompose(J.position, J.quaternion, J.scale), fe.position.copy(J.position), fe.quaternion.copy(J.quaternion), fe.scale.copy(J.scale), fe.matrix.copy(J.matrix), fe.matrixWorld.copy(J.matrixWorld);
      const we = fe.children;
      for (let Xe = 0, Je = we.length; Xe < Je; Xe++)
        we[Xe].updateMatrixWorld(!0);
      ye.length === 2 ? de(J, V, I) : J.projectionMatrix.copy(V.projectionMatrix);
    }, this.getCamera = function() {
      return J;
    }, this.getFoveation = function() {
      if (_ !== null)
        return _.fixedFoveation;
      if (T !== null)
        return T.fixedFoveation;
    }, this.setFoveation = function(fe) {
      _ !== null && (_.fixedFoveation = fe), T !== null && T.fixedFoveation !== void 0 && (T.fixedFoveation = fe);
    };
    let Ce = null;
    function Be(fe, ue) {
      if (m = ue.getViewerPose(h || l), C = ue, m !== null) {
        const ye = m.views;
        T !== null && (e.setRenderTargetFramebuffer(U, T.framebuffer), e.setRenderTarget(U));
        let we = !1;
        ye.length !== J.cameras.length && (J.cameras.length = 0, we = !0);
        for (let Xe = 0; Xe < ye.length; Xe++) {
          const Je = ye[Xe];
          let st = null;
          if (T !== null)
            st = T.getViewport(Je);
          else {
            const ot = S.getViewSubImage(_, Je);
            st = ot.viewport, Xe === 0 && (e.setRenderTargetTextures(
              U,
              ot.colorTexture,
              _.ignoreDepthValues ? void 0 : ot.depthStencilTexture
            ), e.setRenderTarget(U));
          }
          let Ue = X[Xe];
          Ue === void 0 && (Ue = new fo(), Ue.layers.enable(Xe), Ue.viewport = new la(), X[Xe] = Ue), Ue.matrix.fromArray(Je.transform.matrix), Ue.projectionMatrix.fromArray(Je.projectionMatrix), Ue.viewport.set(st.x, st.y, st.width, st.height), Xe === 0 && J.matrix.copy(Ue.matrix), we === !0 && J.cameras.push(Ue);
        }
      }
      for (let ye = 0; ye < B.length; ye++) {
        const we = k[ye], Xe = B[ye];
        we !== null && Xe !== void 0 && Xe.update(we, ue, h || l);
      }
      Ce && Ce(fe, ue), C = null;
    }
    const he = new _F();
    he.setAnimationLoop(Be), this.setAnimationLoop = function(fe) {
      Ce = fe;
    }, this.dispose = function() {
    };
  }
}
function uW(a, e) {
  function t(P, U) {
    P.fogColor.value.copy(U.color), U.isFog ? (P.fogNear.value = U.near, P.fogFar.value = U.far) : U.isFogExp2 && (P.fogDensity.value = U.density);
  }
  function r(P, U, B, k, V) {
    U.isMeshBasicMaterial || U.isMeshLambertMaterial ? i(P, U) : U.isMeshToonMaterial ? (i(P, U), S(P, U)) : U.isMeshPhongMaterial ? (i(P, U), m(P, U)) : U.isMeshStandardMaterial ? (i(P, U), _(P, U), U.isMeshPhysicalMaterial && T(P, U, V)) : U.isMeshMatcapMaterial ? (i(P, U), C(P, U)) : U.isMeshDepthMaterial ? i(P, U) : U.isMeshDistanceMaterial ? (i(P, U), D(P, U)) : U.isMeshNormalMaterial ? i(P, U) : U.isLineBasicMaterial ? (o(P, U), U.isLineDashedMaterial && l(P, U)) : U.isPointsMaterial ? d(P, U, B, k) : U.isSpriteMaterial ? h(P, U) : U.isShadowMaterial ? (P.color.value.copy(U.color), P.opacity.value = U.opacity) : U.isShaderMaterial && (U.uniformsNeedUpdate = !1);
  }
  function i(P, U) {
    P.opacity.value = U.opacity, U.color && P.diffuse.value.copy(U.color), U.emissive && P.emissive.value.copy(U.emissive).multiplyScalar(U.emissiveIntensity), U.map && (P.map.value = U.map), U.alphaMap && (P.alphaMap.value = U.alphaMap), U.bumpMap && (P.bumpMap.value = U.bumpMap, P.bumpScale.value = U.bumpScale, U.side === uf && (P.bumpScale.value *= -1)), U.displacementMap && (P.displacementMap.value = U.displacementMap, P.displacementScale.value = U.displacementScale, P.displacementBias.value = U.displacementBias), U.emissiveMap && (P.emissiveMap.value = U.emissiveMap), U.normalMap && (P.normalMap.value = U.normalMap, P.normalScale.value.copy(U.normalScale), U.side === uf && P.normalScale.value.negate()), U.specularMap && (P.specularMap.value = U.specularMap), U.alphaTest > 0 && (P.alphaTest.value = U.alphaTest);
    const B = e.get(U).envMap;
    if (B && (P.envMap.value = B, P.flipEnvMap.value = B.isCubeTexture && B.isRenderTargetTexture === !1 ? -1 : 1, P.reflectivity.value = U.reflectivity, P.ior.value = U.ior, P.refractionRatio.value = U.refractionRatio), U.lightMap) {
      P.lightMap.value = U.lightMap;
      const I = a.physicallyCorrectLights !== !0 ? Math.PI : 1;
      P.lightMapIntensity.value = U.lightMapIntensity * I;
    }
    U.aoMap && (P.aoMap.value = U.aoMap, P.aoMapIntensity.value = U.aoMapIntensity);
    let k;
    U.map ? k = U.map : U.specularMap ? k = U.specularMap : U.displacementMap ? k = U.displacementMap : U.normalMap ? k = U.normalMap : U.bumpMap ? k = U.bumpMap : U.roughnessMap ? k = U.roughnessMap : U.metalnessMap ? k = U.metalnessMap : U.alphaMap ? k = U.alphaMap : U.emissiveMap ? k = U.emissiveMap : U.clearcoatMap ? k = U.clearcoatMap : U.clearcoatNormalMap ? k = U.clearcoatNormalMap : U.clearcoatRoughnessMap ? k = U.clearcoatRoughnessMap : U.iridescenceMap ? k = U.iridescenceMap : U.iridescenceThicknessMap ? k = U.iridescenceThicknessMap : U.specularIntensityMap ? k = U.specularIntensityMap : U.specularColorMap ? k = U.specularColorMap : U.transmissionMap ? k = U.transmissionMap : U.thicknessMap ? k = U.thicknessMap : U.sheenColorMap ? k = U.sheenColorMap : U.sheenRoughnessMap && (k = U.sheenRoughnessMap), k !== void 0 && (k.isWebGLRenderTarget && (k = k.texture), k.matrixAutoUpdate === !0 && k.updateMatrix(), P.uvTransform.value.copy(k.matrix));
    let V;
    U.aoMap ? V = U.aoMap : U.lightMap && (V = U.lightMap), V !== void 0 && (V.isWebGLRenderTarget && (V = V.texture), V.matrixAutoUpdate === !0 && V.updateMatrix(), P.uv2Transform.value.copy(V.matrix));
  }
  function o(P, U) {
    P.diffuse.value.copy(U.color), P.opacity.value = U.opacity;
  }
  function l(P, U) {
    P.dashSize.value = U.dashSize, P.totalSize.value = U.dashSize + U.gapSize, P.scale.value = U.scale;
  }
  function d(P, U, B, k) {
    P.diffuse.value.copy(U.color), P.opacity.value = U.opacity, P.size.value = U.size * B, P.scale.value = k * 0.5, U.map && (P.map.value = U.map), U.alphaMap && (P.alphaMap.value = U.alphaMap), U.alphaTest > 0 && (P.alphaTest.value = U.alphaTest);
    let V;
    U.map ? V = U.map : U.alphaMap && (V = U.alphaMap), V !== void 0 && (V.matrixAutoUpdate === !0 && V.updateMatrix(), P.uvTransform.value.copy(V.matrix));
  }
  function h(P, U) {
    P.diffuse.value.copy(U.color), P.opacity.value = U.opacity, P.rotation.value = U.rotation, U.map && (P.map.value = U.map), U.alphaMap && (P.alphaMap.value = U.alphaMap), U.alphaTest > 0 && (P.alphaTest.value = U.alphaTest);
    let B;
    U.map ? B = U.map : U.alphaMap && (B = U.alphaMap), B !== void 0 && (B.matrixAutoUpdate === !0 && B.updateMatrix(), P.uvTransform.value.copy(B.matrix));
  }
  function m(P, U) {
    P.specular.value.copy(U.specular), P.shininess.value = Math.max(U.shininess, 1e-4);
  }
  function S(P, U) {
    U.gradientMap && (P.gradientMap.value = U.gradientMap);
  }
  function _(P, U) {
    P.roughness.value = U.roughness, P.metalness.value = U.metalness, U.roughnessMap && (P.roughnessMap.value = U.roughnessMap), U.metalnessMap && (P.metalnessMap.value = U.metalnessMap), e.get(U).envMap && (P.envMapIntensity.value = U.envMapIntensity);
  }
  function T(P, U, B) {
    P.ior.value = U.ior, U.sheen > 0 && (P.sheenColor.value.copy(U.sheenColor).multiplyScalar(U.sheen), P.sheenRoughness.value = U.sheenRoughness, U.sheenColorMap && (P.sheenColorMap.value = U.sheenColorMap), U.sheenRoughnessMap && (P.sheenRoughnessMap.value = U.sheenRoughnessMap)), U.clearcoat > 0 && (P.clearcoat.value = U.clearcoat, P.clearcoatRoughness.value = U.clearcoatRoughness, U.clearcoatMap && (P.clearcoatMap.value = U.clearcoatMap), U.clearcoatRoughnessMap && (P.clearcoatRoughnessMap.value = U.clearcoatRoughnessMap), U.clearcoatNormalMap && (P.clearcoatNormalScale.value.copy(U.clearcoatNormalScale), P.clearcoatNormalMap.value = U.clearcoatNormalMap, U.side === uf && P.clearcoatNormalScale.value.negate())), U.iridescence > 0 && (P.iridescence.value = U.iridescence, P.iridescenceIOR.value = U.iridescenceIOR, P.iridescenceThicknessMinimum.value = U.iridescenceThicknessRange[0], P.iridescenceThicknessMaximum.value = U.iridescenceThicknessRange[1], U.iridescenceMap && (P.iridescenceMap.value = U.iridescenceMap), U.iridescenceThicknessMap && (P.iridescenceThicknessMap.value = U.iridescenceThicknessMap)), U.transmission > 0 && (P.transmission.value = U.transmission, P.transmissionSamplerMap.value = B.texture, P.transmissionSamplerSize.value.set(B.width, B.height), U.transmissionMap && (P.transmissionMap.value = U.transmissionMap), P.thickness.value = U.thickness, U.thicknessMap && (P.thicknessMap.value = U.thicknessMap), P.attenuationDistance.value = U.attenuationDistance, P.attenuationColor.value.copy(U.attenuationColor)), P.specularIntensity.value = U.specularIntensity, P.specularColor.value.copy(U.specularColor), U.specularIntensityMap && (P.specularIntensityMap.value = U.specularIntensityMap), U.specularColorMap && (P.specularColorMap.value = U.specularColorMap);
  }
  function C(P, U) {
    U.matcap && (P.matcap.value = U.matcap);
  }
  function D(P, U) {
    P.referencePosition.value.copy(U.referencePosition), P.nearDistance.value = U.nearDistance, P.farDistance.value = U.farDistance;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: r
  };
}
function cW(a, e, t, r) {
  let i = {}, o = {}, l = [];
  const d = t.isWebGL2 ? a.getParameter(35375) : 0;
  function h(k, V) {
    const I = V.program;
    r.uniformBlockBinding(k, I);
  }
  function m(k, V) {
    let I = i[k.id];
    I === void 0 && (D(k), I = S(k), i[k.id] = I, k.addEventListener("dispose", U));
    const X = V.program;
    r.updateUBOMapping(k, X);
    const J = e.render.frame;
    o[k.id] !== J && (T(k), o[k.id] = J);
  }
  function S(k) {
    const V = _();
    k.__bindingPointIndex = V;
    const I = a.createBuffer(), X = k.__size, J = k.usage;
    return a.bindBuffer(35345, I), a.bufferData(35345, X, J), a.bindBuffer(35345, null), a.bindBufferBase(35345, V, I), I;
  }
  function _() {
    for (let k = 0; k < d; k++)
      if (l.indexOf(k) === -1)
        return l.push(k), k;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function T(k) {
    const V = i[k.id], I = k.uniforms, X = k.__cache;
    a.bindBuffer(35345, V);
    for (let J = 0, $ = I.length; J < $; J++) {
      const W = I[J];
      if (C(W, J, X) === !0) {
        const ee = W.value, ie = W.__offset;
        typeof ee == "number" ? (W.__data[0] = ee, a.bufferSubData(35345, ie, W.__data)) : (W.value.isMatrix3 ? (W.__data[0] = W.value.elements[0], W.__data[1] = W.value.elements[1], W.__data[2] = W.value.elements[2], W.__data[3] = W.value.elements[0], W.__data[4] = W.value.elements[3], W.__data[5] = W.value.elements[4], W.__data[6] = W.value.elements[5], W.__data[7] = W.value.elements[0], W.__data[8] = W.value.elements[6], W.__data[9] = W.value.elements[7], W.__data[10] = W.value.elements[8], W.__data[11] = W.value.elements[0]) : ee.toArray(W.__data), a.bufferSubData(35345, ie, W.__data));
      }
    }
    a.bindBuffer(35345, null);
  }
  function C(k, V, I) {
    const X = k.value;
    if (I[V] === void 0)
      return typeof X == "number" ? I[V] = X : I[V] = X.clone(), !0;
    if (typeof X == "number") {
      if (I[V] !== X)
        return I[V] = X, !0;
    } else {
      const J = I[V];
      if (J.equals(X) === !1)
        return J.copy(X), !0;
    }
    return !1;
  }
  function D(k) {
    const V = k.uniforms;
    let I = 0;
    const X = 16;
    let J = 0;
    for (let $ = 0, W = V.length; $ < W; $++) {
      const ee = V[$], ie = P(ee);
      if (ee.__data = new Float32Array(ie.storage / Float32Array.BYTES_PER_ELEMENT), ee.__offset = I, $ > 0) {
        J = I % X;
        const pe = X - J;
        J !== 0 && pe - ie.boundary < 0 && (I += X - J, ee.__offset = I);
      }
      I += ie.storage;
    }
    return J = I % X, J > 0 && (I += X - J), k.__size = I, k.__cache = {}, this;
  }
  function P(k) {
    const V = k.value, I = {
      boundary: 0,
      storage: 0
    };
    return typeof V == "number" ? (I.boundary = 4, I.storage = 4) : V.isVector2 ? (I.boundary = 8, I.storage = 8) : V.isVector3 || V.isColor ? (I.boundary = 16, I.storage = 12) : V.isVector4 ? (I.boundary = 16, I.storage = 16) : V.isMatrix3 ? (I.boundary = 48, I.storage = 48) : V.isMatrix4 ? (I.boundary = 64, I.storage = 64) : V.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", V), I;
  }
  function U(k) {
    const V = k.target;
    V.removeEventListener("dispose", U);
    const I = l.indexOf(V.__bindingPointIndex);
    l.splice(I, 1), a.deleteBuffer(i[V.id]), delete i[V.id], delete o[V.id];
  }
  function B() {
    for (const k in i)
      a.deleteBuffer(i[k]);
    l = [], i = {}, o = {};
  }
  return {
    bind: h,
    update: m,
    dispose: B
  };
}
function fW() {
  const a = UM("canvas");
  return a.style.display = "block", a;
}
function $3(a = {}) {
  this.isWebGLRenderer = !0;
  const e = a.canvas !== void 0 ? a.canvas : fW(), t = a.context !== void 0 ? a.context : null, r = a.depth !== void 0 ? a.depth : !0, i = a.stencil !== void 0 ? a.stencil : !0, o = a.antialias !== void 0 ? a.antialias : !1, l = a.premultipliedAlpha !== void 0 ? a.premultipliedAlpha : !0, d = a.preserveDrawingBuffer !== void 0 ? a.preserveDrawingBuffer : !1, h = a.powerPreference !== void 0 ? a.powerPreference : "default", m = a.failIfMajorPerformanceCaveat !== void 0 ? a.failIfMajorPerformanceCaveat : !1;
  let S;
  t !== null ? S = t.getContextAttributes().alpha : S = a.alpha !== void 0 ? a.alpha : !1;
  let _ = null, T = null;
  const C = [], D = [];
  this.domElement = e, this.debug = {
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = yv, this.physicallyCorrectLights = !1, this.toneMapping = rg, this.toneMappingExposure = 1, Object.defineProperties(this, {
    gammaFactor: {
      get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  const P = this;
  let U = !1, B = 0, k = 0, V = null, I = -1, X = null;
  const J = new la(), $ = new la();
  let W = null, ee = e.width, ie = e.height, pe = 1, ce = null, Ee = null;
  const de = new la(0, 0, ee, ie), Fe = new la(0, 0, ee, ie);
  let Ce = !1;
  const Be = new IC();
  let he = !1, fe = !1, ue = null;
  const ye = new si(), we = new Ft(), Xe = new ge(), Je = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function st() {
    return V === null ? pe : 1;
  }
  let Ue = t;
  function ot(Te, ct) {
    for (let me = 0; me < Te.length; me++) {
      const Oe = Te[me], qe = e.getContext(Oe, ct);
      if (qe !== null)
        return qe;
    }
    return null;
  }
  try {
    const Te = {
      alpha: !0,
      depth: r,
      stencil: i,
      antialias: o,
      premultipliedAlpha: l,
      preserveDrawingBuffer: d,
      powerPreference: h,
      failIfMajorPerformanceCaveat: m
    };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${U0}`), e.addEventListener("webglcontextlost", it, !1), e.addEventListener("webglcontextrestored", at, !1), e.addEventListener("webglcontextcreationerror", hn, !1), Ue === null) {
      const ct = ["webgl2", "webgl", "experimental-webgl"];
      if (P.isWebGL1Renderer === !0 && ct.shift(), Ue = ot(ct, Te), Ue === null)
        throw ot(ct) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    Ue.getShaderPrecisionFormat === void 0 && (Ue.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (Te) {
    throw console.error("THREE.WebGLRenderer: " + Te.message), Te;
  }
  let rt, _t, Rt, Ot, He, et, mt, vt, bt, Qt, ft, Vt, Jt, Mt, Me, oe, je, lt, zt, Nt, Ut, tt, rn, ze;
  function xe() {
    rt = new TG(Ue), _t = new SG(Ue, rt, a), rt.init(_t), tt = new CF(Ue, rt, _t), Rt = new aW(Ue, rt, _t), Ot = new AG(), He = new X8(), et = new sW(Ue, rt, Rt, He, _t, tt, Ot), mt = new bG(P), vt = new MG(P), bt = new HH(Ue, _t), rn = new yG(Ue, rt, bt, _t), Qt = new CG(Ue, bt, Ot, rn), ft = new OG(Ue, Qt, bt, Ot), zt = new PG(Ue, _t, et), oe = new _G(He), Vt = new Y8(P, mt, vt, rt, _t, rn, oe), Jt = new uW(P, He), Mt = new Q8(), Me = new tW(rt, _t), lt = new gG(P, mt, Rt, ft, S, l), je = new iW(P, ft, _t), ze = new cW(Ue, Ot, _t, Rt), Nt = new xG(Ue, rt, Ot, _t), Ut = new RG(Ue, rt, Ot, _t), Ot.programs = Vt.programs, P.capabilities = _t, P.extensions = rt, P.properties = He, P.renderLists = Mt, P.shadowMap = je, P.state = Rt, P.info = Ot;
  }
  xe();
  const Ie = new lW(P, Ue);
  this.xr = Ie, this.getContext = function() {
    return Ue;
  }, this.getContextAttributes = function() {
    return Ue.getContextAttributes();
  }, this.forceContextLoss = function() {
    const Te = rt.get("WEBGL_lose_context");
    Te && Te.loseContext();
  }, this.forceContextRestore = function() {
    const Te = rt.get("WEBGL_lose_context");
    Te && Te.restoreContext();
  }, this.getPixelRatio = function() {
    return pe;
  }, this.setPixelRatio = function(Te) {
    Te !== void 0 && (pe = Te, this.setSize(ee, ie, !1));
  }, this.getSize = function(Te) {
    return Te.set(ee, ie);
  }, this.setSize = function(Te, ct, me) {
    if (Ie.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    ee = Te, ie = ct, e.width = Math.floor(Te * pe), e.height = Math.floor(ct * pe), me !== !1 && (e.style.width = Te + "px", e.style.height = ct + "px"), this.setViewport(0, 0, Te, ct);
  }, this.getDrawingBufferSize = function(Te) {
    return Te.set(ee * pe, ie * pe).floor();
  }, this.setDrawingBufferSize = function(Te, ct, me) {
    ee = Te, ie = ct, pe = me, e.width = Math.floor(Te * me), e.height = Math.floor(ct * me), this.setViewport(0, 0, Te, ct);
  }, this.getCurrentViewport = function(Te) {
    return Te.copy(J);
  }, this.getViewport = function(Te) {
    return Te.copy(de);
  }, this.setViewport = function(Te, ct, me, Oe) {
    Te.isVector4 ? de.set(Te.x, Te.y, Te.z, Te.w) : de.set(Te, ct, me, Oe), Rt.viewport(J.copy(de).multiplyScalar(pe).floor());
  }, this.getScissor = function(Te) {
    return Te.copy(Fe);
  }, this.setScissor = function(Te, ct, me, Oe) {
    Te.isVector4 ? Fe.set(Te.x, Te.y, Te.z, Te.w) : Fe.set(Te, ct, me, Oe), Rt.scissor($.copy(Fe).multiplyScalar(pe).floor());
  }, this.getScissorTest = function() {
    return Ce;
  }, this.setScissorTest = function(Te) {
    Rt.setScissorTest(Ce = Te);
  }, this.setOpaqueSort = function(Te) {
    ce = Te;
  }, this.setTransparentSort = function(Te) {
    Ee = Te;
  }, this.getClearColor = function(Te) {
    return Te.copy(lt.getClearColor());
  }, this.setClearColor = function() {
    lt.setClearColor.apply(lt, arguments);
  }, this.getClearAlpha = function() {
    return lt.getClearAlpha();
  }, this.setClearAlpha = function() {
    lt.setClearAlpha.apply(lt, arguments);
  }, this.clear = function(Te = !0, ct = !0, me = !0) {
    let Oe = 0;
    Te && (Oe |= 16384), ct && (Oe |= 256), me && (Oe |= 1024), Ue.clear(Oe);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", it, !1), e.removeEventListener("webglcontextrestored", at, !1), e.removeEventListener("webglcontextcreationerror", hn, !1), Mt.dispose(), Me.dispose(), He.dispose(), mt.dispose(), vt.dispose(), ft.dispose(), rn.dispose(), ze.dispose(), Vt.dispose(), Ie.dispose(), Ie.removeEventListener("sessionstart", fn), Ie.removeEventListener("sessionend", Gr), ue && (ue.dispose(), ue = null), Wr.stop();
  };
  function it(Te) {
    Te.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), U = !0;
  }
  function at() {
    console.log("THREE.WebGLRenderer: Context Restored."), U = !1;
    const Te = Ot.autoReset, ct = je.enabled, me = je.autoUpdate, Oe = je.needsUpdate, qe = je.type;
    xe(), Ot.autoReset = Te, je.enabled = ct, je.autoUpdate = me, je.needsUpdate = Oe, je.type = qe;
  }
  function hn(Te) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Te.statusMessage);
  }
  function De(Te) {
    const ct = Te.target;
    ct.removeEventListener("dispose", De), Tt(ct);
  }
  function Tt(Te) {
    Ne(Te), He.remove(Te);
  }
  function Ne(Te) {
    const ct = He.get(Te).programs;
    ct !== void 0 && (ct.forEach(function(me) {
      Vt.releaseProgram(me);
    }), Te.isShaderMaterial && Vt.releaseShaderCache(Te));
  }
  this.renderBufferDirect = function(Te, ct, me, Oe, qe, on) {
    ct === null && (ct = Je);
    const yn = qe.isMesh && qe.matrixWorld.determinant() < 0, Rn = ni(Te, ct, me, Oe, qe);
    Rt.setMaterial(Oe, yn);
    let mn = me.index;
    const vn = me.attributes.position;
    if (mn === null) {
      if (vn === void 0 || vn.count === 0)
        return;
    } else if (mn.count === 0)
      return;
    let Zn = 1;
    Oe.wireframe === !0 && (mn = Qt.getWireframeAttribute(me), Zn = 2), rn.setup(qe, Oe, Rn, me, mn);
    let nr, br = Nt;
    mn !== null && (nr = bt.get(mn), br = Ut, br.setIndex(nr));
    const Yi = mn !== null ? mn.count : vn.count, La = me.drawRange.start * Zn, Ys = me.drawRange.count * Zn, $t = on !== null ? on.start * Zn : 0, Zr = on !== null ? on.count * Zn : 1 / 0, ls = Math.max(La, $t), Xn = Math.min(Yi, La + Ys, $t + Zr) - 1, qa = Math.max(0, Xn - ls + 1);
    if (qa !== 0) {
      if (qe.isMesh)
        Oe.wireframe === !0 ? (Rt.setLineWidth(Oe.wireframeLinewidth * st()), br.setMode(1)) : br.setMode(4);
      else if (qe.isLine) {
        let mo = Oe.linewidth;
        mo === void 0 && (mo = 1), Rt.setLineWidth(mo * st()), qe.isLineSegments ? br.setMode(1) : qe.isLineLoop ? br.setMode(2) : br.setMode(3);
      } else
        qe.isPoints ? br.setMode(0) : qe.isSprite && br.setMode(4);
      if (qe.isInstancedMesh)
        br.renderInstances(ls, qa, qe.count);
      else if (me.isInstancedBufferGeometry) {
        const mo = Math.min(me.instanceCount, me._maxInstanceCount);
        br.renderInstances(ls, qa, mo);
      } else
        br.render(ls, qa);
    }
  }, this.compile = function(Te, ct) {
    T = Me.get(Te), T.init(), D.push(T), Te.traverseVisible(function(me) {
      me.isLight && me.layers.test(ct.layers) && (T.pushLight(me), me.castShadow && T.pushShadow(me));
    }), T.setupLights(P.physicallyCorrectLights), Te.traverse(function(me) {
      const Oe = me.material;
      if (Oe)
        if (Array.isArray(Oe))
          for (let qe = 0; qe < Oe.length; qe++) {
            const on = Oe[qe];
            ki(on, Te, me);
          }
        else
          ki(Oe, Te, me);
    }), D.pop(), T = null;
  };
  let Gt = null;
  function Pt(Te) {
    Gt && Gt(Te);
  }
  function fn() {
    Wr.stop();
  }
  function Gr() {
    Wr.start();
  }
  const Wr = new _F();
  Wr.setAnimationLoop(Pt), typeof self < "u" && Wr.setContext(self), this.setAnimationLoop = function(Te) {
    Gt = Te, Ie.setAnimationLoop(Te), Te === null ? Wr.stop() : Wr.start();
  }, Ie.addEventListener("sessionstart", fn), Ie.addEventListener("sessionend", Gr), this.render = function(Te, ct) {
    if (ct !== void 0 && ct.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (U === !0)
      return;
    Te.autoUpdate === !0 && Te.updateMatrixWorld(), ct.parent === null && ct.updateMatrixWorld(), Ie.enabled === !0 && Ie.isPresenting === !0 && (Ie.cameraAutoUpdate === !0 && Ie.updateCamera(ct), ct = Ie.getCamera()), Te.isScene === !0 && Te.onBeforeRender(P, Te, ct, V), T = Me.get(Te, D.length), T.init(), D.push(T), ye.multiplyMatrices(ct.projectionMatrix, ct.matrixWorldInverse), Be.setFromProjectionMatrix(ye), fe = this.localClippingEnabled, he = oe.init(this.clippingPlanes, fe, ct), _ = Mt.get(Te, C.length), _.init(), C.push(_), Ur(Te, ct, 0, P.sortObjects), _.finish(), P.sortObjects === !0 && _.sort(ce, Ee), he === !0 && oe.beginShadows();
    const me = T.state.shadowsArray;
    if (je.render(me, Te, ct), he === !0 && oe.endShadows(), this.info.autoReset === !0 && this.info.reset(), lt.render(_, Te), T.setupLights(P.physicallyCorrectLights), ct.isArrayCamera) {
      const Oe = ct.cameras;
      for (let qe = 0, on = Oe.length; qe < on; qe++) {
        const yn = Oe[qe];
        ir(_, Te, yn, yn.viewport);
      }
    } else
      ir(_, Te, ct);
    V !== null && (et.updateMultisampleRenderTarget(V), et.updateRenderTargetMipmap(V)), Te.isScene === !0 && Te.onAfterRender(P, Te, ct), rn.resetDefaultState(), I = -1, X = null, D.pop(), D.length > 0 ? T = D[D.length - 1] : T = null, C.pop(), C.length > 0 ? _ = C[C.length - 1] : _ = null;
  };
  function Ur(Te, ct, me, Oe) {
    if (Te.visible === !1)
      return;
    if (Te.layers.test(ct.layers)) {
      if (Te.isGroup)
        me = Te.renderOrder;
      else if (Te.isLOD)
        Te.autoUpdate === !0 && Te.update(ct);
      else if (Te.isLight)
        T.pushLight(Te), Te.castShadow && T.pushShadow(Te);
      else if (Te.isSprite) {
        if (!Te.frustumCulled || Be.intersectsSprite(Te)) {
          Oe && Xe.setFromMatrixPosition(Te.matrixWorld).applyMatrix4(ye);
          const yn = ft.update(Te), Rn = Te.material;
          Rn.visible && _.push(Te, yn, Rn, me, Xe.z, null);
        }
      } else if ((Te.isMesh || Te.isLine || Te.isPoints) && (Te.isSkinnedMesh && Te.skeleton.frame !== Ot.render.frame && (Te.skeleton.update(), Te.skeleton.frame = Ot.render.frame), !Te.frustumCulled || Be.intersectsObject(Te))) {
        Oe && Xe.setFromMatrixPosition(Te.matrixWorld).applyMatrix4(ye);
        const yn = ft.update(Te), Rn = Te.material;
        if (Array.isArray(Rn)) {
          const mn = yn.groups;
          for (let vn = 0, Zn = mn.length; vn < Zn; vn++) {
            const nr = mn[vn], br = Rn[nr.materialIndex];
            br && br.visible && _.push(Te, yn, br, me, Xe.z, nr);
          }
        } else
          Rn.visible && _.push(Te, yn, Rn, me, Xe.z, null);
      }
    }
    const on = Te.children;
    for (let yn = 0, Rn = on.length; yn < Rn; yn++)
      Ur(on[yn], ct, me, Oe);
  }
  function ir(Te, ct, me, Oe) {
    const qe = Te.opaque, on = Te.transmissive, yn = Te.transparent;
    T.setupLightsView(me), on.length > 0 && Vn(qe, ct, me), Oe && Rt.viewport(J.copy(Oe)), qe.length > 0 && jr(qe, ct, me), on.length > 0 && jr(on, ct, me), yn.length > 0 && jr(yn, ct, me), Rt.buffers.depth.setTest(!0), Rt.buffers.depth.setMask(!0), Rt.buffers.color.setMask(!0), Rt.setPolygonOffset(!1);
  }
  function Vn(Te, ct, me) {
    const Oe = _t.isWebGL2;
    ue === null && (ue = new po(1, 1, {
      generateMipmaps: !0,
      type: rt.has("EXT_color_buffer_half_float") ? GS : Gf,
      minFilter: s1,
      samples: Oe && o === !0 ? 4 : 0
    })), P.getDrawingBufferSize(we), Oe ? ue.setSize(we.x, we.y) : ue.setSize(TC(we.x), TC(we.y));
    const qe = P.getRenderTarget();
    P.setRenderTarget(ue), P.clear();
    const on = P.toneMapping;
    P.toneMapping = rg, jr(Te, ct, me), P.toneMapping = on, et.updateMultisampleRenderTarget(ue), et.updateRenderTargetMipmap(ue), P.setRenderTarget(qe);
  }
  function jr(Te, ct, me) {
    const Oe = ct.isScene === !0 ? ct.overrideMaterial : null;
    for (let qe = 0, on = Te.length; qe < on; qe++) {
      const yn = Te[qe], Rn = yn.object, mn = yn.geometry, vn = Oe === null ? yn.material : Oe, Zn = yn.group;
      Rn.layers.test(me.layers) && ti(Rn, ct, me, mn, vn, Zn);
    }
  }
  function ti(Te, ct, me, Oe, qe, on) {
    Te.onBeforeRender(P, ct, me, Oe, qe, on), Te.modelViewMatrix.multiplyMatrices(me.matrixWorldInverse, Te.matrixWorld), Te.normalMatrix.getNormalMatrix(Te.modelViewMatrix), qe.onBeforeRender(P, ct, me, Oe, Te, on), qe.transparent === !0 && qe.side === Pp ? (qe.side = uf, qe.needsUpdate = !0, P.renderBufferDirect(me, ct, Oe, qe, Te, on), qe.side = py, qe.needsUpdate = !0, P.renderBufferDirect(me, ct, Oe, qe, Te, on), qe.side = Pp) : P.renderBufferDirect(me, ct, Oe, qe, Te, on), Te.onAfterRender(P, ct, me, Oe, qe, on);
  }
  function ki(Te, ct, me) {
    ct.isScene !== !0 && (ct = Je);
    const Oe = He.get(Te), qe = T.state.lights, on = T.state.shadowsArray, yn = qe.state.version, Rn = Vt.getParameters(Te, qe.state, on, ct, me), mn = Vt.getProgramCacheKey(Rn);
    let vn = Oe.programs;
    Oe.environment = Te.isMeshStandardMaterial ? ct.environment : null, Oe.fog = ct.fog, Oe.envMap = (Te.isMeshStandardMaterial ? vt : mt).get(Te.envMap || Oe.environment), vn === void 0 && (Te.addEventListener("dispose", De), vn = /* @__PURE__ */ new Map(), Oe.programs = vn);
    let Zn = vn.get(mn);
    if (Zn !== void 0) {
      if (Oe.currentProgram === Zn && Oe.lightsStateVersion === yn)
        return Wi(Te, Rn), Zn;
    } else
      Rn.uniforms = Vt.getUniforms(Te), Te.onBuild(me, Rn, P), Te.onBeforeCompile(Rn, P), Zn = Vt.acquireProgram(Rn, mn), vn.set(mn, Zn), Oe.uniforms = Rn.uniforms;
    const nr = Oe.uniforms;
    (!Te.isShaderMaterial && !Te.isRawShaderMaterial || Te.clipping === !0) && (nr.clippingPlanes = oe.uniform), Wi(Te, Rn), Oe.needsLights = Si(Te), Oe.lightsStateVersion = yn, Oe.needsLights && (nr.ambientLightColor.value = qe.state.ambient, nr.lightProbe.value = qe.state.probe, nr.directionalLights.value = qe.state.directional, nr.directionalLightShadows.value = qe.state.directionalShadow, nr.spotLights.value = qe.state.spot, nr.spotLightShadows.value = qe.state.spotShadow, nr.rectAreaLights.value = qe.state.rectArea, nr.ltc_1.value = qe.state.rectAreaLTC1, nr.ltc_2.value = qe.state.rectAreaLTC2, nr.pointLights.value = qe.state.point, nr.pointLightShadows.value = qe.state.pointShadow, nr.hemisphereLights.value = qe.state.hemi, nr.directionalShadowMap.value = qe.state.directionalShadowMap, nr.directionalShadowMatrix.value = qe.state.directionalShadowMatrix, nr.spotShadowMap.value = qe.state.spotShadowMap, nr.spotShadowMatrix.value = qe.state.spotShadowMatrix, nr.pointShadowMap.value = qe.state.pointShadowMap, nr.pointShadowMatrix.value = qe.state.pointShadowMatrix);
    const br = Zn.getUniforms(), Yi = vC.seqWithValue(br.seq, nr);
    return Oe.currentProgram = Zn, Oe.uniformsList = Yi, Zn;
  }
  function Wi(Te, ct) {
    const me = He.get(Te);
    me.outputEncoding = ct.outputEncoding, me.instancing = ct.instancing, me.skinning = ct.skinning, me.morphTargets = ct.morphTargets, me.morphNormals = ct.morphNormals, me.morphColors = ct.morphColors, me.morphTargetsCount = ct.morphTargetsCount, me.numClippingPlanes = ct.numClippingPlanes, me.numIntersection = ct.numClipIntersection, me.vertexAlphas = ct.vertexAlphas, me.vertexTangents = ct.vertexTangents, me.toneMapping = ct.toneMapping;
  }
  function ni(Te, ct, me, Oe, qe) {
    ct.isScene !== !0 && (ct = Je), et.resetTextureUnits();
    const on = ct.fog, yn = Oe.isMeshStandardMaterial ? ct.environment : null, Rn = V === null ? P.outputEncoding : V.isXRRenderTarget === !0 ? V.texture.encoding : yv, mn = (Oe.isMeshStandardMaterial ? vt : mt).get(Oe.envMap || yn), vn = Oe.vertexColors === !0 && !!me.attributes.color && me.attributes.color.itemSize === 4, Zn = !!Oe.normalMap && !!me.attributes.tangent, nr = !!me.morphAttributes.position, br = !!me.morphAttributes.normal, Yi = !!me.morphAttributes.color, La = Oe.toneMapped ? P.toneMapping : rg, Ys = me.morphAttributes.position || me.morphAttributes.normal || me.morphAttributes.color, $t = Ys !== void 0 ? Ys.length : 0, Zr = He.get(Oe), ls = T.state.lights;
    if (he === !0 && (fe === !0 || Te !== X)) {
      const _i = Te === X && Oe.id === I;
      oe.setState(Oe, Te, _i);
    }
    let Xn = !1;
    Oe.version === Zr.__version ? (Zr.needsLights && Zr.lightsStateVersion !== ls.state.version || Zr.outputEncoding !== Rn || qe.isInstancedMesh && Zr.instancing === !1 || !qe.isInstancedMesh && Zr.instancing === !0 || qe.isSkinnedMesh && Zr.skinning === !1 || !qe.isSkinnedMesh && Zr.skinning === !0 || Zr.envMap !== mn || Oe.fog === !0 && Zr.fog !== on || Zr.numClippingPlanes !== void 0 && (Zr.numClippingPlanes !== oe.numPlanes || Zr.numIntersection !== oe.numIntersection) || Zr.vertexAlphas !== vn || Zr.vertexTangents !== Zn || Zr.morphTargets !== nr || Zr.morphNormals !== br || Zr.morphColors !== Yi || Zr.toneMapping !== La || _t.isWebGL2 === !0 && Zr.morphTargetsCount !== $t) && (Xn = !0) : (Xn = !0, Zr.__version = Oe.version);
    let qa = Zr.currentProgram;
    Xn === !0 && (qa = ki(Oe, ct, qe));
    let mo = !1, Ds = !1, us = !1;
    const mr = qa.getUniforms(), pi = Zr.uniforms;
    if (Rt.useProgram(qa.program) && (mo = !0, Ds = !0, us = !0), Oe.id !== I && (I = Oe.id, Ds = !0), mo || X !== Te) {
      if (mr.setValue(Ue, "projectionMatrix", Te.projectionMatrix), _t.logarithmicDepthBuffer && mr.setValue(
        Ue,
        "logDepthBufFC",
        2 / (Math.log(Te.far + 1) / Math.LN2)
      ), X !== Te && (X = Te, Ds = !0, us = !0), Oe.isShaderMaterial || Oe.isMeshPhongMaterial || Oe.isMeshToonMaterial || Oe.isMeshStandardMaterial || Oe.envMap) {
        const _i = mr.map.cameraPosition;
        _i !== void 0 && _i.setValue(
          Ue,
          Xe.setFromMatrixPosition(Te.matrixWorld)
        );
      }
      (Oe.isMeshPhongMaterial || Oe.isMeshToonMaterial || Oe.isMeshLambertMaterial || Oe.isMeshBasicMaterial || Oe.isMeshStandardMaterial || Oe.isShaderMaterial) && mr.setValue(Ue, "isOrthographic", Te.isOrthographicCamera === !0), (Oe.isMeshPhongMaterial || Oe.isMeshToonMaterial || Oe.isMeshLambertMaterial || Oe.isMeshBasicMaterial || Oe.isMeshStandardMaterial || Oe.isShaderMaterial || Oe.isShadowMaterial || qe.isSkinnedMesh) && mr.setValue(Ue, "viewMatrix", Te.matrixWorldInverse);
    }
    if (qe.isSkinnedMesh) {
      mr.setOptional(Ue, qe, "bindMatrix"), mr.setOptional(Ue, qe, "bindMatrixInverse");
      const _i = qe.skeleton;
      _i && (_t.floatVertexTextures ? (_i.boneTexture === null && _i.computeBoneTexture(), mr.setValue(Ue, "boneTexture", _i.boneTexture, et), mr.setValue(Ue, "boneTextureSize", _i.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const Ea = me.morphAttributes;
    if ((Ea.position !== void 0 || Ea.normal !== void 0 || Ea.color !== void 0 && _t.isWebGL2 === !0) && zt.update(qe, me, Oe, qa), (Ds || Zr.receiveShadow !== qe.receiveShadow) && (Zr.receiveShadow = qe.receiveShadow, mr.setValue(Ue, "receiveShadow", qe.receiveShadow)), Ds && (mr.setValue(Ue, "toneMappingExposure", P.toneMappingExposure), Zr.needsLights && ji(pi, us), on && Oe.fog === !0 && Jt.refreshFogUniforms(pi, on), Jt.refreshMaterialUniforms(pi, Oe, pe, ie, ue), vC.upload(Ue, Zr.uniformsList, pi, et)), Oe.isShaderMaterial && Oe.uniformsNeedUpdate === !0 && (vC.upload(Ue, Zr.uniformsList, pi, et), Oe.uniformsNeedUpdate = !1), Oe.isSpriteMaterial && mr.setValue(Ue, "center", qe.center), mr.setValue(Ue, "modelViewMatrix", qe.modelViewMatrix), mr.setValue(Ue, "normalMatrix", qe.normalMatrix), mr.setValue(Ue, "modelMatrix", qe.matrixWorld), Oe.isShaderMaterial || Oe.isRawShaderMaterial) {
      const _i = Oe.uniformsGroups;
      for (let Ti = 0, Oo = _i.length; Ti < Oo; Ti++)
        if (_t.isWebGL2) {
          const Uo = _i[Ti];
          ze.update(Uo, qa), ze.bind(Uo, qa);
        } else
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return qa;
  }
  function ji(Te, ct) {
    Te.ambientLightColor.needsUpdate = ct, Te.lightProbe.needsUpdate = ct, Te.directionalLights.needsUpdate = ct, Te.directionalLightShadows.needsUpdate = ct, Te.pointLights.needsUpdate = ct, Te.pointLightShadows.needsUpdate = ct, Te.spotLights.needsUpdate = ct, Te.spotLightShadows.needsUpdate = ct, Te.rectAreaLights.needsUpdate = ct, Te.hemisphereLights.needsUpdate = ct;
  }
  function Si(Te) {
    return Te.isMeshLambertMaterial || Te.isMeshToonMaterial || Te.isMeshPhongMaterial || Te.isMeshStandardMaterial || Te.isShadowMaterial || Te.isShaderMaterial && Te.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return B;
  }, this.getActiveMipmapLevel = function() {
    return k;
  }, this.getRenderTarget = function() {
    return V;
  }, this.setRenderTargetTextures = function(Te, ct, me) {
    He.get(Te.texture).__webglTexture = ct, He.get(Te.depthTexture).__webglTexture = me;
    const Oe = He.get(Te);
    Oe.__hasExternalTextures = !0, Oe.__hasExternalTextures && (Oe.__autoAllocateDepthBuffer = me === void 0, Oe.__autoAllocateDepthBuffer || rt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Oe.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(Te, ct) {
    const me = He.get(Te);
    me.__webglFramebuffer = ct, me.__useDefaultFramebuffer = ct === void 0;
  }, this.setRenderTarget = function(Te, ct = 0, me = 0) {
    V = Te, B = ct, k = me;
    let Oe = !0;
    if (Te) {
      const mn = He.get(Te);
      mn.__useDefaultFramebuffer !== void 0 ? (Rt.bindFramebuffer(36160, null), Oe = !1) : mn.__webglFramebuffer === void 0 ? et.setupRenderTarget(Te) : mn.__hasExternalTextures && et.rebindTextures(Te, He.get(Te.texture).__webglTexture, He.get(Te.depthTexture).__webglTexture);
    }
    let qe = null, on = !1, yn = !1;
    if (Te) {
      const mn = Te.texture;
      (mn.isData3DTexture || mn.isDataArrayTexture) && (yn = !0);
      const vn = He.get(Te).__webglFramebuffer;
      Te.isWebGLCubeRenderTarget ? (qe = vn[ct], on = !0) : _t.isWebGL2 && Te.samples > 0 && et.useMultisampledRTT(Te) === !1 ? qe = He.get(Te).__webglMultisampledFramebuffer : qe = vn, J.copy(Te.viewport), $.copy(Te.scissor), W = Te.scissorTest;
    } else
      J.copy(de).multiplyScalar(pe).floor(), $.copy(Fe).multiplyScalar(pe).floor(), W = Ce;
    if (Rt.bindFramebuffer(36160, qe) && _t.drawBuffers && Oe && Rt.drawBuffers(Te, qe), Rt.viewport(J), Rt.scissor($), Rt.setScissorTest(W), on) {
      const mn = He.get(Te.texture);
      Ue.framebufferTexture2D(36160, 36064, 34069 + ct, mn.__webglTexture, me);
    } else if (yn) {
      const mn = He.get(Te.texture), vn = ct || 0;
      Ue.framebufferTextureLayer(36160, 36064, mn.__webglTexture, me || 0, vn);
    }
    I = -1;
  }, this.readRenderTargetPixels = function(Te, ct, me, Oe, qe, on, yn) {
    if (!(Te && Te.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Rn = He.get(Te).__webglFramebuffer;
    if (Te.isWebGLCubeRenderTarget && yn !== void 0 && (Rn = Rn[yn]), Rn) {
      Rt.bindFramebuffer(36160, Rn);
      try {
        const mn = Te.texture, vn = mn.format, Zn = mn.type;
        if (vn !== Sm && tt.convert(vn) !== Ue.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const nr = Zn === GS && (rt.has("EXT_color_buffer_half_float") || _t.isWebGL2 && rt.has("EXT_color_buffer_float"));
        if (Zn !== Gf && tt.convert(Zn) !== Ue.getParameter(35738) && !(Zn === uy && (_t.isWebGL2 || rt.has("OES_texture_float") || rt.has("WEBGL_color_buffer_float"))) && !nr) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        ct >= 0 && ct <= Te.width - Oe && me >= 0 && me <= Te.height - qe && Ue.readPixels(ct, me, Oe, qe, tt.convert(vn), tt.convert(Zn), on);
      } finally {
        const mn = V !== null ? He.get(V).__webglFramebuffer : null;
        Rt.bindFramebuffer(36160, mn);
      }
    }
  }, this.copyFramebufferToTexture = function(Te, ct, me = 0) {
    const Oe = Math.pow(2, -me), qe = Math.floor(ct.image.width * Oe), on = Math.floor(ct.image.height * Oe);
    et.setTexture2D(ct, 0), Ue.copyTexSubImage2D(3553, me, 0, 0, Te.x, Te.y, qe, on), Rt.unbindTexture();
  }, this.copyTextureToTexture = function(Te, ct, me, Oe = 0) {
    const qe = ct.image.width, on = ct.image.height, yn = tt.convert(me.format), Rn = tt.convert(me.type);
    et.setTexture2D(me, 0), Ue.pixelStorei(37440, me.flipY), Ue.pixelStorei(37441, me.premultiplyAlpha), Ue.pixelStorei(3317, me.unpackAlignment), ct.isDataTexture ? Ue.texSubImage2D(3553, Oe, Te.x, Te.y, qe, on, yn, Rn, ct.image.data) : ct.isCompressedTexture ? Ue.compressedTexSubImage2D(3553, Oe, Te.x, Te.y, ct.mipmaps[0].width, ct.mipmaps[0].height, yn, ct.mipmaps[0].data) : Ue.texSubImage2D(3553, Oe, Te.x, Te.y, yn, Rn, ct.image), Oe === 0 && me.generateMipmaps && Ue.generateMipmap(3553), Rt.unbindTexture();
  }, this.copyTextureToTexture3D = function(Te, ct, me, Oe, qe = 0) {
    if (P.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const on = Te.max.x - Te.min.x + 1, yn = Te.max.y - Te.min.y + 1, Rn = Te.max.z - Te.min.z + 1, mn = tt.convert(Oe.format), vn = tt.convert(Oe.type);
    let Zn;
    if (Oe.isData3DTexture)
      et.setTexture3D(Oe, 0), Zn = 32879;
    else if (Oe.isDataArrayTexture)
      et.setTexture2DArray(Oe, 0), Zn = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    Ue.pixelStorei(37440, Oe.flipY), Ue.pixelStorei(37441, Oe.premultiplyAlpha), Ue.pixelStorei(3317, Oe.unpackAlignment);
    const nr = Ue.getParameter(3314), br = Ue.getParameter(32878), Yi = Ue.getParameter(3316), La = Ue.getParameter(3315), Ys = Ue.getParameter(32877), $t = me.isCompressedTexture ? me.mipmaps[0] : me.image;
    Ue.pixelStorei(3314, $t.width), Ue.pixelStorei(32878, $t.height), Ue.pixelStorei(3316, Te.min.x), Ue.pixelStorei(3315, Te.min.y), Ue.pixelStorei(32877, Te.min.z), me.isDataTexture || me.isData3DTexture ? Ue.texSubImage3D(Zn, qe, ct.x, ct.y, ct.z, on, yn, Rn, mn, vn, $t.data) : me.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Ue.compressedTexSubImage3D(Zn, qe, ct.x, ct.y, ct.z, on, yn, Rn, mn, $t.data)) : Ue.texSubImage3D(Zn, qe, ct.x, ct.y, ct.z, on, yn, Rn, mn, vn, $t), Ue.pixelStorei(3314, nr), Ue.pixelStorei(32878, br), Ue.pixelStorei(3316, Yi), Ue.pixelStorei(3315, La), Ue.pixelStorei(32877, Ys), qe === 0 && Oe.generateMipmaps && Ue.generateMipmap(Zn), Rt.unbindTexture();
  }, this.initTexture = function(Te) {
    Te.isCubeTexture ? et.setTextureCube(Te, 0) : Te.isData3DTexture ? et.setTexture3D(Te, 0) : Te.isDataArrayTexture ? et.setTexture2DArray(Te, 0) : et.setTexture2D(Te, 0), Rt.unbindTexture();
  }, this.resetState = function() {
    B = 0, k = 0, V = null, Rt.reset(), rn.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class AF extends $3 {
}
AF.prototype.isWebGL1Renderer = !0;
class VC {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Pn(e), this.density = t;
  }
  clone() {
    return new VC(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class GC {
  constructor(e, t = 1, r = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Pn(e), this.near = t, this.far = r;
  }
  clone() {
    return new GC(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class zM extends Xa {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
}
class WC {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = PM, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = bm();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = bm()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = bm()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Vh = /* @__PURE__ */ new ge();
class _m {
  constructor(e, t, r, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = i === !0;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      Vh.fromBufferAttribute(this, t), Vh.applyMatrix4(e), this.setXYZ(t, Vh.x, Vh.y, Vh.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Vh.fromBufferAttribute(this, t), Vh.applyNormalMatrix(e), this.setXYZ(t, Vh.x, Vh.y, Vh.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Vh.fromBufferAttribute(this, t), Vh.transformDirection(e), this.setXYZ(t, Vh.x, Vh.y, Vh.z);
    return this;
  }
  setX(e, t) {
    return this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset];
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  }
  setXY(e, t, r) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, o) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = o, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return new os(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new _m(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class eL extends ff {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Pn(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Db;
const $E = /* @__PURE__ */ new ge(), Lb = /* @__PURE__ */ new ge(), Pb = /* @__PURE__ */ new ge(), Ob = /* @__PURE__ */ new Ft(), eM = /* @__PURE__ */ new Ft(), DF = /* @__PURE__ */ new si(), C2 = /* @__PURE__ */ new ge(), tM = /* @__PURE__ */ new ge(), R2 = /* @__PURE__ */ new ge(), lU = /* @__PURE__ */ new Ft(), QA = /* @__PURE__ */ new Ft(), uU = /* @__PURE__ */ new Ft();
class LF extends Xa {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Db === void 0) {
      Db = new ui();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), r = new WC(t, 5);
      Db.setIndex([0, 1, 2, 0, 2, 3]), Db.setAttribute("position", new _m(r, 3, 0, !1)), Db.setAttribute("uv", new _m(r, 2, 3, !1));
    }
    this.geometry = Db, this.material = e !== void 0 ? e : new eL(), this.center = new Ft(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Lb.setFromMatrixScale(this.matrixWorld), DF.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Pb.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Lb.multiplyScalar(-Pb.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && (o = Math.cos(r), i = Math.sin(r));
    const l = this.center;
    A2(C2.set(-0.5, -0.5, 0), Pb, l, Lb, i, o), A2(tM.set(0.5, -0.5, 0), Pb, l, Lb, i, o), A2(R2.set(0.5, 0.5, 0), Pb, l, Lb, i, o), lU.set(0, 0), QA.set(1, 0), uU.set(1, 1);
    let d = e.ray.intersectTriangle(C2, tM, R2, !1, $E);
    if (d === null && (A2(tM.set(-0.5, 0.5, 0), Pb, l, Lb, i, o), QA.set(0, 1), d = e.ray.intersectTriangle(C2, R2, tM, !1, $E), d === null))
      return;
    const h = e.ray.origin.distanceTo($E);
    h < e.near || h > e.far || t.push({
      distance: h,
      point: $E.clone(),
      uv: xm.getUV($E, C2, tM, R2, lU, QA, uU, new Ft()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function A2(a, e, t, r, i, o) {
  Ob.subVectors(a, t).addScalar(0.5).multiply(r), i !== void 0 ? (eM.x = o * Ob.x - i * Ob.y, eM.y = i * Ob.x + o * Ob.y) : eM.copy(Ob), a.copy(e), a.x += eM.x, a.y += eM.y, a.applyMatrix4(DF);
}
const D2 = /* @__PURE__ */ new ge(), cU = /* @__PURE__ */ new ge();
class PF extends Xa {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      this.addLevel(o.object.clone(), o.distance);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let i;
    for (i = 0; i < r.length && !(t < r[i].distance); i++)
      ;
    return r.splice(i, 0, { distance: t, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i && !(e < t[r].distance); r++)
        ;
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      D2.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(D2);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      D2.setFromMatrixPosition(e.matrixWorld), cU.setFromMatrixPosition(this.matrixWorld);
      const r = D2.distanceTo(cU) / e.zoom;
      t[0].object.visible = !0;
      let i, o;
      for (i = 1, o = t.length; i < o && r >= t[i].distance; i++)
        t[i - 1].object.visible = !1, t[i].object.visible = !0;
      for (this._currentLevel = i - 1; i < o; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const l = r[i];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance
      });
    }
    return t;
  }
}
const fU = /* @__PURE__ */ new ge(), dU = /* @__PURE__ */ new la(), hU = /* @__PURE__ */ new la(), dW = /* @__PURE__ */ new ge(), pU = /* @__PURE__ */ new si();
class OF extends zn {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new si(), this.bindMatrixInverse = new si();
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new la(), t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const r = this.skeleton, i = this.geometry;
    dU.fromBufferAttribute(i.attributes.skinIndex, e), hU.fromBufferAttribute(i.attributes.skinWeight, e), fU.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const l = hU.getComponent(o);
      if (l !== 0) {
        const d = dU.getComponent(o);
        pU.multiplyMatrices(r.bones[d].matrixWorld, r.boneInverses[d]), t.addScaledVector(dW.copy(fU).applyMatrix4(pU), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class tL extends Xa {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class jb extends iu {
  constructor(e = null, t = 1, r = 1, i, o, l, d, h, m = co, S = co, _, T) {
    super(null, l, d, h, m, S, i, o, _, T), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const mU = /* @__PURE__ */ new si(), hW = /* @__PURE__ */ new si();
class jC {
  constructor(e = [], t = []) {
    this.uuid = bm(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new si());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new si();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture;
    for (let o = 0, l = e.length; o < l; o++) {
      const d = e[o] ? e[o].matrixWorld : hW;
      mU.multiplyMatrices(d, t[o]), mU.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new jC(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = mF(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new jb(t, e, e, Sm, uy);
    return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let l = t[o];
      l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), l = new tL()), this.bones.push(l), this.boneInverses.push(new si().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, r = this.boneInverses;
    for (let i = 0, o = t.length; i < o; i++) {
      const l = t[i];
      e.bones.push(l.uuid);
      const d = r[i];
      e.boneInverses.push(d.toArray());
    }
    return e;
  }
}
class WS extends os {
  constructor(e, t, r, i = 1) {
    typeof r == "number" && (i = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const vU = /* @__PURE__ */ new si(), gU = /* @__PURE__ */ new si(), L2 = [], nM = /* @__PURE__ */ new zn();
class UF extends zn {
  constructor(e, t, r) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new WS(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1;
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const r = this.matrixWorld, i = this.count;
    if (nM.geometry = this.geometry, nM.material = this.material, nM.material !== void 0)
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, vU), gU.multiplyMatrices(r, vU), nM.matrixWorld = gU, nM.raycast(e, L2);
        for (let l = 0, d = L2.length; l < d; l++) {
          const h = L2[l];
          h.instanceId = o, h.object = this, t.push(h);
        }
        L2.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new WS(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ph extends ff {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Pn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const yU = /* @__PURE__ */ new ge(), xU = /* @__PURE__ */ new ge(), SU = /* @__PURE__ */ new si(), ZA = /* @__PURE__ */ new KM(), P2 = /* @__PURE__ */ new vy();
class ch extends Xa {
  constructor(e = new ui(), t = new ph()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [0];
      for (let i = 1, o = t.count; i < o; i++)
        yU.fromBufferAttribute(t, i - 1), xU.fromBufferAttribute(t, i), r[i] = r[i - 1], r[i] += yU.distanceTo(xU);
      e.setAttribute("lineDistance", new sr(r, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, o = e.params.Line.threshold, l = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), P2.copy(r.boundingSphere), P2.applyMatrix4(i), P2.radius += o, e.ray.intersectsSphere(P2) === !1)
      return;
    SU.copy(i).invert(), ZA.copy(e.ray).applyMatrix4(SU);
    const d = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = d * d, m = new ge(), S = new ge(), _ = new ge(), T = new ge(), C = this.isLineSegments ? 2 : 1, D = r.index, U = r.attributes.position;
    if (D !== null) {
      const B = Math.max(0, l.start), k = Math.min(D.count, l.start + l.count);
      for (let V = B, I = k - 1; V < I; V += C) {
        const X = D.getX(V), J = D.getX(V + 1);
        if (m.fromBufferAttribute(U, X), S.fromBufferAttribute(U, J), ZA.distanceSqToSegment(m, S, T, _) > h)
          continue;
        T.applyMatrix4(this.matrixWorld);
        const W = e.ray.origin.distanceTo(T);
        W < e.near || W > e.far || t.push({
          distance: W,
          point: _.clone().applyMatrix4(this.matrixWorld),
          index: V,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const B = Math.max(0, l.start), k = Math.min(U.count, l.start + l.count);
      for (let V = B, I = k - 1; V < I; V += C) {
        if (m.fromBufferAttribute(U, V), S.fromBufferAttribute(U, V + 1), ZA.distanceSqToSegment(m, S, T, _) > h)
          continue;
        T.applyMatrix4(this.matrixWorld);
        const J = e.ray.origin.distanceTo(T);
        J < e.near || J > e.far || t.push({
          distance: J,
          point: _.clone().applyMatrix4(this.matrixWorld),
          index: V,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const d = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = o;
        }
      }
    }
  }
}
const _U = /* @__PURE__ */ new ge(), bU = /* @__PURE__ */ new ge();
class gy extends ch {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [];
      for (let i = 0, o = t.count; i < o; i += 2)
        _U.fromBufferAttribute(t, i), bU.fromBufferAttribute(t, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + _U.distanceTo(bU);
      e.setAttribute("lineDistance", new sr(r, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class zF extends ch {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class nL extends ff {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Pn(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const wU = /* @__PURE__ */ new si(), v3 = /* @__PURE__ */ new KM(), O2 = /* @__PURE__ */ new vy(), U2 = /* @__PURE__ */ new ge();
class NF extends Xa {
  constructor(e = new ui(), t = new nL()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, o = e.params.Points.threshold, l = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), O2.copy(r.boundingSphere), O2.applyMatrix4(i), O2.radius += o, e.ray.intersectsSphere(O2) === !1)
      return;
    wU.copy(i).invert(), v3.copy(e.ray).applyMatrix4(wU);
    const d = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = d * d, m = r.index, _ = r.attributes.position;
    if (m !== null) {
      const T = Math.max(0, l.start), C = Math.min(m.count, l.start + l.count);
      for (let D = T, P = C; D < P; D++) {
        const U = m.getX(D);
        U2.fromBufferAttribute(_, U), EU(U2, U, h, i, e, t, this);
      }
    } else {
      const T = Math.max(0, l.start), C = Math.min(_.count, l.start + l.count);
      for (let D = T, P = C; D < P; D++)
        U2.fromBufferAttribute(_, D), EU(U2, D, h, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const d = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = o;
        }
      }
    }
  }
}
function EU(a, e, t, r, i, o, l) {
  const d = v3.distanceSqToPoint(a);
  if (d < t) {
    const h = new ge();
    v3.closestPointToPoint(a, h), h.applyMatrix4(r);
    const m = i.ray.origin.distanceTo(h);
    if (m < i.near || m > i.far)
      return;
    o.push({
      distance: m,
      distanceToRay: Math.sqrt(d),
      point: h,
      index: e,
      face: null,
      object: l
    });
  }
}
class pW extends iu {
  constructor(e, t, r, i, o, l, d, h, m) {
    super(e, t, r, i, o, l, d, h, m), this.isVideoTexture = !0, this.minFilter = l !== void 0 ? l : Po, this.magFilter = o !== void 0 ? o : Po, this.generateMipmaps = !1;
    const S = this;
    function _() {
      S.needsUpdate = !0, e.requestVideoFrameCallback(_);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(_);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class mW extends iu {
  constructor(e, t, r) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = r, this.magFilter = co, this.minFilter = co, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class FF extends iu {
  constructor(e, t, r, i, o, l, d, h, m, S, _, T) {
    super(null, l, d, h, m, S, i, o, _, T), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class vW extends iu {
  constructor(e, t, r, i, o, l, d, h, m) {
    super(e, t, r, i, o, l, d, h, m), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class lg {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, i = this.getPoint(0), o = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      r = this.getPoint(l / e), o += r.distanceTo(i), t.push(o), i = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let l;
    t ? l = t : l = e * r[o - 1];
    let d = 0, h = o - 1, m;
    for (; d <= h; )
      if (i = Math.floor(d + (h - d) / 2), m = r[i] - l, m < 0)
        d = i + 1;
      else if (m > 0)
        h = i - 1;
      else {
        h = i;
        break;
      }
    if (i = h, r[i] === l)
      return i / (o - 1);
    const S = r[i], T = r[i + 1] - S, C = (l - S) / T;
    return (i + C) / (o - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4, o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const l = this.getPoint(i), d = this.getPoint(o), h = t || (l.isVector2 ? new Ft() : new ge());
    return h.copy(d).sub(l).normalize(), h;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new ge(), i = [], o = [], l = [], d = new ge(), h = new si();
    for (let C = 0; C <= e; C++) {
      const D = C / e;
      i[C] = this.getTangentAt(D, new ge());
    }
    o[0] = new ge(), l[0] = new ge();
    let m = Number.MAX_VALUE;
    const S = Math.abs(i[0].x), _ = Math.abs(i[0].y), T = Math.abs(i[0].z);
    S <= m && (m = S, r.set(1, 0, 0)), _ <= m && (m = _, r.set(0, 1, 0)), T <= m && r.set(0, 0, 1), d.crossVectors(i[0], r).normalize(), o[0].crossVectors(i[0], d), l[0].crossVectors(i[0], o[0]);
    for (let C = 1; C <= e; C++) {
      if (o[C] = o[C - 1].clone(), l[C] = l[C - 1].clone(), d.crossVectors(i[C - 1], i[C]), d.length() > Number.EPSILON) {
        d.normalize();
        const D = Math.acos(Qu(i[C - 1].dot(i[C]), -1, 1));
        o[C].applyMatrix4(h.makeRotationAxis(d, D));
      }
      l[C].crossVectors(i[C], o[C]);
    }
    if (t === !0) {
      let C = Math.acos(Qu(o[0].dot(o[e]), -1, 1));
      C /= e, i[0].dot(d.crossVectors(o[0], o[e])) > 0 && (C = -C);
      for (let D = 1; D <= e; D++)
        o[D].applyMatrix4(h.makeRotationAxis(i[D], C * D)), l[D].crossVectors(i[D], o[D]);
    }
    return {
      tangents: i,
      normals: o,
      binormals: l
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class YC extends lg {
  constructor(e = 0, t = 0, r = 1, i = 1, o = 0, l = Math.PI * 2, d = !1, h = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = i, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = d, this.aRotation = h;
  }
  getPoint(e, t) {
    const r = t || new Ft(), i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(o) < Number.EPSILON;
    for (; o < 0; )
      o += i;
    for (; o > i; )
      o -= i;
    o < Number.EPSILON && (l ? o = 0 : o = i), this.aClockwise === !0 && !l && (o === i ? o = -i : o = o - i);
    const d = this.aStartAngle + e * o;
    let h = this.aX + this.xRadius * Math.cos(d), m = this.aY + this.yRadius * Math.sin(d);
    if (this.aRotation !== 0) {
      const S = Math.cos(this.aRotation), _ = Math.sin(this.aRotation), T = h - this.aX, C = m - this.aY;
      h = T * S - C * _ + this.aX, m = T * _ + C * S + this.aY;
    }
    return r.set(h, m);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class kF extends YC {
  constructor(e, t, r, i, o, l) {
    super(e, t, r, r, i, o, l), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function rL() {
  let a = 0, e = 0, t = 0, r = 0;
  function i(o, l, d, h) {
    a = o, e = d, t = -3 * o + 3 * l - 2 * d - h, r = 2 * o - 2 * l + d + h;
  }
  return {
    initCatmullRom: function(o, l, d, h, m) {
      i(l, d, m * (d - o), m * (h - l));
    },
    initNonuniformCatmullRom: function(o, l, d, h, m, S, _) {
      let T = (l - o) / m - (d - o) / (m + S) + (d - l) / S, C = (d - l) / S - (h - l) / (S + _) + (h - d) / _;
      T *= S, C *= S, i(l, d, T, C);
    },
    calc: function(o) {
      const l = o * o, d = l * o;
      return a + e * o + t * l + r * d;
    }
  };
}
const z2 = /* @__PURE__ */ new ge(), JA = /* @__PURE__ */ new rL(), KA = /* @__PURE__ */ new rL(), $A = /* @__PURE__ */ new rL();
class IF extends lg {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = i;
  }
  getPoint(e, t = new ge()) {
    const r = t, i = this.points, o = i.length, l = (o - (this.closed ? 0 : 1)) * e;
    let d = Math.floor(l), h = l - d;
    this.closed ? d += d > 0 ? 0 : (Math.floor(Math.abs(d) / o) + 1) * o : h === 0 && d === o - 1 && (d = o - 2, h = 1);
    let m, S;
    this.closed || d > 0 ? m = i[(d - 1) % o] : (z2.subVectors(i[0], i[1]).add(i[0]), m = z2);
    const _ = i[d % o], T = i[(d + 1) % o];
    if (this.closed || d + 2 < o ? S = i[(d + 2) % o] : (z2.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), S = z2), this.curveType === "centripetal" || this.curveType === "chordal") {
      const C = this.curveType === "chordal" ? 0.5 : 0.25;
      let D = Math.pow(m.distanceToSquared(_), C), P = Math.pow(_.distanceToSquared(T), C), U = Math.pow(T.distanceToSquared(S), C);
      P < 1e-4 && (P = 1), D < 1e-4 && (D = P), U < 1e-4 && (U = P), JA.initNonuniformCatmullRom(m.x, _.x, T.x, S.x, D, P, U), KA.initNonuniformCatmullRom(m.y, _.y, T.y, S.y, D, P, U), $A.initNonuniformCatmullRom(m.z, _.z, T.z, S.z, D, P, U);
    } else
      this.curveType === "catmullrom" && (JA.initCatmullRom(m.x, _.x, T.x, S.x, this.tension), KA.initCatmullRom(m.y, _.y, T.y, S.y, this.tension), $A.initCatmullRom(m.z, _.z, T.z, S.z, this.tension));
    return r.set(
      JA.calc(h),
      KA.calc(h),
      $A.calc(h)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new ge().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function MU(a, e, t, r, i) {
  const o = (r - e) * 0.5, l = (i - t) * 0.5, d = a * a, h = a * d;
  return (2 * t - 2 * r + o + l) * h + (-3 * t + 3 * r - 2 * o - l) * d + o * a + t;
}
function gW(a, e) {
  const t = 1 - a;
  return t * t * e;
}
function yW(a, e) {
  return 2 * (1 - a) * a * e;
}
function xW(a, e) {
  return a * a * e;
}
function xM(a, e, t, r) {
  return gW(a, e) + yW(a, t) + xW(a, r);
}
function SW(a, e) {
  const t = 1 - a;
  return t * t * t * e;
}
function _W(a, e) {
  const t = 1 - a;
  return 3 * t * t * a * e;
}
function bW(a, e) {
  return 3 * (1 - a) * a * a * e;
}
function wW(a, e) {
  return a * a * a * e;
}
function SM(a, e, t, r, i) {
  return SW(a, e) + _W(a, t) + bW(a, r) + wW(a, i);
}
class iL extends lg {
  constructor(e = new Ft(), t = new Ft(), r = new Ft(), i = new Ft()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new Ft()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2, d = this.v3;
    return r.set(
      SM(e, i.x, o.x, l.x, d.x),
      SM(e, i.y, o.y, l.y, d.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class BF extends lg {
  constructor(e = new ge(), t = new ge(), r = new ge(), i = new ge()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new ge()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2, d = this.v3;
    return r.set(
      SM(e, i.x, o.x, l.x, d.x),
      SM(e, i.y, o.y, l.y, d.y),
      SM(e, i.z, o.z, l.z, d.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class XC extends lg {
  constructor(e = new Ft(), t = new Ft()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new Ft()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const r = t || new Ft();
    return r.copy(this.v2).sub(this.v1).normalize(), r;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class HF extends lg {
  constructor(e = new ge(), t = new ge()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new ge()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class aL extends lg {
  constructor(e = new Ft(), t = new Ft(), r = new Ft()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new Ft()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2;
    return r.set(
      xM(e, i.x, o.x, l.x),
      xM(e, i.y, o.y, l.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class sL extends lg {
  constructor(e = new ge(), t = new ge(), r = new ge()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new ge()) {
    const r = t, i = this.v0, o = this.v1, l = this.v2;
    return r.set(
      xM(e, i.x, o.x, l.x),
      xM(e, i.y, o.y, l.y),
      xM(e, i.z, o.z, l.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class oL extends lg {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new Ft()) {
    const r = t, i = this.points, o = (i.length - 1) * e, l = Math.floor(o), d = o - l, h = i[l === 0 ? l : l - 1], m = i[l], S = i[l > i.length - 2 ? i.length - 1 : l + 1], _ = i[l > i.length - 3 ? i.length - 1 : l + 2];
    return r.set(
      MU(d, h.x, m.x, S.x, _.x),
      MU(d, h.y, m.y, S.y, _.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new Ft().fromArray(i));
    }
    return this;
  }
}
var lL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: kF,
  CatmullRomCurve3: IF,
  CubicBezierCurve: iL,
  CubicBezierCurve3: BF,
  EllipseCurve: YC,
  LineCurve: XC,
  LineCurve3: HF,
  QuadraticBezierCurve: aL,
  QuadraticBezierCurve3: sL,
  SplineCurve: oL
});
class VF extends lg {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new XC(t, e));
  }
  getPoint(e, t) {
    const r = e * this.getLength(), i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const l = i[o] - r, d = this.curves[o], h = d.getLength(), m = h === 0 ? 0 : 1 - l / h;
        return d.getPointAt(m, t);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const l = o[i], d = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, h = l.getPoints(d);
      for (let m = 0; m < h.length; m++) {
        const S = h[m];
        r && r.equals(S) || (t.push(S), r = S);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new lL[i.type]().fromJSON(i));
    }
    return this;
  }
}
class NM extends VF {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Ft(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new XC(this.currentPoint.clone(), new Ft(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const o = new aL(
      this.currentPoint.clone(),
      new Ft(e, t),
      new Ft(r, i)
    );
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, l) {
    const d = new iL(
      this.currentPoint.clone(),
      new Ft(e, t),
      new Ft(r, i),
      new Ft(o, l)
    );
    return this.curves.push(d), this.currentPoint.set(o, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new oL(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, o, l) {
    const d = this.currentPoint.x, h = this.currentPoint.y;
    return this.absarc(
      e + d,
      t + h,
      r,
      i,
      o,
      l
    ), this;
  }
  absarc(e, t, r, i, o, l) {
    return this.absellipse(e, t, r, r, i, o, l), this;
  }
  ellipse(e, t, r, i, o, l, d, h) {
    const m = this.currentPoint.x, S = this.currentPoint.y;
    return this.absellipse(e + m, t + S, r, i, o, l, d, h), this;
  }
  absellipse(e, t, r, i, o, l, d, h) {
    const m = new YC(e, t, r, i, o, l, d, h);
    if (this.curves.length > 0) {
      const _ = m.getPoint(0);
      _.equals(this.currentPoint) || this.lineTo(_.x, _.y);
    }
    this.curves.push(m);
    const S = m.getPoint(1);
    return this.currentPoint.copy(S), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class jS extends ui {
  constructor(e = [new Ft(0, -0.5), new Ft(0.5, 0), new Ft(0, 0.5)], t = 12, r = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: i
    }, t = Math.floor(t), i = Qu(i, 0, Math.PI * 2);
    const o = [], l = [], d = [], h = [], m = [], S = 1 / t, _ = new ge(), T = new Ft(), C = new ge(), D = new ge(), P = new ge();
    let U = 0, B = 0;
    for (let k = 0; k <= e.length - 1; k++)
      switch (k) {
        case 0:
          U = e[k + 1].x - e[k].x, B = e[k + 1].y - e[k].y, C.x = B * 1, C.y = -U, C.z = B * 0, P.copy(C), C.normalize(), h.push(C.x, C.y, C.z);
          break;
        case e.length - 1:
          h.push(P.x, P.y, P.z);
          break;
        default:
          U = e[k + 1].x - e[k].x, B = e[k + 1].y - e[k].y, C.x = B * 1, C.y = -U, C.z = B * 0, D.copy(C), C.x += P.x, C.y += P.y, C.z += P.z, C.normalize(), h.push(C.x, C.y, C.z), P.copy(D);
      }
    for (let k = 0; k <= t; k++) {
      const V = r + k * S * i, I = Math.sin(V), X = Math.cos(V);
      for (let J = 0; J <= e.length - 1; J++) {
        _.x = e[J].x * I, _.y = e[J].y, _.z = e[J].x * X, l.push(_.x, _.y, _.z), T.x = k / t, T.y = J / (e.length - 1), d.push(T.x, T.y);
        const $ = h[3 * J + 0] * I, W = h[3 * J + 1], ee = h[3 * J + 0] * X;
        m.push($, W, ee);
      }
    }
    for (let k = 0; k < t; k++)
      for (let V = 0; V < e.length - 1; V++) {
        const I = V + k * e.length, X = I, J = I + e.length, $ = I + e.length + 1, W = I + 1;
        o.push(X, J, W), o.push($, W, J);
      }
    this.setIndex(o), this.setAttribute("position", new sr(l, 3)), this.setAttribute("uv", new sr(d, 2)), this.setAttribute("normal", new sr(m, 3));
  }
  static fromJSON(e) {
    return new jS(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Kb extends jS {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const o = new NM();
    o.absarc(0, -t / 2, e, Math.PI * 1.5, 0), o.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(o.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: r,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new Kb(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class $b extends ui {
  constructor(e = 1, t = 8, r = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: i
    }, t = Math.max(3, t);
    const o = [], l = [], d = [], h = [], m = new ge(), S = new Ft();
    l.push(0, 0, 0), d.push(0, 0, 1), h.push(0.5, 0.5);
    for (let _ = 0, T = 3; _ <= t; _++, T += 3) {
      const C = r + _ / t * i;
      m.x = e * Math.cos(C), m.y = e * Math.sin(C), l.push(m.x, m.y, m.z), d.push(0, 0, 1), S.x = (l[T] / e + 1) / 2, S.y = (l[T + 1] / e + 1) / 2, h.push(S.x, S.y);
    }
    for (let _ = 1; _ <= t; _++)
      o.push(_, _ + 1, 0);
    this.setIndex(o), this.setAttribute("position", new sr(l, 3)), this.setAttribute("normal", new sr(d, 3)), this.setAttribute("uv", new sr(h, 2));
  }
  static fromJSON(e) {
    return new $b(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Jo extends ui {
  constructor(e = 1, t = 1, r = 1, i = 8, o = 1, l = !1, d = 0, h = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: i,
      heightSegments: o,
      openEnded: l,
      thetaStart: d,
      thetaLength: h
    };
    const m = this;
    i = Math.floor(i), o = Math.floor(o);
    const S = [], _ = [], T = [], C = [];
    let D = 0;
    const P = [], U = r / 2;
    let B = 0;
    k(), l === !1 && (e > 0 && V(!0), t > 0 && V(!1)), this.setIndex(S), this.setAttribute("position", new sr(_, 3)), this.setAttribute("normal", new sr(T, 3)), this.setAttribute("uv", new sr(C, 2));
    function k() {
      const I = new ge(), X = new ge();
      let J = 0;
      const $ = (t - e) / r;
      for (let W = 0; W <= o; W++) {
        const ee = [], ie = W / o, pe = ie * (t - e) + e;
        for (let ce = 0; ce <= i; ce++) {
          const Ee = ce / i, de = Ee * h + d, Fe = Math.sin(de), Ce = Math.cos(de);
          X.x = pe * Fe, X.y = -ie * r + U, X.z = pe * Ce, _.push(X.x, X.y, X.z), I.set(Fe, $, Ce).normalize(), T.push(I.x, I.y, I.z), C.push(Ee, 1 - ie), ee.push(D++);
        }
        P.push(ee);
      }
      for (let W = 0; W < i; W++)
        for (let ee = 0; ee < o; ee++) {
          const ie = P[ee][W], pe = P[ee + 1][W], ce = P[ee + 1][W + 1], Ee = P[ee][W + 1];
          S.push(ie, pe, Ee), S.push(pe, ce, Ee), J += 6;
        }
      m.addGroup(B, J, 0), B += J;
    }
    function V(I) {
      const X = D, J = new Ft(), $ = new ge();
      let W = 0;
      const ee = I === !0 ? e : t, ie = I === !0 ? 1 : -1;
      for (let ce = 1; ce <= i; ce++)
        _.push(0, U * ie, 0), T.push(0, ie, 0), C.push(0.5, 0.5), D++;
      const pe = D;
      for (let ce = 0; ce <= i; ce++) {
        const de = ce / i * h + d, Fe = Math.cos(de), Ce = Math.sin(de);
        $.x = ee * Ce, $.y = U * ie, $.z = ee * Fe, _.push($.x, $.y, $.z), T.push(0, ie, 0), J.x = Fe * 0.5 + 0.5, J.y = Ce * 0.5 * ie + 0.5, C.push(J.x, J.y), D++;
      }
      for (let ce = 0; ce < i; ce++) {
        const Ee = X + ce, de = pe + ce;
        I === !0 ? S.push(de, de + 1, Ee) : S.push(de + 1, de, Ee), W += 3;
      }
      m.addGroup(B, W, I === !0 ? 1 : 2), B += W;
    }
  }
  static fromJSON(e) {
    return new Jo(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class ew extends Jo {
  constructor(e = 1, t = 1, r = 8, i = 1, o = !1, l = 0, d = Math.PI * 2) {
    super(0, e, t, r, i, o, l, d), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: i,
      openEnded: o,
      thetaStart: l,
      thetaLength: d
    };
  }
  static fromJSON(e) {
    return new ew(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class my extends ui {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: i
    };
    const o = [], l = [];
    d(i), m(r), S(), this.setAttribute("position", new sr(o, 3)), this.setAttribute("normal", new sr(o.slice(), 3)), this.setAttribute("uv", new sr(l, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function d(k) {
      const V = new ge(), I = new ge(), X = new ge();
      for (let J = 0; J < t.length; J += 3)
        C(t[J + 0], V), C(t[J + 1], I), C(t[J + 2], X), h(V, I, X, k);
    }
    function h(k, V, I, X) {
      const J = X + 1, $ = [];
      for (let W = 0; W <= J; W++) {
        $[W] = [];
        const ee = k.clone().lerp(I, W / J), ie = V.clone().lerp(I, W / J), pe = J - W;
        for (let ce = 0; ce <= pe; ce++)
          ce === 0 && W === J ? $[W][ce] = ee : $[W][ce] = ee.clone().lerp(ie, ce / pe);
      }
      for (let W = 0; W < J; W++)
        for (let ee = 0; ee < 2 * (J - W) - 1; ee++) {
          const ie = Math.floor(ee / 2);
          ee % 2 === 0 ? (T($[W][ie + 1]), T($[W + 1][ie]), T($[W][ie])) : (T($[W][ie + 1]), T($[W + 1][ie + 1]), T($[W + 1][ie]));
        }
    }
    function m(k) {
      const V = new ge();
      for (let I = 0; I < o.length; I += 3)
        V.x = o[I + 0], V.y = o[I + 1], V.z = o[I + 2], V.normalize().multiplyScalar(k), o[I + 0] = V.x, o[I + 1] = V.y, o[I + 2] = V.z;
    }
    function S() {
      const k = new ge();
      for (let V = 0; V < o.length; V += 3) {
        k.x = o[V + 0], k.y = o[V + 1], k.z = o[V + 2];
        const I = U(k) / 2 / Math.PI + 0.5, X = B(k) / Math.PI + 0.5;
        l.push(I, 1 - X);
      }
      D(), _();
    }
    function _() {
      for (let k = 0; k < l.length; k += 6) {
        const V = l[k + 0], I = l[k + 2], X = l[k + 4], J = Math.max(V, I, X), $ = Math.min(V, I, X);
        J > 0.9 && $ < 0.1 && (V < 0.2 && (l[k + 0] += 1), I < 0.2 && (l[k + 2] += 1), X < 0.2 && (l[k + 4] += 1));
      }
    }
    function T(k) {
      o.push(k.x, k.y, k.z);
    }
    function C(k, V) {
      const I = k * 3;
      V.x = e[I + 0], V.y = e[I + 1], V.z = e[I + 2];
    }
    function D() {
      const k = new ge(), V = new ge(), I = new ge(), X = new ge(), J = new Ft(), $ = new Ft(), W = new Ft();
      for (let ee = 0, ie = 0; ee < o.length; ee += 9, ie += 6) {
        k.set(o[ee + 0], o[ee + 1], o[ee + 2]), V.set(o[ee + 3], o[ee + 4], o[ee + 5]), I.set(o[ee + 6], o[ee + 7], o[ee + 8]), J.set(l[ie + 0], l[ie + 1]), $.set(l[ie + 2], l[ie + 3]), W.set(l[ie + 4], l[ie + 5]), X.copy(k).add(V).add(I).divideScalar(3);
        const pe = U(X);
        P(J, ie + 0, k, pe), P($, ie + 2, V, pe), P(W, ie + 4, I, pe);
      }
    }
    function P(k, V, I, X) {
      X < 0 && k.x === 1 && (l[V] = k.x - 1), I.x === 0 && I.z === 0 && (l[V] = X / 2 / Math.PI + 0.5);
    }
    function U(k) {
      return Math.atan2(k.z, -k.x);
    }
    function B(k) {
      return Math.atan2(-k.y, Math.sqrt(k.x * k.x + k.z * k.z));
    }
  }
  static fromJSON(e) {
    return new my(e.vertices, e.indices, e.radius, e.details);
  }
}
class tw extends my {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, o = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      0,
      -r,
      0,
      -i,
      r,
      0,
      -i,
      -r,
      0,
      i,
      r,
      0,
      i
    ], l = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(o, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new tw(e.radius, e.detail);
  }
}
const N2 = /* @__PURE__ */ new ge(), F2 = /* @__PURE__ */ new ge(), eD = /* @__PURE__ */ new ge(), k2 = /* @__PURE__ */ new xm();
class GF extends ui {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), o = Math.cos(NS * t), l = e.getIndex(), d = e.getAttribute("position"), h = l ? l.count : d.count, m = [0, 0, 0], S = ["a", "b", "c"], _ = new Array(3), T = {}, C = [];
      for (let D = 0; D < h; D += 3) {
        l ? (m[0] = l.getX(D), m[1] = l.getX(D + 1), m[2] = l.getX(D + 2)) : (m[0] = D, m[1] = D + 1, m[2] = D + 2);
        const { a: P, b: U, c: B } = k2;
        if (P.fromBufferAttribute(d, m[0]), U.fromBufferAttribute(d, m[1]), B.fromBufferAttribute(d, m[2]), k2.getNormal(eD), _[0] = `${Math.round(P.x * i)},${Math.round(P.y * i)},${Math.round(P.z * i)}`, _[1] = `${Math.round(U.x * i)},${Math.round(U.y * i)},${Math.round(U.z * i)}`, _[2] = `${Math.round(B.x * i)},${Math.round(B.y * i)},${Math.round(B.z * i)}`, !(_[0] === _[1] || _[1] === _[2] || _[2] === _[0]))
          for (let k = 0; k < 3; k++) {
            const V = (k + 1) % 3, I = _[k], X = _[V], J = k2[S[k]], $ = k2[S[V]], W = `${I}_${X}`, ee = `${X}_${I}`;
            ee in T && T[ee] ? (eD.dot(T[ee].normal) <= o && (C.push(J.x, J.y, J.z), C.push($.x, $.y, $.z)), T[ee] = null) : W in T || (T[W] = {
              index0: m[k],
              index1: m[V],
              normal: eD.clone()
            });
          }
      }
      for (const D in T)
        if (T[D]) {
          const { index0: P, index1: U } = T[D];
          N2.fromBufferAttribute(d, P), F2.fromBufferAttribute(d, U), C.push(N2.x, N2.y, N2.z), C.push(F2.x, F2.y, F2.z);
        }
      this.setAttribute("position", new sr(C, 3));
    }
  }
}
class IS extends NM {
  constructor(e) {
    super(e), this.uuid = bm(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new NM().fromJSON(i));
    }
    return this;
  }
}
const EW = {
  triangulate: function(a, e, t = 2) {
    const r = e && e.length, i = r ? e[0] * t : a.length;
    let o = WF(a, 0, i, t, !0);
    const l = [];
    if (!o || o.next === o.prev)
      return l;
    let d, h, m, S, _, T, C;
    if (r && (o = AW(a, e, o, t)), a.length > 80 * t) {
      d = m = a[0], h = S = a[1];
      for (let D = t; D < i; D += t)
        _ = a[D], T = a[D + 1], _ < d && (d = _), T < h && (h = T), _ > m && (m = _), T > S && (S = T);
      C = Math.max(m - d, S - h), C = C !== 0 ? 1 / C : 0;
    }
    return FM(o, l, t, d, h, C), l;
  }
};
function WF(a, e, t, r, i) {
  let o, l;
  if (i === BW(a, e, t, r) > 0)
    for (o = e; o < t; o += r)
      l = TU(o, a[o], a[o + 1], l);
  else
    for (o = t - r; o >= e; o -= r)
      l = TU(o, a[o], a[o + 1], l);
  return l && qC(l, l.next) && (IM(l), l = l.next), l;
}
function i1(a, e) {
  if (!a)
    return a;
  e || (e = a);
  let t = a, r;
  do
    if (r = !1, !t.steiner && (qC(t, t.next) || ru(t.prev, t, t.next) === 0)) {
      if (IM(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function FM(a, e, t, r, i, o, l) {
  if (!a)
    return;
  !l && o && UW(a, r, i, o);
  let d = a, h, m;
  for (; a.prev !== a.next; ) {
    if (h = a.prev, m = a.next, o ? TW(a, r, i, o) : MW(a)) {
      e.push(h.i / t), e.push(a.i / t), e.push(m.i / t), IM(a), a = m.next, d = m.next;
      continue;
    }
    if (a = m, a === d) {
      l ? l === 1 ? (a = CW(i1(a), e, t), FM(a, e, t, r, i, o, 2)) : l === 2 && RW(a, e, t, r, i, o) : FM(i1(a), e, t, r, i, o, 1);
      break;
    }
  }
}
function MW(a) {
  const e = a.prev, t = a, r = a.next;
  if (ru(e, t, r) >= 0)
    return !1;
  let i = a.next.next;
  for (; i !== a.prev; ) {
    if (Gb(e.x, e.y, t.x, t.y, r.x, r.y, i.x, i.y) && ru(i.prev, i, i.next) >= 0)
      return !1;
    i = i.next;
  }
  return !0;
}
function TW(a, e, t, r) {
  const i = a.prev, o = a, l = a.next;
  if (ru(i, o, l) >= 0)
    return !1;
  const d = i.x < o.x ? i.x < l.x ? i.x : l.x : o.x < l.x ? o.x : l.x, h = i.y < o.y ? i.y < l.y ? i.y : l.y : o.y < l.y ? o.y : l.y, m = i.x > o.x ? i.x > l.x ? i.x : l.x : o.x > l.x ? o.x : l.x, S = i.y > o.y ? i.y > l.y ? i.y : l.y : o.y > l.y ? o.y : l.y, _ = g3(d, h, e, t, r), T = g3(m, S, e, t, r);
  let C = a.prevZ, D = a.nextZ;
  for (; C && C.z >= _ && D && D.z <= T; ) {
    if (C !== a.prev && C !== a.next && Gb(i.x, i.y, o.x, o.y, l.x, l.y, C.x, C.y) && ru(C.prev, C, C.next) >= 0 || (C = C.prevZ, D !== a.prev && D !== a.next && Gb(i.x, i.y, o.x, o.y, l.x, l.y, D.x, D.y) && ru(D.prev, D, D.next) >= 0))
      return !1;
    D = D.nextZ;
  }
  for (; C && C.z >= _; ) {
    if (C !== a.prev && C !== a.next && Gb(i.x, i.y, o.x, o.y, l.x, l.y, C.x, C.y) && ru(C.prev, C, C.next) >= 0)
      return !1;
    C = C.prevZ;
  }
  for (; D && D.z <= T; ) {
    if (D !== a.prev && D !== a.next && Gb(i.x, i.y, o.x, o.y, l.x, l.y, D.x, D.y) && ru(D.prev, D, D.next) >= 0)
      return !1;
    D = D.nextZ;
  }
  return !0;
}
function CW(a, e, t) {
  let r = a;
  do {
    const i = r.prev, o = r.next.next;
    !qC(i, o) && jF(i, r, r.next, o) && kM(i, o) && kM(o, i) && (e.push(i.i / t), e.push(r.i / t), e.push(o.i / t), IM(r), IM(r.next), r = a = o), r = r.next;
  } while (r !== a);
  return i1(r);
}
function RW(a, e, t, r, i, o) {
  let l = a;
  do {
    let d = l.next.next;
    for (; d !== l.prev; ) {
      if (l.i !== d.i && FW(l, d)) {
        let h = YF(l, d);
        l = i1(l, l.next), h = i1(h, h.next), FM(l, e, t, r, i, o), FM(h, e, t, r, i, o);
        return;
      }
      d = d.next;
    }
    l = l.next;
  } while (l !== a);
}
function AW(a, e, t, r) {
  const i = [];
  let o, l, d, h, m;
  for (o = 0, l = e.length; o < l; o++)
    d = e[o] * r, h = o < l - 1 ? e[o + 1] * r : a.length, m = WF(a, d, h, r, !1), m === m.next && (m.steiner = !0), i.push(NW(m));
  for (i.sort(DW), o = 0; o < i.length; o++)
    LW(i[o], t), t = i1(t, t.next);
  return t;
}
function DW(a, e) {
  return a.x - e.x;
}
function LW(a, e) {
  if (e = PW(a, e), e) {
    const t = YF(e, a);
    i1(e, e.next), i1(t, t.next);
  }
}
function PW(a, e) {
  let t = e;
  const r = a.x, i = a.y;
  let o = -1 / 0, l;
  do {
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      const T = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (T <= r && T > o) {
        if (o = T, T === r) {
          if (i === t.y)
            return t;
          if (i === t.next.y)
            return t.next;
        }
        l = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!l)
    return null;
  if (r === o)
    return l;
  const d = l, h = l.x, m = l.y;
  let S = 1 / 0, _;
  t = l;
  do
    r >= t.x && t.x >= h && r !== t.x && Gb(i < m ? r : o, i, h, m, i < m ? o : r, i, t.x, t.y) && (_ = Math.abs(i - t.y) / (r - t.x), kM(t, a) && (_ < S || _ === S && (t.x > l.x || t.x === l.x && OW(l, t))) && (l = t, S = _)), t = t.next;
  while (t !== d);
  return l;
}
function OW(a, e) {
  return ru(a.prev, a, e.prev) < 0 && ru(e.next, a, a.next) < 0;
}
function UW(a, e, t, r) {
  let i = a;
  do
    i.z === null && (i.z = g3(i.x, i.y, e, t, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== a);
  i.prevZ.nextZ = null, i.prevZ = null, zW(i);
}
function zW(a) {
  let e, t, r, i, o, l, d, h, m = 1;
  do {
    for (t = a, a = null, o = null, l = 0; t; ) {
      for (l++, r = t, d = 0, e = 0; e < m && (d++, r = r.nextZ, !!r); e++)
        ;
      for (h = m; d > 0 || h > 0 && r; )
        d !== 0 && (h === 0 || !r || t.z <= r.z) ? (i = t, t = t.nextZ, d--) : (i = r, r = r.nextZ, h--), o ? o.nextZ = i : a = i, i.prevZ = o, o = i;
      t = r;
    }
    o.nextZ = null, m *= 2;
  } while (l > 1);
  return a;
}
function g3(a, e, t, r, i) {
  return a = 32767 * (a - t) * i, e = 32767 * (e - r) * i, a = (a | a << 8) & 16711935, a = (a | a << 4) & 252645135, a = (a | a << 2) & 858993459, a = (a | a << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, a | e << 1;
}
function NW(a) {
  let e = a, t = a;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== a);
  return t;
}
function Gb(a, e, t, r, i, o, l, d) {
  return (i - l) * (e - d) - (a - l) * (o - d) >= 0 && (a - l) * (r - d) - (t - l) * (e - d) >= 0 && (t - l) * (o - d) - (i - l) * (r - d) >= 0;
}
function FW(a, e) {
  return a.next.i !== e.i && a.prev.i !== e.i && !kW(a, e) && (kM(a, e) && kM(e, a) && IW(a, e) && (ru(a.prev, a, e.prev) || ru(a, e.prev, e)) || qC(a, e) && ru(a.prev, a, a.next) > 0 && ru(e.prev, e, e.next) > 0);
}
function ru(a, e, t) {
  return (e.y - a.y) * (t.x - e.x) - (e.x - a.x) * (t.y - e.y);
}
function qC(a, e) {
  return a.x === e.x && a.y === e.y;
}
function jF(a, e, t, r) {
  const i = B2(ru(a, e, t)), o = B2(ru(a, e, r)), l = B2(ru(t, r, a)), d = B2(ru(t, r, e));
  return !!(i !== o && l !== d || i === 0 && I2(a, t, e) || o === 0 && I2(a, r, e) || l === 0 && I2(t, a, r) || d === 0 && I2(t, e, r));
}
function I2(a, e, t) {
  return e.x <= Math.max(a.x, t.x) && e.x >= Math.min(a.x, t.x) && e.y <= Math.max(a.y, t.y) && e.y >= Math.min(a.y, t.y);
}
function B2(a) {
  return a > 0 ? 1 : a < 0 ? -1 : 0;
}
function kW(a, e) {
  let t = a;
  do {
    if (t.i !== a.i && t.next.i !== a.i && t.i !== e.i && t.next.i !== e.i && jF(t, t.next, a, e))
      return !0;
    t = t.next;
  } while (t !== a);
  return !1;
}
function kM(a, e) {
  return ru(a.prev, a, a.next) < 0 ? ru(a, e, a.next) >= 0 && ru(a, a.prev, e) >= 0 : ru(a, e, a.prev) < 0 || ru(a, a.next, e) < 0;
}
function IW(a, e) {
  let t = a, r = !1;
  const i = (a.x + e.x) / 2, o = (a.y + e.y) / 2;
  do
    t.y > o != t.next.y > o && t.next.y !== t.y && i < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== a);
  return r;
}
function YF(a, e) {
  const t = new y3(a.i, a.x, a.y), r = new y3(e.i, e.x, e.y), i = a.next, o = e.prev;
  return a.next = e, e.prev = a, t.next = i, i.prev = t, r.next = t, t.prev = r, o.next = r, r.prev = o, r;
}
function TU(a, e, t, r) {
  const i = new y3(a, e, t);
  return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;
}
function IM(a) {
  a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
}
function y3(a, e, t) {
  this.i = a, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function BW(a, e, t, r) {
  let i = 0;
  for (let o = e, l = t - r; o < t; o += r)
    i += (a[l] - a[o]) * (a[o + 1] + a[l + 1]), l = o;
  return i;
}
class fy {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, o = 0; o < t; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return fy.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], i = [], o = [];
    CU(e), RU(r, e);
    let l = e.length;
    t.forEach(CU);
    for (let h = 0; h < t.length; h++)
      i.push(l), l += t[h].length, RU(r, t[h]);
    const d = EW.triangulate(r, i);
    for (let h = 0; h < d.length; h += 3)
      o.push(d.slice(h, h + 3));
    return o;
  }
}
function CU(a) {
  const e = a.length;
  e > 2 && a[e - 1].equals(a[0]) && a.pop();
}
function RU(a, e) {
  for (let t = 0; t < e.length; t++)
    a.push(e[t].x), a.push(e[t].y);
}
class nw extends ui {
  constructor(e = new IS([new Ft(0.5, 0.5), new Ft(-0.5, 0.5), new Ft(-0.5, -0.5), new Ft(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, i = [], o = [];
    for (let d = 0, h = e.length; d < h; d++) {
      const m = e[d];
      l(m);
    }
    this.setAttribute("position", new sr(i, 3)), this.setAttribute("uv", new sr(o, 2)), this.computeVertexNormals();
    function l(d) {
      const h = [], m = t.curveSegments !== void 0 ? t.curveSegments : 12, S = t.steps !== void 0 ? t.steps : 1, _ = t.depth !== void 0 ? t.depth : 1;
      let T = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, C = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, D = t.bevelSize !== void 0 ? t.bevelSize : C - 0.1, P = t.bevelOffset !== void 0 ? t.bevelOffset : 0, U = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const B = t.extrudePath, k = t.UVGenerator !== void 0 ? t.UVGenerator : HW;
      let V, I = !1, X, J, $, W;
      B && (V = B.getSpacedPoints(S), I = !0, T = !1, X = B.computeFrenetFrames(S, !1), J = new ge(), $ = new ge(), W = new ge()), T || (U = 0, C = 0, D = 0, P = 0);
      const ee = d.extractPoints(m);
      let ie = ee.shape;
      const pe = ee.holes;
      if (!fy.isClockWise(ie)) {
        ie = ie.reverse();
        for (let He = 0, et = pe.length; He < et; He++) {
          const mt = pe[He];
          fy.isClockWise(mt) && (pe[He] = mt.reverse());
        }
      }
      const Ee = fy.triangulateShape(ie, pe), de = ie;
      for (let He = 0, et = pe.length; He < et; He++) {
        const mt = pe[He];
        ie = ie.concat(mt);
      }
      function Fe(He, et, mt) {
        return et || console.error("THREE.ExtrudeGeometry: vec does not exist"), et.clone().multiplyScalar(mt).add(He);
      }
      const Ce = ie.length, Be = Ee.length;
      function he(He, et, mt) {
        let vt, bt, Qt;
        const ft = He.x - et.x, Vt = He.y - et.y, Jt = mt.x - He.x, Mt = mt.y - He.y, Me = ft * ft + Vt * Vt, oe = ft * Mt - Vt * Jt;
        if (Math.abs(oe) > Number.EPSILON) {
          const je = Math.sqrt(Me), lt = Math.sqrt(Jt * Jt + Mt * Mt), zt = et.x - Vt / je, Nt = et.y + ft / je, Ut = mt.x - Mt / lt, tt = mt.y + Jt / lt, rn = ((Ut - zt) * Mt - (tt - Nt) * Jt) / (ft * Mt - Vt * Jt);
          vt = zt + ft * rn - He.x, bt = Nt + Vt * rn - He.y;
          const ze = vt * vt + bt * bt;
          if (ze <= 2)
            return new Ft(vt, bt);
          Qt = Math.sqrt(ze / 2);
        } else {
          let je = !1;
          ft > Number.EPSILON ? Jt > Number.EPSILON && (je = !0) : ft < -Number.EPSILON ? Jt < -Number.EPSILON && (je = !0) : Math.sign(Vt) === Math.sign(Mt) && (je = !0), je ? (vt = -Vt, bt = ft, Qt = Math.sqrt(Me)) : (vt = ft, bt = Vt, Qt = Math.sqrt(Me / 2));
        }
        return new Ft(vt / Qt, bt / Qt);
      }
      const fe = [];
      for (let He = 0, et = de.length, mt = et - 1, vt = He + 1; He < et; He++, mt++, vt++)
        mt === et && (mt = 0), vt === et && (vt = 0), fe[He] = he(de[He], de[mt], de[vt]);
      const ue = [];
      let ye, we = fe.concat();
      for (let He = 0, et = pe.length; He < et; He++) {
        const mt = pe[He];
        ye = [];
        for (let vt = 0, bt = mt.length, Qt = bt - 1, ft = vt + 1; vt < bt; vt++, Qt++, ft++)
          Qt === bt && (Qt = 0), ft === bt && (ft = 0), ye[vt] = he(mt[vt], mt[Qt], mt[ft]);
        ue.push(ye), we = we.concat(ye);
      }
      for (let He = 0; He < U; He++) {
        const et = He / U, mt = C * Math.cos(et * Math.PI / 2), vt = D * Math.sin(et * Math.PI / 2) + P;
        for (let bt = 0, Qt = de.length; bt < Qt; bt++) {
          const ft = Fe(de[bt], fe[bt], vt);
          ot(ft.x, ft.y, -mt);
        }
        for (let bt = 0, Qt = pe.length; bt < Qt; bt++) {
          const ft = pe[bt];
          ye = ue[bt];
          for (let Vt = 0, Jt = ft.length; Vt < Jt; Vt++) {
            const Mt = Fe(ft[Vt], ye[Vt], vt);
            ot(Mt.x, Mt.y, -mt);
          }
        }
      }
      const Xe = D + P;
      for (let He = 0; He < Ce; He++) {
        const et = T ? Fe(ie[He], we[He], Xe) : ie[He];
        I ? ($.copy(X.normals[0]).multiplyScalar(et.x), J.copy(X.binormals[0]).multiplyScalar(et.y), W.copy(V[0]).add($).add(J), ot(W.x, W.y, W.z)) : ot(et.x, et.y, 0);
      }
      for (let He = 1; He <= S; He++)
        for (let et = 0; et < Ce; et++) {
          const mt = T ? Fe(ie[et], we[et], Xe) : ie[et];
          I ? ($.copy(X.normals[He]).multiplyScalar(mt.x), J.copy(X.binormals[He]).multiplyScalar(mt.y), W.copy(V[He]).add($).add(J), ot(W.x, W.y, W.z)) : ot(mt.x, mt.y, _ / S * He);
        }
      for (let He = U - 1; He >= 0; He--) {
        const et = He / U, mt = C * Math.cos(et * Math.PI / 2), vt = D * Math.sin(et * Math.PI / 2) + P;
        for (let bt = 0, Qt = de.length; bt < Qt; bt++) {
          const ft = Fe(de[bt], fe[bt], vt);
          ot(ft.x, ft.y, _ + mt);
        }
        for (let bt = 0, Qt = pe.length; bt < Qt; bt++) {
          const ft = pe[bt];
          ye = ue[bt];
          for (let Vt = 0, Jt = ft.length; Vt < Jt; Vt++) {
            const Mt = Fe(ft[Vt], ye[Vt], vt);
            I ? ot(Mt.x, Mt.y + V[S - 1].y, V[S - 1].x + mt) : ot(Mt.x, Mt.y, _ + mt);
          }
        }
      }
      Je(), st();
      function Je() {
        const He = i.length / 3;
        if (T) {
          let et = 0, mt = Ce * et;
          for (let vt = 0; vt < Be; vt++) {
            const bt = Ee[vt];
            rt(bt[2] + mt, bt[1] + mt, bt[0] + mt);
          }
          et = S + U * 2, mt = Ce * et;
          for (let vt = 0; vt < Be; vt++) {
            const bt = Ee[vt];
            rt(bt[0] + mt, bt[1] + mt, bt[2] + mt);
          }
        } else {
          for (let et = 0; et < Be; et++) {
            const mt = Ee[et];
            rt(mt[2], mt[1], mt[0]);
          }
          for (let et = 0; et < Be; et++) {
            const mt = Ee[et];
            rt(mt[0] + Ce * S, mt[1] + Ce * S, mt[2] + Ce * S);
          }
        }
        r.addGroup(He, i.length / 3 - He, 0);
      }
      function st() {
        const He = i.length / 3;
        let et = 0;
        Ue(de, et), et += de.length;
        for (let mt = 0, vt = pe.length; mt < vt; mt++) {
          const bt = pe[mt];
          Ue(bt, et), et += bt.length;
        }
        r.addGroup(He, i.length / 3 - He, 1);
      }
      function Ue(He, et) {
        let mt = He.length;
        for (; --mt >= 0; ) {
          const vt = mt;
          let bt = mt - 1;
          bt < 0 && (bt = He.length - 1);
          for (let Qt = 0, ft = S + U * 2; Qt < ft; Qt++) {
            const Vt = Ce * Qt, Jt = Ce * (Qt + 1), Mt = et + vt + Vt, Me = et + bt + Vt, oe = et + bt + Jt, je = et + vt + Jt;
            _t(Mt, Me, oe, je);
          }
        }
      }
      function ot(He, et, mt) {
        h.push(He), h.push(et), h.push(mt);
      }
      function rt(He, et, mt) {
        Rt(He), Rt(et), Rt(mt);
        const vt = i.length / 3, bt = k.generateTopUV(r, i, vt - 3, vt - 2, vt - 1);
        Ot(bt[0]), Ot(bt[1]), Ot(bt[2]);
      }
      function _t(He, et, mt, vt) {
        Rt(He), Rt(et), Rt(vt), Rt(et), Rt(mt), Rt(vt);
        const bt = i.length / 3, Qt = k.generateSideWallUV(r, i, bt - 6, bt - 3, bt - 2, bt - 1);
        Ot(Qt[0]), Ot(Qt[1]), Ot(Qt[3]), Ot(Qt[1]), Ot(Qt[2]), Ot(Qt[3]);
      }
      function Rt(He) {
        i.push(h[He * 3 + 0]), i.push(h[He * 3 + 1]), i.push(h[He * 3 + 2]);
      }
      function Ot(He) {
        o.push(He.x), o.push(He.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return VW(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let o = 0, l = e.shapes.length; o < l; o++) {
      const d = t[e.shapes[o]];
      r.push(d);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new lL[i.type]().fromJSON(i)), new nw(r, e.options);
  }
}
const HW = {
  generateTopUV: function(a, e, t, r, i) {
    const o = e[t * 3], l = e[t * 3 + 1], d = e[r * 3], h = e[r * 3 + 1], m = e[i * 3], S = e[i * 3 + 1];
    return [
      new Ft(o, l),
      new Ft(d, h),
      new Ft(m, S)
    ];
  },
  generateSideWallUV: function(a, e, t, r, i, o) {
    const l = e[t * 3], d = e[t * 3 + 1], h = e[t * 3 + 2], m = e[r * 3], S = e[r * 3 + 1], _ = e[r * 3 + 2], T = e[i * 3], C = e[i * 3 + 1], D = e[i * 3 + 2], P = e[o * 3], U = e[o * 3 + 1], B = e[o * 3 + 2];
    return Math.abs(d - S) < Math.abs(l - m) ? [
      new Ft(l, 1 - h),
      new Ft(m, 1 - _),
      new Ft(T, 1 - D),
      new Ft(P, 1 - B)
    ] : [
      new Ft(d, 1 - h),
      new Ft(S, 1 - _),
      new Ft(C, 1 - D),
      new Ft(U, 1 - B)
    ];
  }
};
function VW(a, e, t) {
  if (t.shapes = [], Array.isArray(a))
    for (let r = 0, i = a.length; r < i; r++) {
      const o = a[r];
      t.shapes.push(o.uuid);
    }
  else
    t.shapes.push(a.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class rw extends my {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], o = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new rw(e.radius, e.detail);
  }
}
class ng extends my {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ng(e.radius, e.detail);
  }
}
class iw extends ui {
  constructor(e = 0.5, t = 1, r = 8, i = 1, o = 0, l = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: i,
      thetaStart: o,
      thetaLength: l
    }, r = Math.max(3, r), i = Math.max(1, i);
    const d = [], h = [], m = [], S = [];
    let _ = e;
    const T = (t - e) / i, C = new ge(), D = new Ft();
    for (let P = 0; P <= i; P++) {
      for (let U = 0; U <= r; U++) {
        const B = o + U / r * l;
        C.x = _ * Math.cos(B), C.y = _ * Math.sin(B), h.push(C.x, C.y, C.z), m.push(0, 0, 1), D.x = (C.x / t + 1) / 2, D.y = (C.y / t + 1) / 2, S.push(D.x, D.y);
      }
      _ += T;
    }
    for (let P = 0; P < i; P++) {
      const U = P * (r + 1);
      for (let B = 0; B < r; B++) {
        const k = B + U, V = k, I = k + r + 1, X = k + r + 2, J = k + 1;
        d.push(V, I, J), d.push(I, X, J);
      }
    }
    this.setIndex(d), this.setAttribute("position", new sr(h, 3)), this.setAttribute("normal", new sr(m, 3)), this.setAttribute("uv", new sr(S, 2));
  }
  static fromJSON(e) {
    return new iw(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class aw extends ui {
  constructor(e = new IS([new Ft(0, 0.5), new Ft(-0.5, -0.5), new Ft(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], i = [], o = [], l = [];
    let d = 0, h = 0;
    if (Array.isArray(e) === !1)
      m(e);
    else
      for (let S = 0; S < e.length; S++)
        m(e[S]), this.addGroup(d, h, S), d += h, h = 0;
    this.setIndex(r), this.setAttribute("position", new sr(i, 3)), this.setAttribute("normal", new sr(o, 3)), this.setAttribute("uv", new sr(l, 2));
    function m(S) {
      const _ = i.length / 3, T = S.extractPoints(t);
      let C = T.shape;
      const D = T.holes;
      fy.isClockWise(C) === !1 && (C = C.reverse());
      for (let U = 0, B = D.length; U < B; U++) {
        const k = D[U];
        fy.isClockWise(k) === !0 && (D[U] = k.reverse());
      }
      const P = fy.triangulateShape(C, D);
      for (let U = 0, B = D.length; U < B; U++) {
        const k = D[U];
        C = C.concat(k);
      }
      for (let U = 0, B = C.length; U < B; U++) {
        const k = C[U];
        i.push(k.x, k.y, 0), o.push(0, 0, 1), l.push(k.x, k.y);
      }
      for (let U = 0, B = P.length; U < B; U++) {
        const k = P[U], V = k[0] + _, I = k[1] + _, X = k[2] + _;
        r.push(V, I, X), h += 3;
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return GW(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const l = t[e.shapes[i]];
      r.push(l);
    }
    return new aw(r, e.curveSegments);
  }
}
function GW(a, e) {
  if (e.shapes = [], Array.isArray(a))
    for (let t = 0, r = a.length; t < r; t++) {
      const i = a[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(a.uuid);
  return e;
}
class ag extends ui {
  constructor(e = 1, t = 32, r = 16, i = 0, o = Math.PI * 2, l = 0, d = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: i,
      phiLength: o,
      thetaStart: l,
      thetaLength: d
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const h = Math.min(l + d, Math.PI);
    let m = 0;
    const S = [], _ = new ge(), T = new ge(), C = [], D = [], P = [], U = [];
    for (let B = 0; B <= r; B++) {
      const k = [], V = B / r;
      let I = 0;
      B == 0 && l == 0 ? I = 0.5 / t : B == r && h == Math.PI && (I = -0.5 / t);
      for (let X = 0; X <= t; X++) {
        const J = X / t;
        _.x = -e * Math.cos(i + J * o) * Math.sin(l + V * d), _.y = e * Math.cos(l + V * d), _.z = e * Math.sin(i + J * o) * Math.sin(l + V * d), D.push(_.x, _.y, _.z), T.copy(_).normalize(), P.push(T.x, T.y, T.z), U.push(J + I, 1 - V), k.push(m++);
      }
      S.push(k);
    }
    for (let B = 0; B < r; B++)
      for (let k = 0; k < t; k++) {
        const V = S[B][k + 1], I = S[B][k], X = S[B + 1][k], J = S[B + 1][k + 1];
        (B !== 0 || l > 0) && C.push(V, I, J), (B !== r - 1 || h < Math.PI) && C.push(I, X, J);
      }
    this.setIndex(C), this.setAttribute("position", new sr(D, 3)), this.setAttribute("normal", new sr(P, 3)), this.setAttribute("uv", new sr(U, 2));
  }
  static fromJSON(e) {
    return new ag(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class sw extends my {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new sw(e.radius, e.detail);
  }
}
class tg extends ui {
  constructor(e = 1, t = 0.4, r = 8, i = 6, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: i,
      arc: o
    }, r = Math.floor(r), i = Math.floor(i);
    const l = [], d = [], h = [], m = [], S = new ge(), _ = new ge(), T = new ge();
    for (let C = 0; C <= r; C++)
      for (let D = 0; D <= i; D++) {
        const P = D / i * o, U = C / r * Math.PI * 2;
        _.x = (e + t * Math.cos(U)) * Math.cos(P), _.y = (e + t * Math.cos(U)) * Math.sin(P), _.z = t * Math.sin(U), d.push(_.x, _.y, _.z), S.x = e * Math.cos(P), S.y = e * Math.sin(P), T.subVectors(_, S).normalize(), h.push(T.x, T.y, T.z), m.push(D / i), m.push(C / r);
      }
    for (let C = 1; C <= r; C++)
      for (let D = 1; D <= i; D++) {
        const P = (i + 1) * C + D - 1, U = (i + 1) * (C - 1) + D - 1, B = (i + 1) * (C - 1) + D, k = (i + 1) * C + D;
        l.push(P, U, k), l.push(U, B, k);
      }
    this.setIndex(l), this.setAttribute("position", new sr(d, 3)), this.setAttribute("normal", new sr(h, 3)), this.setAttribute("uv", new sr(m, 2));
  }
  static fromJSON(e) {
    return new tg(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class ow extends ui {
  constructor(e = 1, t = 0.4, r = 64, i = 8, o = 2, l = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: i,
      p: o,
      q: l
    }, r = Math.floor(r), i = Math.floor(i);
    const d = [], h = [], m = [], S = [], _ = new ge(), T = new ge(), C = new ge(), D = new ge(), P = new ge(), U = new ge(), B = new ge();
    for (let V = 0; V <= r; ++V) {
      const I = V / r * o * Math.PI * 2;
      k(I, o, l, e, C), k(I + 0.01, o, l, e, D), U.subVectors(D, C), B.addVectors(D, C), P.crossVectors(U, B), B.crossVectors(P, U), P.normalize(), B.normalize();
      for (let X = 0; X <= i; ++X) {
        const J = X / i * Math.PI * 2, $ = -t * Math.cos(J), W = t * Math.sin(J);
        _.x = C.x + ($ * B.x + W * P.x), _.y = C.y + ($ * B.y + W * P.y), _.z = C.z + ($ * B.z + W * P.z), h.push(_.x, _.y, _.z), T.subVectors(_, C).normalize(), m.push(T.x, T.y, T.z), S.push(V / r), S.push(X / i);
      }
    }
    for (let V = 1; V <= r; V++)
      for (let I = 1; I <= i; I++) {
        const X = (i + 1) * (V - 1) + (I - 1), J = (i + 1) * V + (I - 1), $ = (i + 1) * V + I, W = (i + 1) * (V - 1) + I;
        d.push(X, J, W), d.push(J, $, W);
      }
    this.setIndex(d), this.setAttribute("position", new sr(h, 3)), this.setAttribute("normal", new sr(m, 3)), this.setAttribute("uv", new sr(S, 2));
    function k(V, I, X, J, $) {
      const W = Math.cos(V), ee = Math.sin(V), ie = X / I * V, pe = Math.cos(ie);
      $.x = J * (2 + pe) * 0.5 * W, $.y = J * (2 + pe) * ee * 0.5, $.z = J * Math.sin(ie) * 0.5;
    }
  }
  static fromJSON(e) {
    return new ow(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class lw extends ui {
  constructor(e = new sL(new ge(-1, -1, 0), new ge(-1, 1, 0), new ge(1, 1, 0)), t = 64, r = 1, i = 8, o = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: i,
      closed: o
    };
    const l = e.computeFrenetFrames(t, o);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    const d = new ge(), h = new ge(), m = new Ft();
    let S = new ge();
    const _ = [], T = [], C = [], D = [];
    P(), this.setIndex(D), this.setAttribute("position", new sr(_, 3)), this.setAttribute("normal", new sr(T, 3)), this.setAttribute("uv", new sr(C, 2));
    function P() {
      for (let V = 0; V < t; V++)
        U(V);
      U(o === !1 ? t : 0), k(), B();
    }
    function U(V) {
      S = e.getPointAt(V / t, S);
      const I = l.normals[V], X = l.binormals[V];
      for (let J = 0; J <= i; J++) {
        const $ = J / i * Math.PI * 2, W = Math.sin($), ee = -Math.cos($);
        h.x = ee * I.x + W * X.x, h.y = ee * I.y + W * X.y, h.z = ee * I.z + W * X.z, h.normalize(), T.push(h.x, h.y, h.z), d.x = S.x + r * h.x, d.y = S.y + r * h.y, d.z = S.z + r * h.z, _.push(d.x, d.y, d.z);
      }
    }
    function B() {
      for (let V = 1; V <= t; V++)
        for (let I = 1; I <= i; I++) {
          const X = (i + 1) * (V - 1) + (I - 1), J = (i + 1) * V + (I - 1), $ = (i + 1) * V + I, W = (i + 1) * (V - 1) + I;
          D.push(X, J, W), D.push(J, $, W);
        }
    }
    function k() {
      for (let V = 0; V <= t; V++)
        for (let I = 0; I <= i; I++)
          m.x = V / t, m.y = I / i, C.push(m.x, m.y);
    }
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new lw(
      new lL[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class uL extends ui {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), i = new ge(), o = new ge();
      if (e.index !== null) {
        const l = e.attributes.position, d = e.index;
        let h = e.groups;
        h.length === 0 && (h = [{ start: 0, count: d.count, materialIndex: 0 }]);
        for (let m = 0, S = h.length; m < S; ++m) {
          const _ = h[m], T = _.start, C = _.count;
          for (let D = T, P = T + C; D < P; D += 3)
            for (let U = 0; U < 3; U++) {
              const B = d.getX(D + U), k = d.getX(D + (U + 1) % 3);
              i.fromBufferAttribute(l, B), o.fromBufferAttribute(l, k), AU(i, o, r) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let d = 0, h = l.count / 3; d < h; d++)
          for (let m = 0; m < 3; m++) {
            const S = 3 * d + m, _ = 3 * d + (m + 1) % 3;
            i.fromBufferAttribute(l, S), o.fromBufferAttribute(l, _), AU(i, o, r) === !0 && (t.push(i.x, i.y, i.z), t.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new sr(t, 3));
    }
  }
}
function AU(a, e, t) {
  const r = `${a.x},${a.y},${a.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${a.x},${a.y},${a.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var DU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: cl,
  BoxBufferGeometry: cl,
  CapsuleGeometry: Kb,
  CapsuleBufferGeometry: Kb,
  CircleGeometry: $b,
  CircleBufferGeometry: $b,
  ConeGeometry: ew,
  ConeBufferGeometry: ew,
  CylinderGeometry: Jo,
  CylinderBufferGeometry: Jo,
  DodecahedronGeometry: tw,
  DodecahedronBufferGeometry: tw,
  EdgesGeometry: GF,
  ExtrudeGeometry: nw,
  ExtrudeBufferGeometry: nw,
  IcosahedronGeometry: rw,
  IcosahedronBufferGeometry: rw,
  LatheGeometry: jS,
  LatheBufferGeometry: jS,
  OctahedronGeometry: ng,
  OctahedronBufferGeometry: ng,
  PlaneGeometry: ig,
  PlaneBufferGeometry: ig,
  PolyhedronGeometry: my,
  PolyhedronBufferGeometry: my,
  RingGeometry: iw,
  RingBufferGeometry: iw,
  ShapeGeometry: aw,
  ShapeBufferGeometry: aw,
  SphereGeometry: ag,
  SphereBufferGeometry: ag,
  TetrahedronGeometry: sw,
  TetrahedronBufferGeometry: sw,
  TorusGeometry: tg,
  TorusBufferGeometry: tg,
  TorusKnotGeometry: ow,
  TorusKnotBufferGeometry: ow,
  TubeGeometry: lw,
  TubeBufferGeometry: lw,
  WireframeGeometry: uL
});
class XF extends ff {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Pn(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class qF extends wu {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class BM extends ff {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Pn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qS, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class QF extends BM {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ft(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Qu(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Pn(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Pn(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Pn(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class ZF extends ff {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Pn(16777215), this.specular = new Pn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qS, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ZM, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class JF extends ff {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Pn(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qS, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class cL extends ff {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qS, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class KF extends ff {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Pn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ZM, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class $F extends ff {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Pn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = qS, this.normalScale = new Ft(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class e4 extends ph {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function gv(a, e, t) {
  return fL(a) ? new a.constructor(a.subarray(e, t !== void 0 ? t : a.length)) : a.slice(e, t);
}
function US(a, e, t) {
  return !a || !t && a.constructor === e ? a : typeof e.BYTES_PER_ELEMENT == "number" ? new e(a) : Array.prototype.slice.call(a);
}
function fL(a) {
  return ArrayBuffer.isView(a) && !(a instanceof DataView);
}
function t4(a) {
  function e(i, o) {
    return a[i] - a[o];
  }
  const t = a.length, r = new Array(t);
  for (let i = 0; i !== t; ++i)
    r[i] = i;
  return r.sort(e), r;
}
function x3(a, e, t) {
  const r = a.length, i = new a.constructor(r);
  for (let o = 0, l = 0; l !== r; ++o) {
    const d = t[o] * e;
    for (let h = 0; h !== e; ++h)
      i[l++] = a[d + h];
  }
  return i;
}
function dL(a, e, t, r) {
  let i = 1, o = a[0];
  for (; o !== void 0 && o[r] === void 0; )
    o = a[i++];
  if (o === void 0)
    return;
  let l = o[r];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        l = o[r], l !== void 0 && (e.push(o.time), t.push.apply(t, l)), o = a[i++];
      while (o !== void 0);
    else if (l.toArray !== void 0)
      do
        l = o[r], l !== void 0 && (e.push(o.time), l.toArray(t, t.length)), o = a[i++];
      while (o !== void 0);
    else
      do
        l = o[r], l !== void 0 && (e.push(o.time), t.push(l)), o = a[i++];
      while (o !== void 0);
}
function WW(a, e, t, r, i = 30) {
  const o = a.clone();
  o.name = e;
  const l = [];
  for (let h = 0; h < o.tracks.length; ++h) {
    const m = o.tracks[h], S = m.getValueSize(), _ = [], T = [];
    for (let C = 0; C < m.times.length; ++C) {
      const D = m.times[C] * i;
      if (!(D < t || D >= r)) {
        _.push(m.times[C]);
        for (let P = 0; P < S; ++P)
          T.push(m.values[C * S + P]);
      }
    }
    _.length !== 0 && (m.times = US(_, m.times.constructor), m.values = US(T, m.values.constructor), l.push(m));
  }
  o.tracks = l;
  let d = 1 / 0;
  for (let h = 0; h < o.tracks.length; ++h)
    d > o.tracks[h].times[0] && (d = o.tracks[h].times[0]);
  for (let h = 0; h < o.tracks.length; ++h)
    o.tracks[h].shift(-1 * d);
  return o.resetDuration(), o;
}
function jW(a, e = 0, t = a, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length, o = e / r;
  for (let l = 0; l < i; ++l) {
    const d = t.tracks[l], h = d.ValueTypeName;
    if (h === "bool" || h === "string")
      continue;
    const m = a.tracks.find(function(B) {
      return B.name === d.name && B.ValueTypeName === h;
    });
    if (m === void 0)
      continue;
    let S = 0;
    const _ = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (S = _ / 3);
    let T = 0;
    const C = m.getValueSize();
    m.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (T = C / 3);
    const D = d.times.length - 1;
    let P;
    if (o <= d.times[0]) {
      const B = S, k = _ - S;
      P = gv(d.values, B, k);
    } else if (o >= d.times[D]) {
      const B = D * _ + S, k = B + _ - S;
      P = gv(d.values, B, k);
    } else {
      const B = d.createInterpolant(), k = S, V = _ - S;
      B.evaluate(o), P = gv(B.resultBuffer, k, V);
    }
    h === "quaternion" && new Ko().fromArray(P).normalize().conjugate().toArray(P);
    const U = m.times.length;
    for (let B = 0; B < U; ++B) {
      const k = B * C + T;
      if (h === "quaternion")
        Ko.multiplyQuaternionsFlat(
          m.values,
          k,
          P,
          0,
          m.values,
          k
        );
      else {
        const V = C - T * 2;
        for (let I = 0; I < V; ++I)
          m.values[k + I] -= P[I];
      }
    }
  }
  return a.blendMode = Y3, a;
}
var YW = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arraySlice: gv,
  convertArray: US,
  isTypedArray: fL,
  getKeyframeOrder: t4,
  sortedArray: x3,
  flattenJSON: dL,
  subclip: WW,
  makeClipAdditive: jW
});
class nT {
  constructor(e, t, r, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex, i = t[r], o = t[r - 1];
    e: {
      t: {
        let l;
        n: {
          r:
            if (!(e < i)) {
              for (let d = r + 2; ; ) {
                if (i === void 0) {
                  if (e < o)
                    break r;
                  return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
                }
                if (r === d)
                  break;
                if (o = i, i = t[++r], e < i)
                  break t;
              }
              l = t.length;
              break n;
            }
          if (!(e >= o)) {
            const d = t[1];
            e < d && (r = 2, o = d);
            for (let h = r - 2; ; ) {
              if (o === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (r === h)
                break;
              if (i = o, o = t[--r - 1], e >= o)
                break t;
            }
            l = r, r = 0;
            break n;
          }
          break e;
        }
        for (; r < l; ) {
          const d = r + l >>> 1;
          e < t[d] ? l = d : r = d + 1;
        }
        if (i = t[r], o = t[r - 1], o === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
      }
      this._cachedIndex = r, this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, o = e * i;
    for (let l = 0; l !== i; ++l)
      t[l] = r[o + l];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class n4 extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: LS,
      endingEnd: LS
    };
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let o = e - 2, l = e + 1, d = i[o], h = i[l];
    if (d === void 0)
      switch (this.getSettings_().endingStart) {
        case PS:
          o = e, d = 2 * t - r;
          break;
        case LM:
          o = i.length - 2, d = t + i[o] - i[o + 1];
          break;
        default:
          o = e, d = r;
      }
    if (h === void 0)
      switch (this.getSettings_().endingEnd) {
        case PS:
          l = e, h = 2 * r - t;
          break;
        case LM:
          l = 1, h = r + i[1] - i[0];
          break;
        default:
          l = e - 1, h = t;
      }
    const m = (r - t) * 0.5, S = this.valueSize;
    this._weightPrev = m / (t - d), this._weightNext = m / (h - r), this._offsetPrev = o * S, this._offsetNext = l * S;
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer, l = this.sampleValues, d = this.valueSize, h = e * d, m = h - d, S = this._offsetPrev, _ = this._offsetNext, T = this._weightPrev, C = this._weightNext, D = (r - t) / (i - t), P = D * D, U = P * D, B = -T * U + 2 * T * P - T * D, k = (1 + T) * U + (-1.5 - 2 * T) * P + (-0.5 + T) * D + 1, V = (-1 - C) * U + (1.5 + C) * P + 0.5 * D, I = C * U - C * P;
    for (let X = 0; X !== d; ++X)
      o[X] = B * l[S + X] + k * l[m + X] + V * l[h + X] + I * l[_ + X];
    return o;
  }
}
class hL extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer, l = this.sampleValues, d = this.valueSize, h = e * d, m = h - d, S = (r - t) / (i - t), _ = 1 - S;
    for (let T = 0; T !== d; ++T)
      o[T] = l[m + T] * _ + l[h + T] * S;
    return o;
  }
}
class r4 extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ug {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = US(t, this.TimeBufferType), this.values = US(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: US(e.times, Array),
        values: US(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return r.type = e.ValueTypeName, r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new r4(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new hL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new n4(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case AM:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case DM:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case hC:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return AM;
      case this.InterpolantFactoryMethodLinear:
        return DM;
      case this.InterpolantFactoryMethodSmooth:
        return hC;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times, i = r.length;
    let o = 0, l = i - 1;
    for (; o !== i && r[o] < e; )
      ++o;
    for (; l !== -1 && r[l] > t; )
      --l;
    if (++l, o !== 0 || l !== i) {
      o >= l && (l = Math.max(l, 1), o = l - 1);
      const d = this.getValueSize();
      this.times = gv(r, o, l), this.values = gv(this.values, o * d, l * d);
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const r = this.times, i = this.values, o = r.length;
    o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let l = null;
    for (let d = 0; d !== o; d++) {
      const h = r[d];
      if (typeof h == "number" && isNaN(h)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, d, h), e = !1;
        break;
      }
      if (l !== null && l > h) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, d, h, l), e = !1;
        break;
      }
      l = h;
    }
    if (i !== void 0 && fL(i))
      for (let d = 0, h = i.length; d !== h; ++d) {
        const m = i[d];
        if (isNaN(m)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, d, m), e = !1;
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = gv(this.times), t = gv(this.values), r = this.getValueSize(), i = this.getInterpolation() === hC, o = e.length - 1;
    let l = 1;
    for (let d = 1; d < o; ++d) {
      let h = !1;
      const m = e[d], S = e[d + 1];
      if (m !== S && (d !== 1 || m !== e[0]))
        if (i)
          h = !0;
        else {
          const _ = d * r, T = _ - r, C = _ + r;
          for (let D = 0; D !== r; ++D) {
            const P = t[_ + D];
            if (P !== t[T + D] || P !== t[C + D]) {
              h = !0;
              break;
            }
          }
        }
      if (h) {
        if (d !== l) {
          e[l] = e[d];
          const _ = d * r, T = l * r;
          for (let C = 0; C !== r; ++C)
            t[T + C] = t[_ + C];
        }
        ++l;
      }
    }
    if (o > 0) {
      e[l] = e[o];
      for (let d = o * r, h = l * r, m = 0; m !== r; ++m)
        t[h + m] = t[d + m];
      ++l;
    }
    return l !== e.length ? (this.times = gv(e, 0, l), this.values = gv(t, 0, l * r)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = gv(this.times, 0), t = gv(this.values, 0), r = this.constructor, i = new r(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
ug.prototype.TimeBufferType = Float32Array;
ug.prototype.ValueBufferType = Float32Array;
ug.prototype.DefaultInterpolation = DM;
class ZS extends ug {
}
ZS.prototype.ValueTypeName = "bool";
ZS.prototype.ValueBufferType = Array;
ZS.prototype.DefaultInterpolation = AM;
ZS.prototype.InterpolantFactoryMethodLinear = void 0;
ZS.prototype.InterpolantFactoryMethodSmooth = void 0;
class pL extends ug {
}
pL.prototype.ValueTypeName = "color";
class HM extends ug {
}
HM.prototype.ValueTypeName = "number";
class i4 extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const o = this.resultBuffer, l = this.sampleValues, d = this.valueSize, h = (r - t) / (i - t);
    let m = e * d;
    for (let S = m + d; m !== S; m += 4)
      Ko.slerpFlat(o, 0, l, m - d, l, m, h);
    return o;
  }
}
class mw extends ug {
  InterpolantFactoryMethodLinear(e) {
    return new i4(this.times, this.values, this.getValueSize(), e);
  }
}
mw.prototype.ValueTypeName = "quaternion";
mw.prototype.DefaultInterpolation = DM;
mw.prototype.InterpolantFactoryMethodSmooth = void 0;
class JS extends ug {
}
JS.prototype.ValueTypeName = "string";
JS.prototype.ValueBufferType = Array;
JS.prototype.DefaultInterpolation = AM;
JS.prototype.InterpolantFactoryMethodLinear = void 0;
JS.prototype.InterpolantFactoryMethodSmooth = void 0;
class VM extends ug {
}
VM.prototype.ValueTypeName = "vector";
class GM {
  constructor(e, t = -1, r, i = FC) {
    this.name = e, this.tracks = r, this.duration = t, this.blendMode = i, this.uuid = bm(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], r = e.tracks, i = 1 / (e.fps || 1);
    for (let l = 0, d = r.length; l !== d; ++l)
      t.push(qW(r[l]).scale(i));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return o.uuid = e.uuid, o;
  }
  static toJSON(e) {
    const t = [], r = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let o = 0, l = r.length; o !== l; ++o)
      t.push(ug.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const o = t.length, l = [];
    for (let d = 0; d < o; d++) {
      let h = [], m = [];
      h.push(
        (d + o - 1) % o,
        d,
        (d + 1) % o
      ), m.push(0, 1, 0);
      const S = t4(h);
      h = x3(h, 1, S), m = x3(m, 1, S), !i && h[0] === 0 && (h.push(o), m.push(m[0])), l.push(
        new HM(
          ".morphTargetInfluences[" + t[d].name + "]",
          h,
          m
        ).scale(1 / r)
      );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {}, o = /^([\w-]*?)([\d]+)$/;
    for (let d = 0, h = e.length; d < h; d++) {
      const m = e[d], S = m.name.match(o);
      if (S && S.length > 1) {
        const _ = S[1];
        let T = i[_];
        T || (i[_] = T = []), T.push(m);
      }
    }
    const l = [];
    for (const d in i)
      l.push(this.CreateFromMorphTargetSequence(d, i[d], t, r));
    return l;
  }
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const r = function(_, T, C, D, P) {
      if (C.length !== 0) {
        const U = [], B = [];
        dL(C, U, B, D), U.length !== 0 && P.push(new _(T, U, B));
      }
    }, i = [], o = e.name || "default", l = e.fps || 30, d = e.blendMode;
    let h = e.length || -1;
    const m = e.hierarchy || [];
    for (let _ = 0; _ < m.length; _++) {
      const T = m[_].keys;
      if (!(!T || T.length === 0))
        if (T[0].morphTargets) {
          const C = {};
          let D;
          for (D = 0; D < T.length; D++)
            if (T[D].morphTargets)
              for (let P = 0; P < T[D].morphTargets.length; P++)
                C[T[D].morphTargets[P]] = -1;
          for (const P in C) {
            const U = [], B = [];
            for (let k = 0; k !== T[D].morphTargets.length; ++k) {
              const V = T[D];
              U.push(V.time), B.push(V.morphTarget === P ? 1 : 0);
            }
            i.push(new HM(".morphTargetInfluence[" + P + "]", U, B));
          }
          h = C.length * l;
        } else {
          const C = ".bones[" + t[_].name + "]";
          r(
            VM,
            C + ".position",
            T,
            "pos",
            i
          ), r(
            mw,
            C + ".quaternion",
            T,
            "rot",
            i
          ), r(
            VM,
            C + ".scale",
            T,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(o, h, i, d);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function XW(a) {
  switch (a.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return HM;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VM;
    case "color":
      return pL;
    case "quaternion":
      return mw;
    case "bool":
    case "boolean":
      return ZS;
    case "string":
      return JS;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
}
function qW(a) {
  if (a.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = XW(a.type);
  if (a.times === void 0) {
    const t = [], r = [];
    dL(a.keys, t, r, "value"), a.times = t, a.values = r;
  }
  return e.parse !== void 0 ? e.parse(a) : new e(a.name, a.times, a.values, a.interpolation);
}
const YS = {
  enabled: !1,
  files: {},
  add: function(a, e) {
    this.enabled !== !1 && (this.files[a] = e);
  },
  get: function(a) {
    if (this.enabled !== !1)
      return this.files[a];
  },
  remove: function(a) {
    delete this.files[a];
  },
  clear: function() {
    this.files = {};
  }
};
class mL {
  constructor(e, t, r) {
    const i = this;
    let o = !1, l = 0, d = 0, h;
    const m = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(S) {
      d++, o === !1 && i.onStart !== void 0 && i.onStart(S, l, d), o = !0;
    }, this.itemEnd = function(S) {
      l++, i.onProgress !== void 0 && i.onProgress(S, l, d), l === d && (o = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(S) {
      i.onError !== void 0 && i.onError(S);
    }, this.resolveURL = function(S) {
      return h ? h(S) : S;
    }, this.setURLModifier = function(S) {
      return h = S, this;
    }, this.addHandler = function(S, _) {
      return m.push(S, _), this;
    }, this.removeHandler = function(S) {
      const _ = m.indexOf(S);
      return _ !== -1 && m.splice(_, 2), this;
    }, this.getHandler = function(S) {
      for (let _ = 0, T = m.length; _ < T; _ += 2) {
        const C = m[_], D = m[_ + 1];
        if (C.global && (C.lastIndex = 0), C.test(S))
          return D;
      }
      return null;
    };
  }
}
const a4 = /* @__PURE__ */ new mL();
class Tm {
  constructor(e) {
    this.manager = e !== void 0 ? e : a4, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const r = this;
    return new Promise(function(i, o) {
      r.load(e, i, t, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const M0 = {};
class QW extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class P0 extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = YS.get(e);
    if (o !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(o), this.manager.itemEnd(e);
      }, 0), o;
    if (M0[e] !== void 0) {
      M0[e].push({
        onLoad: t,
        onProgress: r,
        onError: i
      });
      return;
    }
    M0[e] = [], M0[e].push({
      onLoad: t,
      onProgress: r,
      onError: i
    });
    const l = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    }), d = this.mimeType, h = this.responseType;
    fetch(l).then((m) => {
      if (m.status === 200 || m.status === 0) {
        if (m.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || m.body === void 0 || m.body.getReader === void 0)
          return m;
        const S = M0[e], _ = m.body.getReader(), T = m.headers.get("Content-Length"), C = T ? parseInt(T) : 0, D = C !== 0;
        let P = 0;
        const U = new ReadableStream({
          start(B) {
            k();
            function k() {
              _.read().then(({ done: V, value: I }) => {
                if (V)
                  B.close();
                else {
                  P += I.byteLength;
                  const X = new ProgressEvent("progress", { lengthComputable: D, loaded: P, total: C });
                  for (let J = 0, $ = S.length; J < $; J++) {
                    const W = S[J];
                    W.onProgress && W.onProgress(X);
                  }
                  B.enqueue(I), k();
                }
              });
            }
          }
        });
        return new Response(U);
      } else
        throw new QW(`fetch for "${m.url}" responded with ${m.status}: ${m.statusText}`, m);
    }).then((m) => {
      switch (h) {
        case "arraybuffer":
          return m.arrayBuffer();
        case "blob":
          return m.blob();
        case "document":
          return m.text().then((S) => new DOMParser().parseFromString(S, d));
        case "json":
          return m.json();
        default:
          if (d === void 0)
            return m.text();
          {
            const _ = /charset="?([^;"\s]*)"?/i.exec(d), T = _ && _[1] ? _[1].toLowerCase() : void 0, C = new TextDecoder(T);
            return m.arrayBuffer().then((D) => C.decode(D));
          }
      }
    }).then((m) => {
      YS.add(e, m);
      const S = M0[e];
      delete M0[e];
      for (let _ = 0, T = S.length; _ < T; _++) {
        const C = S[_];
        C.onLoad && C.onLoad(m);
      }
    }).catch((m) => {
      const S = M0[e];
      if (S === void 0)
        throw this.manager.itemError(e), m;
      delete M0[e];
      for (let _ = 0, T = S.length; _ < T; _++) {
        const C = S[_];
        C.onError && C.onError(m);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class ZW extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new P0(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(d) {
      try {
        t(o.parse(JSON.parse(d)));
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = GM.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class JW extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = [], d = new FF(), h = new P0(this.manager);
    h.setPath(this.path), h.setResponseType("arraybuffer"), h.setRequestHeader(this.requestHeader), h.setWithCredentials(o.withCredentials);
    let m = 0;
    function S(_) {
      h.load(e[_], function(T) {
        const C = o.parse(T, !0);
        l[_] = {
          width: C.width,
          height: C.height,
          format: C.format,
          mipmaps: C.mipmaps
        }, m += 1, m === 6 && (C.mipmapCount === 1 && (d.minFilter = Po), d.image = l, d.format = C.format, d.needsUpdate = !0, t && t(d));
      }, r, i);
    }
    if (Array.isArray(e))
      for (let _ = 0, T = e.length; _ < T; ++_)
        S(_);
    else
      h.load(e, function(_) {
        const T = o.parse(_, !0);
        if (T.isCubemap) {
          const C = T.mipmaps.length / T.mipmapCount;
          for (let D = 0; D < C; D++) {
            l[D] = { mipmaps: [] };
            for (let P = 0; P < T.mipmapCount; P++)
              l[D].mipmaps.push(T.mipmaps[D * T.mipmapCount + P]), l[D].format = T.format, l[D].width = T.width, l[D].height = T.height;
          }
          d.image = l;
        } else
          d.image.width = T.width, d.image.height = T.height, d.mipmaps = T.mipmaps;
        T.mipmapCount === 1 && (d.minFilter = Po), d.format = T.format, d.needsUpdate = !0, t && t(d);
      }, r, i);
    return d;
  }
}
class WM extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = YS.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const d = UM("img");
    function h() {
      S(), YS.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function m(_) {
      S(), i && i(_), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function S() {
      d.removeEventListener("load", h, !1), d.removeEventListener("error", m, !1);
    }
    return d.addEventListener("load", h, !1), d.addEventListener("error", m, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (d.crossOrigin = this.crossOrigin), o.manager.itemStart(e), d.src = e, d;
  }
}
class KW extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new eT(), l = new WM(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let d = 0;
    function h(m) {
      l.load(e[m], function(S) {
        o.images[m] = S, d++, d === 6 && (o.needsUpdate = !0, t && t(o));
      }, void 0, i);
    }
    for (let m = 0; m < e.length; ++m)
      h(m);
    return o;
  }
}
class $W extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new jb(), d = new P0(this.manager);
    return d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setPath(this.path), d.setWithCredentials(o.withCredentials), d.load(e, function(h) {
      const m = o.parse(h);
      !m || (m.image !== void 0 ? l.image = m.image : m.data !== void 0 && (l.image.width = m.width, l.image.height = m.height, l.image.data = m.data), l.wrapS = m.wrapS !== void 0 ? m.wrapS : Wh, l.wrapT = m.wrapT !== void 0 ? m.wrapT : Wh, l.magFilter = m.magFilter !== void 0 ? m.magFilter : Po, l.minFilter = m.minFilter !== void 0 ? m.minFilter : Po, l.anisotropy = m.anisotropy !== void 0 ? m.anisotropy : 1, m.encoding !== void 0 && (l.encoding = m.encoding), m.flipY !== void 0 && (l.flipY = m.flipY), m.format !== void 0 && (l.format = m.format), m.type !== void 0 && (l.type = m.type), m.mipmaps !== void 0 && (l.mipmaps = m.mipmaps, l.minFilter = s1), m.mipmapCount === 1 && (l.minFilter = Po), m.generateMipmaps !== void 0 && (l.generateMipmaps = m.generateMipmaps), l.needsUpdate = !0, t && t(l, m));
    }, r, i), l;
  }
}
class e7 extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = new iu(), l = new WM(this.manager);
    return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(d) {
      o.image = d, o.needsUpdate = !0, t !== void 0 && t(o);
    }, r, i), o;
  }
}
class l1 extends Xa {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Pn(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class s4 extends l1 {
  constructor(e, t, r) {
    super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Xa.DefaultUp), this.updateMatrix(), this.groundColor = new Pn(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const LU = /* @__PURE__ */ new si(), PU = /* @__PURE__ */ new ge(), OU = /* @__PURE__ */ new ge();
class vL {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ft(512, 512), this.map = null, this.mapPass = null, this.matrix = new si(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new IC(), this._frameExtents = new Ft(1, 1), this._viewportCount = 1, this._viewports = [
      new la(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, r = this.matrix;
    PU.setFromMatrixPosition(e.matrixWorld), t.position.copy(PU), OU.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(OU), t.updateMatrixWorld(), LU.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(LU), r.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), r.multiply(t.projectionMatrix), r.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class t7 extends vL {
  constructor() {
    super(new fo(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, r = OM * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, o = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || o !== t.far) && (t.fov = r, t.aspect = i, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class o4 extends l1 {
  constructor(e, t, r = 0, i = Math.PI / 3, o = 0, l = 1) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Xa.DefaultUp), this.updateMatrix(), this.target = new Xa(), this.distance = r, this.angle = i, this.penumbra = o, this.decay = l, this.shadow = new t7();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const UU = /* @__PURE__ */ new si(), rM = /* @__PURE__ */ new ge(), tD = /* @__PURE__ */ new ge();
class n7 extends vL {
  constructor() {
    super(new fo(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ft(4, 2), this._viewportCount = 6, this._viewports = [
      new la(2, 1, 1, 1),
      new la(0, 1, 1, 1),
      new la(3, 1, 1, 1),
      new la(1, 1, 1, 1),
      new la(3, 0, 1, 1),
      new la(1, 0, 1, 1)
    ], this._cubeDirections = [
      new ge(1, 0, 0),
      new ge(-1, 0, 0),
      new ge(0, 0, 1),
      new ge(0, 0, -1),
      new ge(0, 1, 0),
      new ge(0, -1, 0)
    ], this._cubeUps = [
      new ge(0, 1, 0),
      new ge(0, 1, 0),
      new ge(0, 1, 0),
      new ge(0, 1, 0),
      new ge(0, 0, 1),
      new ge(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const r = this.camera, i = this.matrix, o = e.distance || r.far;
    o !== r.far && (r.far = o, r.updateProjectionMatrix()), rM.setFromMatrixPosition(e.matrixWorld), r.position.copy(rM), tD.copy(r.position), tD.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(tD), r.updateMatrixWorld(), i.makeTranslation(-rM.x, -rM.y, -rM.z), UU.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(UU);
  }
}
class l4 extends l1 {
  constructor(e, t, r = 0, i = 1) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new n7();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class r7 extends vL {
  constructor() {
    super(new cy(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class u4 extends l1 {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Xa.DefaultUp), this.updateMatrix(), this.target = new Xa(), this.shadow = new r7();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class c4 extends l1 {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class f4 extends l1 {
  constructor(e, t, r = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class d4 {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new ge());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * i), t.addScaledVector(l[2], 0.488603 * o), t.addScaledVector(l[3], 0.488603 * r), t.addScaledVector(l[4], 1.092548 * (r * i)), t.addScaledVector(l[5], 1.092548 * (i * o)), t.addScaledVector(l[6], 0.315392 * (3 * o * o - 1)), t.addScaledVector(l[7], 1.092548 * (r * o)), t.addScaledVector(l[8], 0.546274 * (r * r - i * i)), t;
  }
  getIrradianceAt(e, t) {
    const r = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * i), t.addScaledVector(l[2], 2 * 0.511664 * o), t.addScaledVector(l[3], 2 * 0.511664 * r), t.addScaledVector(l[4], 2 * 0.429043 * r * i), t.addScaledVector(l[5], 2 * 0.429043 * i * o), t.addScaledVector(l[6], 0.743125 * o * o - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * r * o), t.addScaledVector(l[8], 0.429043 * (r * r - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x, i = e.y, o = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * o, t[3] = 0.488603 * r, t[4] = 1.092548 * r * i, t[5] = 1.092548 * i * o, t[6] = 0.315392 * (3 * o * o - 1), t[7] = 1.092548 * r * o, t[8] = 0.546274 * (r * r - i * i);
  }
}
class QC extends l1 {
  constructor(e = new d4(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class ZC extends Tm {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, i) {
    const o = this, l = new P0(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(d) {
      try {
        t(o.parse(JSON.parse(d)));
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = this.textures;
    function r(o) {
      return t[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), t[o];
    }
    const i = ZC.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Pn().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const o in e.uniforms) {
        const l = e.uniforms[o];
        switch (i.uniforms[o] = {}, l.type) {
          case "t":
            i.uniforms[o].value = r(l.value);
            break;
          case "c":
            i.uniforms[o].value = new Pn().setHex(l.value);
            break;
          case "v2":
            i.uniforms[o].value = new Ft().fromArray(l.value);
            break;
          case "v3":
            i.uniforms[o].value = new ge().fromArray(l.value);
            break;
          case "v4":
            i.uniforms[o].value = new la().fromArray(l.value);
            break;
          case "m3":
            i.uniforms[o].value = new jh().fromArray(l.value);
            break;
          case "m4":
            i.uniforms[o].value = new si().fromArray(l.value);
            break;
          default:
            i.uniforms[o].value = l.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.extensions !== void 0)
      for (const o in e.extensions)
        i.extensions[o] = e.extensions[o];
    if (e.shading !== void 0 && (i.flatShading = e.shading === 1), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]), i.normalScale = new Ft().fromArray(o);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Ft().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: XF,
      SpriteMaterial: eL,
      RawShaderMaterial: qF,
      ShaderMaterial: wu,
      PointsMaterial: nL,
      MeshPhysicalMaterial: QF,
      MeshStandardMaterial: BM,
      MeshPhongMaterial: ZF,
      MeshToonMaterial: JF,
      MeshNormalMaterial: cL,
      MeshLambertMaterial: KF,
      MeshDepthMaterial: tT,
      MeshDistanceMaterial: HC,
      MeshBasicMaterial: og,
      MeshMatcapMaterial: $F,
      LineDashedMaterial: e4,
      LineBasicMaterial: ph,
      Material: ff
    };
    return new t[e]();
  }
}
class S3 {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class JC extends ui {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class h4 extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new P0(o.manager);
    l.setPath(o.path), l.setRequestHeader(o.requestHeader), l.setWithCredentials(o.withCredentials), l.load(e, function(d) {
      try {
        t(o.parse(JSON.parse(d)));
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = {}, r = {};
    function i(C, D) {
      if (t[D] !== void 0)
        return t[D];
      const U = C.interleavedBuffers[D], B = o(C, U.buffer), k = Bb(U.type, B), V = new WC(k, U.stride);
      return V.uuid = U.uuid, t[D] = V, V;
    }
    function o(C, D) {
      if (r[D] !== void 0)
        return r[D];
      const U = C.arrayBuffers[D], B = new Uint32Array(U).buffer;
      return r[D] = B, B;
    }
    const l = e.isInstancedBufferGeometry ? new JC() : new ui(), d = e.data.index;
    if (d !== void 0) {
      const C = Bb(d.type, d.array);
      l.setIndex(new os(C, 1));
    }
    const h = e.data.attributes;
    for (const C in h) {
      const D = h[C];
      let P;
      if (D.isInterleavedBufferAttribute) {
        const U = i(e.data, D.data);
        P = new _m(U, D.itemSize, D.offset, D.normalized);
      } else {
        const U = Bb(D.type, D.array), B = D.isInstancedBufferAttribute ? WS : os;
        P = new B(U, D.itemSize, D.normalized);
      }
      D.name !== void 0 && (P.name = D.name), D.usage !== void 0 && P.setUsage(D.usage), D.updateRange !== void 0 && (P.updateRange.offset = D.updateRange.offset, P.updateRange.count = D.updateRange.count), l.setAttribute(C, P);
    }
    const m = e.data.morphAttributes;
    if (m)
      for (const C in m) {
        const D = m[C], P = [];
        for (let U = 0, B = D.length; U < B; U++) {
          const k = D[U];
          let V;
          if (k.isInterleavedBufferAttribute) {
            const I = i(e.data, k.data);
            V = new _m(I, k.itemSize, k.offset, k.normalized);
          } else {
            const I = Bb(k.type, k.array);
            V = new os(I, k.itemSize, k.normalized);
          }
          k.name !== void 0 && (V.name = k.name), P.push(V);
        }
        l.morphAttributes[C] = P;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const _ = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (_ !== void 0)
      for (let C = 0, D = _.length; C !== D; ++C) {
        const P = _[C];
        l.addGroup(P.start, P.count, P.materialIndex);
      }
    const T = e.data.boundingSphere;
    if (T !== void 0) {
      const C = new ge();
      T.center !== void 0 && C.fromArray(T.center), l.boundingSphere = new vy(C, T.radius);
    }
    return e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
  }
}
class i7 extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = this.path === "" ? S3.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const d = new P0(this.manager);
    d.setPath(this.path), d.setRequestHeader(this.requestHeader), d.setWithCredentials(this.withCredentials), d.load(e, function(h) {
      let m = null;
      try {
        m = JSON.parse(h);
      } catch (_) {
        i !== void 0 && i(_), console.error("THREE:ObjectLoader: Can't parse " + e + ".", _.message);
        return;
      }
      const S = m.metadata;
      if (S === void 0 || S.type === void 0 || S.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      o.parse(m, t);
    }, r, i);
  }
  async loadAsync(e, t) {
    const r = this, i = this.path === "" ? S3.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new P0(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
    const l = await o.loadAsync(e, t), d = JSON.parse(l), h = d.metadata;
    if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(d);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), o = this.parseGeometries(e.geometries, i), l = this.parseImages(e.images, function() {
      t !== void 0 && t(m);
    }), d = this.parseTextures(e.textures, l), h = this.parseMaterials(e.materials, d), m = this.parseObject(e.object, o, h, d, r), S = this.parseSkeletons(e.skeletons, m);
    if (this.bindSkeletons(m, S), t !== void 0) {
      let _ = !1;
      for (const T in l)
        if (l[T].data instanceof HTMLImageElement) {
          _ = !0;
          break;
        }
      _ === !1 && t(m);
    }
    return m;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), o = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, o), d = this.parseMaterials(e.materials, l), h = this.parseObject(e.object, i, d, l, t), m = this.parseSkeletons(e.skeletons, h);
    return this.bindSkeletons(h, m), h;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new IS().fromJSON(e[r]);
        t[o.uuid] = o;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {}, i = {};
    if (t.traverse(function(o) {
      o.isBone && (i[o.uuid] = o);
    }), e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const d = new jC().fromJSON(e[o], i);
        r[d.uuid] = d;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new h4();
      for (let o = 0, l = e.length; o < l; o++) {
        let d;
        const h = e[o];
        switch (h.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            d = i.parse(h);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            h.type in DU ? d = DU[h.type].fromJSON(h, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${h.type}"`);
        }
        d.uuid = h.uuid, h.name !== void 0 && (d.name = h.name), d.isBufferGeometry === !0 && h.userData !== void 0 && (d.userData = h.userData), r[h.uuid] = d;
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {}, i = {};
    if (e !== void 0) {
      const o = new ZC();
      o.setTextures(t);
      for (let l = 0, d = e.length; l < d; l++) {
        const h = e[l];
        if (h.type === "MultiMaterial") {
          const m = [];
          for (let S = 0; S < h.materials.length; S++) {
            const _ = h.materials[S];
            r[_.uuid] === void 0 && (r[_.uuid] = o.parse(_)), m.push(r[_.uuid]);
          }
          i[h.uuid] = m;
        } else
          r[h.uuid] === void 0 && (r[h.uuid] = o.parse(h)), i[h.uuid] = r[h.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r], o = GM.parse(i);
        t[o.uuid] = o;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this, i = {};
    let o;
    function l(h) {
      return r.manager.itemStart(h), o.load(h, function() {
        r.manager.itemEnd(h);
      }, void 0, function() {
        r.manager.itemError(h), r.manager.itemEnd(h);
      });
    }
    function d(h) {
      if (typeof h == "string") {
        const m = h, S = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(m) ? m : r.resourcePath + m;
        return l(S);
      } else
        return h.data ? {
          data: Bb(h.type, h.data),
          width: h.width,
          height: h.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const h = new mL(t);
      o = new WM(h), o.setCrossOrigin(this.crossOrigin);
      for (let m = 0, S = e.length; m < S; m++) {
        const _ = e[m], T = _.url;
        if (Array.isArray(T)) {
          const C = [];
          for (let D = 0, P = T.length; D < P; D++) {
            const U = T[D], B = d(U);
            B !== null && (B instanceof HTMLImageElement ? C.push(B) : C.push(new jb(B.data, B.width, B.height)));
          }
          i[_.uuid] = new OS(C);
        } else {
          const C = d(_.url);
          i[_.uuid] = new OS(C);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, r = {};
    let i;
    async function o(l) {
      if (typeof l == "string") {
        const d = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : t.resourcePath + d;
        return await i.loadAsync(h);
      } else
        return l.data ? {
          data: Bb(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new WM(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let l = 0, d = e.length; l < d; l++) {
        const h = e[l], m = h.url;
        if (Array.isArray(m)) {
          const S = [];
          for (let _ = 0, T = m.length; _ < T; _++) {
            const C = m[_], D = await o(C);
            D !== null && (D instanceof HTMLImageElement ? S.push(D) : S.push(new jb(D.data, D.width, D.height)));
          }
          r[h.uuid] = new OS(S);
        } else {
          const S = await o(h.url);
          r[h.uuid] = new OS(S);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(o, l) {
      return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), l[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, l = e.length; o < l; o++) {
        const d = e[o];
        d.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', d.uuid), t[d.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", d.image);
        const h = t[d.image], m = h.data;
        let S;
        Array.isArray(m) ? (S = new eT(), m.length === 6 && (S.needsUpdate = !0)) : (m && m.data ? S = new jb() : S = new iu(), m && (S.needsUpdate = !0)), S.source = h, S.uuid = d.uuid, d.name !== void 0 && (S.name = d.name), d.mapping !== void 0 && (S.mapping = r(d.mapping, a7)), d.offset !== void 0 && S.offset.fromArray(d.offset), d.repeat !== void 0 && S.repeat.fromArray(d.repeat), d.center !== void 0 && S.center.fromArray(d.center), d.rotation !== void 0 && (S.rotation = d.rotation), d.wrap !== void 0 && (S.wrapS = r(d.wrap[0], zU), S.wrapT = r(d.wrap[1], zU)), d.format !== void 0 && (S.format = d.format), d.type !== void 0 && (S.type = d.type), d.encoding !== void 0 && (S.encoding = d.encoding), d.minFilter !== void 0 && (S.minFilter = r(d.minFilter, NU)), d.magFilter !== void 0 && (S.magFilter = r(d.magFilter, NU)), d.anisotropy !== void 0 && (S.anisotropy = d.anisotropy), d.flipY !== void 0 && (S.flipY = d.flipY), d.premultiplyAlpha !== void 0 && (S.premultiplyAlpha = d.premultiplyAlpha), d.unpackAlignment !== void 0 && (S.unpackAlignment = d.unpackAlignment), d.userData !== void 0 && (S.userData = d.userData), i[d.uuid] = S;
      }
    return i;
  }
  parseObject(e, t, r, i, o) {
    let l;
    function d(T) {
      return t[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", T), t[T];
    }
    function h(T) {
      if (T !== void 0) {
        if (Array.isArray(T)) {
          const C = [];
          for (let D = 0, P = T.length; D < P; D++) {
            const U = T[D];
            r[U] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", U), C.push(r[U]);
          }
          return C;
        }
        return r[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", T), r[T];
      }
    }
    function m(T) {
      return i[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", T), i[T];
    }
    let S, _;
    switch (e.type) {
      case "Scene":
        l = new zM(), e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new Pn(e.background) : l.background = m(e.background)), e.environment !== void 0 && (l.environment = m(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new GC(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new VC(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        l = new fo(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        l = new cy(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new c4(e.color, e.intensity);
        break;
      case "DirectionalLight":
        l = new u4(e.color, e.intensity);
        break;
      case "PointLight":
        l = new l4(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new f4(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        l = new o4(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        l = new s4(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new QC().fromJSON(e);
        break;
      case "SkinnedMesh":
        S = d(e.geometry), _ = h(e.material), l = new OF(S, _), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        S = d(e.geometry), _ = h(e.material), l = new zn(S, _);
        break;
      case "InstancedMesh":
        S = d(e.geometry), _ = h(e.material);
        const T = e.count, C = e.instanceMatrix, D = e.instanceColor;
        l = new UF(S, _, T), l.instanceMatrix = new WS(new Float32Array(C.array), 16), D !== void 0 && (l.instanceColor = new WS(new Float32Array(D.array), D.itemSize));
        break;
      case "LOD":
        l = new PF();
        break;
      case "Line":
        l = new ch(d(e.geometry), h(e.material));
        break;
      case "LineLoop":
        l = new zF(d(e.geometry), h(e.material));
        break;
      case "LineSegments":
        l = new gy(d(e.geometry), h(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new NF(d(e.geometry), h(e.material));
        break;
      case "Sprite":
        l = new LF(h(e.material));
        break;
      case "Group":
        l = new Vb();
        break;
      case "Bone":
        l = new tL();
        break;
      default:
        l = new Xa();
    }
    if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
      const T = e.children;
      for (let C = 0; C < T.length; C++)
        l.add(this.parseObject(T[C], t, r, i, o));
    }
    if (e.animations !== void 0) {
      const T = e.animations;
      for (let C = 0; C < T.length; C++) {
        const D = T[C];
        l.animations.push(o[D]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const T = e.levels;
      for (let C = 0; C < T.length; C++) {
        const D = T[C], P = l.getObjectByProperty("uuid", D.object);
        P !== void 0 && l.addLevel(P, D.distance);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(r) {
      if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
        const i = t[r.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix);
      }
    });
  }
}
const a7 = {
  UVMapping: NC,
  CubeReflectionMapping: t1,
  CubeRefractionMapping: n1,
  EquirectangularReflectionMapping: TM,
  EquirectangularRefractionMapping: CM,
  CubeUVReflectionMapping: dw
}, zU = {
  RepeatWrapping: Qb,
  ClampToEdgeWrapping: Wh,
  MirroredRepeatWrapping: RM
}, NU = {
  NearestFilter: co,
  NearestMipmapNearestFilter: wC,
  NearestMipmapLinearFilter: EC,
  LinearFilter: Po,
  LinearMipmapNearestFilter: W3,
  LinearMipmapLinearFilter: s1
};
class s7 extends Tm {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, l = YS.get(e);
    if (l !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        t && t(l), o.manager.itemEnd(e);
      }, 0), l;
    const d = {};
    d.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", d.headers = this.requestHeader, fetch(e, d).then(function(h) {
      return h.blob();
    }).then(function(h) {
      return createImageBitmap(h, Object.assign(o.options, { colorSpaceConversion: "none" }));
    }).then(function(h) {
      YS.add(e, h), t && t(h), o.manager.itemEnd(e);
    }).catch(function(h) {
      i && i(h), o.manager.itemError(e), o.manager.itemEnd(e);
    }), o.manager.itemStart(e);
  }
}
let H2;
const gL = {
  getContext: function() {
    return H2 === void 0 && (H2 = new (window.AudioContext || window.webkitAudioContext)()), H2;
  },
  setContext: function(a) {
    H2 = a;
  }
};
class o7 extends Tm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const o = this, l = new P0(this.manager);
    l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(d) {
      try {
        const h = d.slice(0);
        gL.getContext().decodeAudioData(h, function(S) {
          t(S);
        });
      } catch (h) {
        i ? i(h) : console.error(h), o.manager.itemError(e);
      }
    }, r, i);
  }
}
class l7 extends QC {
  constructor(e, t, r = 1) {
    super(void 0, r), this.isHemisphereLightProbe = !0;
    const i = new Pn().set(e), o = new Pn().set(t), l = new ge(i.r, i.g, i.b), d = new ge(o.r, o.g, o.b), h = Math.sqrt(Math.PI), m = h * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(l).add(d).multiplyScalar(h), this.sh.coefficients[1].copy(l).sub(d).multiplyScalar(m);
  }
}
class u7 extends QC {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const r = new Pn().set(e);
    this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const FU = /* @__PURE__ */ new si(), kU = /* @__PURE__ */ new si(), gS = /* @__PURE__ */ new si();
class c7 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new fo(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new fo(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, gS.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, o = i * t.near / t.focus, l = t.near * Math.tan(NS * t.fov * 0.5) / t.zoom;
      let d, h;
      kU.elements[12] = -i, FU.elements[12] = i, d = -l * t.aspect + o, h = l * t.aspect + o, gS.elements[0] = 2 * t.near / (h - d), gS.elements[8] = (h + d) / (h - d), this.cameraL.projectionMatrix.copy(gS), d = -l * t.aspect - o, h = l * t.aspect - o, gS.elements[0] = 2 * t.near / (h - d), gS.elements[8] = (h + d) / (h - d), this.cameraR.projectionMatrix.copy(gS);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(kU), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(FU);
  }
}
class yL {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = IU(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = IU();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function IU() {
  return (typeof performance > "u" ? Date : performance).now();
}
const yS = /* @__PURE__ */ new ge(), BU = /* @__PURE__ */ new Ko(), f7 = /* @__PURE__ */ new ge(), xS = /* @__PURE__ */ new ge();
class d7 extends Xa {
  constructor() {
    super(), this.type = "AudioListener", this.context = gL.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new yL();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, r = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(yS, BU, f7), xS.set(0, 0, -1).applyQuaternion(BU), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(yS.x, i), t.positionY.linearRampToValueAtTime(yS.y, i), t.positionZ.linearRampToValueAtTime(yS.z, i), t.forwardX.linearRampToValueAtTime(xS.x, i), t.forwardY.linearRampToValueAtTime(xS.y, i), t.forwardZ.linearRampToValueAtTime(xS.z, i), t.upX.linearRampToValueAtTime(r.x, i), t.upY.linearRampToValueAtTime(r.y, i), t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(yS.x, yS.y, yS.z), t.setOrientation(xS.x, xS.y, xS.z, r.x, r.y, r.z);
  }
}
class p4 extends Xa {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const SS = /* @__PURE__ */ new ge(), HU = /* @__PURE__ */ new Ko(), h7 = /* @__PURE__ */ new ge(), _S = /* @__PURE__ */ new ge();
class p7 extends p4 {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, r) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(SS, HU, h7), _S.set(0, 0, 1).applyQuaternion(HU);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(SS.x, r), t.positionY.linearRampToValueAtTime(SS.y, r), t.positionZ.linearRampToValueAtTime(SS.z, r), t.orientationX.linearRampToValueAtTime(_S.x, r), t.orientationY.linearRampToValueAtTime(_S.y, r), t.orientationZ.linearRampToValueAtTime(_S.z, r);
    } else
      t.setPosition(SS.x, SS.y, SS.z), t.setOrientation(_S.x, _S.y, _S.z);
  }
}
class m7 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
}
class m4 {
  constructor(e, t, r) {
    this.binding = e, this.valueSize = r;
    let i, o, l;
    switch (t) {
      case "quaternion":
        i = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
        break;
      default:
        i = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const r = this.buffer, i = this.valueSize, o = e * i + i;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let d = 0; d !== i; ++d)
        r[o + d] = r[d];
      l = t;
    } else {
      l += t;
      const d = t / l;
      this._mixBufferRegion(r, o, 0, d, i);
    }
    this.cumulativeWeight = l;
  }
  accumulateAdditive(e) {
    const t = this.buffer, r = this.valueSize, i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, r), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, r = this.buffer, i = e * t + t, o = this.cumulativeWeight, l = this.cumulativeWeightAdditive, d = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
      const h = t * this._origIndex;
      this._mixBufferRegion(
        r,
        i,
        h,
        1 - o,
        t
      );
    }
    l > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let h = t, m = t + t; h !== m; ++h)
      if (r[h] !== r[h + t]) {
        d.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, r = this.valueSize, i = r * this._origIndex;
    e.getValue(t, i);
    for (let o = r, l = i; o !== l; ++o)
      t[o] = t[i + o % r];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let r = e; r < t; r++)
      this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, o) {
    if (i >= 0.5)
      for (let l = 0; l !== o; ++l)
        e[t + l] = e[r + l];
  }
  _slerp(e, t, r, i) {
    Ko.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, o) {
    const l = this._workIndex * o;
    Ko.multiplyQuaternionsFlat(e, l, e, t, e, r), Ko.slerpFlat(e, t, e, t, e, l, i);
  }
  _lerp(e, t, r, i, o) {
    const l = 1 - i;
    for (let d = 0; d !== o; ++d) {
      const h = t + d;
      e[h] = e[h] * l + e[r + d] * i;
    }
  }
  _lerpAdditive(e, t, r, i, o) {
    for (let l = 0; l !== o; ++l) {
      const d = t + l;
      e[d] = e[d] + e[r + l] * i;
    }
  }
}
const xL = "\\[\\]\\.:\\/", v7 = new RegExp("[" + xL + "]", "g"), SL = "[^" + xL + "]", g7 = "[^" + xL.replace("\\.", "") + "]", y7 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", SL), x7 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", g7), S7 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", SL), _7 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", SL), b7 = new RegExp(
  "^" + y7 + x7 + S7 + _7 + "$"
), w7 = ["material", "materials", "bones"];
class E7 {
  constructor(e, t, r) {
    const i = r || Ja.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_, i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class Ja {
  constructor(e, t, r) {
    this.path = t, this.parsedPath = r || Ja.parseTrackName(t), this.node = Ja.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup ? new Ja.Composite(e, t, r) : new Ja(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(v7, "");
  }
  static parseTrackName(e) {
    const t = b7.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      propertyIndex: t[6]
    }, i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      w7.indexOf(o) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = o);
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return r;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      const r = function(o) {
        for (let l = 0; l < o.length; l++) {
          const d = o[l];
          if (d.name === t || d.uuid === t)
            return d;
          const h = r(d.children);
          if (h)
            return h;
        }
        return null;
      }, i = r(e.children);
      if (i)
        return i;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i)
      r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, r = t.objectName, i = t.propertyName;
    let o = t.propertyIndex;
    if (e || (e = Ja.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (r) {
      let m = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let S = 0; S < e.length; S++)
            if (e[S].name === m) {
              m = S;
              break;
            }
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (m !== void 0) {
        if (e[m] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[m];
      }
    }
    const l = e[i];
    if (l === void 0) {
      const m = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + m + "." + i + " but it wasn't found.", e);
      return;
    }
    let d = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? d = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (d = this.Versioning.MatrixWorldNeedsUpdate);
    let h = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[o] !== void 0 && (o = e.morphTargetDictionary[o]);
      }
      h = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o;
    } else
      l.fromArray !== void 0 && l.toArray !== void 0 ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (h = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][d];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ja.Composite = E7;
Ja.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Ja.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Ja.prototype.GetterByBindingType = [
  Ja.prototype._getValue_direct,
  Ja.prototype._getValue_array,
  Ja.prototype._getValue_arrayElement,
  Ja.prototype._getValue_toArray
];
Ja.prototype.SetterByBindingTypeAndVersioning = [
  [
    Ja.prototype._setValue_direct,
    Ja.prototype._setValue_direct_setNeedsUpdate,
    Ja.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    Ja.prototype._setValue_array,
    Ja.prototype._setValue_array_setNeedsUpdate,
    Ja.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    Ja.prototype._setValue_arrayElement,
    Ja.prototype._setValue_arrayElement_setNeedsUpdate,
    Ja.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    Ja.prototype._setValue_fromArray,
    Ja.prototype._setValue_fromArray_setNeedsUpdate,
    Ja.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class M7 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = bm(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, r = this._paths, i = this._parsedPaths, o = this._bindings, l = o.length;
    let d, h = e.length, m = this.nCachedObjects_;
    for (let S = 0, _ = arguments.length; S !== _; ++S) {
      const T = arguments[S], C = T.uuid;
      let D = t[C];
      if (D === void 0) {
        D = h++, t[C] = D, e.push(T);
        for (let P = 0, U = l; P !== U; ++P)
          o[P].push(new Ja(T, r[P], i[P]));
      } else if (D < m) {
        d = e[D];
        const P = --m, U = e[P];
        t[U.uuid] = D, e[D] = U, t[C] = P, e[P] = T;
        for (let B = 0, k = l; B !== k; ++B) {
          const V = o[B], I = V[P];
          let X = V[D];
          V[D] = I, X === void 0 && (X = new Ja(T, r[B], i[B])), V[P] = X;
        }
      } else
        e[D] !== d && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = m;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let o = this.nCachedObjects_;
    for (let l = 0, d = arguments.length; l !== d; ++l) {
      const h = arguments[l], m = h.uuid, S = t[m];
      if (S !== void 0 && S >= o) {
        const _ = o++, T = e[_];
        t[T.uuid] = S, e[S] = T, t[m] = _, e[_] = h;
        for (let C = 0, D = i; C !== D; ++C) {
          const P = r[C], U = P[_], B = P[S];
          P[S] = U, P[_] = B;
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let o = this.nCachedObjects_, l = e.length;
    for (let d = 0, h = arguments.length; d !== h; ++d) {
      const m = arguments[d], S = m.uuid, _ = t[S];
      if (_ !== void 0)
        if (delete t[S], _ < o) {
          const T = --o, C = e[T], D = --l, P = e[D];
          t[C.uuid] = _, e[_] = C, t[P.uuid] = T, e[T] = P, e.pop();
          for (let U = 0, B = i; U !== B; ++U) {
            const k = r[U], V = k[T], I = k[D];
            k[_] = V, k[T] = I, k.pop();
          }
        } else {
          const T = --l, C = e[T];
          T > 0 && (t[C.uuid] = _), e[_] = C, e.pop();
          for (let D = 0, P = i; D !== P; ++D) {
            const U = r[D];
            U[_] = U[T], U.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0)
      return o[i];
    const l = this._paths, d = this._parsedPaths, h = this._objects, m = h.length, S = this.nCachedObjects_, _ = new Array(m);
    i = o.length, r[e] = i, l.push(e), d.push(t), o.push(_);
    for (let T = S, C = h.length; T !== C; ++T) {
      const D = h[T];
      _[T] = new Ja(D, e, t);
    }
    return _;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      const i = this._paths, o = this._parsedPaths, l = this._bindings, d = l.length - 1, h = l[d], m = e[d];
      t[m] = r, l[r] = h, l.pop(), o[r] = o[d], o.pop(), i[r] = i[d], i.pop();
    }
  }
}
class T7 {
  constructor(e, t, r = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i;
    const o = t.tracks, l = o.length, d = new Array(l), h = {
      endingStart: LS,
      endingEnd: LS
    };
    for (let m = 0; m !== l; ++m) {
      const S = o[m].createInterpolant(null);
      d[m] = S, S.settings = h;
    }
    this._interpolantSettings = h, this._interpolants = d, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = fF, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      const i = this._clip.duration, o = e._clip.duration, l = o / i, d = i / o;
      e.warp(1, l, t), this.warp(d, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer, o = i.time, l = this.timeScale;
    let d = this._timeScaleInterpolant;
    d === null && (d = i._lendControlInterpolant(), this._timeScaleInterpolant = d);
    const h = d.parameterPositions, m = d.sampleValues;
    return h[0] = o, h[1] = o + r, m[0] = e / l, m[1] = t / l, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const h = (e - o) * r;
      if (h < 0 || r === 0)
        return;
      this._startTime = null, t = r * h;
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t), d = this._updateWeight(e);
    if (d > 0) {
      const h = this._interpolants, m = this._propertyBindings;
      switch (this.blendMode) {
        case Y3:
          for (let S = 0, _ = h.length; S !== _; ++S)
            h[S].evaluate(l), m[S].accumulateAdditive(d);
          break;
        case FC:
        default:
          for (let S = 0, _ = h.length; S !== _; ++S)
            h[S].evaluate(l), m[S].accumulate(i, d);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        t *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      r !== null && (t *= r.evaluate(e)[0], e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t));
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, r = this.loop;
    let i = this.time + e, o = this._loopCount;
    const l = r === dF;
    if (e === 0)
      return o === -1 ? i : l && (o & 1) === 1 ? t - i : i;
    if (r === cF) {
      o === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (o === -1 && (e >= 0 ? (o = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), i >= t || i < 0) {
        const d = Math.floor(i / t);
        i -= t * d, o += Math.abs(d);
        const h = this.repetitions - o;
        if (h <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (h === 1) {
            const m = e < 0;
            this._setEndings(m, !m, l);
          } else
            this._setEndings(!1, !1, l);
          this._loopCount = o, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: d
          });
        }
      } else
        this.time = i;
      if (l && (o & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r ? (i.endingStart = PS, i.endingEnd = PS) : (e ? i.endingStart = this.zeroSlopeAtStart ? PS : LS : i.endingStart = LM, t ? i.endingEnd = this.zeroSlopeAtEnd ? PS : LS : i.endingEnd = LM);
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer, o = i.time;
    let l = this._weightInterpolant;
    l === null && (l = i._lendControlInterpolant(), this._weightInterpolant = l);
    const d = l.parameterPositions, h = l.sampleValues;
    return d[0] = o, h[0] = t, d[1] = o + e, h[1] = r, this;
  }
}
const C7 = new Float32Array(1);
class R7 extends Mm {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root, i = e._clip.tracks, o = i.length, l = e._propertyBindings, d = e._interpolants, h = r.uuid, m = this._bindingsByRootAndName;
    let S = m[h];
    S === void 0 && (S = {}, m[h] = S);
    for (let _ = 0; _ !== o; ++_) {
      const T = i[_], C = T.name;
      let D = S[C];
      if (D !== void 0)
        ++D.referenceCount, l[_] = D;
      else {
        if (D = l[_], D !== void 0) {
          D._cacheIndex === null && (++D.referenceCount, this._addInactiveBinding(D, h, C));
          continue;
        }
        const P = t && t._propertyBindings[_].binding.parsedPath;
        D = new m4(
          Ja.create(r, C, P),
          T.ValueTypeName,
          T.getValueSize()
        ), ++D.referenceCount, this._addInactiveBinding(D, h, C), l[_] = D;
      }
      d[_].resultBuffer = D.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, o = this._actionsByClip[i];
        this._bindAction(
          e,
          o && o.knownActions[0]
        ), this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const o = t[r];
        --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions, o = this._actionsByClip;
    let l = o[t];
    if (l === void 0)
      l = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, o[t] = l;
    else {
      const d = l.knownActions;
      e._byClipCacheIndex = d.length, d.push(e);
    }
    e._cacheIndex = i.length, i.push(e), l.actionByRoot[r] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, r = t[t.length - 1], i = e._cacheIndex;
    r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null;
    const o = e._clip.uuid, l = this._actionsByClip, d = l[o], h = d.knownActions, m = h[h.length - 1], S = e._byClipCacheIndex;
    m._byClipCacheIndex = S, h[S] = m, h.pop(), e._byClipCacheIndex = null;
    const _ = d.actionByRoot, T = (e._localRoot || this._root).uuid;
    delete _[T], h.length === 0 && delete l[o], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const o = t[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const t = this._actions, r = e._cacheIndex, i = this._nActiveActions++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  _takeBackAction(e) {
    const t = this._actions, r = e._cacheIndex, i = --this._nActiveActions, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName, o = this._bindings;
    let l = i[t];
    l === void 0 && (l = {}, i[t] = l), l[r] = e, e._cacheIndex = o.length, o.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, r = e.binding, i = r.rootNode.uuid, o = r.path, l = this._bindingsByRootAndName, d = l[i], h = t[t.length - 1], m = e._cacheIndex;
    h._cacheIndex = m, t[m] = h, t.pop(), delete d[o], Object.keys(d).length === 0 && delete l[i];
  }
  _lendBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  _takeBackBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, o = t[i];
    e._cacheIndex = i, t[i] = e, o._cacheIndex = r, t[r] = o;
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let r = e[t];
    return r === void 0 && (r = new hL(
      new Float32Array(2),
      new Float32Array(2),
      1,
      C7
    ), r.__cacheIndex = t, e[t] = r), r;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, o = t[i];
    e.__cacheIndex = i, t[i] = e, o.__cacheIndex = r, t[r] = o;
  }
  clipAction(e, t, r) {
    const i = t || this._root, o = i.uuid;
    let l = typeof e == "string" ? GM.findByName(i, e) : e;
    const d = l !== null ? l.uuid : e, h = this._actionsByClip[d];
    let m = null;
    if (r === void 0 && (l !== null ? r = l.blendMode : r = FC), h !== void 0) {
      const _ = h.actionByRoot[o];
      if (_ !== void 0 && _.blendMode === r)
        return _;
      m = h.knownActions[0], l === null && (l = m._clip);
    }
    if (l === null)
      return null;
    const S = new T7(this, l, t, r);
    return this._bindAction(S, m), this._addInactiveAction(S, d, o), S;
  }
  existingAction(e, t) {
    const r = t || this._root, i = r.uuid, o = typeof e == "string" ? GM.findByName(r, e) : e, l = o ? o.uuid : e, d = this._actionsByClip[l];
    return d !== void 0 && d.actionByRoot[i] || null;
  }
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r)
      e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions, r = this._nActiveActions, i = this.time += e, o = Math.sign(e), l = this._accuIndex ^= 1;
    for (let m = 0; m !== r; ++m)
      t[m]._update(i, e, o, l);
    const d = this._bindings, h = this._nActiveBindings;
    for (let m = 0; m !== h; ++m)
      d[m].apply(l);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions, r = e.uuid, i = this._actionsByClip, o = i[r];
    if (o !== void 0) {
      const l = o.knownActions;
      for (let d = 0, h = l.length; d !== h; ++d) {
        const m = l[d];
        this._deactivateAction(m);
        const S = m._cacheIndex, _ = t[t.length - 1];
        m._cacheIndex = null, m._byClipCacheIndex = null, _._cacheIndex = S, t[S] = _, t.pop(), this._removeInactiveBindingsForAction(m);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, r = this._actionsByClip;
    for (const l in r) {
      const d = r[l].actionByRoot, h = d[t];
      h !== void 0 && (this._deactivateAction(h), this._removeInactiveAction(h));
    }
    const i = this._bindingsByRootAndName, o = i[t];
    if (o !== void 0)
      for (const l in o) {
        const d = o[l];
        d.restoreOriginalState(), this._removeInactiveBinding(d);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class Bn {
  constructor(e) {
    typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
  }
  clone() {
    return new Bn(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let A7 = 0;
class D7 extends Mm {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: A7++ }), this.name = "", this.usage = PM, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++)
      this.uniforms.push(t[r].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class CC extends WC {
  constructor(e, t, r = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class L7 {
  constructor(e, t, r, i, o) {
    this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = i, this.count = o, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class _L {
  constructor(e, t, r = 0, i = 1 / 0) {
    this.ray = new KM(e, t), this.near = r, this.far = i, this.camera = null, this.layers = new kS(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, r = []) {
    return _3(e, this, r, t), r.sort(VU), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++)
      _3(e[i], this, r, t);
    return r.sort(VU), r;
  }
}
function VU(a, e) {
  return a.distance - e.distance;
}
function _3(a, e, t, r) {
  if (a.layers.test(e.layers) && a.raycast(e, t), r === !0) {
    const i = a.children;
    for (let o = 0, l = i.length; o < l; o++)
      _3(i[o], e, t, !0);
  }
}
class b3 {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Qu(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class P7 {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const GU = /* @__PURE__ */ new Ft();
class O7 {
  constructor(e = new Ft(1 / 0, 1 / 0), t = new Ft(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = GU.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return GU.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const WU = /* @__PURE__ */ new ge(), V2 = /* @__PURE__ */ new ge();
class bL {
  constructor(e = new ge(), t = new ge()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    WU.subVectors(e, this.start), V2.subVectors(this.end, this.start);
    const r = V2.dot(V2);
    let o = V2.dot(WU) / r;
    return t && (o = Qu(o, 0, 1)), o;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jU = /* @__PURE__ */ new ge();
class U7 extends Xa {
  constructor(e, t) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
    const r = new ui(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let l = 0, d = 1, h = 32; l < h; l++, d++) {
      const m = l / h * Math.PI * 2, S = d / h * Math.PI * 2;
      i.push(
        Math.cos(m),
        Math.sin(m),
        1,
        Math.cos(S),
        Math.sin(S),
        1
      );
    }
    r.setAttribute("position", new sr(i, 3));
    const o = new ph({ fog: !1, toneMapped: !1 });
    this.cone = new gy(r, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), jU.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(jU), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const jx = /* @__PURE__ */ new ge(), G2 = /* @__PURE__ */ new si(), nD = /* @__PURE__ */ new si();
class z7 extends gy {
  constructor(e) {
    const t = v4(e), r = new ui(), i = [], o = [], l = new Pn(0, 0, 1), d = new Pn(0, 1, 0);
    for (let m = 0; m < t.length; m++) {
      const S = t[m];
      S.parent && S.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), o.push(l.r, l.g, l.b), o.push(d.r, d.g, d.b));
    }
    r.setAttribute("position", new sr(i, 3)), r.setAttribute("color", new sr(o, 3));
    const h = new ph({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, h), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, r = this.geometry, i = r.getAttribute("position");
    nD.copy(this.root.matrixWorld).invert();
    for (let o = 0, l = 0; o < t.length; o++) {
      const d = t[o];
      d.parent && d.parent.isBone && (G2.multiplyMatrices(nD, d.matrixWorld), jx.setFromMatrixPosition(G2), i.setXYZ(l, jx.x, jx.y, jx.z), G2.multiplyMatrices(nD, d.parent.matrixWorld), jx.setFromMatrixPosition(G2), i.setXYZ(l + 1, jx.x, jx.y, jx.z), l += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
}
function v4(a) {
  const e = [];
  a.isBone === !0 && e.push(a);
  for (let t = 0; t < a.children.length; t++)
    e.push.apply(e, v4(a.children[t]));
  return e;
}
class N7 extends zn {
  constructor(e, t, r) {
    const i = new ag(t, 4, 2), o = new og({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o), this.light = e, this.light.updateMatrixWorld(), this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const F7 = /* @__PURE__ */ new ge(), YU = /* @__PURE__ */ new Pn(), XU = /* @__PURE__ */ new Pn();
class k7 extends Xa {
  constructor(e, t, r) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r;
    const i = new ng(t);
    i.rotateY(Math.PI * 0.5), this.material = new og({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"), l = new Float32Array(o.count * 3);
    i.setAttribute("color", new os(l, 3)), this.add(new zn(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      YU.copy(this.light.color), XU.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const o = r < i / 2 ? YU : XU;
        t.setXYZ(r, o.r, o.g, o.b);
      }
      t.needsUpdate = !0;
    }
    e.lookAt(F7.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class I7 extends gy {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    r = new Pn(r), i = new Pn(i);
    const o = t / 2, l = e / t, d = e / 2, h = [], m = [];
    for (let T = 0, C = 0, D = -d; T <= t; T++, D += l) {
      h.push(-d, 0, D, d, 0, D), h.push(D, 0, -d, D, 0, d);
      const P = T === o ? r : i;
      P.toArray(m, C), C += 3, P.toArray(m, C), C += 3, P.toArray(m, C), C += 3, P.toArray(m, C), C += 3;
    }
    const S = new ui();
    S.setAttribute("position", new sr(h, 3)), S.setAttribute("color", new sr(m, 3));
    const _ = new ph({ vertexColors: !0, toneMapped: !1 });
    super(S, _), this.type = "GridHelper";
  }
}
class B7 extends gy {
  constructor(e = 10, t = 16, r = 8, i = 64, o = 4473924, l = 8947848) {
    o = new Pn(o), l = new Pn(l);
    const d = [], h = [];
    for (let _ = 0; _ <= t; _++) {
      const T = _ / t * (Math.PI * 2), C = Math.sin(T) * e, D = Math.cos(T) * e;
      d.push(0, 0, 0), d.push(C, 0, D);
      const P = _ & 1 ? o : l;
      h.push(P.r, P.g, P.b), h.push(P.r, P.g, P.b);
    }
    for (let _ = 0; _ <= r; _++) {
      const T = _ & 1 ? o : l, C = e - e / r * _;
      for (let D = 0; D < i; D++) {
        let P = D / i * (Math.PI * 2), U = Math.sin(P) * C, B = Math.cos(P) * C;
        d.push(U, 0, B), h.push(T.r, T.g, T.b), P = (D + 1) / i * (Math.PI * 2), U = Math.sin(P) * C, B = Math.cos(P) * C, d.push(U, 0, B), h.push(T.r, T.g, T.b);
      }
    }
    const m = new ui();
    m.setAttribute("position", new sr(d, 3)), m.setAttribute("color", new sr(h, 3));
    const S = new ph({ vertexColors: !0, toneMapped: !1 });
    super(m, S), this.type = "PolarGridHelper";
  }
}
const qU = /* @__PURE__ */ new ge(), W2 = /* @__PURE__ */ new ge(), QU = /* @__PURE__ */ new ge();
class H7 extends Xa {
  constructor(e, t, r) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, t === void 0 && (t = 1);
    let i = new ui();
    i.setAttribute("position", new sr([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const o = new ph({ fog: !1, toneMapped: !1 });
    this.lightPlane = new ch(i, o), this.add(this.lightPlane), i = new ui(), i.setAttribute("position", new sr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ch(i, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    qU.setFromMatrixPosition(this.light.matrixWorld), W2.setFromMatrixPosition(this.light.target.matrixWorld), QU.subVectors(W2, qU), this.lightPlane.lookAt(W2), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(W2), this.targetLine.scale.z = QU.length();
  }
}
const j2 = /* @__PURE__ */ new ge(), bu = /* @__PURE__ */ new hw();
class V7 extends gy {
  constructor(e) {
    const t = new ui(), r = new ph({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], o = [], l = {};
    d("n1", "n2"), d("n2", "n4"), d("n4", "n3"), d("n3", "n1"), d("f1", "f2"), d("f2", "f4"), d("f4", "f3"), d("f3", "f1"), d("n1", "f1"), d("n2", "f2"), d("n3", "f3"), d("n4", "f4"), d("p", "n1"), d("p", "n2"), d("p", "n3"), d("p", "n4"), d("u1", "u2"), d("u2", "u3"), d("u3", "u1"), d("c", "t"), d("p", "c"), d("cn1", "cn2"), d("cn3", "cn4"), d("cf1", "cf2"), d("cf3", "cf4");
    function d(D, P) {
      h(D), h(P);
    }
    function h(D) {
      i.push(0, 0, 0), o.push(0, 0, 0), l[D] === void 0 && (l[D] = []), l[D].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new sr(i, 3)), t.setAttribute("color", new sr(o, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
    const m = new Pn(16755200), S = new Pn(16711680), _ = new Pn(43775), T = new Pn(16777215), C = new Pn(3355443);
    this.setColors(m, S, _, T, C);
  }
  setColors(e, t, r, i, o) {
    const d = this.geometry.getAttribute("color");
    d.setXYZ(0, e.r, e.g, e.b), d.setXYZ(1, e.r, e.g, e.b), d.setXYZ(2, e.r, e.g, e.b), d.setXYZ(3, e.r, e.g, e.b), d.setXYZ(4, e.r, e.g, e.b), d.setXYZ(5, e.r, e.g, e.b), d.setXYZ(6, e.r, e.g, e.b), d.setXYZ(7, e.r, e.g, e.b), d.setXYZ(8, e.r, e.g, e.b), d.setXYZ(9, e.r, e.g, e.b), d.setXYZ(10, e.r, e.g, e.b), d.setXYZ(11, e.r, e.g, e.b), d.setXYZ(12, e.r, e.g, e.b), d.setXYZ(13, e.r, e.g, e.b), d.setXYZ(14, e.r, e.g, e.b), d.setXYZ(15, e.r, e.g, e.b), d.setXYZ(16, e.r, e.g, e.b), d.setXYZ(17, e.r, e.g, e.b), d.setXYZ(18, e.r, e.g, e.b), d.setXYZ(19, e.r, e.g, e.b), d.setXYZ(20, e.r, e.g, e.b), d.setXYZ(21, e.r, e.g, e.b), d.setXYZ(22, e.r, e.g, e.b), d.setXYZ(23, e.r, e.g, e.b), d.setXYZ(24, t.r, t.g, t.b), d.setXYZ(25, t.r, t.g, t.b), d.setXYZ(26, t.r, t.g, t.b), d.setXYZ(27, t.r, t.g, t.b), d.setXYZ(28, t.r, t.g, t.b), d.setXYZ(29, t.r, t.g, t.b), d.setXYZ(30, t.r, t.g, t.b), d.setXYZ(31, t.r, t.g, t.b), d.setXYZ(32, r.r, r.g, r.b), d.setXYZ(33, r.r, r.g, r.b), d.setXYZ(34, r.r, r.g, r.b), d.setXYZ(35, r.r, r.g, r.b), d.setXYZ(36, r.r, r.g, r.b), d.setXYZ(37, r.r, r.g, r.b), d.setXYZ(38, i.r, i.g, i.b), d.setXYZ(39, i.r, i.g, i.b), d.setXYZ(40, o.r, o.g, o.b), d.setXYZ(41, o.r, o.g, o.b), d.setXYZ(42, o.r, o.g, o.b), d.setXYZ(43, o.r, o.g, o.b), d.setXYZ(44, o.r, o.g, o.b), d.setXYZ(45, o.r, o.g, o.b), d.setXYZ(46, o.r, o.g, o.b), d.setXYZ(47, o.r, o.g, o.b), d.setXYZ(48, o.r, o.g, o.b), d.setXYZ(49, o.r, o.g, o.b), d.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, r = 1, i = 1;
    bu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Xu("c", t, e, bu, 0, 0, -1), Xu("t", t, e, bu, 0, 0, 1), Xu("n1", t, e, bu, -r, -i, -1), Xu("n2", t, e, bu, r, -i, -1), Xu("n3", t, e, bu, -r, i, -1), Xu("n4", t, e, bu, r, i, -1), Xu("f1", t, e, bu, -r, -i, 1), Xu("f2", t, e, bu, r, -i, 1), Xu("f3", t, e, bu, -r, i, 1), Xu("f4", t, e, bu, r, i, 1), Xu("u1", t, e, bu, r * 0.7, i * 1.1, -1), Xu("u2", t, e, bu, -r * 0.7, i * 1.1, -1), Xu("u3", t, e, bu, 0, i * 2, -1), Xu("cf1", t, e, bu, -r, 0, 1), Xu("cf2", t, e, bu, r, 0, 1), Xu("cf3", t, e, bu, 0, -i, 1), Xu("cf4", t, e, bu, 0, i, 1), Xu("cn1", t, e, bu, -r, 0, -1), Xu("cn2", t, e, bu, r, 0, -1), Xu("cn3", t, e, bu, 0, -i, -1), Xu("cn4", t, e, bu, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Xu(a, e, t, r, i, o, l) {
  j2.set(i, o, l).unproject(r);
  const d = e[a];
  if (d !== void 0) {
    const h = t.getAttribute("position");
    for (let m = 0, S = d.length; m < S; m++)
      h.setXYZ(d[m], j2.x, j2.y, j2.z);
  }
}
const Y2 = /* @__PURE__ */ new sg();
class G7 extends gy {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), o = new ui();
    o.setIndex(new os(r, 1)), o.setAttribute("position", new os(i, 3)), super(o, new ph({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Y2.setFromObject(this.object), Y2.isEmpty())
      return;
    const t = Y2.min, r = Y2.max, i = this.geometry.attributes.position, o = i.array;
    o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = t.x, o[4] = r.y, o[5] = r.z, o[6] = t.x, o[7] = t.y, o[8] = r.z, o[9] = r.x, o[10] = t.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = t.z, o[15] = t.x, o[16] = r.y, o[17] = t.z, o[18] = t.x, o[19] = t.y, o[20] = t.z, o[21] = r.x, o[22] = t.y, o[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
}
class W7 extends gy {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new ui();
    o.setIndex(new os(r, 1)), o.setAttribute("position", new sr(i, 3)), super(o, new ph({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
}
class j7 extends ch {
  constructor(e, t = 1, r = 16776960) {
    const i = r, o = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], l = new ui();
    l.setAttribute("position", new sr(o, 3)), l.computeBoundingSphere(), super(l, new ph({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const d = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], h = new ui();
    h.setAttribute("position", new sr(d, 3)), h.computeBoundingSphere(), this.add(new zn(h, new og({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
}
const ZU = /* @__PURE__ */ new ge();
let X2, rD;
class Y7 extends Xa {
  constructor(e = new ge(0, 0, 1), t = new ge(0, 0, 0), r = 1, i = 16776960, o = r * 0.2, l = o * 0.2) {
    super(), this.type = "ArrowHelper", X2 === void 0 && (X2 = new ui(), X2.setAttribute("position", new sr([0, 0, 0, 0, 1, 0], 3)), rD = new Jo(0, 0.5, 1, 5, 1), rD.translate(0, -0.5, 0)), this.position.copy(t), this.line = new ch(X2, new ph({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new zn(rD, new og({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, o, l);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      ZU.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(ZU, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
}
class X7 extends gy {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], r = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new ui();
    i.setAttribute("position", new sr(t, 3)), i.setAttribute("color", new sr(r, 3));
    const o = new ph({ vertexColors: !0, toneMapped: !1 });
    super(i, o), this.type = "AxesHelper";
  }
  setColors(e, t, r) {
    const i = new Pn(), o = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(o, 0), i.toArray(o, 3), i.set(t), i.toArray(o, 6), i.toArray(o, 9), i.set(r), i.toArray(o, 12), i.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class q7 {
  constructor() {
    this.type = "ShapePath", this.color = new Pn(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new NM(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, o, l) {
    return this.currentPath.bezierCurveTo(e, t, r, i, o, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e, t) {
    function r(k) {
      const V = [];
      for (let I = 0, X = k.length; I < X; I++) {
        const J = k[I], $ = new IS();
        $.curves = J.curves, V.push($);
      }
      return V;
    }
    function i(k, V) {
      const I = V.length;
      let X = !1;
      for (let J = I - 1, $ = 0; $ < I; J = $++) {
        let W = V[J], ee = V[$], ie = ee.x - W.x, pe = ee.y - W.y;
        if (Math.abs(pe) > Number.EPSILON) {
          if (pe < 0 && (W = V[$], ie = -ie, ee = V[J], pe = -pe), k.y < W.y || k.y > ee.y)
            continue;
          if (k.y === W.y) {
            if (k.x === W.x)
              return !0;
          } else {
            const ce = pe * (k.x - W.x) - ie * (k.y - W.y);
            if (ce === 0)
              return !0;
            if (ce < 0)
              continue;
            X = !X;
          }
        } else {
          if (k.y !== W.y)
            continue;
          if (ee.x <= k.x && k.x <= W.x || W.x <= k.x && k.x <= ee.x)
            return !0;
        }
      }
      return X;
    }
    const o = fy.isClockWise, l = this.subPaths;
    if (l.length === 0)
      return [];
    if (t === !0)
      return r(l);
    let d, h, m;
    const S = [];
    if (l.length === 1)
      return h = l[0], m = new IS(), m.curves = h.curves, S.push(m), S;
    let _ = !o(l[0].getPoints());
    _ = e ? !_ : _;
    const T = [], C = [];
    let D = [], P = 0, U;
    C[P] = void 0, D[P] = [];
    for (let k = 0, V = l.length; k < V; k++)
      h = l[k], U = h.getPoints(), d = o(U), d = e ? !d : d, d ? (!_ && C[P] && P++, C[P] = { s: new IS(), p: U }, C[P].s.curves = h.curves, _ && P++, D[P] = []) : D[P].push({ h, p: U[0] });
    if (!C[0])
      return r(l);
    if (C.length > 1) {
      let k = !1, V = 0;
      for (let I = 0, X = C.length; I < X; I++)
        T[I] = [];
      for (let I = 0, X = C.length; I < X; I++) {
        const J = D[I];
        for (let $ = 0; $ < J.length; $++) {
          const W = J[$];
          let ee = !0;
          for (let ie = 0; ie < C.length; ie++)
            i(W.p, C[ie].p) && (I !== ie && V++, ee ? (ee = !1, T[ie].push(W)) : k = !0);
          ee && T[I].push(W);
        }
      }
      V > 0 && k === !1 && (D = T);
    }
    let B;
    for (let k = 0, V = C.length; k < V; k++) {
      m = C[k].s, S.push(m), B = D[k];
      for (let I = 0, X = B.length; I < X; I++)
        m.holes.push(B[I].h);
    }
    return S;
  }
}
const R0 = /* @__PURE__ */ Q7();
function Q7() {
  const a = new ArrayBuffer(4), e = new Float32Array(a), t = new Uint32Array(a), r = new Uint32Array(512), i = new Uint32Array(512);
  for (let h = 0; h < 256; ++h) {
    const m = h - 127;
    m < -27 ? (r[h] = 0, r[h | 256] = 32768, i[h] = 24, i[h | 256] = 24) : m < -14 ? (r[h] = 1024 >> -m - 14, r[h | 256] = 1024 >> -m - 14 | 32768, i[h] = -m - 1, i[h | 256] = -m - 1) : m <= 15 ? (r[h] = m + 15 << 10, r[h | 256] = m + 15 << 10 | 32768, i[h] = 13, i[h | 256] = 13) : m < 128 ? (r[h] = 31744, r[h | 256] = 64512, i[h] = 24, i[h | 256] = 24) : (r[h] = 31744, r[h | 256] = 64512, i[h] = 13, i[h | 256] = 13);
  }
  const o = new Uint32Array(2048), l = new Uint32Array(64), d = new Uint32Array(64);
  for (let h = 1; h < 1024; ++h) {
    let m = h << 13, S = 0;
    for (; (m & 8388608) === 0; )
      m <<= 1, S -= 8388608;
    m &= -8388609, S += 947912704, o[h] = m | S;
  }
  for (let h = 1024; h < 2048; ++h)
    o[h] = 939524096 + (h - 1024 << 13);
  for (let h = 1; h < 31; ++h)
    l[h] = h << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let h = 33; h < 63; ++h)
    l[h] = 2147483648 + (h - 32 << 23);
  l[63] = 3347054592;
  for (let h = 1; h < 64; ++h)
    h !== 32 && (d[h] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: l,
    offsetTable: d
  };
}
function Z7(a) {
  Math.abs(a) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), a = Qu(a, -65504, 65504), R0.floatView[0] = a;
  const e = R0.uint32View[0], t = e >> 23 & 511;
  return R0.baseTable[t] + ((e & 8388607) >> R0.shiftTable[t]);
}
function J7(a) {
  const e = a >> 10;
  return R0.uint32View[0] = R0.mantissaTable[R0.offsetTable[e] + (a & 1023)] + R0.exponentTable[e], R0.floatView[0];
}
var K7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toHalfFloat: Z7,
  fromHalfFloat: J7
});
class $7 extends ui {
  constructor() {
    console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), super();
  }
}
class e9 extends ui {
  constructor() {
    console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), super();
  }
}
function t9() {
  console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
}
function n9() {
  console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
}
function r9() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
class g4 extends po {
  constructor(e, t, r) {
    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, r), this.samples = 4;
  }
}
class i9 extends JM {
  constructor(e, t, r, i) {
    console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, r, i);
  }
}
class a9 extends kC {
  constructor(e, t, r, i) {
    console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, r, i);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: U0
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = U0);
const RC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: G3,
  AddEquation: AS,
  AddOperation: WN,
  AdditiveAnimationBlendMode: Y3,
  AdditiveBlending: _C,
  AlphaFormat: eF,
  AlwaysDepth: FN,
  AlwaysStencilFunc: pF,
  AmbientLight: c4,
  AmbientLightProbe: u7,
  AnimationClip: GM,
  AnimationLoader: ZW,
  AnimationMixer: R7,
  AnimationObjectGroup: M7,
  AnimationUtils: YW,
  ArcCurve: kF,
  ArrayCamera: RF,
  ArrowHelper: Y7,
  Audio: p4,
  AudioAnalyser: m7,
  AudioContext: gL,
  AudioListener: d7,
  AudioLoader: o7,
  AxesHelper: X7,
  BackSide: uf,
  BasicDepthPacking: o1,
  BasicShadowMap: S5,
  Bone: tL,
  BooleanKeyframeTrack: ZS,
  Box2: O7,
  Box3: sg,
  Box3Helper: W7,
  BoxBufferGeometry: cl,
  BoxGeometry: cl,
  BoxHelper: G7,
  BufferAttribute: os,
  BufferGeometry: ui,
  BufferGeometryLoader: h4,
  ByteType: QN,
  Cache: YS,
  Camera: hw,
  CameraHelper: V7,
  CanvasTexture: vW,
  CapsuleBufferGeometry: Kb,
  CapsuleGeometry: Kb,
  CatmullRomCurve3: IF,
  CineonToneMapping: XN,
  CircleBufferGeometry: $b,
  CircleGeometry: $b,
  ClampToEdgeWrapping: Wh,
  Clock: yL,
  Color: Pn,
  ColorKeyframeTrack: pL,
  ColorManagement: vv,
  CompressedTexture: FF,
  CompressedTextureLoader: JW,
  ConeBufferGeometry: ew,
  ConeGeometry: ew,
  CubeCamera: xF,
  CubeReflectionMapping: t1,
  CubeRefractionMapping: n1,
  CubeTexture: eT,
  CubeTextureLoader: KW,
  CubeUVReflectionMapping: dw,
  CubicBezierCurve: iL,
  CubicBezierCurve3: BF,
  CubicInterpolant: n4,
  CullFaceBack: BD,
  CullFaceFront: wN,
  CullFaceFrontBack: x5,
  CullFaceNone: bN,
  Curve: lg,
  CurvePath: VF,
  CustomBlending: MN,
  CustomToneMapping: qN,
  CylinderBufferGeometry: Jo,
  CylinderGeometry: Jo,
  Cylindrical: P7,
  Data3DTexture: kC,
  DataArrayTexture: JM,
  DataTexture: jb,
  DataTexture2DArray: i9,
  DataTexture3D: a9,
  DataTextureLoader: $W,
  DataUtils: K7,
  DecrementStencilOp: O5,
  DecrementWrapStencilOp: z5,
  DefaultLoadingManager: a4,
  DepthFormat: $x,
  DepthStencilFormat: r1,
  DepthTexture: K3,
  DirectionalLight: u4,
  DirectionalLightHelper: H7,
  DiscreteInterpolant: r4,
  DodecahedronBufferGeometry: tw,
  DodecahedronGeometry: tw,
  DoubleSide: Pp,
  DstAlphaFactor: LN,
  DstColorFactor: ON,
  DynamicCopyUsage: Z5,
  DynamicDrawUsage: W5,
  DynamicReadUsage: X5,
  EdgesGeometry: GF,
  EllipseCurve: YC,
  EqualDepth: IN,
  EqualStencilFunc: I5,
  EquirectangularReflectionMapping: TM,
  EquirectangularRefractionMapping: CM,
  Euler: QS,
  EventDispatcher: Mm,
  ExtrudeBufferGeometry: nw,
  ExtrudeGeometry: nw,
  FileLoader: P0,
  FlatShading: EN,
  Float16BufferAttribute: PH,
  Float32BufferAttribute: sr,
  Float64BufferAttribute: OH,
  FloatType: uy,
  Fog: GC,
  FogExp2: VC,
  Font: n9,
  FontLoader: t9,
  FramebufferTexture: mW,
  FrontSide: py,
  Frustum: IC,
  GLBufferAttribute: L7,
  GLSL1: K5,
  GLSL3: d3,
  GreaterDepth: HN,
  GreaterEqualDepth: BN,
  GreaterEqualStencilFunc: G5,
  GreaterStencilFunc: H5,
  GridHelper: I7,
  Group: Vb,
  HalfFloatType: GS,
  HemisphereLight: s4,
  HemisphereLightHelper: k7,
  HemisphereLightProbe: l7,
  IcosahedronBufferGeometry: rw,
  IcosahedronGeometry: rw,
  ImageBitmapLoader: s7,
  ImageLoader: WM,
  ImageUtils: q3,
  ImmediateRenderObject: r9,
  IncrementStencilOp: P5,
  IncrementWrapStencilOp: U5,
  InstancedBufferAttribute: WS,
  InstancedBufferGeometry: JC,
  InstancedInterleavedBuffer: CC,
  InstancedMesh: UF,
  Int16BufferAttribute: DH,
  Int32BufferAttribute: LH,
  Int8BufferAttribute: CH,
  IntType: JN,
  InterleavedBuffer: WC,
  InterleavedBufferAttribute: _m,
  Interpolant: nT,
  InterpolateDiscrete: AM,
  InterpolateLinear: DM,
  InterpolateSmooth: hC,
  InvertStencilOp: N5,
  KeepStencilOp: pC,
  KeyframeTrack: ug,
  LOD: PF,
  LatheBufferGeometry: jS,
  LatheGeometry: jS,
  Layers: kS,
  LessDepth: kN,
  LessEqualDepth: bC,
  LessEqualStencilFunc: B5,
  LessStencilFunc: k5,
  Light: l1,
  LightProbe: QC,
  Line: ch,
  Line3: bL,
  LineBasicMaterial: ph,
  LineCurve: XC,
  LineCurve3: HF,
  LineDashedMaterial: e4,
  LineLoop: zF,
  LineSegments: gy,
  LinearEncoding: yv,
  LinearFilter: Po,
  LinearInterpolant: hL,
  LinearMipMapLinearFilter: M5,
  LinearMipMapNearestFilter: E5,
  LinearMipmapLinearFilter: s1,
  LinearMipmapNearestFilter: W3,
  LinearSRGBColorSpace: Jx,
  LinearToneMapping: jN,
  Loader: Tm,
  LoaderUtils: S3,
  LoadingManager: mL,
  LoopOnce: cF,
  LoopPingPong: dF,
  LoopRepeat: fF,
  LuminanceAlphaFormat: rF,
  LuminanceFormat: nF,
  MOUSE: ES,
  Material: ff,
  MaterialLoader: ZC,
  MathUtils: vF,
  Matrix3: jh,
  Matrix4: si,
  MaxEquation: WD,
  Mesh: zn,
  MeshBasicMaterial: og,
  MeshDepthMaterial: tT,
  MeshDistanceMaterial: HC,
  MeshLambertMaterial: KF,
  MeshMatcapMaterial: $F,
  MeshNormalMaterial: cL,
  MeshPhongMaterial: ZF,
  MeshPhysicalMaterial: QF,
  MeshStandardMaterial: BM,
  MeshToonMaterial: JF,
  MinEquation: GD,
  MirroredRepeatWrapping: RM,
  MixOperation: GN,
  MultiplyBlending: VD,
  MultiplyOperation: ZM,
  NearestFilter: co,
  NearestMipMapLinearFilter: w5,
  NearestMipMapNearestFilter: b5,
  NearestMipmapLinearFilter: EC,
  NearestMipmapNearestFilter: wC,
  NeverDepth: NN,
  NeverStencilFunc: F5,
  NoBlending: cf,
  NoColorSpace: A5,
  NoToneMapping: rg,
  NormalAnimationBlendMode: FC,
  NormalBlending: L0,
  NotEqualDepth: VN,
  NotEqualStencilFunc: V5,
  NumberKeyframeTrack: HM,
  Object3D: Xa,
  ObjectLoader: i7,
  ObjectSpaceNormalMap: hF,
  OctahedronBufferGeometry: ng,
  OctahedronGeometry: ng,
  OneFactor: RN,
  OneMinusDstAlphaFactor: PN,
  OneMinusDstColorFactor: UN,
  OneMinusSrcAlphaFactor: zC,
  OneMinusSrcColorFactor: DN,
  OrthographicCamera: cy,
  PCFShadowMap: B3,
  PCFSoftShadowMap: H3,
  PMREMGenerator: p3,
  ParametricGeometry: $7,
  Path: NM,
  PerspectiveCamera: fo,
  Plane: C0,
  PlaneBufferGeometry: ig,
  PlaneGeometry: ig,
  PlaneHelper: j7,
  PointLight: l4,
  PointLightHelper: N7,
  Points: NF,
  PointsMaterial: nL,
  PolarGridHelper: B7,
  PolyhedronBufferGeometry: my,
  PolyhedronGeometry: my,
  PositionalAudio: p7,
  PropertyBinding: Ja,
  PropertyMixer: m4,
  QuadraticBezierCurve: aL,
  QuadraticBezierCurve3: sL,
  Quaternion: Ko,
  QuaternionKeyframeTrack: mw,
  QuaternionLinearInterpolant: i4,
  REVISION: U0,
  RGBADepthPacking: Zb,
  RGBAFormat: Sm,
  RGBAIntegerFormat: lF,
  RGBA_ASTC_10x10_Format: l3,
  RGBA_ASTC_10x5_Format: a3,
  RGBA_ASTC_10x6_Format: s3,
  RGBA_ASTC_10x8_Format: o3,
  RGBA_ASTC_12x10_Format: u3,
  RGBA_ASTC_12x12_Format: c3,
  RGBA_ASTC_4x4_Format: JD,
  RGBA_ASTC_5x4_Format: KD,
  RGBA_ASTC_5x5_Format: $D,
  RGBA_ASTC_6x5_Format: e3,
  RGBA_ASTC_6x6_Format: t3,
  RGBA_ASTC_8x5_Format: n3,
  RGBA_ASTC_8x6_Format: r3,
  RGBA_ASTC_8x8_Format: i3,
  RGBA_BPTC_Format: f3,
  RGBA_ETC2_EAC_Format: ZD,
  RGBA_PVRTC_2BPPV1_Format: qD,
  RGBA_PVRTC_4BPPV1_Format: XD,
  RGBA_S3TC_DXT1_Format: cC,
  RGBA_S3TC_DXT3_Format: fC,
  RGBA_S3TC_DXT5_Format: dC,
  RGBFormat: tF,
  RGB_ETC1_Format: uF,
  RGB_ETC2_Format: QD,
  RGB_PVRTC_2BPPV1_Format: YD,
  RGB_PVRTC_4BPPV1_Format: jD,
  RGB_S3TC_DXT1_Format: uC,
  RGFormat: sF,
  RGIntegerFormat: oF,
  RawShaderMaterial: qF,
  Ray: KM,
  Raycaster: _L,
  RectAreaLight: f4,
  RedFormat: iF,
  RedIntegerFormat: aF,
  ReinhardToneMapping: YN,
  RepeatWrapping: Qb,
  ReplaceStencilOp: L5,
  ReverseSubtractEquation: V3,
  RingBufferGeometry: iw,
  RingGeometry: iw,
  SRGBColorSpace: sy,
  Scene: zM,
  ShaderChunk: na,
  ShaderLib: Gh,
  ShaderMaterial: wu,
  ShadowMaterial: XF,
  Shape: IS,
  ShapeBufferGeometry: aw,
  ShapeGeometry: aw,
  ShapePath: q7,
  ShapeUtils: fy,
  ShortType: ZN,
  Skeleton: jC,
  SkeletonHelper: z7,
  SkinnedMesh: OF,
  SmoothShading: _5,
  Source: OS,
  Sphere: vy,
  SphereBufferGeometry: ag,
  SphereGeometry: ag,
  Spherical: b3,
  SphericalHarmonics3: d4,
  SplineCurve: oL,
  SpotLight: o4,
  SpotLightHelper: U7,
  Sprite: LF,
  SpriteMaterial: eL,
  SrcAlphaFactor: UC,
  SrcAlphaSaturateFactor: zN,
  SrcColorFactor: AN,
  StaticCopyUsage: Q5,
  StaticDrawUsage: PM,
  StaticReadUsage: Y5,
  StereoCamera: c7,
  StreamCopyUsage: J5,
  StreamDrawUsage: j5,
  StreamReadUsage: q5,
  StringKeyframeTrack: JS,
  SubtractEquation: TN,
  SubtractiveBlending: HD,
  TOUCH: MS,
  TangentSpaceNormalMap: qS,
  TetrahedronBufferGeometry: sw,
  TetrahedronGeometry: sw,
  TextGeometry: e9,
  Texture: iu,
  TextureLoader: e7,
  TorusBufferGeometry: tg,
  TorusGeometry: tg,
  TorusKnotBufferGeometry: ow,
  TorusKnotGeometry: ow,
  Triangle: xm,
  TriangleFanDrawMode: R5,
  TriangleStripDrawMode: C5,
  TrianglesDrawMode: T5,
  TubeBufferGeometry: lw,
  TubeGeometry: lw,
  UVMapping: NC,
  Uint16BufferAttribute: Q3,
  Uint32BufferAttribute: Z3,
  Uint8BufferAttribute: RH,
  Uint8ClampedBufferAttribute: AH,
  Uniform: Bn,
  UniformsGroup: D7,
  UniformsLib: Fn,
  UniformsUtils: $M,
  UnsignedByteType: Gf,
  UnsignedInt248Type: Kx,
  UnsignedIntType: D0,
  UnsignedShort4444Type: KN,
  UnsignedShort5551Type: $N,
  UnsignedShortType: j3,
  VSMShadowMap: Ib,
  Vector2: Ft,
  Vector3: ge,
  Vector4: la,
  VectorKeyframeTrack: VM,
  VideoTexture: pW,
  WebGL1Renderer: AF,
  WebGL3DRenderTarget: gH,
  WebGLArrayRenderTarget: vH,
  WebGLCubeRenderTarget: SF,
  WebGLMultipleRenderTargets: yH,
  WebGLMultisampleRenderTarget: g4,
  WebGLRenderTarget: po,
  WebGLRenderer: $3,
  WebGLUtils: CF,
  WireframeGeometry: uL,
  WrapAroundEnding: LM,
  ZeroCurvatureEnding: LS,
  ZeroFactor: CN,
  ZeroSlopeEnding: PS,
  ZeroStencilOp: D5,
  _SRGBAFormat: MC,
  sRGBEncoding: Mi
}, Symbol.toStringTag, { value: "Module" }));
var A0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function y4(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var Yb = { exports: {} }, Yx = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JU;
function s9() {
  return JU || (JU = 1, Yx.ConcurrentRoot = 1, Yx.ContinuousEventPriority = 4, Yx.DefaultEventPriority = 16, Yx.DiscreteEventPriority = 1, Yx.IdleEventPriority = 536870912, Yx.LegacyRoot = 0), Yx;
}
var Xx = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KU;
function o9() {
  return KU || (KU = 1, process.env.NODE_ENV !== "production" && function() {
    var a = 1, e = 4, t = 16, r = 536870912, i = a, o = e, l = t, d = r, h = 0, m = 1;
    Xx.ConcurrentRoot = m, Xx.ContinuousEventPriority = o, Xx.DefaultEventPriority = l, Xx.DiscreteEventPriority = i, Xx.IdleEventPriority = d, Xx.LegacyRoot = h;
  }()), Xx;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = s9() : a.exports = o9();
})(Yb);
function l9(a) {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (m, S) => {
    const _ = typeof m == "function" ? m(e) : m;
    if (_ !== e) {
      const T = e;
      e = S ? _ : Object.assign({}, e, _), t.forEach((C) => C(e, T));
    }
  }, i = () => e, o = (m, S = i, _ = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let T = S(e);
    function C() {
      const D = S(e);
      if (!_(T, D)) {
        const P = T;
        m(T = D, P);
      }
    }
    return t.add(C), () => t.delete(C);
  }, h = { setState: r, getState: i, subscribe: (m, S, _) => S || _ ? o(m, S, _) : (t.add(m), () => t.delete(m)), destroy: () => t.clear() };
  return e = a(r, i, h), h;
}
const u9 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), $U = u9 ? fh : I3;
function c9(a) {
  const e = typeof a == "function" ? l9(a) : a, t = (r = e.getState, i = Object.is) => {
    const [, o] = v5((U) => U + 1, 0), l = e.getState(), d = uo(l), h = uo(r), m = uo(i), S = uo(!1), _ = uo();
    _.current === void 0 && (_.current = r(l));
    let T, C = !1;
    (d.current !== l || h.current !== r || m.current !== i || S.current) && (T = r(l), C = !i(_.current, T)), $U(() => {
      C && (_.current = T), d.current = l, h.current = r, m.current = i, S.current = !1;
    });
    const D = uo(l);
    $U(() => {
      const U = () => {
        try {
          const k = e.getState(), V = h.current(k);
          m.current(_.current, V) || (d.current = k, _.current = V, o());
        } catch {
          S.current = !0, o();
        }
      }, B = e.subscribe(U);
      return e.getState() !== D.current && U(), B;
    }, []);
    const P = C ? T : _.current;
    return _N(P), P;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const r = [t, e];
    return {
      next() {
        const i = r.length <= 0;
        return { value: r.shift(), done: i };
      }
    };
  }, t;
}
var x4 = { exports: {} }, jM = { exports: {} }, iD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ez;
function f9() {
  return ez || (ez = 1, function(a) {
    function e(he, fe) {
      var ue = he.length;
      he.push(fe);
      e:
        for (; 0 < ue; ) {
          var ye = ue - 1 >>> 1, we = he[ye];
          if (0 < i(we, fe))
            he[ye] = fe, he[ue] = we, ue = ye;
          else
            break e;
        }
    }
    function t(he) {
      return he.length === 0 ? null : he[0];
    }
    function r(he) {
      if (he.length === 0)
        return null;
      var fe = he[0], ue = he.pop();
      if (ue !== fe) {
        he[0] = ue;
        e:
          for (var ye = 0, we = he.length, Xe = we >>> 1; ye < Xe; ) {
            var Je = 2 * (ye + 1) - 1, st = he[Je], Ue = Je + 1, ot = he[Ue];
            if (0 > i(st, ue))
              Ue < we && 0 > i(ot, st) ? (he[ye] = ot, he[Ue] = ue, ye = Ue) : (he[ye] = st, he[Je] = ue, ye = Je);
            else if (Ue < we && 0 > i(ot, ue))
              he[ye] = ot, he[Ue] = ue, ye = Ue;
            else
              break e;
          }
      }
      return fe;
    }
    function i(he, fe) {
      var ue = he.sortIndex - fe.sortIndex;
      return ue !== 0 ? ue : he.id - fe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      a.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, d = l.now();
      a.unstable_now = function() {
        return l.now() - d;
      };
    }
    var h = [], m = [], S = 1, _ = null, T = 3, C = !1, D = !1, P = !1, U = typeof setTimeout == "function" ? setTimeout : null, B = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function V(he) {
      for (var fe = t(m); fe !== null; ) {
        if (fe.callback === null)
          r(m);
        else if (fe.startTime <= he)
          r(m), fe.sortIndex = fe.expirationTime, e(h, fe);
        else
          break;
        fe = t(m);
      }
    }
    function I(he) {
      if (P = !1, V(he), !D)
        if (t(h) !== null)
          D = !0, Ce(X);
        else {
          var fe = t(m);
          fe !== null && Be(I, fe.startTime - he);
        }
    }
    function X(he, fe) {
      D = !1, P && (P = !1, B(W), W = -1), C = !0;
      var ue = T;
      try {
        for (V(fe), _ = t(h); _ !== null && (!(_.expirationTime > fe) || he && !pe()); ) {
          var ye = _.callback;
          if (typeof ye == "function") {
            _.callback = null, T = _.priorityLevel;
            var we = ye(_.expirationTime <= fe);
            fe = a.unstable_now(), typeof we == "function" ? _.callback = we : _ === t(h) && r(h), V(fe);
          } else
            r(h);
          _ = t(h);
        }
        if (_ !== null)
          var Xe = !0;
        else {
          var Je = t(m);
          Je !== null && Be(I, Je.startTime - fe), Xe = !1;
        }
        return Xe;
      } finally {
        _ = null, T = ue, C = !1;
      }
    }
    var J = !1, $ = null, W = -1, ee = 5, ie = -1;
    function pe() {
      return !(a.unstable_now() - ie < ee);
    }
    function ce() {
      if ($ !== null) {
        var he = a.unstable_now();
        ie = he;
        var fe = !0;
        try {
          fe = $(!0, he);
        } finally {
          fe ? Ee() : (J = !1, $ = null);
        }
      } else
        J = !1;
    }
    var Ee;
    if (typeof k == "function")
      Ee = function() {
        k(ce);
      };
    else if (typeof MessageChannel < "u") {
      var de = new MessageChannel(), Fe = de.port2;
      de.port1.onmessage = ce, Ee = function() {
        Fe.postMessage(null);
      };
    } else
      Ee = function() {
        U(ce, 0);
      };
    function Ce(he) {
      $ = he, J || (J = !0, Ee());
    }
    function Be(he, fe) {
      W = U(function() {
        he(a.unstable_now());
      }, fe);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(he) {
      he.callback = null;
    }, a.unstable_continueExecution = function() {
      D || C || (D = !0, Ce(X));
    }, a.unstable_forceFrameRate = function(he) {
      0 > he || 125 < he ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ee = 0 < he ? Math.floor(1e3 / he) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return T;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(h);
    }, a.unstable_next = function(he) {
      switch (T) {
        case 1:
        case 2:
        case 3:
          var fe = 3;
          break;
        default:
          fe = T;
      }
      var ue = T;
      T = fe;
      try {
        return he();
      } finally {
        T = ue;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(he, fe) {
      switch (he) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          he = 3;
      }
      var ue = T;
      T = he;
      try {
        return fe();
      } finally {
        T = ue;
      }
    }, a.unstable_scheduleCallback = function(he, fe, ue) {
      var ye = a.unstable_now();
      switch (typeof ue == "object" && ue !== null ? (ue = ue.delay, ue = typeof ue == "number" && 0 < ue ? ye + ue : ye) : ue = ye, he) {
        case 1:
          var we = -1;
          break;
        case 2:
          we = 250;
          break;
        case 5:
          we = 1073741823;
          break;
        case 4:
          we = 1e4;
          break;
        default:
          we = 5e3;
      }
      return we = ue + we, he = { id: S++, callback: fe, priorityLevel: he, startTime: ue, expirationTime: we, sortIndex: -1 }, ue > ye ? (he.sortIndex = ue, e(m, he), t(h) === null && he === t(m) && (P ? (B(W), W = -1) : P = !0, Be(I, ue - ye))) : (he.sortIndex = we, e(h, he), D || C || (D = !0, Ce(X))), he;
    }, a.unstable_shouldYield = pe, a.unstable_wrapCallback = function(he) {
      var fe = T;
      return function() {
        var ue = T;
        T = fe;
        try {
          return he.apply(this, arguments);
        } finally {
          T = ue;
        }
      };
    };
  }(iD)), iD;
}
var aD = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tz;
function d9() {
  return tz || (tz = 1, function(a) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(ze, xe) {
        var Ie = ze.length;
        ze.push(xe), d(ze, xe, Ie);
      }
      function o(ze) {
        return ze.length === 0 ? null : ze[0];
      }
      function l(ze) {
        if (ze.length === 0)
          return null;
        var xe = ze[0], Ie = ze.pop();
        return Ie !== xe && (ze[0] = Ie, h(ze, Ie, 0)), xe;
      }
      function d(ze, xe, Ie) {
        for (var it = Ie; it > 0; ) {
          var at = it - 1 >>> 1, hn = ze[at];
          if (m(hn, xe) > 0)
            ze[at] = xe, ze[it] = hn, it = at;
          else
            return;
        }
      }
      function h(ze, xe, Ie) {
        for (var it = Ie, at = ze.length, hn = at >>> 1; it < hn; ) {
          var De = (it + 1) * 2 - 1, Tt = ze[De], Ne = De + 1, Gt = ze[Ne];
          if (m(Tt, xe) < 0)
            Ne < at && m(Gt, Tt) < 0 ? (ze[it] = Gt, ze[Ne] = xe, it = Ne) : (ze[it] = Tt, ze[De] = xe, it = De);
          else if (Ne < at && m(Gt, xe) < 0)
            ze[it] = Gt, ze[Ne] = xe, it = Ne;
          else
            return;
        }
      }
      function m(ze, xe) {
        var Ie = ze.sortIndex - xe.sortIndex;
        return Ie !== 0 ? Ie : ze.id - xe.id;
      }
      var S = 1, _ = 2, T = 3, C = 4, D = 5;
      function P(ze, xe) {
      }
      var U = typeof performance == "object" && typeof performance.now == "function";
      if (U) {
        var B = performance;
        a.unstable_now = function() {
          return B.now();
        };
      } else {
        var k = Date, V = k.now();
        a.unstable_now = function() {
          return k.now() - V;
        };
      }
      var I = 1073741823, X = -1, J = 250, $ = 5e3, W = 1e4, ee = I, ie = [], pe = [], ce = 1, Ee = null, de = T, Fe = !1, Ce = !1, Be = !1, he = typeof setTimeout == "function" ? setTimeout : null, fe = typeof clearTimeout == "function" ? clearTimeout : null, ue = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ye(ze) {
        for (var xe = o(pe); xe !== null; ) {
          if (xe.callback === null)
            l(pe);
          else if (xe.startTime <= ze)
            l(pe), xe.sortIndex = xe.expirationTime, i(ie, xe);
          else
            return;
          xe = o(pe);
        }
      }
      function we(ze) {
        if (Be = !1, ye(ze), !Ce)
          if (o(ie) !== null)
            Ce = !0, zt(Xe);
          else {
            var xe = o(pe);
            xe !== null && Nt(we, xe.startTime - ze);
          }
      }
      function Xe(ze, xe) {
        Ce = !1, Be && (Be = !1, Ut()), Fe = !0;
        var Ie = de;
        try {
          var it;
          if (!t)
            return Je(ze, xe);
        } finally {
          Ee = null, de = Ie, Fe = !1;
        }
      }
      function Je(ze, xe) {
        var Ie = xe;
        for (ye(Ie), Ee = o(ie); Ee !== null && !e && !(Ee.expirationTime > Ie && (!ze || Vt())); ) {
          var it = Ee.callback;
          if (typeof it == "function") {
            Ee.callback = null, de = Ee.priorityLevel;
            var at = Ee.expirationTime <= Ie, hn = it(at);
            Ie = a.unstable_now(), typeof hn == "function" ? Ee.callback = hn : Ee === o(ie) && l(ie), ye(Ie);
          } else
            l(ie);
          Ee = o(ie);
        }
        if (Ee !== null)
          return !0;
        var De = o(pe);
        return De !== null && Nt(we, De.startTime - Ie), !1;
      }
      function st(ze, xe) {
        switch (ze) {
          case S:
          case _:
          case T:
          case C:
          case D:
            break;
          default:
            ze = T;
        }
        var Ie = de;
        de = ze;
        try {
          return xe();
        } finally {
          de = Ie;
        }
      }
      function Ue(ze) {
        var xe;
        switch (de) {
          case S:
          case _:
          case T:
            xe = T;
            break;
          default:
            xe = de;
            break;
        }
        var Ie = de;
        de = xe;
        try {
          return ze();
        } finally {
          de = Ie;
        }
      }
      function ot(ze) {
        var xe = de;
        return function() {
          var Ie = de;
          de = xe;
          try {
            return ze.apply(this, arguments);
          } finally {
            de = Ie;
          }
        };
      }
      function rt(ze, xe, Ie) {
        var it = a.unstable_now(), at;
        if (typeof Ie == "object" && Ie !== null) {
          var hn = Ie.delay;
          typeof hn == "number" && hn > 0 ? at = it + hn : at = it;
        } else
          at = it;
        var De;
        switch (ze) {
          case S:
            De = X;
            break;
          case _:
            De = J;
            break;
          case D:
            De = ee;
            break;
          case C:
            De = W;
            break;
          case T:
          default:
            De = $;
            break;
        }
        var Tt = at + De, Ne = {
          id: ce++,
          callback: xe,
          priorityLevel: ze,
          startTime: at,
          expirationTime: Tt,
          sortIndex: -1
        };
        return at > it ? (Ne.sortIndex = at, i(pe, Ne), o(ie) === null && Ne === o(pe) && (Be ? Ut() : Be = !0, Nt(we, at - it))) : (Ne.sortIndex = Tt, i(ie, Ne), !Ce && !Fe && (Ce = !0, zt(Xe))), Ne;
      }
      function _t() {
      }
      function Rt() {
        !Ce && !Fe && (Ce = !0, zt(Xe));
      }
      function Ot() {
        return o(ie);
      }
      function He(ze) {
        ze.callback = null;
      }
      function et() {
        return de;
      }
      var mt = !1, vt = null, bt = -1, Qt = r, ft = -1;
      function Vt() {
        var ze = a.unstable_now() - ft;
        return !(ze < Qt);
      }
      function Jt() {
      }
      function Mt(ze) {
        if (ze < 0 || ze > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ze > 0 ? Qt = Math.floor(1e3 / ze) : Qt = r;
      }
      var Me = function() {
        if (vt !== null) {
          var ze = a.unstable_now();
          ft = ze;
          var xe = !0, Ie = !0;
          try {
            Ie = vt(xe, ze);
          } finally {
            Ie ? oe() : (mt = !1, vt = null);
          }
        } else
          mt = !1;
      }, oe;
      if (typeof ue == "function")
        oe = function() {
          ue(Me);
        };
      else if (typeof MessageChannel < "u") {
        var je = new MessageChannel(), lt = je.port2;
        je.port1.onmessage = Me, oe = function() {
          lt.postMessage(null);
        };
      } else
        oe = function() {
          he(Me, 0);
        };
      function zt(ze) {
        vt = ze, mt || (mt = !0, oe());
      }
      function Nt(ze, xe) {
        bt = he(function() {
          ze(a.unstable_now());
        }, xe);
      }
      function Ut() {
        fe(bt), bt = -1;
      }
      var tt = Jt, rn = null;
      a.unstable_IdlePriority = D, a.unstable_ImmediatePriority = S, a.unstable_LowPriority = C, a.unstable_NormalPriority = T, a.unstable_Profiling = rn, a.unstable_UserBlockingPriority = _, a.unstable_cancelCallback = He, a.unstable_continueExecution = Rt, a.unstable_forceFrameRate = Mt, a.unstable_getCurrentPriorityLevel = et, a.unstable_getFirstCallbackNode = Ot, a.unstable_next = Ue, a.unstable_pauseExecution = _t, a.unstable_requestPaint = tt, a.unstable_runWithPriority = st, a.unstable_scheduleCallback = rt, a.unstable_shouldYield = Vt, a.unstable_wrapCallback = ot, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(aD)), aD;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = f9() : a.exports = d9();
})(jM);
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sD, nz;
function h9() {
  return nz || (nz = 1, sD = function(e) {
    var t = {}, r = hh, i = jM.exports, o = Object.assign;
    function l(y) {
      for (var x = "https://reactjs.org/docs/error-decoder.html?invariant=" + y, L = 1; L < arguments.length; L++)
        x += "&args[]=" + encodeURIComponent(arguments[L]);
      return "Minified React error #" + y + "; visit " + x + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var d = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, h = Symbol.for("react.element"), m = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), _ = Symbol.for("react.strict_mode"), T = Symbol.for("react.profiler"), C = Symbol.for("react.provider"), D = Symbol.for("react.context"), P = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), B = Symbol.for("react.suspense_list"), k = Symbol.for("react.memo"), V = Symbol.for("react.lazy"), I = Symbol.for("react.offscreen"), X = Symbol.iterator;
    function J(y) {
      return y === null || typeof y != "object" ? null : (y = X && y[X] || y["@@iterator"], typeof y == "function" ? y : null);
    }
    function $(y) {
      if (y == null)
        return null;
      if (typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case S:
          return "Fragment";
        case m:
          return "Portal";
        case T:
          return "Profiler";
        case _:
          return "StrictMode";
        case U:
          return "Suspense";
        case B:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case D:
            return (y.displayName || "Context") + ".Consumer";
          case C:
            return (y._context.displayName || "Context") + ".Provider";
          case P:
            var x = y.render;
            return y = y.displayName, y || (y = x.displayName || x.name || "", y = y !== "" ? "ForwardRef(" + y + ")" : "ForwardRef"), y;
          case k:
            return x = y.displayName || null, x !== null ? x : $(y.type) || "Memo";
          case V:
            x = y._payload, y = y._init;
            try {
              return $(y(x));
            } catch {
            }
        }
      return null;
    }
    function W(y) {
      var x = y.type;
      switch (y.tag) {
        case 24:
          return "Cache";
        case 9:
          return (x.displayName || "Context") + ".Consumer";
        case 10:
          return (x._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return y = x.render, y = y.displayName || y.name || "", x.displayName || (y !== "" ? "ForwardRef(" + y + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return x;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return $(x);
        case 8:
          return x === _ ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof x == "function")
            return x.displayName || x.name || null;
          if (typeof x == "string")
            return x;
      }
      return null;
    }
    function ee(y) {
      var x = y, L = y;
      if (y.alternate)
        for (; x.return; )
          x = x.return;
      else {
        y = x;
        do
          x = y, (x.flags & 4098) !== 0 && (L = x.return), y = x.return;
        while (y);
      }
      return x.tag === 3 ? L : null;
    }
    function ie(y) {
      if (ee(y) !== y)
        throw Error(l(188));
    }
    function pe(y) {
      var x = y.alternate;
      if (!x) {
        if (x = ee(y), x === null)
          throw Error(l(188));
        return x !== y ? null : y;
      }
      for (var L = y, H = x; ; ) {
        var q = L.return;
        if (q === null)
          break;
        var te = q.alternate;
        if (te === null) {
          if (H = q.return, H !== null) {
            L = H;
            continue;
          }
          break;
        }
        if (q.child === te.child) {
          for (te = q.child; te; ) {
            if (te === L)
              return ie(q), y;
            if (te === H)
              return ie(q), x;
            te = te.sibling;
          }
          throw Error(l(188));
        }
        if (L.return !== H.return)
          L = q, H = te;
        else {
          for (var Ae = !1, Ke = q.child; Ke; ) {
            if (Ke === L) {
              Ae = !0, L = q, H = te;
              break;
            }
            if (Ke === H) {
              Ae = !0, H = q, L = te;
              break;
            }
            Ke = Ke.sibling;
          }
          if (!Ae) {
            for (Ke = te.child; Ke; ) {
              if (Ke === L) {
                Ae = !0, L = te, H = q;
                break;
              }
              if (Ke === H) {
                Ae = !0, H = te, L = q;
                break;
              }
              Ke = Ke.sibling;
            }
            if (!Ae)
              throw Error(l(189));
          }
        }
        if (L.alternate !== H)
          throw Error(l(190));
      }
      if (L.tag !== 3)
        throw Error(l(188));
      return L.stateNode.current === L ? y : x;
    }
    function ce(y) {
      return y = pe(y), y !== null ? Ee(y) : null;
    }
    function Ee(y) {
      if (y.tag === 5 || y.tag === 6)
        return y;
      for (y = y.child; y !== null; ) {
        var x = Ee(y);
        if (x !== null)
          return x;
        y = y.sibling;
      }
      return null;
    }
    function de(y) {
      if (y.tag === 5 || y.tag === 6)
        return y;
      for (y = y.child; y !== null; ) {
        if (y.tag !== 4) {
          var x = de(y);
          if (x !== null)
            return x;
        }
        y = y.sibling;
      }
      return null;
    }
    var Fe = Array.isArray, Ce = e.getPublicInstance, Be = e.getRootHostContext, he = e.getChildHostContext, fe = e.prepareForCommit, ue = e.resetAfterCommit, ye = e.createInstance, we = e.appendInitialChild, Xe = e.finalizeInitialChildren, Je = e.prepareUpdate, st = e.shouldSetTextContent, Ue = e.createTextInstance, ot = e.scheduleTimeout, rt = e.cancelTimeout, _t = e.noTimeout, Rt = e.isPrimaryRenderer, Ot = e.supportsMutation, He = e.supportsPersistence, et = e.supportsHydration, mt = e.getInstanceFromNode, vt = e.preparePortalMount, bt = e.getCurrentEventPriority, Qt = e.detachDeletedInstance, ft = e.supportsMicrotasks, Vt = e.scheduleMicrotask, Jt = e.supportsTestSelectors, Mt = e.findFiberRoot, Me = e.getBoundingRect, oe = e.getTextContent, je = e.isHiddenSubtree, lt = e.matchAccessibilityRole, zt = e.setFocusIfFocusable, Nt = e.setupIntersectionObserver, Ut = e.appendChild, tt = e.appendChildToContainer, rn = e.commitTextUpdate, ze = e.commitMount, xe = e.commitUpdate, Ie = e.insertBefore, it = e.insertInContainerBefore, at = e.removeChild, hn = e.removeChildFromContainer, De = e.resetTextContent, Tt = e.hideInstance, Ne = e.hideTextInstance, Gt = e.unhideInstance, Pt = e.unhideTextInstance, fn = e.clearContainer, Gr = e.cloneInstance, Wr = e.createContainerChildSet, Ur = e.appendChildToContainerChildSet, ir = e.finalizeContainerChildren, Vn = e.replaceContainerChildren, jr = e.cloneHiddenInstance, ti = e.cloneHiddenTextInstance, ki = e.canHydrateInstance, Wi = e.canHydrateTextInstance, ni = e.canHydrateSuspenseInstance, ji = e.isSuspenseInstancePending, Si = e.isSuspenseInstanceFallback, Te = e.registerSuspenseInstanceRetry, ct = e.getNextHydratableSibling, me = e.getFirstHydratableChild, Oe = e.getFirstHydratableChildWithinContainer, qe = e.getFirstHydratableChildWithinSuspenseInstance, on = e.hydrateInstance, yn = e.hydrateTextInstance, Rn = e.hydrateSuspenseInstance, mn = e.getNextHydratableInstanceAfterSuspenseInstance, vn = e.commitHydratedContainer, Zn = e.commitHydratedSuspenseInstance, nr = e.clearSuspenseBoundary, br = e.clearSuspenseBoundaryFromContainer, Yi = e.shouldDeleteUnhydratedTailInstances, La = e.didNotMatchHydratedContainerTextInstance, Ys = e.didNotMatchHydratedTextInstance, $t;
    function Zr(y) {
      if ($t === void 0)
        try {
          throw Error();
        } catch (L) {
          var x = L.stack.trim().match(/\n( *(at )?)/);
          $t = x && x[1] || "";
        }
      return `
` + $t + y;
    }
    var ls = !1;
    function Xn(y, x) {
      if (!y || ls)
        return "";
      ls = !0;
      var L = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (x)
          if (x = function() {
            throw Error();
          }, Object.defineProperty(x.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(x, []);
            } catch (cn) {
              var H = cn;
            }
            Reflect.construct(y, [], x);
          } else {
            try {
              x.call();
            } catch (cn) {
              H = cn;
            }
            y.call(x.prototype);
          }
        else {
          try {
            throw Error();
          } catch (cn) {
            H = cn;
          }
          y();
        }
      } catch (cn) {
        if (cn && H && typeof cn.stack == "string") {
          for (var q = cn.stack.split(`
`), te = H.stack.split(`
`), Ae = q.length - 1, Ke = te.length - 1; 1 <= Ae && 0 <= Ke && q[Ae] !== te[Ke]; )
            Ke--;
          for (; 1 <= Ae && 0 <= Ke; Ae--, Ke--)
            if (q[Ae] !== te[Ke]) {
              if (Ae !== 1 || Ke !== 1)
                do
                  if (Ae--, Ke--, 0 > Ke || q[Ae] !== te[Ke]) {
                    var kt = `
` + q[Ae].replace(" at new ", " at ");
                    return y.displayName && kt.includes("<anonymous>") && (kt = kt.replace("<anonymous>", y.displayName)), kt;
                  }
                while (1 <= Ae && 0 <= Ke);
              break;
            }
        }
      } finally {
        ls = !1, Error.prepareStackTrace = L;
      }
      return (y = y ? y.displayName || y.name : "") ? Zr(y) : "";
    }
    var qa = Object.prototype.hasOwnProperty, mo = [], Ds = -1;
    function us(y) {
      return { current: y };
    }
    function mr(y) {
      0 > Ds || (y.current = mo[Ds], mo[Ds] = null, Ds--);
    }
    function pi(y, x) {
      Ds++, mo[Ds] = y.current, y.current = x;
    }
    var Ea = {}, _i = us(Ea), Ti = us(!1), Oo = Ea;
    function Uo(y, x) {
      var L = y.type.contextTypes;
      if (!L)
        return Ea;
      var H = y.stateNode;
      if (H && H.__reactInternalMemoizedUnmaskedChildContext === x)
        return H.__reactInternalMemoizedMaskedChildContext;
      var q = {}, te;
      for (te in L)
        q[te] = x[te];
      return H && (y = y.stateNode, y.__reactInternalMemoizedUnmaskedChildContext = x, y.__reactInternalMemoizedMaskedChildContext = q), q;
    }
    function Pa(y) {
      return y = y.childContextTypes, y != null;
    }
    function Rl() {
      mr(Ti), mr(_i);
    }
    function vo(y, x, L) {
      if (_i.current !== Ea)
        throw Error(l(168));
      pi(_i, x), pi(Ti, L);
    }
    function Wf(y, x, L) {
      var H = y.stateNode;
      if (x = x.childContextTypes, typeof H.getChildContext != "function")
        return L;
      H = H.getChildContext();
      for (var q in H)
        if (!(q in x))
          throw Error(l(108, W(y) || "Unknown", q));
      return o({}, L, H);
    }
    function Al(y) {
      return y = (y = y.stateNode) && y.__reactInternalMemoizedMergedChildContext || Ea, Oo = _i.current, pi(_i, y), pi(Ti, Ti.current), !0;
    }
    function zd(y, x, L) {
      var H = y.stateNode;
      if (!H)
        throw Error(l(169));
      L ? (y = Wf(y, x, Oo), H.__reactInternalMemoizedMergedChildContext = y, mr(Ti), mr(_i), pi(_i, y)) : mr(Ti), pi(Ti, L);
    }
    var Ls = Math.clz32 ? Math.clz32 : qh, Ju = Math.log, au = Math.LN2;
    function qh(y) {
      return y >>>= 0, y === 0 ? 32 : 31 - (Ju(y) / au | 0) | 0;
    }
    var Dl = 64, ri = 4194304;
    function go(y) {
      switch (y & -y) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return y & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return y & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return y;
      }
    }
    function jf(y, x) {
      var L = y.pendingLanes;
      if (L === 0)
        return 0;
      var H = 0, q = y.suspendedLanes, te = y.pingedLanes, Ae = L & 268435455;
      if (Ae !== 0) {
        var Ke = Ae & ~q;
        Ke !== 0 ? H = go(Ke) : (te &= Ae, te !== 0 && (H = go(te)));
      } else
        Ae = L & ~q, Ae !== 0 ? H = go(Ae) : te !== 0 && (H = go(te));
      if (H === 0)
        return 0;
      if (x !== 0 && x !== H && (x & q) === 0 && (q = H & -H, te = x & -x, q >= te || q === 16 && (te & 4194240) !== 0))
        return x;
      if ((H & 4) !== 0 && (H |= L & 16), x = y.entangledLanes, x !== 0)
        for (y = y.entanglements, x &= H; 0 < x; )
          L = 31 - Ls(x), q = 1 << L, H |= y[L], x &= ~q;
      return H;
    }
    function zo(y, x) {
      switch (y) {
        case 1:
        case 2:
        case 4:
          return x + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return x + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Ci(y, x) {
      for (var L = y.suspendedLanes, H = y.pingedLanes, q = y.expirationTimes, te = y.pendingLanes; 0 < te; ) {
        var Ae = 31 - Ls(te), Ke = 1 << Ae, kt = q[Ae];
        kt === -1 ? ((Ke & L) === 0 || (Ke & H) !== 0) && (q[Ae] = zo(Ke, x)) : kt <= x && (y.expiredLanes |= Ke), te &= ~Ke;
      }
    }
    function cs(y) {
      return y = y.pendingLanes & -1073741825, y !== 0 ? y : y & 1073741824 ? 1073741824 : 0;
    }
    function Yf(y) {
      for (var x = [], L = 0; 31 > L; L++)
        x.push(y);
      return x;
    }
    function xr(y, x, L) {
      y.pendingLanes |= x, x !== 536870912 && (y.suspendedLanes = 0, y.pingedLanes = 0), y = y.eventTimes, x = 31 - Ls(x), y[x] = L;
    }
    function Eu(y, x) {
      var L = y.pendingLanes & ~x;
      y.pendingLanes = x, y.suspendedLanes = 0, y.pingedLanes = 0, y.expiredLanes &= x, y.mutableReadLanes &= x, y.entangledLanes &= x, x = y.entanglements;
      var H = y.eventTimes;
      for (y = y.expirationTimes; 0 < L; ) {
        var q = 31 - Ls(L), te = 1 << q;
        x[q] = 0, H[q] = -1, y[q] = -1, L &= ~te;
      }
    }
    function ua(y, x) {
      var L = y.entangledLanes |= x;
      for (y = y.entanglements; L; ) {
        var H = 31 - Ls(L), q = 1 << H;
        q & x | y[H] & x && (y[H] |= x), L &= ~q;
      }
    }
    var Cr = 0;
    function fl(y) {
      return y &= -y, 1 < y ? 4 < y ? (y & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
    }
    var yo = i.unstable_scheduleCallback, Ka = i.unstable_cancelCallback, Xi = i.unstable_shouldYield, Rm = i.unstable_requestPaint, mi = i.unstable_now, Qa = i.unstable_ImmediatePriority, Sc = i.unstable_UserBlockingPriority, dl = i.unstable_NormalPriority, df = i.unstable_IdlePriority, hf = null, su = null;
    function Ii(y) {
      if (su && typeof su.onCommitFiberRoot == "function")
        try {
          su.onCommitFiberRoot(hf, y, void 0, (y.current.flags & 128) === 128);
        } catch {
        }
    }
    function Ri(y, x) {
      return y === x && (y !== 0 || 1 / y === 1 / x) || y !== y && x !== x;
    }
    var No = typeof Object.is == "function" ? Object.is : Ri, Ps = null, _c = !1, Ll = !1;
    function Xf(y) {
      Ps === null ? Ps = [y] : Ps.push(y);
    }
    function qf(y) {
      _c = !0, Xf(y);
    }
    function Fo() {
      if (!Ll && Ps !== null) {
        Ll = !0;
        var y = 0, x = Cr;
        try {
          var L = Ps;
          for (Cr = 1; y < L.length; y++) {
            var H = L[y];
            do
              H = H(!0);
            while (H !== null);
          }
          Ps = null, _c = !1;
        } catch (q) {
          throw Ps !== null && (Ps = Ps.slice(y + 1)), yo(Qa, Fo), q;
        } finally {
          Cr = x, Ll = !1;
        }
      }
      return null;
    }
    var Qf = d.ReactCurrentBatchConfig;
    function Ki(y, x) {
      if (No(y, x))
        return !0;
      if (typeof y != "object" || y === null || typeof x != "object" || x === null)
        return !1;
      var L = Object.keys(y), H = Object.keys(x);
      if (L.length !== H.length)
        return !1;
      for (H = 0; H < L.length; H++) {
        var q = L[H];
        if (!qa.call(x, q) || !No(y[q], x[q]))
          return !1;
      }
      return !0;
    }
    function Mu(y) {
      switch (y.tag) {
        case 5:
          return Zr(y.type);
        case 16:
          return Zr("Lazy");
        case 13:
          return Zr("Suspense");
        case 19:
          return Zr("SuspenseList");
        case 0:
        case 2:
        case 15:
          return y = Xn(y.type, !1), y;
        case 11:
          return y = Xn(y.type.render, !1), y;
        case 1:
          return y = Xn(y.type, !0), y;
        default:
          return "";
      }
    }
    function Oa(y, x) {
      if (y && y.defaultProps) {
        x = o({}, x), y = y.defaultProps;
        for (var L in y)
          x[L] === void 0 && (x[L] = y[L]);
        return x;
      }
      return x;
    }
    var ys = us(null), ou = null, Ua = null, bc = null;
    function xo() {
      bc = Ua = ou = null;
    }
    function Tu(y, x, L) {
      Rt ? (pi(ys, x._currentValue), x._currentValue = L) : (pi(ys, x._currentValue2), x._currentValue2 = L);
    }
    function Pl(y) {
      var x = ys.current;
      mr(ys), Rt ? y._currentValue = x : y._currentValue2 = x;
    }
    function za(y, x, L) {
      for (; y !== null; ) {
        var H = y.alternate;
        if ((y.childLanes & x) !== x ? (y.childLanes |= x, H !== null && (H.childLanes |= x)) : H !== null && (H.childLanes & x) !== x && (H.childLanes |= x), y === L)
          break;
        y = y.return;
      }
    }
    function Xs(y, x) {
      ou = y, bc = Ua = null, y = y.dependencies, y !== null && y.firstContext !== null && ((y.lanes & x) !== 0 && (oi = !0), y.firstContext = null);
    }
    function Jr(y) {
      var x = Rt ? y._currentValue : y._currentValue2;
      if (bc !== y)
        if (y = { context: y, memoizedValue: x, next: null }, Ua === null) {
          if (ou === null)
            throw Error(l(308));
          Ua = y, ou.dependencies = { lanes: 0, firstContext: y };
        } else
          Ua = Ua.next = y;
      return x;
    }
    var xs = null, va = !1;
    function qs(y) {
      y.updateQueue = { baseState: y.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Zf(y, x) {
      y = y.updateQueue, x.updateQueue === y && (x.updateQueue = { baseState: y.baseState, firstBaseUpdate: y.firstBaseUpdate, lastBaseUpdate: y.lastBaseUpdate, shared: y.shared, effects: y.effects });
    }
    function $o(y, x) {
      return { eventTime: y, lane: x, tag: 0, payload: null, callback: null, next: null };
    }
    function Ku(y, x) {
      var L = y.updateQueue;
      L !== null && (L = L.shared, Ra !== null && (y.mode & 1) !== 0 && (Kr & 2) === 0 ? (y = L.interleaved, y === null ? (x.next = x, xs === null ? xs = [L] : xs.push(L)) : (x.next = y.next, y.next = x), L.interleaved = x) : (y = L.pending, y === null ? x.next = x : (x.next = y.next, y.next = x), L.pending = x));
    }
    function Qh(y, x, L) {
      if (x = x.updateQueue, x !== null && (x = x.shared, (L & 4194240) !== 0)) {
        var H = x.lanes;
        H &= y.pendingLanes, L |= H, x.lanes = L, ua(y, L);
      }
    }
    function qi(y, x) {
      var L = y.updateQueue, H = y.alternate;
      if (H !== null && (H = H.updateQueue, L === H)) {
        var q = null, te = null;
        if (L = L.firstBaseUpdate, L !== null) {
          do {
            var Ae = { eventTime: L.eventTime, lane: L.lane, tag: L.tag, payload: L.payload, callback: L.callback, next: null };
            te === null ? q = te = Ae : te = te.next = Ae, L = L.next;
          } while (L !== null);
          te === null ? q = te = x : te = te.next = x;
        } else
          q = te = x;
        L = { baseState: H.baseState, firstBaseUpdate: q, lastBaseUpdate: te, shared: H.shared, effects: H.effects }, y.updateQueue = L;
        return;
      }
      y = L.lastBaseUpdate, y === null ? L.firstBaseUpdate = x : y.next = x, L.lastBaseUpdate = x;
    }
    function Cu(y, x, L, H) {
      var q = y.updateQueue;
      va = !1;
      var te = q.firstBaseUpdate, Ae = q.lastBaseUpdate, Ke = q.shared.pending;
      if (Ke !== null) {
        q.shared.pending = null;
        var kt = Ke, cn = kt.next;
        kt.next = null, Ae === null ? te = cn : Ae.next = cn, Ae = kt;
        var bn = y.alternate;
        bn !== null && (bn = bn.updateQueue, Ke = bn.lastBaseUpdate, Ke !== Ae && (Ke === null ? bn.firstBaseUpdate = cn : Ke.next = cn, bn.lastBaseUpdate = kt));
      }
      if (te !== null) {
        var wr = q.baseState;
        Ae = 0, bn = cn = kt = null, Ke = te;
        do {
          var ur = Ke.lane, _a = Ke.eventTime;
          if ((H & ur) === ur) {
            bn !== null && (bn = bn.next = {
              eventTime: _a,
              lane: 0,
              tag: Ke.tag,
              payload: Ke.payload,
              callback: Ke.callback,
              next: null
            });
            e: {
              var Tn = y, Li = Ke;
              switch (ur = x, _a = L, Li.tag) {
                case 1:
                  if (Tn = Li.payload, typeof Tn == "function") {
                    wr = Tn.call(_a, wr, ur);
                    break e;
                  }
                  wr = Tn;
                  break e;
                case 3:
                  Tn.flags = Tn.flags & -65537 | 128;
                case 0:
                  if (Tn = Li.payload, ur = typeof Tn == "function" ? Tn.call(_a, wr, ur) : Tn, ur == null)
                    break e;
                  wr = o({}, wr, ur);
                  break e;
                case 2:
                  va = !0;
              }
            }
            Ke.callback !== null && Ke.lane !== 0 && (y.flags |= 64, ur = q.effects, ur === null ? q.effects = [Ke] : ur.push(Ke));
          } else
            _a = { eventTime: _a, lane: ur, tag: Ke.tag, payload: Ke.payload, callback: Ke.callback, next: null }, bn === null ? (cn = bn = _a, kt = wr) : bn = bn.next = _a, Ae |= ur;
          if (Ke = Ke.next, Ke === null) {
            if (Ke = q.shared.pending, Ke === null)
              break;
            ur = Ke, Ke = ur.next, ur.next = null, q.lastBaseUpdate = ur, q.shared.pending = null;
          }
        } while (1);
        if (bn === null && (kt = wr), q.baseState = kt, q.firstBaseUpdate = cn, q.lastBaseUpdate = bn, x = q.shared.interleaved, x !== null) {
          q = x;
          do
            Ae |= q.lane, q = q.next;
          while (q !== x);
        } else
          te === null && (q.shared.lanes = 0);
        zc |= Ae, y.lanes = Ae, y.memoizedState = wr;
      }
    }
    function Up(y, x, L) {
      if (y = x.effects, x.effects = null, y !== null)
        for (x = 0; x < y.length; x++) {
          var H = y[x], q = H.callback;
          if (q !== null) {
            if (H.callback = null, H = L, typeof q != "function")
              throw Error(l(191, q));
            q.call(H);
          }
        }
    }
    var cg = new r.Component().refs;
    function Zh(y, x, L, H) {
      x = y.memoizedState, L = L(H, x), L = L == null ? x : o({}, x, L), y.memoizedState = L, y.lanes === 0 && (y.updateQueue.baseState = L);
    }
    var Am = { isMounted: function(y) {
      return (y = y._reactInternals) ? ee(y) === y : !1;
    }, enqueueSetState: function(y, x, L) {
      y = y._reactInternals;
      var H = fi(), q = Ns(y), te = $o(H, q);
      te.payload = x, L != null && (te.callback = L), Ku(y, te), x = jl(y, q, H), x !== null && Qh(x, y, q);
    }, enqueueReplaceState: function(y, x, L) {
      y = y._reactInternals;
      var H = fi(), q = Ns(y), te = $o(H, q);
      te.tag = 1, te.payload = x, L != null && (te.callback = L), Ku(y, te), x = jl(y, q, H), x !== null && Qh(x, y, q);
    }, enqueueForceUpdate: function(y, x) {
      y = y._reactInternals;
      var L = fi(), H = Ns(y), q = $o(
        L,
        H
      );
      q.tag = 2, x != null && (q.callback = x), Ku(y, q), x = jl(y, H, L), x !== null && Qh(x, y, H);
    } };
    function Dm(y, x, L, H, q, te, Ae) {
      return y = y.stateNode, typeof y.shouldComponentUpdate == "function" ? y.shouldComponentUpdate(H, te, Ae) : x.prototype && x.prototype.isPureReactComponent ? !Ki(L, H) || !Ki(q, te) : !0;
    }
    function Lm(y, x, L) {
      var H = !1, q = Ea, te = x.contextType;
      return typeof te == "object" && te !== null ? te = Jr(te) : (q = Pa(x) ? Oo : _i.current, H = x.contextTypes, te = (H = H != null) ? Uo(y, q) : Ea), x = new x(L, te), y.memoizedState = x.state !== null && x.state !== void 0 ? x.state : null, x.updater = Am, y.stateNode = x, x._reactInternals = y, H && (y = y.stateNode, y.__reactInternalMemoizedUnmaskedChildContext = q, y.__reactInternalMemoizedMaskedChildContext = te), x;
    }
    function Pm(y, x, L, H) {
      y = x.state, typeof x.componentWillReceiveProps == "function" && x.componentWillReceiveProps(L, H), typeof x.UNSAFE_componentWillReceiveProps == "function" && x.UNSAFE_componentWillReceiveProps(L, H), x.state !== y && Am.enqueueReplaceState(x, x.state, null);
    }
    function vh(y, x, L, H) {
      var q = y.stateNode;
      q.props = L, q.state = y.memoizedState, q.refs = cg, qs(y);
      var te = x.contextType;
      typeof te == "object" && te !== null ? q.context = Jr(te) : (te = Pa(x) ? Oo : _i.current, q.context = Uo(y, te)), q.state = y.memoizedState, te = x.getDerivedStateFromProps, typeof te == "function" && (Zh(y, x, te, L), q.state = y.memoizedState), typeof x.getDerivedStateFromProps == "function" || typeof q.getSnapshotBeforeUpdate == "function" || typeof q.UNSAFE_componentWillMount != "function" && typeof q.componentWillMount != "function" || (x = q.state, typeof q.componentWillMount == "function" && q.componentWillMount(), typeof q.UNSAFE_componentWillMount == "function" && q.UNSAFE_componentWillMount(), x !== q.state && Am.enqueueReplaceState(q, q.state, null), Cu(y, L, q, H), q.state = y.memoizedState), typeof q.componentDidMount == "function" && (y.flags |= 4194308);
    }
    var $u = [], Nd = 0, Ru = null, zp = 0, hl = [], el = 0, pf = null, Jf = 1, lu = "";
    function mf(y, x) {
      $u[Nd++] = zp, $u[Nd++] = Ru, Ru = y, zp = x;
    }
    function Ol(y, x, L) {
      hl[el++] = Jf, hl[el++] = lu, hl[el++] = pf, pf = y;
      var H = Jf;
      y = lu;
      var q = 32 - Ls(H) - 1;
      H &= ~(1 << q), L += 1;
      var te = 32 - Ls(x) + q;
      if (30 < te) {
        var Ae = q - q % 5;
        te = (H & (1 << Ae) - 1).toString(32), H >>= Ae, q -= Ae, Jf = 1 << 32 - Ls(x) + q | L << q | H, lu = te + y;
      } else
        Jf = 1 << te | L << q | H, lu = y;
    }
    function ec(y) {
      y.return !== null && (mf(y, 1), Ol(y, 1, 0));
    }
    function Oi(y) {
      for (; y === Ru; )
        Ru = $u[--Nd], $u[Nd] = null, zp = $u[--Nd], $u[Nd] = null;
      for (; y === pf; )
        pf = hl[--el], hl[el] = null, lu = hl[--el], hl[el] = null, Jf = hl[--el], hl[el] = null;
    }
    var Za = null, Ma = null, ca = !1, Fd = !1, tl = null;
    function Om(y, x) {
      var L = Mo(5, null, null, 0);
      L.elementType = "DELETED", L.stateNode = x, L.return = y, x = y.deletions, x === null ? (y.deletions = [L], y.flags |= 16) : x.push(L);
    }
    function Um(y, x) {
      switch (y.tag) {
        case 5:
          return x = ki(x, y.type, y.pendingProps), x !== null ? (y.stateNode = x, Za = y, Ma = me(x), !0) : !1;
        case 6:
          return x = Wi(x, y.pendingProps), x !== null ? (y.stateNode = x, Za = y, Ma = null, !0) : !1;
        case 13:
          if (x = ni(x), x !== null) {
            var L = pf !== null ? { id: Jf, overflow: lu } : null;
            return y.memoizedState = { dehydrated: x, treeContext: L, retryLane: 1073741824 }, L = Mo(18, null, null, 0), L.stateNode = x, L.return = y, y.child = L, Za = y, Ma = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function gh(y) {
      return (y.mode & 1) !== 0 && (y.flags & 128) === 0;
    }
    function Kf(y) {
      if (ca) {
        var x = Ma;
        if (x) {
          var L = x;
          if (!Um(y, x)) {
            if (gh(y))
              throw Error(l(418));
            x = ct(L);
            var H = Za;
            x && Um(y, x) ? Om(H, L) : (y.flags = y.flags & -4097 | 2, ca = !1, Za = y);
          }
        } else {
          if (gh(y))
            throw Error(l(418));
          y.flags = y.flags & -4097 | 2, ca = !1, Za = y;
        }
      }
    }
    function kd(y) {
      for (y = y.return; y !== null && y.tag !== 5 && y.tag !== 3 && y.tag !== 13; )
        y = y.return;
      Za = y;
    }
    function Np(y) {
      if (!et || y !== Za)
        return !1;
      if (!ca)
        return kd(y), ca = !0, !1;
      if (y.tag !== 3 && (y.tag !== 5 || Yi(y.type) && !st(y.type, y.memoizedProps))) {
        var x = Ma;
        if (x) {
          if (gh(y)) {
            for (y = Ma; y; )
              y = ct(y);
            throw Error(l(418));
          }
          for (; x; )
            Om(y, x), x = ct(x);
        }
      }
      if (kd(y), y.tag === 13) {
        if (!et)
          throw Error(l(316));
        if (y = y.memoizedState, y = y !== null ? y.dehydrated : null, !y)
          throw Error(l(317));
        Ma = mn(y);
      } else
        Ma = Za ? ct(y.stateNode) : null;
      return !0;
    }
    function yh() {
      et && (Ma = Za = null, Fd = ca = !1);
    }
    function Id(y) {
      tl === null ? tl = [y] : tl.push(y);
    }
    function $f(y, x, L) {
      if (y = L.ref, y !== null && typeof y != "function" && typeof y != "object") {
        if (L._owner) {
          if (L = L._owner, L) {
            if (L.tag !== 1)
              throw Error(l(309));
            var H = L.stateNode;
          }
          if (!H)
            throw Error(l(147, y));
          var q = H, te = "" + y;
          return x !== null && x.ref !== null && typeof x.ref == "function" && x.ref._stringRef === te ? x.ref : (x = function(Ae) {
            var Ke = q.refs;
            Ke === cg && (Ke = q.refs = {}), Ae === null ? delete Ke[te] : Ke[te] = Ae;
          }, x._stringRef = te, x);
        }
        if (typeof y != "string")
          throw Error(l(284));
        if (!L._owner)
          throw Error(l(290, y));
      }
      return y;
    }
    function Ss(y, x) {
      throw y = Object.prototype.toString.call(x), Error(l(31, y === "[object Object]" ? "object with keys {" + Object.keys(x).join(", ") + "}" : y));
    }
    function tc(y) {
      var x = y._init;
      return x(y._payload);
    }
    function vf(y) {
      function x(dt, Qe) {
        if (y) {
          var At = dt.deletions;
          At === null ? (dt.deletions = [Qe], dt.flags |= 16) : At.push(Qe);
        }
      }
      function L(dt, Qe) {
        if (!y)
          return null;
        for (; Qe !== null; )
          x(dt, Qe), Qe = Qe.sibling;
        return null;
      }
      function H(dt, Qe) {
        for (dt = /* @__PURE__ */ new Map(); Qe !== null; )
          Qe.key !== null ? dt.set(Qe.key, Qe) : dt.set(Qe.index, Qe), Qe = Qe.sibling;
        return dt;
      }
      function q(dt, Qe) {
        return dt = Yo(dt, Qe), dt.index = 0, dt.sibling = null, dt;
      }
      function te(dt, Qe, At) {
        return dt.index = At, y ? (At = dt.alternate, At !== null ? (At = At.index, At < Qe ? (dt.flags |= 2, Qe) : At) : (dt.flags |= 2, Qe)) : (dt.flags |= 1048576, Qe);
      }
      function Ae(dt) {
        return y && dt.alternate === null && (dt.flags |= 2), dt;
      }
      function Ke(dt, Qe, At, qt) {
        return Qe === null || Qe.tag !== 6 ? (Qe = Ms(At, dt.mode, qt), Qe.return = dt, Qe) : (Qe = q(Qe, At), Qe.return = dt, Qe);
      }
      function kt(dt, Qe, At, qt) {
        var Wn = At.type;
        return Wn === S ? bn(dt, Qe, At.props.children, qt, At.key) : Qe !== null && (Qe.elementType === Wn || typeof Wn == "object" && Wn !== null && Wn.$$typeof === V && tc(Wn) === Qe.type) ? (qt = q(Qe, At.props), qt.ref = $f(dt, Qe, At), qt.return = dt, qt) : (qt = fd(At.type, At.key, At.props, null, dt.mode, qt), qt.ref = $f(dt, Qe, At), qt.return = dt, qt);
      }
      function cn(dt, Qe, At, qt) {
        return Qe === null || Qe.tag !== 4 || Qe.stateNode.containerInfo !== At.containerInfo || Qe.stateNode.implementation !== At.implementation ? (Qe = ks(At, dt.mode, qt), Qe.return = dt, Qe) : (Qe = q(Qe, At.children || []), Qe.return = dt, Qe);
      }
      function bn(dt, Qe, At, qt, Wn) {
        return Qe === null || Qe.tag !== 7 ? (Qe = mu(At, dt.mode, qt, Wn), Qe.return = dt, Qe) : (Qe = q(Qe, At), Qe.return = dt, Qe);
      }
      function wr(dt, Qe, At) {
        if (typeof Qe == "string" && Qe !== "" || typeof Qe == "number")
          return Qe = Ms("" + Qe, dt.mode, At), Qe.return = dt, Qe;
        if (typeof Qe == "object" && Qe !== null) {
          switch (Qe.$$typeof) {
            case h:
              return At = fd(Qe.type, Qe.key, Qe.props, null, dt.mode, At), At.ref = $f(dt, null, Qe), At.return = dt, At;
            case m:
              return Qe = ks(Qe, dt.mode, At), Qe.return = dt, Qe;
            case V:
              var qt = Qe._init;
              return wr(dt, qt(Qe._payload), At);
          }
          if (Fe(Qe) || J(Qe))
            return Qe = mu(Qe, dt.mode, At, null), Qe.return = dt, Qe;
          Ss(dt, Qe);
        }
        return null;
      }
      function ur(dt, Qe, At, qt) {
        var Wn = Qe !== null ? Qe.key : null;
        if (typeof At == "string" && At !== "" || typeof At == "number")
          return Wn !== null ? null : Ke(dt, Qe, "" + At, qt);
        if (typeof At == "object" && At !== null) {
          switch (At.$$typeof) {
            case h:
              return At.key === Wn ? kt(dt, Qe, At, qt) : null;
            case m:
              return At.key === Wn ? cn(dt, Qe, At, qt) : null;
            case V:
              return Wn = At._init, ur(
                dt,
                Qe,
                Wn(At._payload),
                qt
              );
          }
          if (Fe(At) || J(At))
            return Wn !== null ? null : bn(dt, Qe, At, qt, null);
          Ss(dt, At);
        }
        return null;
      }
      function _a(dt, Qe, At, qt, Wn) {
        if (typeof qt == "string" && qt !== "" || typeof qt == "number")
          return dt = dt.get(At) || null, Ke(Qe, dt, "" + qt, Wn);
        if (typeof qt == "object" && qt !== null) {
          switch (qt.$$typeof) {
            case h:
              return dt = dt.get(qt.key === null ? At : qt.key) || null, kt(Qe, dt, qt, Wn);
            case m:
              return dt = dt.get(qt.key === null ? At : qt.key) || null, cn(Qe, dt, qt, Wn);
            case V:
              var Xr = qt._init;
              return _a(dt, Qe, At, Xr(qt._payload), Wn);
          }
          if (Fe(qt) || J(qt))
            return dt = dt.get(At) || null, bn(Qe, dt, qt, Wn, null);
          Ss(Qe, qt);
        }
        return null;
      }
      function Tn(dt, Qe, At, qt) {
        for (var Wn = null, Xr = null, Er = Qe, Ar = Qe = 0, Va = null; Er !== null && Ar < At.length; Ar++) {
          Er.index > Ar ? (Va = Er, Er = null) : Va = Er.sibling;
          var $r = ur(dt, Er, At[Ar], qt);
          if ($r === null) {
            Er === null && (Er = Va);
            break;
          }
          y && Er && $r.alternate === null && x(dt, Er), Qe = te($r, Qe, Ar), Xr === null ? Wn = $r : Xr.sibling = $r, Xr = $r, Er = Va;
        }
        if (Ar === At.length)
          return L(dt, Er), ca && mf(dt, Ar), Wn;
        if (Er === null) {
          for (; Ar < At.length; Ar++)
            Er = wr(dt, At[Ar], qt), Er !== null && (Qe = te(Er, Qe, Ar), Xr === null ? Wn = Er : Xr.sibling = Er, Xr = Er);
          return ca && mf(dt, Ar), Wn;
        }
        for (Er = H(dt, Er); Ar < At.length; Ar++)
          Va = _a(Er, dt, Ar, At[Ar], qt), Va !== null && (y && Va.alternate !== null && Er.delete(Va.key === null ? Ar : Va.key), Qe = te(Va, Qe, Ar), Xr === null ? Wn = Va : Xr.sibling = Va, Xr = Va);
        return y && Er.forEach(function(hc) {
          return x(dt, hc);
        }), ca && mf(dt, Ar), Wn;
      }
      function Li(dt, Qe, At, qt) {
        var Wn = J(At);
        if (typeof Wn != "function")
          throw Error(l(150));
        if (At = Wn.call(At), At == null)
          throw Error(l(151));
        for (var Xr = Wn = null, Er = Qe, Ar = Qe = 0, Va = null, $r = At.next(); Er !== null && !$r.done; Ar++, $r = At.next()) {
          Er.index > Ar ? (Va = Er, Er = null) : Va = Er.sibling;
          var hc = ur(dt, Er, $r.value, qt);
          if (hc === null) {
            Er === null && (Er = Va);
            break;
          }
          y && Er && hc.alternate === null && x(dt, Er), Qe = te(hc, Qe, Ar), Xr === null ? Wn = hc : Xr.sibling = hc, Xr = hc, Er = Va;
        }
        if ($r.done)
          return L(
            dt,
            Er
          ), ca && mf(dt, Ar), Wn;
        if (Er === null) {
          for (; !$r.done; Ar++, $r = At.next())
            $r = wr(dt, $r.value, qt), $r !== null && (Qe = te($r, Qe, Ar), Xr === null ? Wn = $r : Xr.sibling = $r, Xr = $r);
          return ca && mf(dt, Ar), Wn;
        }
        for (Er = H(dt, Er); !$r.done; Ar++, $r = At.next())
          $r = _a(Er, dt, Ar, $r.value, qt), $r !== null && (y && $r.alternate !== null && Er.delete($r.key === null ? Ar : $r.key), Qe = te($r, Qe, Ar), Xr === null ? Wn = $r : Xr.sibling = $r, Xr = $r);
        return y && Er.forEach(function(hd) {
          return x(dt, hd);
        }), ca && mf(dt, Ar), Wn;
      }
      function ms(dt, Qe, At, qt) {
        if (typeof At == "object" && At !== null && At.type === S && At.key === null && (At = At.props.children), typeof At == "object" && At !== null) {
          switch (At.$$typeof) {
            case h:
              e: {
                for (var Wn = At.key, Xr = Qe; Xr !== null; ) {
                  if (Xr.key === Wn) {
                    if (Wn = At.type, Wn === S) {
                      if (Xr.tag === 7) {
                        L(dt, Xr.sibling), Qe = q(Xr, At.props.children), Qe.return = dt, dt = Qe;
                        break e;
                      }
                    } else if (Xr.elementType === Wn || typeof Wn == "object" && Wn !== null && Wn.$$typeof === V && tc(Wn) === Xr.type) {
                      L(dt, Xr.sibling), Qe = q(Xr, At.props), Qe.ref = $f(dt, Xr, At), Qe.return = dt, dt = Qe;
                      break e;
                    }
                    L(dt, Xr);
                    break;
                  } else
                    x(dt, Xr);
                  Xr = Xr.sibling;
                }
                At.type === S ? (Qe = mu(At.props.children, dt.mode, qt, At.key), Qe.return = dt, dt = Qe) : (qt = fd(At.type, At.key, At.props, null, dt.mode, qt), qt.ref = $f(dt, Qe, At), qt.return = dt, dt = qt);
              }
              return Ae(dt);
            case m:
              e: {
                for (Xr = At.key; Qe !== null; ) {
                  if (Qe.key === Xr)
                    if (Qe.tag === 4 && Qe.stateNode.containerInfo === At.containerInfo && Qe.stateNode.implementation === At.implementation) {
                      L(dt, Qe.sibling), Qe = q(Qe, At.children || []), Qe.return = dt, dt = Qe;
                      break e;
                    } else {
                      L(dt, Qe);
                      break;
                    }
                  else
                    x(dt, Qe);
                  Qe = Qe.sibling;
                }
                Qe = ks(At, dt.mode, qt), Qe.return = dt, dt = Qe;
              }
              return Ae(dt);
            case V:
              return Xr = At._init, ms(dt, Qe, Xr(At._payload), qt);
          }
          if (Fe(At))
            return Tn(dt, Qe, At, qt);
          if (J(At))
            return Li(dt, Qe, At, qt);
          Ss(dt, At);
        }
        return typeof At == "string" && At !== "" || typeof At == "number" ? (At = "" + At, Qe !== null && Qe.tag === 6 ? (L(dt, Qe.sibling), Qe = q(Qe, At), Qe.return = dt, dt = Qe) : (L(dt, Qe), Qe = Ms(At, dt.mode, qt), Qe.return = dt, dt = Qe), Ae(dt)) : L(dt, Qe);
      }
      return ms;
    }
    var wc = vf(!0), Fp = vf(!1), nc = {}, Na = us(nc), Bd = us(nc), ed = us(nc);
    function rc(y) {
      if (y === nc)
        throw Error(l(174));
      return y;
    }
    function kp(y, x) {
      pi(ed, x), pi(Bd, y), pi(Na, nc), y = Be(x), mr(Na), pi(Na, y);
    }
    function xh() {
      mr(Na), mr(Bd), mr(ed);
    }
    function Ip(y) {
      var x = rc(ed.current), L = rc(Na.current);
      x = he(L, y.type, x), L !== x && (pi(Bd, y), pi(Na, x));
    }
    function ko(y) {
      Bd.current === y && (mr(Na), mr(Bd));
    }
    var Ye = us(0);
    function Bt(y) {
      for (var x = y; x !== null; ) {
        if (x.tag === 13) {
          var L = x.memoizedState;
          if (L !== null && (L = L.dehydrated, L === null || ji(L) || Si(L)))
            return x;
        } else if (x.tag === 19 && x.memoizedProps.revealOrder !== void 0) {
          if ((x.flags & 128) !== 0)
            return x;
        } else if (x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === y)
          break;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === y)
            return null;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
      return null;
    }
    var pt = [];
    function Mn() {
      for (var y = 0; y < pt.length; y++) {
        var x = pt[y];
        Rt ? x._workInProgressVersionPrimary = null : x._workInProgressVersionSecondary = null;
      }
      pt.length = 0;
    }
    var Kn = d.ReactCurrentDispatcher, or = d.ReactCurrentBatchConfig, Ta = 0, $n = null, Ui = null, ra = null, Io = !1, fs = !1, Hd = 0, Ul = 0;
    function $a() {
      throw Error(l(321));
    }
    function pl(y, x) {
      if (x === null)
        return !1;
      for (var L = 0; L < x.length && L < y.length; L++)
        if (!No(y[L], x[L]))
          return !1;
      return !0;
    }
    function xi(y, x, L, H, q, te) {
      if (Ta = te, $n = x, x.memoizedState = null, x.updateQueue = null, x.lanes = 0, Kn.current = y === null || y.memoizedState === null ? Lu : rd, y = L(H, q), fs) {
        te = 0;
        do {
          if (fs = !1, Hd = 0, 25 <= te)
            throw Error(l(301));
          te += 1, ra = Ui = null, x.updateQueue = null, Kn.current = uu, y = L(H, q);
        } while (fs);
      }
      if (Kn.current = xf, x = Ui !== null && Ui.next !== null, Ta = 0, ra = Ui = $n = null, Io = !1, x)
        throw Error(l(300));
      return y;
    }
    function Ec() {
      var y = Hd !== 0;
      return Hd = 0, y;
    }
    function Au() {
      var y = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return ra === null ? $n.memoizedState = ra = y : ra = ra.next = y, ra;
    }
    function ml() {
      if (Ui === null) {
        var y = $n.alternate;
        y = y !== null ? y.memoizedState : null;
      } else
        y = Ui.next;
      var x = ra === null ? $n.memoizedState : ra.next;
      if (x !== null)
        ra = x, Ui = y;
      else {
        if (y === null)
          throw Error(l(310));
        Ui = y, y = { memoizedState: Ui.memoizedState, baseState: Ui.baseState, baseQueue: Ui.baseQueue, queue: Ui.queue, next: null }, ra === null ? $n.memoizedState = ra = y : ra = ra.next = y;
      }
      return ra;
    }
    function Ca(y, x) {
      return typeof x == "function" ? x(y) : x;
    }
    function Sh(y) {
      var x = ml(), L = x.queue;
      if (L === null)
        throw Error(l(311));
      L.lastRenderedReducer = y;
      var H = Ui, q = H.baseQueue, te = L.pending;
      if (te !== null) {
        if (q !== null) {
          var Ae = q.next;
          q.next = te.next, te.next = Ae;
        }
        H.baseQueue = q = te, L.pending = null;
      }
      if (q !== null) {
        te = q.next, H = H.baseState;
        var Ke = Ae = null, kt = null, cn = te;
        do {
          var bn = cn.lane;
          if ((Ta & bn) === bn)
            kt !== null && (kt = kt.next = { lane: 0, action: cn.action, hasEagerState: cn.hasEagerState, eagerState: cn.eagerState, next: null }), H = cn.hasEagerState ? cn.eagerState : y(H, cn.action);
          else {
            var wr = {
              lane: bn,
              action: cn.action,
              hasEagerState: cn.hasEagerState,
              eagerState: cn.eagerState,
              next: null
            };
            kt === null ? (Ke = kt = wr, Ae = H) : kt = kt.next = wr, $n.lanes |= bn, zc |= bn;
          }
          cn = cn.next;
        } while (cn !== null && cn !== te);
        kt === null ? Ae = H : kt.next = Ke, No(H, x.memoizedState) || (oi = !0), x.memoizedState = H, x.baseState = Ae, x.baseQueue = kt, L.lastRenderedState = H;
      }
      if (y = L.interleaved, y !== null) {
        q = y;
        do
          te = q.lane, $n.lanes |= te, zc |= te, q = q.next;
        while (q !== y);
      } else
        q === null && (L.lanes = 0);
      return [x.memoizedState, L.dispatch];
    }
    function Bp(y) {
      var x = ml(), L = x.queue;
      if (L === null)
        throw Error(l(311));
      L.lastRenderedReducer = y;
      var H = L.dispatch, q = L.pending, te = x.memoizedState;
      if (q !== null) {
        L.pending = null;
        var Ae = q = q.next;
        do
          te = y(te, Ae.action), Ae = Ae.next;
        while (Ae !== q);
        No(te, x.memoizedState) || (oi = !0), x.memoizedState = te, x.baseQueue === null && (x.baseState = te), L.lastRenderedState = te;
      }
      return [te, H];
    }
    function Mc() {
    }
    function Tc(y, x) {
      var L = $n, H = ml(), q = x(), te = !No(H.memoizedState, q);
      if (te && (H.memoizedState = q, oi = !0), H = H.queue, an(Br.bind(null, L, H, y), [y]), H.getSnapshot !== x || te || ra !== null && ra.memoizedState.tag & 1) {
        if (L.flags |= 2048, td(9, $i.bind(null, L, H, q, x), void 0, null), Ra === null)
          throw Error(l(349));
        (Ta & 30) !== 0 || Mr(L, x, q);
      }
      return q;
    }
    function Mr(y, x, L) {
      y.flags |= 16384, y = { getSnapshot: x, value: L }, x = $n.updateQueue, x === null ? (x = { lastEffect: null, stores: null }, $n.updateQueue = x, x.stores = [y]) : (L = x.stores, L === null ? x.stores = [y] : L.push(y));
    }
    function $i(y, x, L, H) {
      x.value = L, x.getSnapshot = H, Fa(x) && jl(y, 1, -1);
    }
    function Br(y, x, L) {
      return L(function() {
        Fa(x) && jl(y, 1, -1);
      });
    }
    function Fa(y) {
      var x = y.getSnapshot;
      y = y.value;
      try {
        var L = x();
        return !No(y, L);
      } catch {
        return !0;
      }
    }
    function So(y) {
      var x = Au();
      return typeof y == "function" && (y = y()), x.memoizedState = x.baseState = y, y = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ca, lastRenderedState: y }, x.queue = y, y = y.dispatch = Qs.bind(null, $n, y), [x.memoizedState, y];
    }
    function td(y, x, L, H) {
      return y = { tag: y, create: x, destroy: L, deps: H, next: null }, x = $n.updateQueue, x === null ? (x = { lastEffect: null, stores: null }, $n.updateQueue = x, x.lastEffect = y.next = y) : (L = x.lastEffect, L === null ? x.lastEffect = y.next = y : (H = L.next, L.next = y, y.next = H, x.lastEffect = y)), y;
    }
    function _h() {
      return ml().memoizedState;
    }
    function ic(y, x, L, H) {
      var q = Au();
      $n.flags |= y, q.memoizedState = td(1 | x, L, void 0, H === void 0 ? null : H);
    }
    function gf(y, x, L, H) {
      var q = ml();
      H = H === void 0 ? null : H;
      var te = void 0;
      if (Ui !== null) {
        var Ae = Ui.memoizedState;
        if (te = Ae.destroy, H !== null && pl(H, Ae.deps)) {
          q.memoizedState = td(x, L, te, H);
          return;
        }
      }
      $n.flags |= y, q.memoizedState = td(1 | x, L, te, H);
    }
    function nd(y, x) {
      return ic(8390656, 8, y, x);
    }
    function an(y, x) {
      return gf(2048, 8, y, x);
    }
    function Ir(y, x) {
      return gf(4, 2, y, x);
    }
    function Hr(y, x) {
      return gf(4, 4, y, x);
    }
    function Bo(y, x) {
      if (typeof x == "function")
        return y = y(), x(y), function() {
          x(null);
        };
      if (x != null)
        return y = y(), x.current = y, function() {
          x.current = null;
        };
    }
    function nl(y, x, L) {
      return L = L != null ? L.concat([y]) : null, gf(4, 4, Bo.bind(null, x, y), L);
    }
    function ac() {
    }
    function Du(y, x) {
      var L = ml();
      x = x === void 0 ? null : x;
      var H = L.memoizedState;
      return H !== null && x !== null && pl(x, H[1]) ? H[0] : (L.memoizedState = [y, x], y);
    }
    function Cc(y, x) {
      var L = ml();
      x = x === void 0 ? null : x;
      var H = L.memoizedState;
      return H !== null && x !== null && pl(x, H[1]) ? H[0] : (y = y(), L.memoizedState = [y, x], y);
    }
    function yf(y, x) {
      var L = Cr;
      Cr = L !== 0 && 4 > L ? L : 4, y(!0);
      var H = or.transition;
      or.transition = {};
      try {
        y(!1), x();
      } finally {
        Cr = L, or.transition = H;
      }
    }
    function sc() {
      return ml().memoizedState;
    }
    function ds(y, x, L) {
      var H = Ns(y);
      L = { lane: H, action: L, hasEagerState: !1, eagerState: null, next: null }, zm(y) ? Jh(x, L) : (Vd(y, x, L), L = fi(), y = jl(y, H, L), y !== null && bh(y, x, H));
    }
    function Qs(y, x, L) {
      var H = Ns(y), q = { lane: H, action: L, hasEagerState: !1, eagerState: null, next: null };
      if (zm(y))
        Jh(x, q);
      else {
        Vd(y, x, q);
        var te = y.alternate;
        if (y.lanes === 0 && (te === null || te.lanes === 0) && (te = x.lastRenderedReducer, te !== null))
          try {
            var Ae = x.lastRenderedState, Ke = te(Ae, L);
            if (q.hasEagerState = !0, q.eagerState = Ke, No(Ke, Ae))
              return;
          } catch {
          } finally {
          }
        L = fi(), y = jl(y, H, L), y !== null && bh(y, x, H);
      }
    }
    function zm(y) {
      var x = y.alternate;
      return y === $n || x !== null && x === $n;
    }
    function Jh(y, x) {
      fs = Io = !0;
      var L = y.pending;
      L === null ? x.next = x : (x.next = L.next, L.next = x), y.pending = x;
    }
    function Vd(y, x, L) {
      Ra !== null && (y.mode & 1) !== 0 && (Kr & 2) === 0 ? (y = x.interleaved, y === null ? (L.next = L, xs === null ? xs = [x] : xs.push(x)) : (L.next = y.next, y.next = L), x.interleaved = L) : (y = x.pending, y === null ? L.next = L : (L.next = y.next, y.next = L), x.pending = L);
    }
    function bh(y, x, L) {
      if ((L & 4194240) !== 0) {
        var H = x.lanes;
        H &= y.pendingLanes, L |= H, x.lanes = L, ua(y, L);
      }
    }
    var xf = { readContext: Jr, useCallback: $a, useContext: $a, useEffect: $a, useImperativeHandle: $a, useInsertionEffect: $a, useLayoutEffect: $a, useMemo: $a, useReducer: $a, useRef: $a, useState: $a, useDebugValue: $a, useDeferredValue: $a, useTransition: $a, useMutableSource: $a, useSyncExternalStore: $a, useId: $a, unstable_isNewReconciler: !1 }, Lu = { readContext: Jr, useCallback: function(y, x) {
      return Au().memoizedState = [y, x === void 0 ? null : x], y;
    }, useContext: Jr, useEffect: nd, useImperativeHandle: function(y, x, L) {
      return L = L != null ? L.concat([y]) : null, ic(
        4194308,
        4,
        Bo.bind(null, x, y),
        L
      );
    }, useLayoutEffect: function(y, x) {
      return ic(4194308, 4, y, x);
    }, useInsertionEffect: function(y, x) {
      return ic(4, 2, y, x);
    }, useMemo: function(y, x) {
      var L = Au();
      return x = x === void 0 ? null : x, y = y(), L.memoizedState = [y, x], y;
    }, useReducer: function(y, x, L) {
      var H = Au();
      return x = L !== void 0 ? L(x) : x, H.memoizedState = H.baseState = x, y = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: y, lastRenderedState: x }, H.queue = y, y = y.dispatch = ds.bind(null, $n, y), [H.memoizedState, y];
    }, useRef: function(y) {
      var x = Au();
      return y = { current: y }, x.memoizedState = y;
    }, useState: So, useDebugValue: ac, useDeferredValue: function(y) {
      var x = So(y), L = x[0], H = x[1];
      return nd(function() {
        var q = or.transition;
        or.transition = {};
        try {
          H(y);
        } finally {
          or.transition = q;
        }
      }, [y]), L;
    }, useTransition: function() {
      var y = So(!1), x = y[0];
      return y = yf.bind(null, y[1]), Au().memoizedState = y, [x, y];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(y, x, L) {
      var H = $n, q = Au();
      if (ca) {
        if (L === void 0)
          throw Error(l(407));
        L = L();
      } else {
        if (L = x(), Ra === null)
          throw Error(l(349));
        (Ta & 30) !== 0 || Mr(H, x, L);
      }
      q.memoizedState = L;
      var te = { value: L, getSnapshot: x };
      return q.queue = te, nd(Br.bind(null, H, te, y), [y]), H.flags |= 2048, td(9, $i.bind(null, H, te, L, x), void 0, null), L;
    }, useId: function() {
      var y = Au(), x = Ra.identifierPrefix;
      if (ca) {
        var L = lu, H = Jf;
        L = (H & ~(1 << 32 - Ls(H) - 1)).toString(32) + L, x = ":" + x + "R" + L, L = Hd++, 0 < L && (x += "H" + L.toString(32)), x += ":";
      } else
        L = Ul++, x = ":" + x + "r" + L.toString(32) + ":";
      return y.memoizedState = x;
    }, unstable_isNewReconciler: !1 }, rd = {
      readContext: Jr,
      useCallback: Du,
      useContext: Jr,
      useEffect: an,
      useImperativeHandle: nl,
      useInsertionEffect: Ir,
      useLayoutEffect: Hr,
      useMemo: Cc,
      useReducer: Sh,
      useRef: _h,
      useState: function() {
        return Sh(Ca);
      },
      useDebugValue: ac,
      useDeferredValue: function(y) {
        var x = Sh(Ca), L = x[0], H = x[1];
        return an(function() {
          var q = or.transition;
          or.transition = {};
          try {
            H(y);
          } finally {
            or.transition = q;
          }
        }, [y]), L;
      },
      useTransition: function() {
        var y = Sh(Ca)[0], x = ml().memoizedState;
        return [y, x];
      },
      useMutableSource: Mc,
      useSyncExternalStore: Tc,
      useId: sc,
      unstable_isNewReconciler: !1
    }, uu = {
      readContext: Jr,
      useCallback: Du,
      useContext: Jr,
      useEffect: an,
      useImperativeHandle: nl,
      useInsertionEffect: Ir,
      useLayoutEffect: Hr,
      useMemo: Cc,
      useReducer: Bp,
      useRef: _h,
      useState: function() {
        return Bp(Ca);
      },
      useDebugValue: ac,
      useDeferredValue: function(y) {
        var x = Bp(Ca), L = x[0], H = x[1];
        return an(function() {
          var q = or.transition;
          or.transition = {};
          try {
            H(y);
          } finally {
            or.transition = q;
          }
        }, [y]), L;
      },
      useTransition: function() {
        var y = Bp(Ca)[0], x = ml().memoizedState;
        return [y, x];
      },
      useMutableSource: Mc,
      useSyncExternalStore: Tc,
      useId: sc,
      unstable_isNewReconciler: !1
    };
    function Sf(y, x) {
      try {
        var L = "", H = x;
        do
          L += Mu(H), H = H.return;
        while (H);
        var q = L;
      } catch (te) {
        q = `
Error generating stack: ` + te.message + `
` + te.stack;
      }
      return { value: y, source: x, stack: q };
    }
    function Rc(y, x) {
      try {
        console.error(x.value);
      } catch (L) {
        setTimeout(function() {
          throw L;
        });
      }
    }
    var Gd = typeof WeakMap == "function" ? WeakMap : Map;
    function id(y, x, L) {
      L = $o(-1, L), L.tag = 3, L.payload = { element: null };
      var H = x.value;
      return L.callback = function() {
        Mf || (Mf = !0, Vl = H), Rc(y, x);
      }, L;
    }
    function Ac(y, x, L) {
      L = $o(-1, L), L.tag = 3;
      var H = y.type.getDerivedStateFromError;
      if (typeof H == "function") {
        var q = x.value;
        L.payload = function() {
          return H(q);
        }, L.callback = function() {
          Rc(y, x);
        };
      }
      var te = y.stateNode;
      return te !== null && typeof te.componentDidCatch == "function" && (L.callback = function() {
        Rc(y, x), typeof H != "function" && (Gl === null ? Gl = /* @__PURE__ */ new Set([this]) : Gl.add(this));
        var Ae = x.stack;
        this.componentDidCatch(x.value, { componentStack: Ae !== null ? Ae : "" });
      }), L;
    }
    function zl(y, x, L) {
      var H = y.pingCache;
      if (H === null) {
        H = y.pingCache = new Gd();
        var q = /* @__PURE__ */ new Set();
        H.set(x, q);
      } else
        q = H.get(x), q === void 0 && (q = /* @__PURE__ */ new Set(), H.set(x, q));
      q.has(L) || (q.add(L), y = eo.bind(null, y, x, L), x.then(y, y));
    }
    function Dc(y) {
      do {
        var x;
        if ((x = y.tag === 13) && (x = y.memoizedState, x = x !== null ? x.dehydrated !== null : !0), x)
          return y;
        y = y.return;
      } while (y !== null);
      return null;
    }
    function Lc(y, x, L, H, q) {
      return (y.mode & 1) === 0 ? (y === x ? y.flags |= 65536 : (y.flags |= 128, L.flags |= 131072, L.flags &= -52805, L.tag === 1 && (L.alternate === null ? L.tag = 17 : (x = $o(-1, 1), x.tag = 2, Ku(L, x))), L.lanes |= 1), y) : (y.flags |= 65536, y.lanes = q, y);
    }
    function Os(y) {
      y.flags |= 4;
    }
    function Pu(y, x) {
      if (y !== null && y.child === x.child)
        return !0;
      if ((x.flags & 16) !== 0)
        return !1;
      for (y = x.child; y !== null; ) {
        if ((y.flags & 12854) !== 0 || (y.subtreeFlags & 12854) !== 0)
          return !1;
        y = y.sibling;
      }
      return !0;
    }
    var _o, ad, ve, oc;
    if (Ot)
      _o = function(y, x) {
        for (var L = x.child; L !== null; ) {
          if (L.tag === 5 || L.tag === 6)
            we(y, L.stateNode);
          else if (L.tag !== 4 && L.child !== null) {
            L.child.return = L, L = L.child;
            continue;
          }
          if (L === x)
            break;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === x)
              return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      }, ad = function() {
      }, ve = function(y, x, L, H, q) {
        if (y = y.memoizedProps, y !== H) {
          var te = x.stateNode, Ae = rc(Na.current);
          L = Je(te, L, y, H, q, Ae), (x.updateQueue = L) && Os(x);
        }
      }, oc = function(y, x, L, H) {
        L !== H && Os(x);
      };
    else if (He) {
      _o = function(y, x, L, H) {
        for (var q = x.child; q !== null; ) {
          if (q.tag === 5) {
            var te = q.stateNode;
            L && H && (te = jr(te, q.type, q.memoizedProps, q)), we(y, te);
          } else if (q.tag === 6)
            te = q.stateNode, L && H && (te = ti(te, q.memoizedProps, q)), we(y, te);
          else if (q.tag !== 4) {
            if (q.tag === 22 && q.memoizedState !== null)
              te = q.child, te !== null && (te.return = q), _o(y, q, !0, !0);
            else if (q.child !== null) {
              q.child.return = q, q = q.child;
              continue;
            }
          }
          if (q === x)
            break;
          for (; q.sibling === null; ) {
            if (q.return === null || q.return === x)
              return;
            q = q.return;
          }
          q.sibling.return = q.return, q = q.sibling;
        }
      };
      var Zs = function(y, x, L, H) {
        for (var q = x.child; q !== null; ) {
          if (q.tag === 5) {
            var te = q.stateNode;
            L && H && (te = jr(te, q.type, q.memoizedProps, q)), Ur(y, te);
          } else if (q.tag === 6)
            te = q.stateNode, L && H && (te = ti(te, q.memoizedProps, q)), Ur(y, te);
          else if (q.tag !== 4) {
            if (q.tag === 22 && q.memoizedState !== null)
              te = q.child, te !== null && (te.return = q), Zs(y, q, !0, !0);
            else if (q.child !== null) {
              q.child.return = q, q = q.child;
              continue;
            }
          }
          if (q === x)
            break;
          for (; q.sibling === null; ) {
            if (q.return === null || q.return === x)
              return;
            q = q.return;
          }
          q.sibling.return = q.return, q = q.sibling;
        }
      };
      ad = function(y, x) {
        var L = x.stateNode;
        if (!Pu(y, x)) {
          y = L.containerInfo;
          var H = Wr(y);
          Zs(H, x, !1, !1), L.pendingChildren = H, Os(x), ir(y, H);
        }
      }, ve = function(y, x, L, H, q) {
        var te = y.stateNode, Ae = y.memoizedProps;
        if ((y = Pu(y, x)) && Ae === H)
          x.stateNode = te;
        else {
          var Ke = x.stateNode, kt = rc(Na.current), cn = null;
          Ae !== H && (cn = Je(Ke, L, Ae, H, q, kt)), y && cn === null ? x.stateNode = te : (te = Gr(te, cn, L, Ae, H, x, y, Ke), Xe(te, L, H, q, kt) && Os(x), x.stateNode = te, y ? Os(x) : _o(te, x, !1, !1));
        }
      }, oc = function(y, x, L, H) {
        L !== H ? (y = rc(ed.current), L = rc(Na.current), x.stateNode = Ue(H, y, L, x), Os(x)) : x.stateNode = y.stateNode;
      };
    } else
      ad = function() {
      }, ve = function() {
      }, oc = function() {
      };
    function ka(y, x) {
      if (!ca)
        switch (y.tailMode) {
          case "hidden":
            x = y.tail;
            for (var L = null; x !== null; )
              x.alternate !== null && (L = x), x = x.sibling;
            L === null ? y.tail = null : L.sibling = null;
            break;
          case "collapsed":
            L = y.tail;
            for (var H = null; L !== null; )
              L.alternate !== null && (H = L), L = L.sibling;
            H === null ? x || y.tail === null ? y.tail = null : y.tail.sibling = null : H.sibling = null;
        }
    }
    function Hn(y) {
      var x = y.alternate !== null && y.alternate.child === y.child, L = 0, H = 0;
      if (x)
        for (var q = y.child; q !== null; )
          L |= q.lanes | q.childLanes, H |= q.subtreeFlags & 14680064, H |= q.flags & 14680064, q.return = y, q = q.sibling;
      else
        for (q = y.child; q !== null; )
          L |= q.lanes | q.childLanes, H |= q.subtreeFlags, H |= q.flags, q.return = y, q = q.sibling;
      return y.subtreeFlags |= H, y.childLanes = L, x;
    }
    function vr(y, x, L) {
      var H = x.pendingProps;
      switch (Oi(x), x.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Hn(x), null;
        case 1:
          return Pa(x.type) && Rl(), Hn(x), null;
        case 3:
          return H = x.stateNode, xh(), mr(Ti), mr(_i), Mn(), H.pendingContext && (H.context = H.pendingContext, H.pendingContext = null), (y === null || y.child === null) && (Np(x) ? Os(x) : y === null || y.memoizedState.isDehydrated && (x.flags & 256) === 0 || (x.flags |= 1024, tl !== null && (Ht(tl), tl = null))), ad(y, x), Hn(x), null;
        case 5:
          ko(x), L = rc(ed.current);
          var q = x.type;
          if (y !== null && x.stateNode != null)
            ve(y, x, q, H, L), y.ref !== x.ref && (x.flags |= 512, x.flags |= 2097152);
          else {
            if (!H) {
              if (x.stateNode === null)
                throw Error(l(166));
              return Hn(x), null;
            }
            if (y = rc(Na.current), Np(x)) {
              if (!et)
                throw Error(l(175));
              y = on(x.stateNode, x.type, x.memoizedProps, L, y, x, !Fd), x.updateQueue = y, y !== null && Os(x);
            } else {
              var te = ye(q, H, L, y, x);
              _o(te, x, !1, !1), x.stateNode = te, Xe(te, q, H, L, y) && Os(x);
            }
            x.ref !== null && (x.flags |= 512, x.flags |= 2097152);
          }
          return Hn(x), null;
        case 6:
          if (y && x.stateNode != null)
            oc(y, x, y.memoizedProps, H);
          else {
            if (typeof H != "string" && x.stateNode === null)
              throw Error(l(166));
            if (y = rc(ed.current), L = rc(Na.current), Np(x)) {
              if (!et)
                throw Error(l(176));
              if (y = x.stateNode, H = x.memoizedProps, (L = yn(y, H, x, !Fd)) && (q = Za, q !== null))
                switch (te = (q.mode & 1) !== 0, q.tag) {
                  case 3:
                    La(q.stateNode.containerInfo, y, H, te);
                    break;
                  case 5:
                    Ys(q.type, q.memoizedProps, q.stateNode, y, H, te);
                }
              L && Os(x);
            } else
              x.stateNode = Ue(H, y, L, x);
          }
          return Hn(x), null;
        case 13:
          if (mr(Ye), H = x.memoizedState, ca && Ma !== null && (x.mode & 1) !== 0 && (x.flags & 128) === 0) {
            for (y = Ma; y; )
              y = ct(y);
            return yh(), x.flags |= 98560, x;
          }
          if (H !== null && H.dehydrated !== null) {
            if (H = Np(x), y === null) {
              if (!H)
                throw Error(l(318));
              if (!et)
                throw Error(l(344));
              if (y = x.memoizedState, y = y !== null ? y.dehydrated : null, !y)
                throw Error(l(317));
              Rn(y, x);
            } else
              yh(), (x.flags & 128) === 0 && (x.memoizedState = null), x.flags |= 4;
            return Hn(x), null;
          }
          return tl !== null && (Ht(tl), tl = null), (x.flags & 128) !== 0 ? (x.lanes = L, x) : (H = H !== null, L = !1, y === null ? Np(x) : L = y.memoizedState !== null, H && !L && (x.child.flags |= 8192, (x.mode & 1) !== 0 && (y === null || (Ye.current & 1) !== 0 ? ws === 0 && (ws = 3) : Rf())), x.updateQueue !== null && (x.flags |= 4), Hn(x), null);
        case 4:
          return xh(), ad(y, x), y === null && vt(x.stateNode.containerInfo), Hn(x), null;
        case 10:
          return Pl(x.type._context), Hn(x), null;
        case 17:
          return Pa(x.type) && Rl(), Hn(x), null;
        case 19:
          if (mr(Ye), q = x.memoizedState, q === null)
            return Hn(x), null;
          if (H = (x.flags & 128) !== 0, te = q.rendering, te === null)
            if (H)
              ka(q, !1);
            else {
              if (ws !== 0 || y !== null && (y.flags & 128) !== 0)
                for (y = x.child; y !== null; ) {
                  if (te = Bt(y), te !== null) {
                    for (x.flags |= 128, ka(q, !1), y = te.updateQueue, y !== null && (x.updateQueue = y, x.flags |= 4), x.subtreeFlags = 0, y = L, H = x.child; H !== null; )
                      L = H, q = y, L.flags &= 14680066, te = L.alternate, te === null ? (L.childLanes = 0, L.lanes = q, L.child = null, L.subtreeFlags = 0, L.memoizedProps = null, L.memoizedState = null, L.updateQueue = null, L.dependencies = null, L.stateNode = null) : (L.childLanes = te.childLanes, L.lanes = te.lanes, L.child = te.child, L.subtreeFlags = 0, L.deletions = null, L.memoizedProps = te.memoizedProps, L.memoizedState = te.memoizedState, L.updateQueue = te.updateQueue, L.type = te.type, q = te.dependencies, L.dependencies = q === null ? null : { lanes: q.lanes, firstContext: q.firstContext }), H = H.sibling;
                    return pi(Ye, Ye.current & 1 | 2), x.child;
                  }
                  y = y.sibling;
                }
              q.tail !== null && mi() > Ef && (x.flags |= 128, H = !0, ka(q, !1), x.lanes = 4194304);
            }
          else {
            if (!H)
              if (y = Bt(te), y !== null) {
                if (x.flags |= 128, H = !0, y = y.updateQueue, y !== null && (x.updateQueue = y, x.flags |= 4), ka(q, !0), q.tail === null && q.tailMode === "hidden" && !te.alternate && !ca)
                  return Hn(x), null;
              } else
                2 * mi() - q.renderingStartTime > Ef && L !== 1073741824 && (x.flags |= 128, H = !0, ka(q, !1), x.lanes = 4194304);
            q.isBackwards ? (te.sibling = x.child, x.child = te) : (y = q.last, y !== null ? y.sibling = te : x.child = te, q.last = te);
          }
          return q.tail !== null ? (x = q.tail, q.rendering = x, q.tail = x.sibling, q.renderingStartTime = mi(), x.sibling = null, y = Ye.current, pi(Ye, H ? y & 1 | 2 : y & 1), x) : (Hn(x), null);
        case 22:
        case 23:
          return jo(), H = x.memoizedState !== null, y !== null && y.memoizedState !== null !== H && (x.flags |= 8192), H && (x.mode & 1) !== 0 ? (Hl & 1073741824) !== 0 && (Hn(x), Ot && x.subtreeFlags & 6 && (x.flags |= 8192)) : Hn(x), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(l(156, x.tag));
    }
    var Bi = d.ReactCurrentOwner, oi = !1;
    function Gn(y, x, L, H) {
      x.child = y === null ? Fp(x, null, L, H) : wc(x, y.child, L, H);
    }
    function bi(y, x, L, H, q) {
      L = L.render;
      var te = x.ref;
      return Xs(x, q), H = xi(y, x, L, H, te, q), L = Ec(), y !== null && !oi ? (x.updateQueue = y.updateQueue, x.flags &= -2053, y.lanes &= ~q, Vr(y, x, q)) : (ca && L && ec(x), x.flags |= 1, Gn(y, x, H, q), x.child);
    }
    function zi(y, x, L, H, q) {
      if (y === null) {
        var te = L.type;
        return typeof te == "function" && !Bc(te) && te.defaultProps === void 0 && L.compare === null && L.defaultProps === void 0 ? (x.tag = 15, x.type = te, Pc(y, x, te, H, q)) : (y = fd(L.type, null, H, x, x.mode, q), y.ref = x.ref, y.return = x, x.child = y);
      }
      if (te = y.child, (y.lanes & q) === 0) {
        var Ae = te.memoizedProps;
        if (L = L.compare, L = L !== null ? L : Ki, L(Ae, H) && y.ref === x.ref)
          return Vr(y, x, q);
      }
      return x.flags |= 1, y = Yo(te, H), y.ref = x.ref, y.return = x, x.child = y;
    }
    function Pc(y, x, L, H, q) {
      if (y !== null && Ki(y.memoizedProps, H) && y.ref === x.ref)
        if (oi = !1, (y.lanes & q) !== 0)
          (y.flags & 131072) !== 0 && (oi = !0);
        else
          return x.lanes = y.lanes, Vr(y, x, q);
      return es(y, x, L, H, q);
    }
    function Rr(y, x, L) {
      var H = x.pendingProps, q = H.children, te = y !== null ? y.memoizedState : null;
      if (H.mode === "hidden")
        if ((x.mode & 1) === 0)
          x.memoizedState = { baseLanes: 0, cachePool: null }, pi(od, Hl), Hl |= L;
        else if ((L & 1073741824) !== 0)
          x.memoizedState = { baseLanes: 0, cachePool: null }, H = te !== null ? te.baseLanes : L, pi(od, Hl), Hl |= H;
        else
          return y = te !== null ? te.baseLanes | L : L, x.lanes = x.childLanes = 1073741824, x.memoizedState = { baseLanes: y, cachePool: null }, x.updateQueue = null, pi(od, Hl), Hl |= y, null;
      else
        te !== null ? (H = te.baseLanes | L, x.memoizedState = null) : H = L, pi(od, Hl), Hl |= H;
      return Gn(y, x, q, L), x.child;
    }
    function hs(y, x) {
      var L = x.ref;
      (y === null && L !== null || y !== null && y.ref !== L) && (x.flags |= 512, x.flags |= 2097152);
    }
    function es(y, x, L, H, q) {
      var te = Pa(L) ? Oo : _i.current;
      return te = Uo(x, te), Xs(x, q), L = xi(y, x, L, H, te, q), H = Ec(), y !== null && !oi ? (x.updateQueue = y.updateQueue, x.flags &= -2053, y.lanes &= ~q, Vr(y, x, q)) : (ca && H && ec(x), x.flags |= 1, Gn(y, x, L, q), x.child);
    }
    function Nl(y, x, L, H, q) {
      if (Pa(L)) {
        var te = !0;
        Al(x);
      } else
        te = !1;
      if (Xs(x, q), x.stateNode === null)
        y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), Lm(x, L, H), vh(x, L, H, q), H = !0;
      else if (y === null) {
        var Ae = x.stateNode, Ke = x.memoizedProps;
        Ae.props = Ke;
        var kt = Ae.context, cn = L.contextType;
        typeof cn == "object" && cn !== null ? cn = Jr(cn) : (cn = Pa(L) ? Oo : _i.current, cn = Uo(x, cn));
        var bn = L.getDerivedStateFromProps, wr = typeof bn == "function" || typeof Ae.getSnapshotBeforeUpdate == "function";
        wr || typeof Ae.UNSAFE_componentWillReceiveProps != "function" && typeof Ae.componentWillReceiveProps != "function" || (Ke !== H || kt !== cn) && Pm(x, Ae, H, cn), va = !1;
        var ur = x.memoizedState;
        Ae.state = ur, Cu(x, H, Ae, q), kt = x.memoizedState, Ke !== H || ur !== kt || Ti.current || va ? (typeof bn == "function" && (Zh(x, L, bn, H), kt = x.memoizedState), (Ke = va || Dm(x, L, Ke, H, ur, kt, cn)) ? (wr || typeof Ae.UNSAFE_componentWillMount != "function" && typeof Ae.componentWillMount != "function" || (typeof Ae.componentWillMount == "function" && Ae.componentWillMount(), typeof Ae.UNSAFE_componentWillMount == "function" && Ae.UNSAFE_componentWillMount()), typeof Ae.componentDidMount == "function" && (x.flags |= 4194308)) : (typeof Ae.componentDidMount == "function" && (x.flags |= 4194308), x.memoizedProps = H, x.memoizedState = kt), Ae.props = H, Ae.state = kt, Ae.context = cn, H = Ke) : (typeof Ae.componentDidMount == "function" && (x.flags |= 4194308), H = !1);
      } else {
        Ae = x.stateNode, Zf(y, x), Ke = x.memoizedProps, cn = x.type === x.elementType ? Ke : Oa(x.type, Ke), Ae.props = cn, wr = x.pendingProps, ur = Ae.context, kt = L.contextType, typeof kt == "object" && kt !== null ? kt = Jr(kt) : (kt = Pa(L) ? Oo : _i.current, kt = Uo(x, kt));
        var _a = L.getDerivedStateFromProps;
        (bn = typeof _a == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") || typeof Ae.UNSAFE_componentWillReceiveProps != "function" && typeof Ae.componentWillReceiveProps != "function" || (Ke !== wr || ur !== kt) && Pm(x, Ae, H, kt), va = !1, ur = x.memoizedState, Ae.state = ur, Cu(x, H, Ae, q);
        var Tn = x.memoizedState;
        Ke !== wr || ur !== Tn || Ti.current || va ? (typeof _a == "function" && (Zh(x, L, _a, H), Tn = x.memoizedState), (cn = va || Dm(x, L, cn, H, ur, Tn, kt) || !1) ? (bn || typeof Ae.UNSAFE_componentWillUpdate != "function" && typeof Ae.componentWillUpdate != "function" || (typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate(
          H,
          Tn,
          kt
        ), typeof Ae.UNSAFE_componentWillUpdate == "function" && Ae.UNSAFE_componentWillUpdate(H, Tn, kt)), typeof Ae.componentDidUpdate == "function" && (x.flags |= 4), typeof Ae.getSnapshotBeforeUpdate == "function" && (x.flags |= 1024)) : (typeof Ae.componentDidUpdate != "function" || Ke === y.memoizedProps && ur === y.memoizedState || (x.flags |= 4), typeof Ae.getSnapshotBeforeUpdate != "function" || Ke === y.memoizedProps && ur === y.memoizedState || (x.flags |= 1024), x.memoizedProps = H, x.memoizedState = Tn), Ae.props = H, Ae.state = Tn, Ae.context = kt, H = cn) : (typeof Ae.componentDidUpdate != "function" || Ke === y.memoizedProps && ur === y.memoizedState || (x.flags |= 4), typeof Ae.getSnapshotBeforeUpdate != "function" || Ke === y.memoizedProps && ur === y.memoizedState || (x.flags |= 1024), H = !1);
      }
      return Ia(y, x, L, H, te, q);
    }
    function Ia(y, x, L, H, q, te) {
      hs(y, x);
      var Ae = (x.flags & 128) !== 0;
      if (!H && !Ae)
        return q && zd(x, L, !1), Vr(y, x, te);
      H = x.stateNode, Bi.current = x;
      var Ke = Ae && typeof L.getDerivedStateFromError != "function" ? null : H.render();
      return x.flags |= 1, y !== null && Ae ? (x.child = wc(x, y.child, null, te), x.child = wc(x, null, Ke, te)) : Gn(y, x, Ke, te), x.memoizedState = H.state, q && zd(x, L, !0), x.child;
    }
    function Fl(y) {
      var x = y.stateNode;
      x.pendingContext ? vo(y, x.pendingContext, x.pendingContext !== x.context) : x.context && vo(y, x.context, !1), kp(y, x.containerInfo);
    }
    function _f(y, x, L, H, q) {
      return yh(), Id(q), x.flags |= 256, Gn(y, x, L, H), x.child;
    }
    var Wd = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Ho(y) {
      return { baseLanes: y, cachePool: null };
    }
    function Sv(y, x, L) {
      var H = x.pendingProps, q = Ye.current, te = !1, Ae = (x.flags & 128) !== 0, Ke;
      if ((Ke = Ae) || (Ke = y !== null && y.memoizedState === null ? !1 : (q & 2) !== 0), Ke ? (te = !0, x.flags &= -129) : (y === null || y.memoizedState !== null) && (q |= 1), pi(Ye, q & 1), y === null)
        return Kf(x), y = x.memoizedState, y !== null && (y = y.dehydrated, y !== null) ? ((x.mode & 1) === 0 ? x.lanes = 1 : Si(y) ? x.lanes = 8 : x.lanes = 1073741824, null) : (q = H.children, y = H.fallback, te ? (H = x.mode, te = x.child, q = { mode: "hidden", children: q }, (H & 1) === 0 && te !== null ? (te.childLanes = 0, te.pendingProps = q) : te = dd(q, H, 0, null), y = mu(y, H, L, null), te.return = x, y.return = x, te.sibling = y, x.child = te, x.child.memoizedState = Ho(L), x.memoizedState = Wd, y) : vl(x, q));
      if (q = y.memoizedState, q !== null) {
        if (Ke = q.dehydrated, Ke !== null) {
          if (Ae)
            return x.flags & 256 ? (x.flags &= -257, lc(y, x, L, Error(l(422)))) : x.memoizedState !== null ? (x.child = y.child, x.flags |= 128, null) : (te = H.fallback, q = x.mode, H = dd({ mode: "visible", children: H.children }, q, 0, null), te = mu(te, q, L, null), te.flags |= 2, H.return = x, te.return = x, H.sibling = te, x.child = H, (x.mode & 1) !== 0 && wc(
              x,
              y.child,
              null,
              L
            ), x.child.memoizedState = Ho(L), x.memoizedState = Wd, te);
          if ((x.mode & 1) === 0)
            x = lc(y, x, L, null);
          else if (Si(Ke))
            x = lc(y, x, L, Error(l(419)));
          else if (H = (L & y.childLanes) !== 0, oi || H) {
            if (H = Ra, H !== null) {
              switch (L & -L) {
                case 4:
                  te = 2;
                  break;
                case 16:
                  te = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  te = 32;
                  break;
                case 536870912:
                  te = 268435456;
                  break;
                default:
                  te = 0;
              }
              H = (te & (H.suspendedLanes | L)) !== 0 ? 0 : te, H !== 0 && H !== q.retryLane && (q.retryLane = H, jl(y, H, -1));
            }
            Rf(), x = lc(y, x, L, Error(l(421)));
          } else
            ji(Ke) ? (x.flags |= 128, x.child = y.child, x = Ic.bind(null, y), Te(Ke, x), x = null) : (L = q.treeContext, et && (Ma = qe(Ke), Za = x, ca = !0, tl = null, Fd = !1, L !== null && (hl[el++] = Jf, hl[el++] = lu, hl[el++] = pf, Jf = L.id, lu = L.overflow, pf = x)), x = vl(x, x.pendingProps.children), x.flags |= 4096);
          return x;
        }
        return te ? (H = Kh(y, x, H.children, H.fallback, L), te = x.child, q = y.child.memoizedState, te.memoizedState = q === null ? Ho(L) : { baseLanes: q.baseLanes | L, cachePool: null }, te.childLanes = y.childLanes & ~L, x.memoizedState = Wd, H) : (L = bo(y, x, H.children, L), x.memoizedState = null, L);
      }
      return te ? (H = Kh(y, x, H.children, H.fallback, L), te = x.child, q = y.child.memoizedState, te.memoizedState = q === null ? Ho(L) : { baseLanes: q.baseLanes | L, cachePool: null }, te.childLanes = y.childLanes & ~L, x.memoizedState = Wd, H) : (L = bo(y, x, H.children, L), x.memoizedState = null, L);
    }
    function vl(y, x) {
      return x = dd({ mode: "visible", children: x }, y.mode, 0, null), x.return = y, y.child = x;
    }
    function bo(y, x, L, H) {
      var q = y.child;
      return y = q.sibling, L = Yo(q, { mode: "visible", children: L }), (x.mode & 1) === 0 && (L.lanes = H), L.return = x, L.sibling = null, y !== null && (H = x.deletions, H === null ? (x.deletions = [y], x.flags |= 16) : H.push(y)), x.child = L;
    }
    function Kh(y, x, L, H, q) {
      var te = x.mode;
      y = y.child;
      var Ae = y.sibling, Ke = { mode: "hidden", children: L };
      return (te & 1) === 0 && x.child !== y ? (L = x.child, L.childLanes = 0, L.pendingProps = Ke, x.deletions = null) : (L = Yo(y, Ke), L.subtreeFlags = y.subtreeFlags & 14680064), Ae !== null ? H = Yo(Ae, H) : (H = mu(H, te, q, null), H.flags |= 2), H.return = x, L.return = x, L.sibling = H, x.child = L, H;
    }
    function lc(y, x, L, H) {
      return H !== null && Id(H), wc(x, y.child, null, L), y = vl(x, x.pendingProps.children), y.flags |= 2, x.memoizedState = null, y;
    }
    function cu(y, x, L) {
      y.lanes |= x;
      var H = y.alternate;
      H !== null && (H.lanes |= x), za(y.return, x, L);
    }
    function _s(y, x, L, H, q) {
      var te = y.memoizedState;
      te === null ? y.memoizedState = { isBackwards: x, rendering: null, renderingStartTime: 0, last: H, tail: L, tailMode: q } : (te.isBackwards = x, te.rendering = null, te.renderingStartTime = 0, te.last = H, te.tail = L, te.tailMode = q);
    }
    function Oc(y, x, L) {
      var H = x.pendingProps, q = H.revealOrder, te = H.tail;
      if (Gn(y, x, H.children, L), H = Ye.current, (H & 2) !== 0)
        H = H & 1 | 2, x.flags |= 128;
      else {
        if (y !== null && (y.flags & 128) !== 0)
          e:
            for (y = x.child; y !== null; ) {
              if (y.tag === 13)
                y.memoizedState !== null && cu(y, L, x);
              else if (y.tag === 19)
                cu(y, L, x);
              else if (y.child !== null) {
                y.child.return = y, y = y.child;
                continue;
              }
              if (y === x)
                break e;
              for (; y.sibling === null; ) {
                if (y.return === null || y.return === x)
                  break e;
                y = y.return;
              }
              y.sibling.return = y.return, y = y.sibling;
            }
        H &= 1;
      }
      if (pi(Ye, H), (x.mode & 1) === 0)
        x.memoizedState = null;
      else
        switch (q) {
          case "forwards":
            for (L = x.child, q = null; L !== null; )
              y = L.alternate, y !== null && Bt(y) === null && (q = L), L = L.sibling;
            L = q, L === null ? (q = x.child, x.child = null) : (q = L.sibling, L.sibling = null), _s(x, !1, q, L, te);
            break;
          case "backwards":
            for (L = null, q = x.child, x.child = null; q !== null; ) {
              if (y = q.alternate, y !== null && Bt(y) === null) {
                x.child = q;
                break;
              }
              y = q.sibling, q.sibling = L, L = q, q = y;
            }
            _s(x, !0, L, null, te);
            break;
          case "together":
            _s(x, !1, null, null, void 0);
            break;
          default:
            x.memoizedState = null;
        }
      return x.child;
    }
    function Vr(y, x, L) {
      if (y !== null && (x.dependencies = y.dependencies), zc |= x.lanes, (L & x.childLanes) === 0)
        return null;
      if (y !== null && x.child !== y.child)
        throw Error(l(153));
      if (x.child !== null) {
        for (y = x.child, L = Yo(y, y.pendingProps), x.child = L, L.return = x; y.sibling !== null; )
          y = y.sibling, L = L.sibling = Yo(y, y.pendingProps), L.return = x;
        L.sibling = null;
      }
      return x.child;
    }
    function uc(y, x, L) {
      switch (x.tag) {
        case 3:
          Fl(x), yh();
          break;
        case 5:
          Ip(x);
          break;
        case 1:
          Pa(x.type) && Al(x);
          break;
        case 4:
          kp(x, x.stateNode.containerInfo);
          break;
        case 10:
          Tu(x, x.type._context, x.memoizedProps.value);
          break;
        case 13:
          var H = x.memoizedState;
          if (H !== null)
            return H.dehydrated !== null ? (pi(Ye, Ye.current & 1), x.flags |= 128, null) : (L & x.child.childLanes) !== 0 ? Sv(y, x, L) : (pi(Ye, Ye.current & 1), y = Vr(y, x, L), y !== null ? y.sibling : null);
          pi(Ye, Ye.current & 1);
          break;
        case 19:
          if (H = (L & x.childLanes) !== 0, (y.flags & 128) !== 0) {
            if (H)
              return Oc(
                y,
                x,
                L
              );
            x.flags |= 128;
          }
          var q = x.memoizedState;
          if (q !== null && (q.rendering = null, q.tail = null, q.lastEffect = null), pi(Ye, Ye.current), H)
            break;
          return null;
        case 22:
        case 23:
          return x.lanes = 0, Rr(y, x, L);
      }
      return Vr(y, x, L);
    }
    function zr(y, x) {
      switch (Oi(x), x.tag) {
        case 1:
          return Pa(x.type) && Rl(), y = x.flags, y & 65536 ? (x.flags = y & -65537 | 128, x) : null;
        case 3:
          return xh(), mr(Ti), mr(_i), Mn(), y = x.flags, (y & 65536) !== 0 && (y & 128) === 0 ? (x.flags = y & -65537 | 128, x) : null;
        case 5:
          return ko(x), null;
        case 13:
          if (mr(Ye), y = x.memoizedState, y !== null && y.dehydrated !== null) {
            if (x.alternate === null)
              throw Error(l(340));
            yh();
          }
          return y = x.flags, y & 65536 ? (x.flags = y & -65537 | 128, x) : null;
        case 19:
          return mr(Ye), null;
        case 4:
          return xh(), null;
        case 10:
          return Pl(x.type._context), null;
        case 22:
        case 23:
          return jo(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Js = !1, ps = !1, Uc = typeof WeakSet == "function" ? WeakSet : Set, pn = null;
    function kl(y, x) {
      var L = y.ref;
      if (L !== null)
        if (typeof L == "function")
          try {
            L(null);
          } catch (H) {
            wi(y, x, H);
          }
        else
          L.current = null;
    }
    function wo(y, x, L) {
      try {
        L();
      } catch (H) {
        wi(y, x, H);
      }
    }
    var Nm = !1;
    function wh(y, x) {
      for (fe(y.containerInfo), pn = x; pn !== null; )
        if (y = pn, x = y.child, (y.subtreeFlags & 1028) !== 0 && x !== null)
          x.return = y, pn = x;
        else
          for (; pn !== null; ) {
            y = pn;
            try {
              var L = y.alternate;
              if ((y.flags & 1024) !== 0)
                switch (y.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (L !== null) {
                      var H = L.memoizedProps, q = L.memoizedState, te = y.stateNode, Ae = te.getSnapshotBeforeUpdate(y.elementType === y.type ? H : Oa(y.type, H), q);
                      te.__reactInternalSnapshotBeforeUpdate = Ae;
                    }
                    break;
                  case 3:
                    Ot && fn(y.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(l(163));
                }
            } catch (Ke) {
              wi(y, y.return, Ke);
            }
            if (x = y.sibling, x !== null) {
              x.return = y.return, pn = x;
              break;
            }
            pn = y.return;
          }
      return L = Nm, Nm = !1, L;
    }
    function Ou(y, x, L) {
      var H = x.updateQueue;
      if (H = H !== null ? H.lastEffect : null, H !== null) {
        var q = H = H.next;
        do {
          if ((q.tag & y) === y) {
            var te = q.destroy;
            q.destroy = void 0, te !== void 0 && wo(x, L, te);
          }
          q = q.next;
        } while (q !== H);
      }
    }
    function bs(y, x) {
      if (x = x.updateQueue, x = x !== null ? x.lastEffect : null, x !== null) {
        var L = x = x.next;
        do {
          if ((L.tag & y) === y) {
            var H = L.create;
            L.destroy = H();
          }
          L = L.next;
        } while (L !== x);
      }
    }
    function gl(y) {
      var x = y.ref;
      if (x !== null) {
        var L = y.stateNode;
        switch (y.tag) {
          case 5:
            y = Ce(L);
            break;
          default:
            y = L;
        }
        typeof x == "function" ? x(y) : x.current = y;
      }
    }
    function ga(y, x, L) {
      if (su && typeof su.onCommitFiberUnmount == "function")
        try {
          su.onCommitFiberUnmount(hf, x);
        } catch {
        }
      switch (x.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (y = x.updateQueue, y !== null && (y = y.lastEffect, y !== null)) {
            var H = y = y.next;
            do {
              var q = H, te = q.destroy;
              q = q.tag, te !== void 0 && ((q & 2) !== 0 || (q & 4) !== 0) && wo(x, L, te), H = H.next;
            } while (H !== y);
          }
          break;
        case 1:
          if (kl(x, L), y = x.stateNode, typeof y.componentWillUnmount == "function")
            try {
              y.props = x.memoizedProps, y.state = x.memoizedState, y.componentWillUnmount();
            } catch (Ae) {
              wi(
                x,
                L,
                Ae
              );
            }
          break;
        case 5:
          kl(x, L);
          break;
        case 4:
          Ot ? zs(y, x, L) : He && He && (x = x.stateNode.containerInfo, L = Wr(x), Vn(x, L));
      }
    }
    function fu(y, x, L) {
      for (var H = x; ; )
        if (ga(y, H, L), H.child === null || Ot && H.tag === 4) {
          if (H === x)
            break;
          for (; H.sibling === null; ) {
            if (H.return === null || H.return === x)
              return;
            H = H.return;
          }
          H.sibling.return = H.return, H = H.sibling;
        } else
          H.child.return = H, H = H.child;
    }
    function Us(y) {
      var x = y.alternate;
      x !== null && (y.alternate = null, Us(x)), y.child = null, y.deletions = null, y.sibling = null, y.tag === 5 && (x = y.stateNode, x !== null && Qt(x)), y.stateNode = null, y.return = null, y.dependencies = null, y.memoizedProps = null, y.memoizedState = null, y.pendingProps = null, y.stateNode = null, y.updateQueue = null;
    }
    function sd(y) {
      return y.tag === 5 || y.tag === 3 || y.tag === 4;
    }
    function Il(y) {
      e:
        for (; ; ) {
          for (; y.sibling === null; ) {
            if (y.return === null || sd(y.return))
              return null;
            y = y.return;
          }
          for (y.sibling.return = y.return, y = y.sibling; y.tag !== 5 && y.tag !== 6 && y.tag !== 18; ) {
            if (y.flags & 2 || y.child === null || y.tag === 4)
              continue e;
            y.child.return = y, y = y.child;
          }
          if (!(y.flags & 2))
            return y.stateNode;
        }
    }
    function Vo(y) {
      if (Ot) {
        e: {
          for (var x = y.return; x !== null; ) {
            if (sd(x))
              break e;
            x = x.return;
          }
          throw Error(l(160));
        }
        var L = x;
        switch (L.tag) {
          case 5:
            x = L.stateNode, L.flags & 32 && (De(x), L.flags &= -33), L = Il(y), rl(y, L, x);
            break;
          case 3:
          case 4:
            x = L.stateNode.containerInfo, L = Il(y), jd(y, L, x);
            break;
          default:
            throw Error(l(161));
        }
      }
    }
    function jd(y, x, L) {
      var H = y.tag;
      if (H === 5 || H === 6)
        y = y.stateNode, x ? it(L, y, x) : tt(L, y);
      else if (H !== 4 && (y = y.child, y !== null))
        for (jd(y, x, L), y = y.sibling; y !== null; )
          jd(y, x, L), y = y.sibling;
    }
    function rl(y, x, L) {
      var H = y.tag;
      if (H === 5 || H === 6)
        y = y.stateNode, x ? Ie(L, y, x) : Ut(L, y);
      else if (H !== 4 && (y = y.child, y !== null))
        for (rl(y, x, L), y = y.sibling; y !== null; )
          rl(y, x, L), y = y.sibling;
    }
    function zs(y, x, L) {
      for (var H = x, q = !1, te, Ae; ; ) {
        if (!q) {
          q = H.return;
          e:
            for (; ; ) {
              if (q === null)
                throw Error(l(160));
              switch (te = q.stateNode, q.tag) {
                case 5:
                  Ae = !1;
                  break e;
                case 3:
                  te = te.containerInfo, Ae = !0;
                  break e;
                case 4:
                  te = te.containerInfo, Ae = !0;
                  break e;
              }
              q = q.return;
            }
          q = !0;
        }
        if (H.tag === 5 || H.tag === 6)
          fu(y, H, L), Ae ? hn(te, H.stateNode) : at(te, H.stateNode);
        else if (H.tag === 18)
          Ae ? br(te, H.stateNode) : nr(te, H.stateNode);
        else if (H.tag === 4) {
          if (H.child !== null) {
            te = H.stateNode.containerInfo, Ae = !0, H.child.return = H, H = H.child;
            continue;
          }
        } else if (ga(y, H, L), H.child !== null) {
          H.child.return = H, H = H.child;
          continue;
        }
        if (H === x)
          break;
        for (; H.sibling === null; ) {
          if (H.return === null || H.return === x)
            return;
          H = H.return, H.tag === 4 && (q = !1);
        }
        H.sibling.return = H.return, H = H.sibling;
      }
    }
    function fa(y, x) {
      if (Ot) {
        switch (x.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ou(3, x, x.return), bs(3, x), Ou(5, x, x.return);
            return;
          case 1:
            return;
          case 5:
            var L = x.stateNode;
            if (L != null) {
              var H = x.memoizedProps;
              y = y !== null ? y.memoizedProps : H;
              var q = x.type, te = x.updateQueue;
              x.updateQueue = null, te !== null && xe(L, te, q, y, H, x);
            }
            return;
          case 6:
            if (x.stateNode === null)
              throw Error(l(162));
            L = x.memoizedProps, rn(x.stateNode, y !== null ? y.memoizedProps : L, L);
            return;
          case 3:
            et && y !== null && y.memoizedState.isDehydrated && vn(x.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Uu(x);
            return;
          case 19:
            Uu(x);
            return;
          case 17:
            return;
        }
        throw Error(l(163));
      }
      switch (x.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ou(3, x, x.return), bs(3, x), Ou(5, x, x.return);
          return;
        case 12:
          return;
        case 13:
          Uu(x);
          return;
        case 19:
          Uu(x);
          return;
        case 3:
          et && y !== null && y.memoizedState.isDehydrated && vn(x.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e:
        if (He) {
          switch (x.tag) {
            case 1:
            case 5:
            case 6:
              break e;
            case 3:
            case 4:
              x = x.stateNode, Vn(x.containerInfo, x.pendingChildren);
              break e;
          }
          throw Error(l(163));
        }
    }
    function Uu(y) {
      var x = y.updateQueue;
      if (x !== null) {
        y.updateQueue = null;
        var L = y.stateNode;
        L === null && (L = y.stateNode = new Uc()), x.forEach(function(H) {
          var q = hu.bind(null, y, H);
          L.has(H) || (L.add(H), H.then(q, q));
        });
      }
    }
    function Hp(y, x) {
      for (pn = x; pn !== null; ) {
        x = pn;
        var L = x.deletions;
        if (L !== null)
          for (var H = 0; H < L.length; H++) {
            var q = L[H];
            try {
              var te = y;
              Ot ? zs(te, q, x) : fu(te, q, x);
              var Ae = q.alternate;
              Ae !== null && (Ae.return = null), q.return = null;
            } catch (Wn) {
              wi(q, x, Wn);
            }
          }
        if (L = x.child, (x.subtreeFlags & 12854) !== 0 && L !== null)
          L.return = x, pn = L;
        else
          for (; pn !== null; ) {
            x = pn;
            try {
              var Ke = x.flags;
              if (Ke & 32 && Ot && De(x.stateNode), Ke & 512) {
                var kt = x.alternate;
                if (kt !== null) {
                  var cn = kt.ref;
                  cn !== null && (typeof cn == "function" ? cn(null) : cn.current = null);
                }
              }
              if (Ke & 8192)
                switch (x.tag) {
                  case 13:
                    if (x.memoizedState !== null) {
                      var bn = x.alternate;
                      (bn === null || bn.memoizedState === null) && (Fm = mi());
                    }
                    break;
                  case 22:
                    var wr = x.memoizedState !== null, ur = x.alternate, _a = ur !== null && ur.memoizedState !== null;
                    if (L = x, Ot) {
                      e:
                        if (H = L, q = wr, te = null, Ot)
                          for (var Tn = H; ; ) {
                            if (Tn.tag === 5) {
                              if (te === null) {
                                te = Tn;
                                var Li = Tn.stateNode;
                                q ? Tt(Li) : Gt(Tn.stateNode, Tn.memoizedProps);
                              }
                            } else if (Tn.tag === 6) {
                              if (te === null) {
                                var ms = Tn.stateNode;
                                q ? Ne(ms) : Pt(ms, Tn.memoizedProps);
                              }
                            } else if ((Tn.tag !== 22 && Tn.tag !== 23 || Tn.memoizedState === null || Tn === H) && Tn.child !== null) {
                              Tn.child.return = Tn, Tn = Tn.child;
                              continue;
                            }
                            if (Tn === H)
                              break;
                            for (; Tn.sibling === null; ) {
                              if (Tn.return === null || Tn.return === H)
                                break e;
                              te === Tn && (te = null), Tn = Tn.return;
                            }
                            te === Tn && (te = null), Tn.sibling.return = Tn.return, Tn = Tn.sibling;
                          }
                    }
                    if (wr && !_a && (L.mode & 1) !== 0) {
                      pn = L;
                      for (var dt = L.child; dt !== null; ) {
                        for (L = pn = dt; pn !== null; ) {
                          H = pn;
                          var Qe = H.child;
                          switch (H.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              Ou(4, H, H.return);
                              break;
                            case 1:
                              kl(H, H.return);
                              var At = H.stateNode;
                              if (typeof At.componentWillUnmount == "function") {
                                var qt = H.return;
                                try {
                                  At.props = H.memoizedProps, At.state = H.memoizedState, At.componentWillUnmount();
                                } catch (Wn) {
                                  wi(
                                    H,
                                    qt,
                                    Wn
                                  );
                                }
                              }
                              break;
                            case 5:
                              kl(H, H.return);
                              break;
                            case 22:
                              if (H.memoizedState !== null) {
                                bf(L);
                                continue;
                              }
                          }
                          Qe !== null ? (Qe.return = H, pn = Qe) : bf(L);
                        }
                        dt = dt.sibling;
                      }
                    }
                }
              switch (Ke & 4102) {
                case 2:
                  Vo(x), x.flags &= -3;
                  break;
                case 6:
                  Vo(x), x.flags &= -3, fa(x.alternate, x);
                  break;
                case 4096:
                  x.flags &= -4097;
                  break;
                case 4100:
                  x.flags &= -4097, fa(x.alternate, x);
                  break;
                case 4:
                  fa(x.alternate, x);
              }
            } catch (Wn) {
              wi(x, x.return, Wn);
            }
            if (L = x.sibling, L !== null) {
              L.return = x.return, pn = L;
              break;
            }
            pn = x.return;
          }
      }
    }
    function du(y, x, L) {
      pn = y, Bl(y);
    }
    function Bl(y, x, L) {
      for (var H = (y.mode & 1) !== 0; pn !== null; ) {
        var q = pn, te = q.child;
        if (q.tag === 22 && H) {
          var Ae = q.memoizedState !== null || Js;
          if (!Ae) {
            var Ke = q.alternate, kt = Ke !== null && Ke.memoizedState !== null || ps;
            Ke = Js;
            var cn = ps;
            if (Js = Ae, (ps = kt) && !cn)
              for (pn = q; pn !== null; )
                Ae = pn, kt = Ae.child, Ae.tag === 22 && Ae.memoizedState !== null ? Ks(q) : kt !== null ? (kt.return = Ae, pn = kt) : Ks(q);
            for (; te !== null; )
              pn = te, Bl(te), te = te.sibling;
            pn = q, Js = Ke, ps = cn;
          }
          $h(y);
        } else
          (q.subtreeFlags & 8772) !== 0 && te !== null ? (te.return = q, pn = te) : $h(y);
      }
    }
    function $h(y) {
      for (; pn !== null; ) {
        var x = pn;
        if ((x.flags & 8772) !== 0) {
          var L = x.alternate;
          try {
            if ((x.flags & 8772) !== 0)
              switch (x.tag) {
                case 0:
                case 11:
                case 15:
                  ps || bs(5, x);
                  break;
                case 1:
                  var H = x.stateNode;
                  if (x.flags & 4 && !ps)
                    if (L === null)
                      H.componentDidMount();
                    else {
                      var q = x.elementType === x.type ? L.memoizedProps : Oa(x.type, L.memoizedProps);
                      H.componentDidUpdate(q, L.memoizedState, H.__reactInternalSnapshotBeforeUpdate);
                    }
                  var te = x.updateQueue;
                  te !== null && Up(x, te, H);
                  break;
                case 3:
                  var Ae = x.updateQueue;
                  if (Ae !== null) {
                    if (L = null, x.child !== null)
                      switch (x.child.tag) {
                        case 5:
                          L = Ce(x.child.stateNode);
                          break;
                        case 1:
                          L = x.child.stateNode;
                      }
                    Up(x, Ae, L);
                  }
                  break;
                case 5:
                  var Ke = x.stateNode;
                  L === null && x.flags & 4 && ze(Ke, x.type, x.memoizedProps, x);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (et && x.memoizedState === null) {
                    var kt = x.alternate;
                    if (kt !== null) {
                      var cn = kt.memoizedState;
                      if (cn !== null) {
                        var bn = cn.dehydrated;
                        bn !== null && Zn(bn);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(l(163));
              }
            ps || x.flags & 512 && gl(x);
          } catch (wr) {
            wi(x, x.return, wr);
          }
        }
        if (x === y) {
          pn = null;
          break;
        }
        if (L = x.sibling, L !== null) {
          L.return = x.return, pn = L;
          break;
        }
        pn = x.return;
      }
    }
    function bf(y) {
      for (; pn !== null; ) {
        var x = pn;
        if (x === y) {
          pn = null;
          break;
        }
        var L = x.sibling;
        if (L !== null) {
          L.return = x.return, pn = L;
          break;
        }
        pn = x.return;
      }
    }
    function Ks(y) {
      for (; pn !== null; ) {
        var x = pn;
        try {
          switch (x.tag) {
            case 0:
            case 11:
            case 15:
              var L = x.return;
              try {
                bs(4, x);
              } catch (kt) {
                wi(x, L, kt);
              }
              break;
            case 1:
              var H = x.stateNode;
              if (typeof H.componentDidMount == "function") {
                var q = x.return;
                try {
                  H.componentDidMount();
                } catch (kt) {
                  wi(x, q, kt);
                }
              }
              var te = x.return;
              try {
                gl(x);
              } catch (kt) {
                wi(x, te, kt);
              }
              break;
            case 5:
              var Ae = x.return;
              try {
                gl(x);
              } catch (kt) {
                wi(x, Ae, kt);
              }
          }
        } catch (kt) {
          wi(x, x.return, kt);
        }
        if (x === y) {
          pn = null;
          break;
        }
        var Ke = x.sibling;
        if (Ke !== null) {
          Ke.return = x.return, pn = Ke;
          break;
        }
        pn = x.return;
      }
    }
    var Yd = 0, da = 1, Hi = 2, wn = 3, Qi = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var ya = Symbol.for;
      Yd = ya("selector.component"), da = ya("selector.has_pseudo_class"), Hi = ya("selector.role"), wn = ya("selector.test_id"), Qi = ya("selector.text");
    }
    function ep(y) {
      var x = mt(y);
      if (x != null) {
        if (typeof x.memoizedProps["data-testname"] != "string")
          throw Error(l(364));
        return x;
      }
      if (y = Mt(y), y === null)
        throw Error(l(362));
      return y.stateNode.current;
    }
    function Go(y, x) {
      switch (x.$$typeof) {
        case Yd:
          if (y.type === x.value)
            return !0;
          break;
        case da:
          e: {
            x = x.value, y = [y, 0];
            for (var L = 0; L < y.length; ) {
              var H = y[L++], q = y[L++], te = x[q];
              if (H.tag !== 5 || !je(H)) {
                for (; te != null && Go(H, te); )
                  q++, te = x[q];
                if (q === x.length) {
                  x = !0;
                  break e;
                } else
                  for (H = H.child; H !== null; )
                    y.push(H, q), H = H.sibling;
              }
            }
            x = !1;
          }
          return x;
        case Hi:
          if (y.tag === 5 && lt(y.stateNode, x.value))
            return !0;
          break;
        case Qi:
          if ((y.tag === 5 || y.tag === 6) && (y = oe(y), y !== null && 0 <= y.indexOf(x.value)))
            return !0;
          break;
        case wn:
          if (y.tag === 5 && (y = y.memoizedProps["data-testname"], typeof y == "string" && y.toLowerCase() === x.value.toLowerCase()))
            return !0;
          break;
        default:
          throw Error(l(365));
      }
      return !1;
    }
    function Wo(y) {
      switch (y.$$typeof) {
        case Yd:
          return "<" + ($(y.value) || "Unknown") + ">";
        case da:
          return ":has(" + (Wo(y) || "") + ")";
        case Hi:
          return '[role="' + y.value + '"]';
        case Qi:
          return '"' + y.value + '"';
        case wn:
          return '[data-testname="' + y.value + '"]';
        default:
          throw Error(l(365));
      }
    }
    function ts(y, x) {
      var L = [];
      y = [y, 0];
      for (var H = 0; H < y.length; ) {
        var q = y[H++], te = y[H++], Ae = x[te];
        if (q.tag !== 5 || !je(q)) {
          for (; Ae != null && Go(q, Ae); )
            te++, Ae = x[te];
          if (te === x.length)
            L.push(q);
          else
            for (q = q.child; q !== null; )
              y.push(q, te), q = q.sibling;
        }
      }
      return L;
    }
    function An(y, x) {
      if (!Jt)
        throw Error(l(363));
      y = ep(y), y = ts(y, x), x = [], y = Array.from(y);
      for (var L = 0; L < y.length; ) {
        var H = y[L++];
        if (H.tag === 5)
          je(H) || x.push(H.stateNode);
        else
          for (H = H.child; H !== null; )
            y.push(H), H = H.sibling;
      }
      return x;
    }
    var xa = Math.ceil, ns = d.ReactCurrentDispatcher, wf = d.ReactCurrentOwner, Sa = d.ReactCurrentBatchConfig, Kr = 0, Ra = null, Ba = null, ci = 0, Hl = 0, od = us(0), ws = 0, Xd = null, zc = 0, cc = 0, qd = 0, ld = null, il = null, Fm = 0, Ef = 1 / 0;
    function Qd() {
      Ef = mi() + 500;
    }
    var Mf = !1, Vl = null, Gl = null, ud = !1, Wl = null, Eh = 0, fc = 0, hr = null, Yr = -1, fr = 0;
    function fi() {
      return (Kr & 6) !== 0 ? mi() : Yr !== -1 ? Yr : Yr = mi();
    }
    function Ns(y) {
      return (y.mode & 1) === 0 ? 1 : (Kr & 2) !== 0 && ci !== 0 ? ci & -ci : Qf.transition !== null ? (fr === 0 && (y = Dl, Dl <<= 1, (Dl & 4194240) === 0 && (Dl = 64), fr = y), fr) : (y = Cr, y !== 0 ? y : bt());
    }
    function jl(y, x, L) {
      if (50 < fc)
        throw fc = 0, hr = null, Error(l(185));
      var H = Nc(y, x);
      return H === null ? null : (xr(H, x, L), ((Kr & 2) === 0 || H !== Ra) && (H === Ra && ((Kr & 2) === 0 && (cc |= x), ws === 4 && lr(H, ci)), Sr(H, L), x === 1 && Kr === 0 && (y.mode & 1) === 0 && (Qd(), _c && Fo())), H);
    }
    function Nc(y, x) {
      y.lanes |= x;
      var L = y.alternate;
      for (L !== null && (L.lanes |= x), L = y, y = y.return; y !== null; )
        y.childLanes |= x, L = y.alternate, L !== null && (L.childLanes |= x), L = y, y = y.return;
      return L.tag === 3 ? L.stateNode : null;
    }
    function Sr(y, x) {
      var L = y.callbackNode;
      Ci(y, x);
      var H = jf(y, y === Ra ? ci : 0);
      if (H === 0)
        L !== null && Ka(L), y.callbackNode = null, y.callbackPriority = 0;
      else if (x = H & -H, y.callbackPriority !== x) {
        if (L != null && Ka(L), x === 1)
          y.tag === 0 ? qf(Fc.bind(null, y)) : Xf(Fc.bind(null, y)), ft ? Vt(function() {
            Kr === 0 && Fo();
          }) : yo(Qa, Fo), L = null;
        else {
          switch (fl(H)) {
            case 1:
              L = Qa;
              break;
            case 4:
              L = Sc;
              break;
            case 16:
              L = dl;
              break;
            case 536870912:
              L = df;
              break;
            default:
              L = dl;
          }
          L = pu(L, Eo.bind(null, y));
        }
        y.callbackPriority = x, y.callbackNode = L;
      }
    }
    function Eo(y, x) {
      if (Yr = -1, fr = 0, (Kr & 6) !== 0)
        throw Error(l(327));
      var L = y.callbackNode;
      if (kc() && y.callbackNode !== L)
        return null;
      var H = jf(y, y === Ra ? ci : 0);
      if (H === 0)
        return null;
      if ((H & 30) !== 0 || (H & y.expiredLanes) !== 0 || x)
        x = ia(y, H);
      else {
        x = H;
        var q = Kr;
        Kr |= 2;
        var te = Cf();
        (Ra !== y || ci !== x) && (Qd(), Di(y, x));
        do
          try {
            Af();
            break;
          } catch (Ke) {
            Tf(y, Ke);
          }
        while (1);
        xo(), ns.current = te, Kr = q, Ba !== null ? x = 0 : (Ra = null, ci = 0, x = ws);
      }
      if (x !== 0) {
        if (x === 2 && (q = cs(y), q !== 0 && (H = q, x = Ai(y, q))), x === 1)
          throw L = Xd, Di(y, 0), lr(y, H), Sr(y, mi()), L;
        if (x === 6)
          lr(y, H);
        else {
          if (q = y.current.alternate, (H & 30) === 0 && !vi(q) && (x = ia(y, H), x === 2 && (te = cs(y), te !== 0 && (H = te, x = Ai(y, te))), x === 1))
            throw L = Xd, Di(y, 0), lr(y, H), Sr(y, mi()), L;
          switch (y.finishedWork = q, y.finishedLanes = H, x) {
            case 0:
            case 1:
              throw Error(l(345));
            case 2:
              Yl(y, il);
              break;
            case 3:
              if (lr(y, H), (H & 130023424) === H && (x = Fm + 500 - mi(), 10 < x)) {
                if (jf(y, 0) !== 0)
                  break;
                if (q = y.suspendedLanes, (q & H) !== H) {
                  fi(), y.pingedLanes |= y.suspendedLanes & q;
                  break;
                }
                y.timeoutHandle = ot(Yl.bind(null, y, il), x);
                break;
              }
              Yl(y, il);
              break;
            case 4:
              if (lr(y, H), (H & 4194240) === H)
                break;
              for (x = y.eventTimes, q = -1; 0 < H; ) {
                var Ae = 31 - Ls(H);
                te = 1 << Ae, Ae = x[Ae], Ae > q && (q = Ae), H &= ~te;
              }
              if (H = q, H = mi() - H, H = (120 > H ? 120 : 480 > H ? 480 : 1080 > H ? 1080 : 1920 > H ? 1920 : 3e3 > H ? 3e3 : 4320 > H ? 4320 : 1960 * xa(H / 1960)) - H, 10 < H) {
                y.timeoutHandle = ot(Yl.bind(null, y, il), H);
                break;
              }
              Yl(y, il);
              break;
            case 5:
              Yl(y, il);
              break;
            default:
              throw Error(l(329));
          }
        }
      }
      return Sr(y, mi()), y.callbackNode === L ? Eo.bind(null, y) : null;
    }
    function Ai(y, x) {
      var L = ld;
      return y.current.memoizedState.isDehydrated && (Di(y, x).flags |= 256), y = ia(y, x), y !== 2 && (x = il, il = L, x !== null && Ht(x)), y;
    }
    function Ht(y) {
      il === null ? il = y : il.push.apply(il, y);
    }
    function vi(y) {
      for (var x = y; ; ) {
        if (x.flags & 16384) {
          var L = x.updateQueue;
          if (L !== null && (L = L.stores, L !== null))
            for (var H = 0; H < L.length; H++) {
              var q = L[H], te = q.getSnapshot;
              q = q.value;
              try {
                if (!No(te(), q))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (L = x.child, x.subtreeFlags & 16384 && L !== null)
          L.return = x, x = L;
        else {
          if (x === y)
            break;
          for (; x.sibling === null; ) {
            if (x.return === null || x.return === y)
              return !0;
            x = x.return;
          }
          x.sibling.return = x.return, x = x.sibling;
        }
      }
      return !0;
    }
    function lr(y, x) {
      for (x &= ~qd, x &= ~cc, y.suspendedLanes |= x, y.pingedLanes &= ~x, y = y.expirationTimes; 0 < x; ) {
        var L = 31 - Ls(x), H = 1 << L;
        y[L] = -1, x &= ~H;
      }
    }
    function Fc(y) {
      if ((Kr & 6) !== 0)
        throw Error(l(327));
      kc();
      var x = jf(y, 0);
      if ((x & 1) === 0)
        return Sr(y, mi()), null;
      var L = ia(y, x);
      if (y.tag !== 0 && L === 2) {
        var H = cs(y);
        H !== 0 && (x = H, L = Ai(y, H));
      }
      if (L === 1)
        throw L = Xd, Di(y, 0), lr(y, x), Sr(y, mi()), L;
      if (L === 6)
        throw Error(l(345));
      return y.finishedWork = y.current.alternate, y.finishedLanes = x, Yl(y, il), Sr(y, mi()), null;
    }
    function Ha(y) {
      Wl !== null && Wl.tag === 0 && (Kr & 6) === 0 && kc();
      var x = Kr;
      Kr |= 1;
      var L = Sa.transition, H = Cr;
      try {
        if (Sa.transition = null, Cr = 1, y)
          return y();
      } finally {
        Cr = H, Sa.transition = L, Kr = x, (Kr & 6) === 0 && Fo();
      }
    }
    function jo() {
      Hl = od.current, mr(od);
    }
    function Di(y, x) {
      y.finishedWork = null, y.finishedLanes = 0;
      var L = y.timeoutHandle;
      if (L !== _t && (y.timeoutHandle = _t, rt(L)), Ba !== null)
        for (L = Ba.return; L !== null; ) {
          var H = L;
          switch (Oi(H), H.tag) {
            case 1:
              H = H.type.childContextTypes, H != null && Rl();
              break;
            case 3:
              xh(), mr(Ti), mr(_i), Mn();
              break;
            case 5:
              ko(H);
              break;
            case 4:
              xh();
              break;
            case 13:
              mr(Ye);
              break;
            case 19:
              mr(Ye);
              break;
            case 10:
              Pl(H.type._context);
              break;
            case 22:
            case 23:
              jo();
          }
          L = L.return;
        }
      if (Ra = y, Ba = y = Yo(y.current, null), ci = Hl = x, ws = 0, Xd = null, qd = cc = zc = 0, il = ld = null, xs !== null) {
        for (x = 0; x < xs.length; x++)
          if (L = xs[x], H = L.interleaved, H !== null) {
            L.interleaved = null;
            var q = H.next, te = L.pending;
            if (te !== null) {
              var Ae = te.next;
              te.next = q, H.next = Ae;
            }
            L.pending = H;
          }
        xs = null;
      }
      return y;
    }
    function Tf(y, x) {
      do {
        var L = Ba;
        try {
          if (xo(), Kn.current = xf, Io) {
            for (var H = $n.memoizedState; H !== null; ) {
              var q = H.queue;
              q !== null && (q.pending = null), H = H.next;
            }
            Io = !1;
          }
          if (Ta = 0, ra = Ui = $n = null, fs = !1, Hd = 0, wf.current = null, L === null || L.return === null) {
            ws = 1, Xd = x, Ba = null;
            break;
          }
          e: {
            var te = y, Ae = L.return, Ke = L, kt = x;
            if (x = ci, Ke.flags |= 32768, kt !== null && typeof kt == "object" && typeof kt.then == "function") {
              var cn = kt, bn = Ke, wr = bn.tag;
              if ((bn.mode & 1) === 0 && (wr === 0 || wr === 11 || wr === 15)) {
                var ur = bn.alternate;
                ur ? (bn.updateQueue = ur.updateQueue, bn.memoizedState = ur.memoizedState, bn.lanes = ur.lanes) : (bn.updateQueue = null, bn.memoizedState = null);
              }
              var _a = Dc(Ae);
              if (_a !== null) {
                _a.flags &= -257, Lc(_a, Ae, Ke, te, x), _a.mode & 1 && zl(te, cn, x), x = _a, kt = cn;
                var Tn = x.updateQueue;
                if (Tn === null) {
                  var Li = /* @__PURE__ */ new Set();
                  Li.add(kt), x.updateQueue = Li;
                } else
                  Tn.add(kt);
                break e;
              } else {
                if ((x & 1) === 0) {
                  zl(te, cn, x), Rf();
                  break e;
                }
                kt = Error(l(426));
              }
            } else if (ca && Ke.mode & 1) {
              var ms = Dc(Ae);
              if (ms !== null) {
                (ms.flags & 65536) === 0 && (ms.flags |= 256), Lc(ms, Ae, Ke, te, x), Id(kt);
                break e;
              }
            }
            te = kt, ws !== 4 && (ws = 2), ld === null ? ld = [te] : ld.push(te), kt = Sf(kt, Ke), Ke = Ae;
            do {
              switch (Ke.tag) {
                case 3:
                  Ke.flags |= 65536, x &= -x, Ke.lanes |= x;
                  var dt = id(Ke, kt, x);
                  qi(Ke, dt);
                  break e;
                case 1:
                  te = kt;
                  var Qe = Ke.type, At = Ke.stateNode;
                  if ((Ke.flags & 128) === 0 && (typeof Qe.getDerivedStateFromError == "function" || At !== null && typeof At.componentDidCatch == "function" && (Gl === null || !Gl.has(At)))) {
                    Ke.flags |= 65536, x &= -x, Ke.lanes |= x;
                    var qt = Ac(Ke, te, x);
                    qi(Ke, qt);
                    break e;
                  }
              }
              Ke = Ke.return;
            } while (Ke !== null);
          }
          $s(L);
        } catch (Wn) {
          x = Wn, Ba === L && L !== null && (Ba = L = L.return);
          continue;
        }
        break;
      } while (1);
    }
    function Cf() {
      var y = ns.current;
      return ns.current = xf, y === null ? xf : y;
    }
    function Rf() {
      (ws === 0 || ws === 3 || ws === 2) && (ws = 4), Ra === null || (zc & 268435455) === 0 && (cc & 268435455) === 0 || lr(Ra, ci);
    }
    function ia(y, x) {
      var L = Kr;
      Kr |= 2;
      var H = Cf();
      Ra === y && ci === x || Di(y, x);
      do
        try {
          Fs();
          break;
        } catch (q) {
          Tf(y, q);
        }
      while (1);
      if (xo(), Kr = L, ns.current = H, Ba !== null)
        throw Error(l(261));
      return Ra = null, ci = 0, ws;
    }
    function Fs() {
      for (; Ba !== null; )
        Zd(Ba);
    }
    function Af() {
      for (; Ba !== null && !Xi(); )
        Zd(Ba);
    }
    function Zd(y) {
      var x = Df(y.alternate, y, Hl);
      y.memoizedProps = y.pendingProps, x === null ? $s(y) : Ba = x, wf.current = null;
    }
    function $s(y) {
      var x = y;
      do {
        var L = x.alternate;
        if (y = x.return, (x.flags & 32768) === 0) {
          if (L = vr(L, x, Hl), L !== null) {
            Ba = L;
            return;
          }
        } else {
          if (L = zr(L, x), L !== null) {
            L.flags &= 32767, Ba = L;
            return;
          }
          if (y !== null)
            y.flags |= 32768, y.subtreeFlags = 0, y.deletions = null;
          else {
            ws = 6, Ba = null;
            return;
          }
        }
        if (x = x.sibling, x !== null) {
          Ba = x;
          return;
        }
        Ba = x = y;
      } while (x !== null);
      ws === 0 && (ws = 5);
    }
    function Yl(y, x) {
      var L = Cr, H = Sa.transition;
      try {
        Sa.transition = null, Cr = 1, tp(y, x, L);
      } finally {
        Sa.transition = H, Cr = L;
      }
      return null;
    }
    function tp(y, x, L) {
      do
        kc();
      while (Wl !== null);
      if ((Kr & 6) !== 0)
        throw Error(l(327));
      var H = y.finishedWork, q = y.finishedLanes;
      if (H === null)
        return null;
      if (y.finishedWork = null, y.finishedLanes = 0, H === y.current)
        throw Error(l(177));
      y.callbackNode = null, y.callbackPriority = 0;
      var te = H.lanes | H.childLanes;
      if (Eu(y, te), y === Ra && (Ba = Ra = null, ci = 0), (H.subtreeFlags & 2064) === 0 && (H.flags & 2064) === 0 || ud || (ud = !0, pu(dl, function() {
        return kc(), null;
      })), te = (H.flags & 15990) !== 0, (H.subtreeFlags & 15990) !== 0 || te) {
        te = Sa.transition, Sa.transition = null;
        var Ae = Cr;
        Cr = 1;
        var Ke = Kr;
        Kr |= 4, wf.current = null, wh(y, H), Hp(y, H), ue(y.containerInfo), y.current = H, du(H), Rm(), Kr = Ke, Cr = Ae, Sa.transition = te;
      } else
        y.current = H;
      if (ud && (ud = !1, Wl = y, Eh = q), te = y.pendingLanes, te === 0 && (Gl = null), Ii(H.stateNode), Sr(y, mi()), x !== null)
        for (L = y.onRecoverableError, H = 0; H < x.length; H++)
          L(x[H]);
      if (Mf)
        throw Mf = !1, y = Vl, Vl = null, y;
      return (Eh & 1) !== 0 && y.tag !== 0 && kc(), te = y.pendingLanes, (te & 1) !== 0 ? y === hr ? fc++ : (fc = 0, hr = y) : fc = 0, Fo(), null;
    }
    function kc() {
      if (Wl !== null) {
        var y = fl(Eh), x = Sa.transition, L = Cr;
        try {
          if (Sa.transition = null, Cr = 16 > y ? 16 : y, Wl === null)
            var H = !1;
          else {
            if (y = Wl, Wl = null, Eh = 0, (Kr & 6) !== 0)
              throw Error(l(331));
            var q = Kr;
            for (Kr |= 4, pn = y.current; pn !== null; ) {
              var te = pn, Ae = te.child;
              if ((pn.flags & 16) !== 0) {
                var Ke = te.deletions;
                if (Ke !== null) {
                  for (var kt = 0; kt < Ke.length; kt++) {
                    var cn = Ke[kt];
                    for (pn = cn; pn !== null; ) {
                      var bn = pn;
                      switch (bn.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Ou(8, bn, te);
                      }
                      var wr = bn.child;
                      if (wr !== null)
                        wr.return = bn, pn = wr;
                      else
                        for (; pn !== null; ) {
                          bn = pn;
                          var ur = bn.sibling, _a = bn.return;
                          if (Us(bn), bn === cn) {
                            pn = null;
                            break;
                          }
                          if (ur !== null) {
                            ur.return = _a, pn = ur;
                            break;
                          }
                          pn = _a;
                        }
                    }
                  }
                  var Tn = te.alternate;
                  if (Tn !== null) {
                    var Li = Tn.child;
                    if (Li !== null) {
                      Tn.child = null;
                      do {
                        var ms = Li.sibling;
                        Li.sibling = null, Li = ms;
                      } while (Li !== null);
                    }
                  }
                  pn = te;
                }
              }
              if ((te.subtreeFlags & 2064) !== 0 && Ae !== null)
                Ae.return = te, pn = Ae;
              else
                e:
                  for (; pn !== null; ) {
                    if (te = pn, (te.flags & 2048) !== 0)
                      switch (te.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Ou(9, te, te.return);
                      }
                    var dt = te.sibling;
                    if (dt !== null) {
                      dt.return = te.return, pn = dt;
                      break e;
                    }
                    pn = te.return;
                  }
            }
            var Qe = y.current;
            for (pn = Qe; pn !== null; ) {
              Ae = pn;
              var At = Ae.child;
              if ((Ae.subtreeFlags & 2064) !== 0 && At !== null)
                At.return = Ae, pn = At;
              else
                e:
                  for (Ae = Qe; pn !== null; ) {
                    if (Ke = pn, (Ke.flags & 2048) !== 0)
                      try {
                        switch (Ke.tag) {
                          case 0:
                          case 11:
                          case 15:
                            bs(9, Ke);
                        }
                      } catch (Wn) {
                        wi(Ke, Ke.return, Wn);
                      }
                    if (Ke === Ae) {
                      pn = null;
                      break e;
                    }
                    var qt = Ke.sibling;
                    if (qt !== null) {
                      qt.return = Ke.return, pn = qt;
                      break e;
                    }
                    pn = Ke.return;
                  }
            }
            if (Kr = q, Fo(), su && typeof su.onPostCommitFiberRoot == "function")
              try {
                su.onPostCommitFiberRoot(hf, y);
              } catch {
              }
            H = !0;
          }
          return H;
        } finally {
          Cr = L, Sa.transition = x;
        }
      }
      return !1;
    }
    function Es(y, x, L) {
      x = Sf(L, x), x = id(y, x, 1), Ku(y, x), x = fi(), y = Nc(y, 1), y !== null && (xr(y, 1, x), Sr(y, x));
    }
    function wi(y, x, L) {
      if (y.tag === 3)
        Es(y, y, L);
      else
        for (; x !== null; ) {
          if (x.tag === 3) {
            Es(x, y, L);
            break;
          } else if (x.tag === 1) {
            var H = x.stateNode;
            if (typeof x.type.getDerivedStateFromError == "function" || typeof H.componentDidCatch == "function" && (Gl === null || !Gl.has(H))) {
              y = Sf(L, y), y = Ac(x, y, 1), Ku(x, y), y = fi(), x = Nc(x, 1), x !== null && (xr(x, 1, y), Sr(x, y));
              break;
            }
          }
          x = x.return;
        }
    }
    function eo(y, x, L) {
      var H = y.pingCache;
      H !== null && H.delete(x), x = fi(), y.pingedLanes |= y.suspendedLanes & L, Ra === y && (ci & L) === L && (ws === 4 || ws === 3 && (ci & 130023424) === ci && 500 > mi() - Fm ? Di(y, 0) : qd |= L), Sr(y, x);
    }
    function Xl(y, x) {
      x === 0 && ((y.mode & 1) === 0 ? x = 1 : (x = ri, ri <<= 1, (ri & 130023424) === 0 && (ri = 4194304)));
      var L = fi();
      y = Nc(y, x), y !== null && (xr(y, x, L), Sr(y, L));
    }
    function Ic(y) {
      var x = y.memoizedState, L = 0;
      x !== null && (L = x.retryLane), Xl(y, L);
    }
    function hu(y, x) {
      var L = 0;
      switch (y.tag) {
        case 13:
          var H = y.stateNode, q = y.memoizedState;
          q !== null && (L = q.retryLane);
          break;
        case 19:
          H = y.stateNode;
          break;
        default:
          throw Error(l(314));
      }
      H !== null && H.delete(x), Xl(y, L);
    }
    var Df;
    Df = function(y, x, L) {
      if (y !== null)
        if (y.memoizedProps !== x.pendingProps || Ti.current)
          oi = !0;
        else {
          if ((y.lanes & L) === 0 && (x.flags & 128) === 0)
            return oi = !1, uc(y, x, L);
          oi = (y.flags & 131072) !== 0;
        }
      else
        oi = !1, ca && (x.flags & 1048576) !== 0 && Ol(x, zp, x.index);
      switch (x.lanes = 0, x.tag) {
        case 2:
          var H = x.type;
          y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), y = x.pendingProps;
          var q = Uo(x, _i.current);
          Xs(x, L), q = xi(null, x, H, y, q, L);
          var te = Ec();
          return x.flags |= 1, typeof q == "object" && q !== null && typeof q.render == "function" && q.$$typeof === void 0 ? (x.tag = 1, x.memoizedState = null, x.updateQueue = null, Pa(H) ? (te = !0, Al(x)) : te = !1, x.memoizedState = q.state !== null && q.state !== void 0 ? q.state : null, qs(x), q.updater = Am, x.stateNode = q, q._reactInternals = x, vh(x, H, y, L), x = Ia(null, x, H, !0, te, L)) : (x.tag = 0, ca && te && ec(x), Gn(null, x, q, L), x = x.child), x;
        case 16:
          H = x.elementType;
          e: {
            switch (y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), y = x.pendingProps, q = H._init, H = q(H._payload), x.type = H, q = x.tag = cd(H), y = Oa(H, y), q) {
              case 0:
                x = es(null, x, H, y, L);
                break e;
              case 1:
                x = Nl(
                  null,
                  x,
                  H,
                  y,
                  L
                );
                break e;
              case 11:
                x = bi(null, x, H, y, L);
                break e;
              case 14:
                x = zi(null, x, H, Oa(H.type, y), L);
                break e;
            }
            throw Error(l(306, H, ""));
          }
          return x;
        case 0:
          return H = x.type, q = x.pendingProps, q = x.elementType === H ? q : Oa(H, q), es(y, x, H, q, L);
        case 1:
          return H = x.type, q = x.pendingProps, q = x.elementType === H ? q : Oa(H, q), Nl(y, x, H, q, L);
        case 3:
          e: {
            if (Fl(x), y === null)
              throw Error(l(387));
            H = x.pendingProps, te = x.memoizedState, q = te.element, Zf(y, x), Cu(x, H, null, L);
            var Ae = x.memoizedState;
            if (H = Ae.element, et && te.isDehydrated)
              if (te = {
                element: H,
                isDehydrated: !1,
                cache: Ae.cache,
                transitions: Ae.transitions
              }, x.updateQueue.baseState = te, x.memoizedState = te, x.flags & 256) {
                q = Error(l(423)), x = _f(y, x, H, L, q);
                break e;
              } else if (H !== q) {
                q = Error(l(424)), x = _f(y, x, H, L, q);
                break e;
              } else
                for (et && (Ma = Oe(x.stateNode.containerInfo), Za = x, ca = !0, tl = null, Fd = !1), L = Fp(x, null, H, L), x.child = L; L; )
                  L.flags = L.flags & -3 | 4096, L = L.sibling;
            else {
              if (yh(), H === q) {
                x = Vr(y, x, L);
                break e;
              }
              Gn(y, x, H, L);
            }
            x = x.child;
          }
          return x;
        case 5:
          return Ip(x), y === null && Kf(x), H = x.type, q = x.pendingProps, te = y !== null ? y.memoizedProps : null, Ae = q.children, st(H, q) ? Ae = null : te !== null && st(H, te) && (x.flags |= 32), hs(y, x), Gn(y, x, Ae, L), x.child;
        case 6:
          return y === null && Kf(x), null;
        case 13:
          return Sv(y, x, L);
        case 4:
          return kp(x, x.stateNode.containerInfo), H = x.pendingProps, y === null ? x.child = wc(x, null, H, L) : Gn(y, x, H, L), x.child;
        case 11:
          return H = x.type, q = x.pendingProps, q = x.elementType === H ? q : Oa(H, q), bi(y, x, H, q, L);
        case 7:
          return Gn(y, x, x.pendingProps, L), x.child;
        case 8:
          return Gn(y, x, x.pendingProps.children, L), x.child;
        case 12:
          return Gn(y, x, x.pendingProps.children, L), x.child;
        case 10:
          e: {
            if (H = x.type._context, q = x.pendingProps, te = x.memoizedProps, Ae = q.value, Tu(x, H, Ae), te !== null)
              if (No(te.value, Ae)) {
                if (te.children === q.children && !Ti.current) {
                  x = Vr(y, x, L);
                  break e;
                }
              } else
                for (te = x.child, te !== null && (te.return = x); te !== null; ) {
                  var Ke = te.dependencies;
                  if (Ke !== null) {
                    Ae = te.child;
                    for (var kt = Ke.firstContext; kt !== null; ) {
                      if (kt.context === H) {
                        if (te.tag === 1) {
                          kt = $o(-1, L & -L), kt.tag = 2;
                          var cn = te.updateQueue;
                          if (cn !== null) {
                            cn = cn.shared;
                            var bn = cn.pending;
                            bn === null ? kt.next = kt : (kt.next = bn.next, bn.next = kt), cn.pending = kt;
                          }
                        }
                        te.lanes |= L, kt = te.alternate, kt !== null && (kt.lanes |= L), za(te.return, L, x), Ke.lanes |= L;
                        break;
                      }
                      kt = kt.next;
                    }
                  } else if (te.tag === 10)
                    Ae = te.type === x.type ? null : te.child;
                  else if (te.tag === 18) {
                    if (Ae = te.return, Ae === null)
                      throw Error(l(341));
                    Ae.lanes |= L, Ke = Ae.alternate, Ke !== null && (Ke.lanes |= L), za(Ae, L, x), Ae = te.sibling;
                  } else
                    Ae = te.child;
                  if (Ae !== null)
                    Ae.return = te;
                  else
                    for (Ae = te; Ae !== null; ) {
                      if (Ae === x) {
                        Ae = null;
                        break;
                      }
                      if (te = Ae.sibling, te !== null) {
                        te.return = Ae.return, Ae = te;
                        break;
                      }
                      Ae = Ae.return;
                    }
                  te = Ae;
                }
            Gn(y, x, q.children, L), x = x.child;
          }
          return x;
        case 9:
          return q = x.type, H = x.pendingProps.children, Xs(x, L), q = Jr(q), H = H(q), x.flags |= 1, Gn(y, x, H, L), x.child;
        case 14:
          return H = x.type, q = Oa(H, x.pendingProps), q = Oa(H.type, q), zi(y, x, H, q, L);
        case 15:
          return Pc(y, x, x.type, x.pendingProps, L);
        case 17:
          return H = x.type, q = x.pendingProps, q = x.elementType === H ? q : Oa(H, q), y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), x.tag = 1, Pa(H) ? (y = !0, Al(x)) : y = !1, Xs(x, L), Lm(x, H, q), vh(x, H, q, L), Ia(null, x, H, !0, y, L);
        case 19:
          return Oc(y, x, L);
        case 22:
          return Rr(y, x, L);
      }
      throw Error(l(156, x.tag));
    };
    function pu(y, x) {
      return yo(y, x);
    }
    function zu(y, x, L, H) {
      this.tag = y, this.key = L, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = x, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = H, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Mo(y, x, L, H) {
      return new zu(y, x, L, H);
    }
    function Bc(y) {
      return y = y.prototype, !(!y || !y.isReactComponent);
    }
    function cd(y) {
      if (typeof y == "function")
        return Bc(y) ? 1 : 0;
      if (y != null) {
        if (y = y.$$typeof, y === P)
          return 11;
        if (y === k)
          return 14;
      }
      return 2;
    }
    function Yo(y, x) {
      var L = y.alternate;
      return L === null ? (L = Mo(y.tag, x, y.key, y.mode), L.elementType = y.elementType, L.type = y.type, L.stateNode = y.stateNode, L.alternate = y, y.alternate = L) : (L.pendingProps = x, L.type = y.type, L.flags = 0, L.subtreeFlags = 0, L.deletions = null), L.flags = y.flags & 14680064, L.childLanes = y.childLanes, L.lanes = y.lanes, L.child = y.child, L.memoizedProps = y.memoizedProps, L.memoizedState = y.memoizedState, L.updateQueue = y.updateQueue, x = y.dependencies, L.dependencies = x === null ? null : { lanes: x.lanes, firstContext: x.firstContext }, L.sibling = y.sibling, L.index = y.index, L.ref = y.ref, L;
    }
    function fd(y, x, L, H, q, te) {
      var Ae = 2;
      if (H = y, typeof y == "function")
        Bc(y) && (Ae = 1);
      else if (typeof y == "string")
        Ae = 5;
      else
        e:
          switch (y) {
            case S:
              return mu(L.children, q, te, x);
            case _:
              Ae = 8, q |= 8;
              break;
            case T:
              return y = Mo(12, L, x, q | 2), y.elementType = T, y.lanes = te, y;
            case U:
              return y = Mo(13, L, x, q), y.elementType = U, y.lanes = te, y;
            case B:
              return y = Mo(19, L, x, q), y.elementType = B, y.lanes = te, y;
            case I:
              return dd(L, q, te, x);
            default:
              if (typeof y == "object" && y !== null)
                switch (y.$$typeof) {
                  case C:
                    Ae = 10;
                    break e;
                  case D:
                    Ae = 9;
                    break e;
                  case P:
                    Ae = 11;
                    break e;
                  case k:
                    Ae = 14;
                    break e;
                  case V:
                    Ae = 16, H = null;
                    break e;
                }
              throw Error(l(130, y == null ? y : typeof y, ""));
          }
      return x = Mo(Ae, L, x, q), x.elementType = y, x.type = H, x.lanes = te, x;
    }
    function mu(y, x, L, H) {
      return y = Mo(7, y, H, x), y.lanes = L, y;
    }
    function dd(y, x, L, H) {
      return y = Mo(22, y, H, x), y.elementType = I, y.lanes = L, y.stateNode = {}, y;
    }
    function Ms(y, x, L) {
      return y = Mo(6, y, null, x), y.lanes = L, y;
    }
    function ks(y, x, L) {
      return x = Mo(4, y.children !== null ? y.children : [], y.key, x), x.lanes = L, x.stateNode = { containerInfo: y.containerInfo, pendingChildren: null, implementation: y.implementation }, x;
    }
    function vu(y, x, L, H, q) {
      this.tag = x, this.containerInfo = y, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = _t, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Yf(0), this.expirationTimes = Yf(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Yf(0), this.identifierPrefix = H, this.onRecoverableError = q, et && (this.mutableSourceEagerHydrationData = null);
    }
    function fg(y, x, L, H, q, te, Ae, Ke, kt) {
      return y = new vu(y, x, L, Ke, kt), x === 1 ? (x = 1, te === !0 && (x |= 8)) : x = 0, te = Mo(3, null, null, x), y.current = te, te.stateNode = y, te.memoizedState = { element: H, isDehydrated: L, cache: null, transitions: null }, qs(te), y;
    }
    function ii(y) {
      if (!y)
        return Ea;
      y = y._reactInternals;
      e: {
        if (ee(y) !== y || y.tag !== 1)
          throw Error(l(170));
        var x = y;
        do {
          switch (x.tag) {
            case 3:
              x = x.stateNode.context;
              break e;
            case 1:
              if (Pa(x.type)) {
                x = x.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          x = x.return;
        } while (x !== null);
        throw Error(l(171));
      }
      if (y.tag === 1) {
        var L = y.type;
        if (Pa(L))
          return Wf(y, L, x);
      }
      return x;
    }
    function Nu(y) {
      var x = y._reactInternals;
      if (x === void 0)
        throw typeof y.render == "function" ? Error(l(188)) : (y = Object.keys(y).join(","), Error(l(268, y)));
      return y = ce(x), y === null ? null : y.stateNode;
    }
    function Lf(y, x) {
      if (y = y.memoizedState, y !== null && y.dehydrated !== null) {
        var L = y.retryLane;
        y.retryLane = L !== 0 && L < x ? L : x;
      }
    }
    function dc(y, x) {
      Lf(y, x), (y = y.alternate) && Lf(y, x);
    }
    function Pf(y) {
      return y = ce(y), y === null ? null : y.stateNode;
    }
    function Vp() {
      return null;
    }
    return t.attemptContinuousHydration = function(y) {
      if (y.tag === 13) {
        var x = fi();
        jl(y, 134217728, x), dc(y, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(y) {
      if (y.tag === 13) {
        var x = fi(), L = Ns(y);
        jl(y, L, x), dc(y, L);
      }
    }, t.attemptSynchronousHydration = function(y) {
      switch (y.tag) {
        case 3:
          var x = y.stateNode;
          if (x.current.memoizedState.isDehydrated) {
            var L = go(x.pendingLanes);
            L !== 0 && (ua(x, L | 1), Sr(x, mi()), (Kr & 6) === 0 && (Qd(), Fo()));
          }
          break;
        case 13:
          var H = fi();
          Ha(function() {
            return jl(y, 1, H);
          }), dc(y, 1);
      }
    }, t.batchedUpdates = function(y, x) {
      var L = Kr;
      Kr |= 1;
      try {
        return y(x);
      } finally {
        Kr = L, Kr === 0 && (Qd(), _c && Fo());
      }
    }, t.createComponentSelector = function(y) {
      return { $$typeof: Yd, value: y };
    }, t.createContainer = function(y, x, L, H, q, te, Ae) {
      return fg(y, x, !1, null, L, H, q, te, Ae);
    }, t.createHasPseudoClassSelector = function(y) {
      return { $$typeof: da, value: y };
    }, t.createHydrationContainer = function(y, x, L, H, q, te, Ae, Ke, kt) {
      return y = fg(L, H, !0, y, q, te, Ae, Ke, kt), y.context = ii(null), L = y.current, H = fi(), q = Ns(L), te = $o(H, q), te.callback = x != null ? x : null, Ku(L, te), y.current.lanes = q, xr(y, q, H), Sr(y, H), y;
    }, t.createPortal = function(y, x, L) {
      var H = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: m, key: H == null ? null : "" + H, children: y, containerInfo: x, implementation: L };
    }, t.createRoleSelector = function(y) {
      return { $$typeof: Hi, value: y };
    }, t.createTestNameSelector = function(y) {
      return { $$typeof: wn, value: y };
    }, t.createTextSelector = function(y) {
      return { $$typeof: Qi, value: y };
    }, t.deferredUpdates = function(y) {
      var x = Cr, L = Sa.transition;
      try {
        return Sa.transition = null, Cr = 16, y();
      } finally {
        Cr = x, Sa.transition = L;
      }
    }, t.discreteUpdates = function(y, x, L, H, q) {
      var te = Cr, Ae = Sa.transition;
      try {
        return Sa.transition = null, Cr = 1, y(x, L, H, q);
      } finally {
        Cr = te, Sa.transition = Ae, Kr === 0 && Qd();
      }
    }, t.findAllNodes = An, t.findBoundingRects = function(y, x) {
      if (!Jt)
        throw Error(l(363));
      x = An(y, x), y = [];
      for (var L = 0; L < x.length; L++)
        y.push(Me(x[L]));
      for (x = y.length - 1; 0 < x; x--) {
        L = y[x];
        for (var H = L.x, q = H + L.width, te = L.y, Ae = te + L.height, Ke = x - 1; 0 <= Ke; Ke--)
          if (x !== Ke) {
            var kt = y[Ke], cn = kt.x, bn = cn + kt.width, wr = kt.y, ur = wr + kt.height;
            if (H >= cn && te >= wr && q <= bn && Ae <= ur) {
              y.splice(x, 1);
              break;
            } else if (H !== cn || L.width !== kt.width || ur < te || wr > Ae) {
              if (!(te !== wr || L.height !== kt.height || bn < H || cn > q)) {
                cn > H && (kt.width += cn - H, kt.x = H), bn < q && (kt.width = q - cn), y.splice(x, 1);
                break;
              }
            } else {
              wr > te && (kt.height += wr - te, kt.y = te), ur < Ae && (kt.height = Ae - wr), y.splice(x, 1);
              break;
            }
          }
      }
      return y;
    }, t.findHostInstance = Nu, t.findHostInstanceWithNoPortals = function(y) {
      return y = pe(y), y = y !== null ? de(y) : null, y === null ? null : y.stateNode;
    }, t.findHostInstanceWithWarning = function(y) {
      return Nu(y);
    }, t.flushControlled = function(y) {
      var x = Kr;
      Kr |= 1;
      var L = Sa.transition, H = Cr;
      try {
        Sa.transition = null, Cr = 1, y();
      } finally {
        Cr = H, Sa.transition = L, Kr = x, Kr === 0 && (Qd(), Fo());
      }
    }, t.flushPassiveEffects = kc, t.flushSync = Ha, t.focusWithin = function(y, x) {
      if (!Jt)
        throw Error(l(363));
      for (y = ep(y), x = ts(y, x), x = Array.from(x), y = 0; y < x.length; ) {
        var L = x[y++];
        if (!je(L)) {
          if (L.tag === 5 && zt(L.stateNode))
            return !0;
          for (L = L.child; L !== null; )
            x.push(L), L = L.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Cr;
    }, t.getFindAllNodesFailureDescription = function(y, x) {
      if (!Jt)
        throw Error(l(363));
      var L = 0, H = [];
      y = [ep(y), 0];
      for (var q = 0; q < y.length; ) {
        var te = y[q++], Ae = y[q++], Ke = x[Ae];
        if ((te.tag !== 5 || !je(te)) && (Go(te, Ke) && (H.push(Wo(Ke)), Ae++, Ae > L && (L = Ae)), Ae < x.length))
          for (te = te.child; te !== null; )
            y.push(te, Ae), te = te.sibling;
      }
      if (L < x.length) {
        for (y = []; L < x.length; L++)
          y.push(Wo(x[L]));
        return `findAllNodes was able to match part of the selector:
  ` + (H.join(" > ") + `

No matching component was found for:
  `) + y.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(y) {
      if (y = y.current, !y.child)
        return null;
      switch (y.child.tag) {
        case 5:
          return Ce(y.child.stateNode);
        default:
          return y.child.stateNode;
      }
    }, t.injectIntoDevTools = function(y) {
      if (y = { bundleType: y.bundleType, version: y.version, rendererPackageName: y.rendererPackageName, rendererConfig: y.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: d.ReactCurrentDispatcher, findHostInstanceByFiber: Pf, findFiberByHostInstance: y.findFiberByHostInstance || Vp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        y = !1;
      else {
        var x = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (x.isDisabled || !x.supportsFiber)
          y = !0;
        else {
          try {
            hf = x.inject(y), su = x;
          } catch {
          }
          y = !!x.checkDCE;
        }
      }
      return y;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(y, x, L, H) {
      if (!Jt)
        throw Error(l(363));
      y = An(y, x);
      var q = Nt(y, L, H).disconnect;
      return { disconnect: function() {
        q();
      } };
    }, t.registerMutableSourceForHydration = function(y, x) {
      var L = x._getVersion;
      L = L(x._source), y.mutableSourceEagerHydrationData == null ? y.mutableSourceEagerHydrationData = [x, L] : y.mutableSourceEagerHydrationData.push(x, L);
    }, t.runWithPriority = function(y, x) {
      var L = Cr;
      try {
        return Cr = y, x();
      } finally {
        Cr = L;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(y, x, L, H) {
      var q = x.current, te = fi(), Ae = Ns(q);
      return L = ii(L), x.context === null ? x.context = L : x.pendingContext = L, x = $o(te, Ae), x.payload = { element: y }, H = H === void 0 ? null : H, H !== null && (x.callback = H), Ku(q, x), y = jl(q, Ae, te), y !== null && Qh(y, q, Ae), Ae;
    }, t;
  }), sD;
}
var oD = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rz;
function p9() {
  return rz || (rz = 1, process.env.NODE_ENV !== "production" && (oD.exports = function(e) {
    var t = {}, r = hh, i = jM.exports, o = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = !1;
    function d(u) {
      l = u;
    }
    function h(u) {
      if (!l) {
        for (var f = arguments.length, M = new Array(f > 1 ? f - 1 : 0), A = 1; A < f; A++)
          M[A - 1] = arguments[A];
        S("warn", u, M);
      }
    }
    function m(u) {
      if (!l) {
        for (var f = arguments.length, M = new Array(f > 1 ? f - 1 : 0), A = 1; A < f; A++)
          M[A - 1] = arguments[A];
        S("error", u, M);
      }
    }
    function S(u, f, M) {
      {
        var A = o.ReactDebugCurrentFrame, z = A.getStackAddendum();
        z !== "" && (f += "%s", M = M.concat([z]));
        var j = M.map(function(ne) {
          return String(ne);
        });
        j.unshift("Warning: " + f), Function.prototype.apply.call(console[u], console, j);
      }
    }
    var _ = Object.assign;
    function T(u) {
      return u._reactInternals;
    }
    function C(u, f) {
      u._reactInternals = f;
    }
    var D = !1, P = !1, U = !1, B = !1, k = !1, V = !1, I = !0, X = !0, J = !0, $ = 0, W = 1, ee = 2, ie = 3, pe = 4, ce = 5, Ee = 6, de = 7, Fe = 8, Ce = 9, Be = 10, he = 11, fe = 12, ue = 13, ye = 14, we = 15, Xe = 16, Je = 17, st = 18, Ue = 19, ot = 21, rt = 22, _t = 23, Rt = 24, Ot = 25, He = Symbol.for("react.element"), et = Symbol.for("react.portal"), mt = Symbol.for("react.fragment"), vt = Symbol.for("react.strict_mode"), bt = Symbol.for("react.profiler"), Qt = Symbol.for("react.provider"), ft = Symbol.for("react.context"), Vt = Symbol.for("react.forward_ref"), Jt = Symbol.for("react.suspense"), Mt = Symbol.for("react.suspense_list"), Me = Symbol.for("react.memo"), oe = Symbol.for("react.lazy"), je = Symbol.for("react.scope"), lt = Symbol.for("react.debug_trace_mode"), zt = Symbol.for("react.offscreen"), Nt = Symbol.for("react.legacy_hidden"), Ut = Symbol.for("react.cache"), tt = Symbol.for("react.tracing_marker"), rn = Symbol.iterator, ze = "@@iterator";
    function xe(u) {
      if (u === null || typeof u != "object")
        return null;
      var f = rn && u[rn] || u[ze];
      return typeof f == "function" ? f : null;
    }
    function Ie(u, f, M) {
      var A = u.displayName;
      if (A)
        return A;
      var z = f.displayName || f.name || "";
      return z !== "" ? M + "(" + z + ")" : M;
    }
    function it(u) {
      return u.displayName || "Context";
    }
    function at(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && m("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case mt:
          return "Fragment";
        case et:
          return "Portal";
        case bt:
          return "Profiler";
        case vt:
          return "StrictMode";
        case Jt:
          return "Suspense";
        case Mt:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case ft:
            var f = u;
            return it(f) + ".Consumer";
          case Qt:
            var M = u;
            return it(M._context) + ".Provider";
          case Vt:
            return Ie(u, u.render, "ForwardRef");
          case Me:
            var A = u.displayName || null;
            return A !== null ? A : at(u.type) || "Memo";
          case oe: {
            var z = u, j = z._payload, ne = z._init;
            try {
              return at(ne(j));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function hn(u, f, M) {
      var A = f.displayName || f.name || "";
      return u.displayName || (A !== "" ? M + "(" + A + ")" : M);
    }
    function De(u) {
      return u.displayName || "Context";
    }
    function Tt(u) {
      var f = u.tag, M = u.type;
      switch (f) {
        case Rt:
          return "Cache";
        case Ce:
          var A = M;
          return De(A) + ".Consumer";
        case Be:
          var z = M;
          return De(z._context) + ".Provider";
        case st:
          return "DehydratedFragment";
        case he:
          return hn(M, M.render, "ForwardRef");
        case de:
          return "Fragment";
        case ce:
          return M;
        case pe:
          return "Portal";
        case ie:
          return "Root";
        case Ee:
          return "Text";
        case Xe:
          return at(M);
        case Fe:
          return M === vt ? "StrictMode" : "Mode";
        case rt:
          return "Offscreen";
        case fe:
          return "Profiler";
        case ot:
          return "Scope";
        case ue:
          return "Suspense";
        case Ue:
          return "SuspenseList";
        case Ot:
          return "TracingMarker";
        case W:
        case $:
        case Je:
        case ee:
        case ye:
        case we:
          if (typeof M == "function")
            return M.displayName || M.name || null;
          if (typeof M == "string")
            return M;
          break;
      }
      return null;
    }
    var Ne = 0, Gt = 1, Pt = 2, fn = 4, Gr = Pt | fn, Wr = 16, Ur = 32, ir = 64, Vn = 128, jr = 256, ti = 512, ki = 1024, Wi = 2048, ni = 4096, ji = ni | fn, Si = 8192, Te = 16384, ct = Wi | fn | ir | ti | ki | Te, me = 32767, Oe = 32768, qe = 65536, on = 131072, yn = 1048576, Rn = 2097152, mn = 4194304, vn = 8388608, Zn = 16777216, nr = 33554432, br = fn | ki | 0, Yi = Pt | fn | Wr | Ur | ti | ni | Si, La = fn | ir | ti | Si, Ys = Wi | Wr, $t = mn | vn | Rn, Zr = o.ReactCurrentOwner;
    function ls(u) {
      var f = u, M = u;
      if (u.alternate)
        for (; f.return; )
          f = f.return;
      else {
        var A = f;
        do
          f = A, (f.flags & (Pt | ni)) !== Ne && (M = f.return), A = f.return;
        while (A);
      }
      return f.tag === ie ? M : null;
    }
    function Xn(u) {
      return ls(u) === u;
    }
    function qa(u) {
      {
        var f = Zr.current;
        if (f !== null && f.tag === W) {
          var M = f, A = M.stateNode;
          A._warnedAboutRefsInRender || m("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Tt(M) || "A component"), A._warnedAboutRefsInRender = !0;
        }
      }
      var z = T(u);
      return z ? ls(z) === z : !1;
    }
    function mo(u) {
      if (ls(u) !== u)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Ds(u) {
      var f = u.alternate;
      if (!f) {
        var M = ls(u);
        if (M === null)
          throw new Error("Unable to find node on an unmounted component.");
        return M !== u ? null : u;
      }
      for (var A = u, z = f; ; ) {
        var j = A.return;
        if (j === null)
          break;
        var ne = j.alternate;
        if (ne === null) {
          var se = j.return;
          if (se !== null) {
            A = z = se;
            continue;
          }
          break;
        }
        if (j.child === ne.child) {
          for (var Se = j.child; Se; ) {
            if (Se === A)
              return mo(j), u;
            if (Se === z)
              return mo(j), f;
            Se = Se.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (A.return !== z.return)
          A = j, z = ne;
        else {
          for (var Pe = !1, Ge = j.child; Ge; ) {
            if (Ge === A) {
              Pe = !0, A = j, z = ne;
              break;
            }
            if (Ge === z) {
              Pe = !0, z = j, A = ne;
              break;
            }
            Ge = Ge.sibling;
          }
          if (!Pe) {
            for (Ge = ne.child; Ge; ) {
              if (Ge === A) {
                Pe = !0, A = ne, z = j;
                break;
              }
              if (Ge === z) {
                Pe = !0, z = ne, A = j;
                break;
              }
              Ge = Ge.sibling;
            }
            if (!Pe)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (A.alternate !== z)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (A.tag !== ie)
        throw new Error("Unable to find node on an unmounted component.");
      return A.stateNode.current === A ? u : f;
    }
    function us(u) {
      var f = Ds(u);
      return f !== null ? mr(f) : null;
    }
    function mr(u) {
      if (u.tag === ce || u.tag === Ee)
        return u;
      for (var f = u.child; f !== null; ) {
        var M = mr(f);
        if (M !== null)
          return M;
        f = f.sibling;
      }
      return null;
    }
    function pi(u) {
      var f = Ds(u);
      return f !== null ? Ea(f) : null;
    }
    function Ea(u) {
      if (u.tag === ce || u.tag === Ee)
        return u;
      for (var f = u.child; f !== null; ) {
        if (f.tag !== pe) {
          var M = Ea(f);
          if (M !== null)
            return M;
        }
        f = f.sibling;
      }
      return null;
    }
    var _i = Array.isArray;
    function Ti(u) {
      return _i(u);
    }
    var Oo = e.getPublicInstance, Uo = e.getRootHostContext, Pa = e.getChildHostContext, Rl = e.prepareForCommit, vo = e.resetAfterCommit, Wf = e.createInstance, Al = e.appendInitialChild, zd = e.finalizeInitialChildren, Ls = e.prepareUpdate, Ju = e.shouldSetTextContent, au = e.createTextInstance, qh = e.scheduleTimeout, Dl = e.cancelTimeout, ri = e.noTimeout;
    e.now;
    var go = e.isPrimaryRenderer, jf = e.warnsIfNotActing, zo = e.supportsMutation, Ci = e.supportsPersistence, cs = e.supportsHydration, Yf = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var xr = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var Eu = e.getCurrentEventPriority, ua = e.detachDeletedInstance, Cr = e.supportsMicrotasks, fl = e.scheduleMicrotask, yo = e.supportsTestSelectors, Ka = e.findFiberRoot, Xi = e.getBoundingRect, Rm = e.getTextContent, mi = e.isHiddenSubtree, Qa = e.matchAccessibilityRole, Sc = e.setFocusIfFocusable, dl = e.setupIntersectionObserver, df = e.appendChild, hf = e.appendChildToContainer, su = e.commitTextUpdate, Ii = e.commitMount, Ri = e.commitUpdate, No = e.insertBefore, Ps = e.insertInContainerBefore, _c = e.removeChild, Ll = e.removeChildFromContainer, Xf = e.resetTextContent, qf = e.hideInstance, Fo = e.hideTextInstance, Qf = e.unhideInstance, Ki = e.unhideTextInstance, Mu = e.clearContainer, Oa = e.cloneInstance, ys = e.createContainerChildSet, ou = e.appendChildToContainerChildSet, Ua = e.finalizeContainerChildren, bc = e.replaceContainerChildren;
    e.getOffscreenContainerType;
    var xo = e.getOffscreenContainerProps, Tu = e.cloneHiddenInstance, Pl = e.cloneHiddenTextInstance, za = e.canHydrateInstance, Xs = e.canHydrateTextInstance, Jr = e.canHydrateSuspenseInstance, xs = e.isSuspenseInstancePending, va = e.isSuspenseInstanceFallback, qs = e.registerSuspenseInstanceRetry, Zf = e.getNextHydratableSibling, $o = e.getFirstHydratableChild, Ku = e.getFirstHydratableChildWithinContainer, Qh = e.getFirstHydratableChildWithinSuspenseInstance, qi = e.hydrateInstance, Cu = e.hydrateTextInstance, Up = e.hydrateSuspenseInstance, cg = e.getNextHydratableInstanceAfterSuspenseInstance, Zh = e.commitHydratedContainer, Am = e.commitHydratedSuspenseInstance, Dm = e.clearSuspenseBoundary, Lm = e.clearSuspenseBoundaryFromContainer, Pm = e.shouldDeleteUnhydratedTailInstances, vh = e.didNotMatchHydratedContainerTextInstance, $u = e.didNotMatchHydratedTextInstance, Nd = e.didNotHydrateInstanceWithinContainer, Ru = e.didNotHydrateInstanceWithinSuspenseInstance, zp = e.didNotHydrateInstance, hl = e.didNotFindHydratableInstanceWithinContainer, el = e.didNotFindHydratableTextInstanceWithinContainer, pf = e.didNotFindHydratableSuspenseInstanceWithinContainer, Jf = e.didNotFindHydratableInstanceWithinSuspenseInstance, lu = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, mf = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, Ol = e.didNotFindHydratableInstance, ec = e.didNotFindHydratableTextInstance, Oi = e.didNotFindHydratableSuspenseInstance, Za = e.errorHydratingContainer, Ma = 0, ca, Fd, tl, Om, Um, gh, Kf;
    function kd() {
    }
    kd.__reactDisabledLog = !0;
    function Np() {
      {
        if (Ma === 0) {
          ca = console.log, Fd = console.info, tl = console.warn, Om = console.error, Um = console.group, gh = console.groupCollapsed, Kf = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: kd,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        Ma++;
      }
    }
    function yh() {
      {
        if (Ma--, Ma === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: _({}, u, {
              value: ca
            }),
            info: _({}, u, {
              value: Fd
            }),
            warn: _({}, u, {
              value: tl
            }),
            error: _({}, u, {
              value: Om
            }),
            group: _({}, u, {
              value: Um
            }),
            groupCollapsed: _({}, u, {
              value: gh
            }),
            groupEnd: _({}, u, {
              value: Kf
            })
          });
        }
        Ma < 0 && m("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Id = o.ReactCurrentDispatcher, $f;
    function Ss(u, f, M) {
      {
        if ($f === void 0)
          try {
            throw Error();
          } catch (z) {
            var A = z.stack.trim().match(/\n( *(at )?)/);
            $f = A && A[1] || "";
          }
        return `
` + $f + u;
      }
    }
    var tc = !1, vf;
    {
      var wc = typeof WeakMap == "function" ? WeakMap : Map;
      vf = new wc();
    }
    function Fp(u, f) {
      if (!u || tc)
        return "";
      {
        var M = vf.get(u);
        if (M !== void 0)
          return M;
      }
      var A;
      tc = !0;
      var z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var j;
      j = Id.current, Id.current = null, Np();
      try {
        if (f) {
          var ne = function() {
            throw Error();
          };
          if (Object.defineProperty(ne.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ne, []);
            } catch (dn) {
              A = dn;
            }
            Reflect.construct(u, [], ne);
          } else {
            try {
              ne.call();
            } catch (dn) {
              A = dn;
            }
            u.call(ne.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (dn) {
            A = dn;
          }
          u();
        }
      } catch (dn) {
        if (dn && A && typeof dn.stack == "string") {
          for (var se = dn.stack.split(`
`), Se = A.stack.split(`
`), Pe = se.length - 1, Ge = Se.length - 1; Pe >= 1 && Ge >= 0 && se[Pe] !== Se[Ge]; )
            Ge--;
          for (; Pe >= 1 && Ge >= 0; Pe--, Ge--)
            if (se[Pe] !== Se[Ge]) {
              if (Pe !== 1 || Ge !== 1)
                do
                  if (Pe--, Ge--, Ge < 0 || se[Pe] !== Se[Ge]) {
                    var yt = `
` + se[Pe].replace(" at new ", " at ");
                    return u.displayName && yt.includes("<anonymous>") && (yt = yt.replace("<anonymous>", u.displayName)), typeof u == "function" && vf.set(u, yt), yt;
                  }
                while (Pe >= 1 && Ge >= 0);
              break;
            }
        }
      } finally {
        tc = !1, Id.current = j, yh(), Error.prepareStackTrace = z;
      }
      var It = u ? u.displayName || u.name : "", jt = It ? Ss(It) : "";
      return typeof u == "function" && vf.set(u, jt), jt;
    }
    function nc(u, f, M) {
      return Fp(u, !0);
    }
    function Na(u, f, M) {
      return Fp(u, !1);
    }
    function Bd(u) {
      var f = u.prototype;
      return !!(f && f.isReactComponent);
    }
    function ed(u, f, M) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return Fp(u, Bd(u));
      if (typeof u == "string")
        return Ss(u);
      switch (u) {
        case Jt:
          return Ss("Suspense");
        case Mt:
          return Ss("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case Vt:
            return Na(u.render);
          case Me:
            return ed(u.type, f, M);
          case oe: {
            var A = u, z = A._payload, j = A._init;
            try {
              return ed(j(z), f, M);
            } catch {
            }
          }
        }
      return "";
    }
    var rc = Object.prototype.hasOwnProperty, kp = {}, xh = o.ReactDebugCurrentFrame;
    function Ip(u) {
      if (u) {
        var f = u._owner, M = ed(u.type, u._source, f ? f.type : null);
        xh.setExtraStackFrame(M);
      } else
        xh.setExtraStackFrame(null);
    }
    function ko(u, f, M, A, z) {
      {
        var j = Function.call.bind(rc);
        for (var ne in u)
          if (j(u, ne)) {
            var se = void 0;
            try {
              if (typeof u[ne] != "function") {
                var Se = Error((A || "React class") + ": " + M + " type `" + ne + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[ne] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Se.name = "Invariant Violation", Se;
              }
              se = u[ne](f, ne, A, M, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Pe) {
              se = Pe;
            }
            se && !(se instanceof Error) && (Ip(z), m("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", A || "React class", M, ne, typeof se), Ip(null)), se instanceof Error && !(se.message in kp) && (kp[se.message] = !0, Ip(z), m("Failed %s type: %s", M, se.message), Ip(null));
          }
      }
    }
    var Ye = [], Bt;
    Bt = [];
    var pt = -1;
    function Mn(u) {
      return {
        current: u
      };
    }
    function Kn(u, f) {
      if (pt < 0) {
        m("Unexpected pop.");
        return;
      }
      f !== Bt[pt] && m("Unexpected Fiber popped."), u.current = Ye[pt], Ye[pt] = null, Bt[pt] = null, pt--;
    }
    function or(u, f, M) {
      pt++, Ye[pt] = u.current, Bt[pt] = M, u.current = f;
    }
    var Ta;
    Ta = {};
    var $n = {};
    Object.freeze($n);
    var Ui = Mn($n), ra = Mn(!1), Io = $n;
    function fs(u, f, M) {
      return M && pl(f) ? Io : Ui.current;
    }
    function Hd(u, f, M) {
      {
        var A = u.stateNode;
        A.__reactInternalMemoizedUnmaskedChildContext = f, A.__reactInternalMemoizedMaskedChildContext = M;
      }
    }
    function Ul(u, f) {
      {
        var M = u.type, A = M.contextTypes;
        if (!A)
          return $n;
        var z = u.stateNode;
        if (z && z.__reactInternalMemoizedUnmaskedChildContext === f)
          return z.__reactInternalMemoizedMaskedChildContext;
        var j = {};
        for (var ne in A)
          j[ne] = f[ne];
        {
          var se = Tt(u) || "Unknown";
          ko(A, j, "context", se);
        }
        return z && Hd(u, f, j), j;
      }
    }
    function $a() {
      return ra.current;
    }
    function pl(u) {
      {
        var f = u.childContextTypes;
        return f != null;
      }
    }
    function xi(u) {
      Kn(ra, u), Kn(Ui, u);
    }
    function Ec(u) {
      Kn(ra, u), Kn(Ui, u);
    }
    function Au(u, f, M) {
      {
        if (Ui.current !== $n)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        or(Ui, f, u), or(ra, M, u);
      }
    }
    function ml(u, f, M) {
      {
        var A = u.stateNode, z = f.childContextTypes;
        if (typeof A.getChildContext != "function") {
          {
            var j = Tt(u) || "Unknown";
            Ta[j] || (Ta[j] = !0, m("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", j, j));
          }
          return M;
        }
        var ne = A.getChildContext();
        for (var se in ne)
          if (!(se in z))
            throw new Error((Tt(u) || "Unknown") + '.getChildContext(): key "' + se + '" is not defined in childContextTypes.');
        {
          var Se = Tt(u) || "Unknown";
          ko(z, ne, "child context", Se);
        }
        return _({}, M, ne);
      }
    }
    function Ca(u) {
      {
        var f = u.stateNode, M = f && f.__reactInternalMemoizedMergedChildContext || $n;
        return Io = Ui.current, or(Ui, M, u), or(ra, ra.current, u), !0;
      }
    }
    function Sh(u, f, M) {
      {
        var A = u.stateNode;
        if (!A)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (M) {
          var z = ml(u, f, Io);
          A.__reactInternalMemoizedMergedChildContext = z, Kn(ra, u), Kn(Ui, u), or(Ui, z, u), or(ra, M, u);
        } else
          Kn(ra, u), or(ra, M, u);
      }
    }
    function Bp(u) {
      {
        if (!Xn(u) || u.tag !== W)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var f = u;
        do {
          switch (f.tag) {
            case ie:
              return f.stateNode.context;
            case W: {
              var M = f.type;
              if (pl(M))
                return f.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          f = f.return;
        } while (f !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Mc = 0, Tc = 1, Mr = 0, $i = 1, Br = 2, Fa = 8, So = 16, td = Math.clz32 ? Math.clz32 : gf, _h = Math.log, ic = Math.LN2;
    function gf(u) {
      var f = u >>> 0;
      return f === 0 ? 32 : 31 - (_h(f) / ic | 0) | 0;
    }
    var nd = 31, an = 0, Ir = 0, Hr = 1, Bo = 2, nl = 4, ac = 8, Du = 16, Cc = 32, yf = 4194240, sc = 64, ds = 128, Qs = 256, zm = 512, Jh = 1024, Vd = 2048, bh = 4096, xf = 8192, Lu = 16384, rd = 32768, uu = 65536, Sf = 131072, Rc = 262144, Gd = 524288, id = 1048576, Ac = 2097152, zl = 130023424, Dc = 4194304, Lc = 8388608, Os = 16777216, Pu = 33554432, _o = 67108864, ad = Dc, ve = 134217728, oc = 268435455, Zs = 268435456, ka = 536870912, Hn = 1073741824;
    function vr(u) {
      {
        if (u & Hr)
          return "Sync";
        if (u & Bo)
          return "InputContinuousHydration";
        if (u & nl)
          return "InputContinuous";
        if (u & ac)
          return "DefaultHydration";
        if (u & Du)
          return "Default";
        if (u & Cc)
          return "TransitionHydration";
        if (u & yf)
          return "Transition";
        if (u & zl)
          return "Retry";
        if (u & ve)
          return "SelectiveHydration";
        if (u & Zs)
          return "IdleHydration";
        if (u & ka)
          return "Idle";
        if (u & Hn)
          return "Offscreen";
      }
    }
    var Bi = -1, oi = sc, Gn = Dc;
    function bi(u) {
      switch (lc(u)) {
        case Hr:
          return Hr;
        case Bo:
          return Bo;
        case nl:
          return nl;
        case ac:
          return ac;
        case Du:
          return Du;
        case Cc:
          return Cc;
        case sc:
        case ds:
        case Qs:
        case zm:
        case Jh:
        case Vd:
        case bh:
        case xf:
        case Lu:
        case rd:
        case uu:
        case Sf:
        case Rc:
        case Gd:
        case id:
        case Ac:
          return u & yf;
        case Dc:
        case Lc:
        case Os:
        case Pu:
        case _o:
          return u & zl;
        case ve:
          return ve;
        case Zs:
          return Zs;
        case ka:
          return ka;
        case Hn:
          return Hn;
        default:
          return m("Should have found matching lanes. This is a bug in React."), u;
      }
    }
    function zi(u, f) {
      var M = u.pendingLanes;
      if (M === an)
        return an;
      var A = an, z = u.suspendedLanes, j = u.pingedLanes, ne = M & oc;
      if (ne !== an) {
        var se = ne & ~z;
        if (se !== an)
          A = bi(se);
        else {
          var Se = ne & j;
          Se !== an && (A = bi(Se));
        }
      } else {
        var Pe = M & ~z;
        Pe !== an ? A = bi(Pe) : j !== an && (A = bi(j));
      }
      if (A === an)
        return an;
      if (f !== an && f !== A && (f & z) === an) {
        var Ge = lc(A), yt = lc(f);
        if (Ge >= yt || Ge === Du && (yt & yf) !== an)
          return f;
      }
      (A & nl) !== an && (A |= M & Du);
      var It = u.entangledLanes;
      if (It !== an)
        for (var jt = u.entanglements, dn = A & It; dn > 0; ) {
          var Sn = _s(dn), Tr = 1 << Sn;
          A |= jt[Sn], dn &= ~Tr;
        }
      return A;
    }
    function Pc(u, f) {
      for (var M = u.eventTimes, A = Bi; f > 0; ) {
        var z = _s(f), j = 1 << z, ne = M[z];
        ne > A && (A = ne), f &= ~j;
      }
      return A;
    }
    function Rr(u, f) {
      switch (u) {
        case Hr:
        case Bo:
        case nl:
          return f + 250;
        case ac:
        case Du:
        case Cc:
        case sc:
        case ds:
        case Qs:
        case zm:
        case Jh:
        case Vd:
        case bh:
        case xf:
        case Lu:
        case rd:
        case uu:
        case Sf:
        case Rc:
        case Gd:
        case id:
        case Ac:
          return f + 5e3;
        case Dc:
        case Lc:
        case Os:
        case Pu:
        case _o:
          return Bi;
        case ve:
        case Zs:
        case ka:
        case Hn:
          return Bi;
        default:
          return m("Should have found matching lanes. This is a bug in React."), Bi;
      }
    }
    function hs(u, f) {
      for (var M = u.pendingLanes, A = u.suspendedLanes, z = u.pingedLanes, j = u.expirationTimes, ne = M; ne > 0; ) {
        var se = _s(ne), Se = 1 << se, Pe = j[se];
        Pe === Bi ? ((Se & A) === an || (Se & z) !== an) && (j[se] = Rr(Se, f)) : Pe <= f && (u.expiredLanes |= Se), ne &= ~Se;
      }
    }
    function es(u) {
      return bi(u.pendingLanes);
    }
    function Nl(u) {
      var f = u.pendingLanes & ~Hn;
      return f !== an ? f : f & Hn ? Hn : an;
    }
    function Ia(u) {
      return (u & Hr) !== an;
    }
    function Fl(u) {
      return (u & oc) !== an;
    }
    function _f(u) {
      return (u & zl) === u;
    }
    function Wd(u) {
      return (u & yf) === u;
    }
    function Ho(u, f) {
      var M = Bo | nl | ac | Du;
      return (f & M) !== an;
    }
    function Sv(u, f) {
      return (f & u.expiredLanes) !== an;
    }
    function vl(u) {
      return (u & yf) !== 0;
    }
    function bo() {
      var u = oi;
      return oi <<= 1, (oi & yf) === 0 && (oi = sc), u;
    }
    function Kh() {
      var u = Gn;
      return Gn <<= 1, (Gn & zl) === 0 && (Gn = Dc), u;
    }
    function lc(u) {
      return u & -u;
    }
    function cu(u) {
      return lc(u);
    }
    function _s(u) {
      return 31 - td(u);
    }
    function Oc(u) {
      return _s(u);
    }
    function Vr(u, f) {
      return (u & f) !== an;
    }
    function uc(u, f) {
      return (u & f) === f;
    }
    function zr(u, f) {
      return u | f;
    }
    function Js(u, f) {
      return u & ~f;
    }
    function ps(u, f) {
      return u & f;
    }
    function Uc(u) {
      return u;
    }
    function pn(u, f) {
      return u !== Ir && u < f ? u : f;
    }
    function kl(u) {
      for (var f = [], M = 0; M < nd; M++)
        f.push(u);
      return f;
    }
    function wo(u, f, M) {
      u.pendingLanes |= f, f !== ka && (u.suspendedLanes = an, u.pingedLanes = an);
      var A = u.eventTimes, z = Oc(f);
      A[z] = M;
    }
    function Nm(u, f) {
      u.suspendedLanes |= f, u.pingedLanes &= ~f;
      for (var M = u.expirationTimes, A = f; A > 0; ) {
        var z = _s(A), j = 1 << z;
        M[z] = Bi, A &= ~j;
      }
    }
    function wh(u, f, M) {
      u.pingedLanes |= u.suspendedLanes & f;
    }
    function Ou(u, f) {
      var M = u.pendingLanes & ~f;
      u.pendingLanes = f, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= f, u.mutableReadLanes &= f, u.entangledLanes &= f;
      for (var A = u.entanglements, z = u.eventTimes, j = u.expirationTimes, ne = M; ne > 0; ) {
        var se = _s(ne), Se = 1 << se;
        A[se] = an, z[se] = Bi, j[se] = Bi, ne &= ~Se;
      }
    }
    function bs(u, f) {
      for (var M = u.entangledLanes |= f, A = u.entanglements, z = M; z; ) {
        var j = _s(z), ne = 1 << j;
        ne & f | A[j] & f && (A[j] |= f), z &= ~ne;
      }
    }
    function gl(u, f) {
      var M = lc(f), A;
      switch (M) {
        case nl:
          A = Bo;
          break;
        case Du:
          A = ac;
          break;
        case sc:
        case ds:
        case Qs:
        case zm:
        case Jh:
        case Vd:
        case bh:
        case xf:
        case Lu:
        case rd:
        case uu:
        case Sf:
        case Rc:
        case Gd:
        case id:
        case Ac:
        case Dc:
        case Lc:
        case Os:
        case Pu:
        case _o:
          A = Cc;
          break;
        case ka:
          A = Zs;
          break;
        default:
          A = Ir;
          break;
      }
      return (A & (u.suspendedLanes | f)) !== Ir ? Ir : A;
    }
    function ga(u, f, M) {
      if (!!ns)
        for (var A = u.pendingUpdatersLaneMap; M > 0; ) {
          var z = Oc(M), j = 1 << z, ne = A[z];
          ne.add(f), M &= ~j;
        }
    }
    function fu(u, f) {
      if (!!ns)
        for (var M = u.pendingUpdatersLaneMap, A = u.memoizedUpdaters; f > 0; ) {
          var z = Oc(f), j = 1 << z, ne = M[z];
          ne.size > 0 && (ne.forEach(function(se) {
            var Se = se.alternate;
            (Se === null || !A.has(Se)) && A.add(se);
          }), ne.clear()), f &= ~j;
        }
    }
    var Us = Hr, sd = nl, Il = Du, Vo = ka, jd = Ir;
    function rl() {
      return jd;
    }
    function zs(u) {
      jd = u;
    }
    function fa(u, f) {
      var M = jd;
      try {
        return jd = u, f();
      } finally {
        jd = M;
      }
    }
    function Uu(u, f) {
      return u !== 0 && u < f ? u : f;
    }
    function Hp(u, f) {
      return u === 0 || u > f ? u : f;
    }
    function du(u, f) {
      return u !== 0 && u < f;
    }
    function Bl(u) {
      var f = lc(u);
      return du(Us, f) ? du(sd, f) ? Fl(f) ? Il : Vo : sd : Us;
    }
    var $h = i.unstable_scheduleCallback, bf = i.unstable_cancelCallback, Ks = i.unstable_shouldYield, Yd = i.unstable_requestPaint, da = i.unstable_now, Hi = i.unstable_ImmediatePriority, wn = i.unstable_UserBlockingPriority, Qi = i.unstable_NormalPriority, ya = i.unstable_IdlePriority, ep = i.unstable_yieldValue, Go = i.unstable_setDisableYieldValue, Wo = null, ts = null, An = null, xa = !1, ns = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function wf(u) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (f.isDisabled)
        return !0;
      if (!f.supportsFiber)
        return m("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        I && (u = _({}, u, {
          getLaneLabelMap: od,
          injectProfilingHooks: Hl
        })), Wo = f.inject(u), ts = f;
      } catch (M) {
        m("React instrumentation encountered an error: %s.", M);
      }
      return !!f.checkDCE;
    }
    function Sa(u, f) {
      if (ts && typeof ts.onScheduleFiberRoot == "function")
        try {
          ts.onScheduleFiberRoot(Wo, u, f);
        } catch (M) {
          xa || (xa = !0, m("React instrumentation encountered an error: %s", M));
        }
    }
    function Kr(u, f) {
      if (ts && typeof ts.onCommitFiberRoot == "function")
        try {
          var M = (u.current.flags & Vn) === Vn;
          if (X) {
            var A;
            switch (f) {
              case Us:
                A = Hi;
                break;
              case sd:
                A = wn;
                break;
              case Il:
                A = Qi;
                break;
              case Vo:
                A = ya;
                break;
              default:
                A = Qi;
                break;
            }
            ts.onCommitFiberRoot(Wo, u, A, M);
          }
        } catch (z) {
          xa || (xa = !0, m("React instrumentation encountered an error: %s", z));
        }
    }
    function Ra(u) {
      if (ts && typeof ts.onPostCommitFiberRoot == "function")
        try {
          ts.onPostCommitFiberRoot(Wo, u);
        } catch (f) {
          xa || (xa = !0, m("React instrumentation encountered an error: %s", f));
        }
    }
    function Ba(u) {
      if (ts && typeof ts.onCommitFiberUnmount == "function")
        try {
          ts.onCommitFiberUnmount(Wo, u);
        } catch (f) {
          xa || (xa = !0, m("React instrumentation encountered an error: %s", f));
        }
    }
    function ci(u) {
      if (typeof ep == "function" && (Go(u), d(u)), ts && typeof ts.setStrictMode == "function")
        try {
          ts.setStrictMode(Wo, u);
        } catch (f) {
          xa || (xa = !0, m("React instrumentation encountered an error: %s", f));
        }
    }
    function Hl(u) {
      An = u;
    }
    function od() {
      {
        for (var u = /* @__PURE__ */ new Map(), f = 1, M = 0; M < nd; M++) {
          var A = vr(f);
          u.set(f, A), f *= 2;
        }
        return u;
      }
    }
    function ws(u) {
      An !== null && typeof An.markCommitStarted == "function" && An.markCommitStarted(u);
    }
    function Xd() {
      An !== null && typeof An.markCommitStopped == "function" && An.markCommitStopped();
    }
    function zc(u) {
      An !== null && typeof An.markComponentRenderStarted == "function" && An.markComponentRenderStarted(u);
    }
    function cc() {
      An !== null && typeof An.markComponentRenderStopped == "function" && An.markComponentRenderStopped();
    }
    function qd(u) {
      An !== null && typeof An.markComponentPassiveEffectMountStarted == "function" && An.markComponentPassiveEffectMountStarted(u);
    }
    function ld() {
      An !== null && typeof An.markComponentPassiveEffectMountStopped == "function" && An.markComponentPassiveEffectMountStopped();
    }
    function il(u) {
      An !== null && typeof An.markComponentPassiveEffectUnmountStarted == "function" && An.markComponentPassiveEffectUnmountStarted(u);
    }
    function Fm() {
      An !== null && typeof An.markComponentPassiveEffectUnmountStopped == "function" && An.markComponentPassiveEffectUnmountStopped();
    }
    function Ef(u) {
      An !== null && typeof An.markComponentLayoutEffectMountStarted == "function" && An.markComponentLayoutEffectMountStarted(u);
    }
    function Qd() {
      An !== null && typeof An.markComponentLayoutEffectMountStopped == "function" && An.markComponentLayoutEffectMountStopped();
    }
    function Mf(u) {
      An !== null && typeof An.markComponentLayoutEffectUnmountStarted == "function" && An.markComponentLayoutEffectUnmountStarted(u);
    }
    function Vl() {
      An !== null && typeof An.markComponentLayoutEffectUnmountStopped == "function" && An.markComponentLayoutEffectUnmountStopped();
    }
    function Gl(u, f, M) {
      An !== null && typeof An.markComponentErrored == "function" && An.markComponentErrored(u, f, M);
    }
    function ud(u, f, M) {
      An !== null && typeof An.markComponentSuspended == "function" && An.markComponentSuspended(u, f, M);
    }
    function Wl(u) {
      An !== null && typeof An.markLayoutEffectsStarted == "function" && An.markLayoutEffectsStarted(u);
    }
    function Eh() {
      An !== null && typeof An.markLayoutEffectsStopped == "function" && An.markLayoutEffectsStopped();
    }
    function fc(u) {
      An !== null && typeof An.markPassiveEffectsStarted == "function" && An.markPassiveEffectsStarted(u);
    }
    function hr() {
      An !== null && typeof An.markPassiveEffectsStopped == "function" && An.markPassiveEffectsStopped();
    }
    function Yr(u) {
      An !== null && typeof An.markRenderStarted == "function" && An.markRenderStarted(u);
    }
    function fr() {
      An !== null && typeof An.markRenderYielded == "function" && An.markRenderYielded();
    }
    function fi() {
      An !== null && typeof An.markRenderStopped == "function" && An.markRenderStopped();
    }
    function Ns(u) {
      An !== null && typeof An.markRenderScheduled == "function" && An.markRenderScheduled(u);
    }
    function jl(u, f) {
      An !== null && typeof An.markForceUpdateScheduled == "function" && An.markForceUpdateScheduled(u, f);
    }
    function Nc(u, f) {
      An !== null && typeof An.markStateUpdateScheduled == "function" && An.markStateUpdateScheduled(u, f);
    }
    function Sr(u, f) {
      return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
    }
    var Eo = typeof Object.is == "function" ? Object.is : Sr, Ai = null, Ht = !1, vi = !1;
    function lr(u) {
      Ai === null ? Ai = [u] : Ai.push(u);
    }
    function Fc(u) {
      Ht = !0, lr(u);
    }
    function Ha() {
      Ht && jo();
    }
    function jo() {
      if (!vi && Ai !== null) {
        vi = !0;
        var u = 0, f = rl();
        try {
          var M = !0, A = Ai;
          for (zs(Us); u < A.length; u++) {
            var z = A[u];
            do
              z = z(M);
            while (z !== null);
          }
          Ai = null, Ht = !1;
        } catch (j) {
          throw Ai !== null && (Ai = Ai.slice(u + 1)), $h(Hi, jo), j;
        } finally {
          zs(f), vi = !1;
        }
      }
      return null;
    }
    function Di(u) {
      var f = u.current.memoizedState;
      return f.isDehydrated;
    }
    var Tf = o.ReactCurrentBatchConfig, Cf = null;
    function Rf() {
      return Tf.transition;
    }
    function ia(u, f) {
      if (Eo(u, f))
        return !0;
      if (typeof u != "object" || u === null || typeof f != "object" || f === null)
        return !1;
      var M = Object.keys(u), A = Object.keys(f);
      if (M.length !== A.length)
        return !1;
      for (var z = 0; z < M.length; z++) {
        var j = M[z];
        if (!rc.call(f, j) || !Eo(u[j], f[j]))
          return !1;
      }
      return !0;
    }
    function Fs(u) {
      switch (u._debugOwner && u._debugOwner.type, u._debugSource, u.tag) {
        case ce:
          return Ss(u.type);
        case Xe:
          return Ss("Lazy");
        case ue:
          return Ss("Suspense");
        case Ue:
          return Ss("SuspenseList");
        case $:
        case ee:
        case we:
          return Na(u.type);
        case he:
          return Na(u.type.render);
        case W:
          return nc(u.type);
        default:
          return "";
      }
    }
    function Af(u) {
      try {
        var f = "", M = u;
        do
          f += Fs(M), M = M.return;
        while (M);
        return f;
      } catch (A) {
        return `
Error generating stack: ` + A.message + `
` + A.stack;
      }
    }
    var Zd = o.ReactDebugCurrentFrame, $s = null, Yl = !1;
    function tp() {
      {
        if ($s === null)
          return null;
        var u = $s._debugOwner;
        if (u !== null && typeof u < "u")
          return Tt(u);
      }
      return null;
    }
    function kc() {
      return $s === null ? "" : Af($s);
    }
    function Es() {
      Zd.getCurrentStack = null, $s = null, Yl = !1;
    }
    function wi(u) {
      Zd.getCurrentStack = kc, $s = u, Yl = !1;
    }
    function eo(u) {
      Yl = u;
    }
    var Xl = {
      recordUnsafeLifecycleWarnings: function(u, f) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(u, f) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Ic = function(u) {
        for (var f = null, M = u; M !== null; )
          M.mode & Fa && (f = M), M = M.return;
        return f;
      }, hu = function(u) {
        var f = [];
        return u.forEach(function(M) {
          f.push(M);
        }), f.sort().join(", ");
      }, Df = [], pu = [], zu = [], Mo = [], Bc = [], cd = [], Yo = /* @__PURE__ */ new Set();
      Xl.recordUnsafeLifecycleWarnings = function(u, f) {
        Yo.has(u.type) || (typeof f.componentWillMount == "function" && f.componentWillMount.__suppressDeprecationWarning !== !0 && Df.push(u), u.mode & Fa && typeof f.UNSAFE_componentWillMount == "function" && pu.push(u), typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && zu.push(u), u.mode & Fa && typeof f.UNSAFE_componentWillReceiveProps == "function" && Mo.push(u), typeof f.componentWillUpdate == "function" && f.componentWillUpdate.__suppressDeprecationWarning !== !0 && Bc.push(u), u.mode & Fa && typeof f.UNSAFE_componentWillUpdate == "function" && cd.push(u));
      }, Xl.flushPendingUnsafeLifecycleWarnings = function() {
        var u = /* @__PURE__ */ new Set();
        Df.length > 0 && (Df.forEach(function(It) {
          u.add(Tt(It) || "Component"), Yo.add(It.type);
        }), Df = []);
        var f = /* @__PURE__ */ new Set();
        pu.length > 0 && (pu.forEach(function(It) {
          f.add(Tt(It) || "Component"), Yo.add(It.type);
        }), pu = []);
        var M = /* @__PURE__ */ new Set();
        zu.length > 0 && (zu.forEach(function(It) {
          M.add(Tt(It) || "Component"), Yo.add(It.type);
        }), zu = []);
        var A = /* @__PURE__ */ new Set();
        Mo.length > 0 && (Mo.forEach(function(It) {
          A.add(Tt(It) || "Component"), Yo.add(It.type);
        }), Mo = []);
        var z = /* @__PURE__ */ new Set();
        Bc.length > 0 && (Bc.forEach(function(It) {
          z.add(Tt(It) || "Component"), Yo.add(It.type);
        }), Bc = []);
        var j = /* @__PURE__ */ new Set();
        if (cd.length > 0 && (cd.forEach(function(It) {
          j.add(Tt(It) || "Component"), Yo.add(It.type);
        }), cd = []), f.size > 0) {
          var ne = hu(f);
          m(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, ne);
        }
        if (A.size > 0) {
          var se = hu(A);
          m(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, se);
        }
        if (j.size > 0) {
          var Se = hu(j);
          m(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, Se);
        }
        if (u.size > 0) {
          var Pe = hu(u);
          h(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Pe);
        }
        if (M.size > 0) {
          var Ge = hu(M);
          h(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ge);
        }
        if (z.size > 0) {
          var yt = hu(z);
          h(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, yt);
        }
      };
      var fd = /* @__PURE__ */ new Map(), mu = /* @__PURE__ */ new Set();
      Xl.recordLegacyContextWarning = function(u, f) {
        var M = Ic(u);
        if (M === null) {
          m("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!mu.has(u.type)) {
          var A = fd.get(M);
          (u.type.contextTypes != null || u.type.childContextTypes != null || f !== null && typeof f.getChildContext == "function") && (A === void 0 && (A = [], fd.set(M, A)), A.push(u));
        }
      }, Xl.flushLegacyContextWarning = function() {
        fd.forEach(function(u, f) {
          if (u.length !== 0) {
            var M = u[0], A = /* @__PURE__ */ new Set();
            u.forEach(function(j) {
              A.add(Tt(j) || "Component"), mu.add(j.type);
            });
            var z = hu(A);
            try {
              wi(M), m(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, z);
            } finally {
              Es();
            }
          }
        });
      }, Xl.discardPendingWarnings = function() {
        Df = [], pu = [], zu = [], Mo = [], Bc = [], cd = [], fd = /* @__PURE__ */ new Map();
      };
    }
    function dd(u) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, M = f && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return M;
      }
    }
    function Ms(u) {
      try {
        return ks(u), !1;
      } catch {
        return !0;
      }
    }
    function ks(u) {
      return "" + u;
    }
    function vu(u) {
      if (Ms(u))
        return m("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", dd(u)), ks(u);
    }
    function fg(u, f) {
      if (Ms(u))
        return m("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", f, dd(u)), ks(u);
    }
    function ii(u, f) {
      if (u && u.defaultProps) {
        var M = _({}, f), A = u.defaultProps;
        for (var z in A)
          M[z] === void 0 && (M[z] = A[z]);
        return M;
      }
      return f;
    }
    var Nu = Mn(null), Lf;
    Lf = {};
    var dc = null, Pf = null, Vp = null, y = !1;
    function x() {
      dc = null, Pf = null, Vp = null, y = !1;
    }
    function L() {
      y = !0;
    }
    function H() {
      y = !1;
    }
    function q(u, f, M) {
      go ? (or(Nu, f._currentValue, u), f._currentValue = M, f._currentRenderer !== void 0 && f._currentRenderer !== null && f._currentRenderer !== Lf && m("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), f._currentRenderer = Lf) : (or(Nu, f._currentValue2, u), f._currentValue2 = M, f._currentRenderer2 !== void 0 && f._currentRenderer2 !== null && f._currentRenderer2 !== Lf && m("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), f._currentRenderer2 = Lf);
    }
    function te(u, f) {
      var M = Nu.current;
      Kn(Nu, f), go ? u._currentValue = M : u._currentValue2 = M;
    }
    function Ae(u, f, M) {
      for (var A = u; A !== null; ) {
        var z = A.alternate;
        if (uc(A.childLanes, f) ? z !== null && !uc(z.childLanes, f) && (z.childLanes = zr(z.childLanes, f)) : (A.childLanes = zr(A.childLanes, f), z !== null && (z.childLanes = zr(z.childLanes, f))), A === M)
          break;
        A = A.return;
      }
      A !== M && m("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ke(u, f, M) {
      kt(u, f, M);
    }
    function kt(u, f, M) {
      var A = u.child;
      for (A !== null && (A.return = u); A !== null; ) {
        var z = void 0, j = A.dependencies;
        if (j !== null) {
          z = A.child;
          for (var ne = j.firstContext; ne !== null; ) {
            if (ne.context === f) {
              if (A.tag === W) {
                var se = cu(M), Se = Er(Bi, se);
                Se.tag = ms;
                var Pe = A.updateQueue;
                if (Pe !== null) {
                  var Ge = Pe.shared, yt = Ge.pending;
                  yt === null ? Se.next = Se : (Se.next = yt.next, yt.next = Se), Ge.pending = Se;
                }
              }
              A.lanes = zr(A.lanes, M);
              var It = A.alternate;
              It !== null && (It.lanes = zr(It.lanes, M)), Ae(A.return, M, u), j.lanes = zr(j.lanes, M);
              break;
            }
            ne = ne.next;
          }
        } else if (A.tag === Be)
          z = A.type === u.type ? null : A.child;
        else if (A.tag === st) {
          var jt = A.return;
          if (jt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          jt.lanes = zr(jt.lanes, M);
          var dn = jt.alternate;
          dn !== null && (dn.lanes = zr(dn.lanes, M)), Ae(jt, M, u), z = A.sibling;
        } else
          z = A.child;
        if (z !== null)
          z.return = A;
        else
          for (z = A; z !== null; ) {
            if (z === u) {
              z = null;
              break;
            }
            var Sn = z.sibling;
            if (Sn !== null) {
              Sn.return = z.return, z = Sn;
              break;
            }
            z = z.return;
          }
        A = z;
      }
    }
    function cn(u, f) {
      dc = u, Pf = null, Vp = null;
      var M = u.dependencies;
      if (M !== null) {
        var A = M.firstContext;
        A !== null && (Vr(M.lanes, f) && sx(), M.firstContext = null);
      }
    }
    function bn(u) {
      y && m("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var f = go ? u._currentValue : u._currentValue2;
      if (Vp !== u) {
        var M = {
          context: u,
          memoizedValue: f,
          next: null
        };
        if (Pf === null) {
          if (dc === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Pf = M, dc.dependencies = {
            lanes: an,
            firstContext: M
          };
        } else
          Pf = Pf.next = M;
      }
      return f;
    }
    var wr = null;
    function ur(u) {
      wr === null ? wr = [u] : wr.push(u);
    }
    function _a() {
      if (wr !== null) {
        for (var u = 0; u < wr.length; u++) {
          var f = wr[u], M = f.interleaved;
          if (M !== null) {
            f.interleaved = null;
            var A = M.next, z = f.pending;
            if (z !== null) {
              var j = z.next;
              z.next = A, M.next = j;
            }
            f.pending = M;
          }
        }
        wr = null;
      }
    }
    var Tn = 0, Li = 1, ms = 2, dt = 3, Qe = !1, At, qt;
    At = !1, qt = null;
    function Wn(u) {
      var f = {
        baseState: u.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: an
        },
        effects: null
      };
      u.updateQueue = f;
    }
    function Xr(u, f) {
      var M = f.updateQueue, A = u.updateQueue;
      if (M === A) {
        var z = {
          baseState: A.baseState,
          firstBaseUpdate: A.firstBaseUpdate,
          lastBaseUpdate: A.lastBaseUpdate,
          shared: A.shared,
          effects: A.effects
        };
        f.updateQueue = z;
      }
    }
    function Er(u, f) {
      var M = {
        eventTime: u,
        lane: f,
        tag: Tn,
        payload: null,
        callback: null,
        next: null
      };
      return M;
    }
    function Ar(u, f, M) {
      var A = u.updateQueue;
      if (A !== null) {
        var z = A.shared;
        if (N_(u)) {
          var j = z.interleaved;
          j === null ? (f.next = f, ur(z)) : (f.next = j.next, j.next = f), z.interleaved = f;
        } else {
          var ne = z.pending;
          ne === null ? f.next = f : (f.next = ne.next, ne.next = f), z.pending = f;
        }
        qt === z && !At && (m("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), At = !0);
      }
    }
    function Va(u, f, M) {
      var A = f.updateQueue;
      if (A !== null) {
        var z = A.shared;
        if (vl(M)) {
          var j = z.lanes;
          j = ps(j, u.pendingLanes);
          var ne = zr(j, M);
          z.lanes = ne, bs(u, ne);
        }
      }
    }
    function $r(u, f) {
      var M = u.updateQueue, A = u.alternate;
      if (A !== null) {
        var z = A.updateQueue;
        if (M === z) {
          var j = null, ne = null, se = M.firstBaseUpdate;
          if (se !== null) {
            var Se = se;
            do {
              var Pe = {
                eventTime: Se.eventTime,
                lane: Se.lane,
                tag: Se.tag,
                payload: Se.payload,
                callback: Se.callback,
                next: null
              };
              ne === null ? j = ne = Pe : (ne.next = Pe, ne = Pe), Se = Se.next;
            } while (Se !== null);
            ne === null ? j = ne = f : (ne.next = f, ne = f);
          } else
            j = ne = f;
          M = {
            baseState: z.baseState,
            firstBaseUpdate: j,
            lastBaseUpdate: ne,
            shared: z.shared,
            effects: z.effects
          }, u.updateQueue = M;
          return;
        }
      }
      var Ge = M.lastBaseUpdate;
      Ge === null ? M.firstBaseUpdate = f : Ge.next = f, M.lastBaseUpdate = f;
    }
    function hc(u, f, M, A, z, j) {
      switch (M.tag) {
        case Li: {
          var ne = M.payload;
          if (typeof ne == "function") {
            L();
            var se = ne.call(j, A, z);
            {
              if (u.mode & Fa) {
                ci(!0);
                try {
                  ne.call(j, A, z);
                } finally {
                  ci(!1);
                }
              }
              H();
            }
            return se;
          }
          return ne;
        }
        case dt:
          u.flags = u.flags & ~qe | Vn;
        case Tn: {
          var Se = M.payload, Pe;
          if (typeof Se == "function") {
            L(), Pe = Se.call(j, A, z);
            {
              if (u.mode & Fa) {
                ci(!0);
                try {
                  Se.call(j, A, z);
                } finally {
                  ci(!1);
                }
              }
              H();
            }
          } else
            Pe = Se;
          return Pe == null ? A : _({}, A, Pe);
        }
        case ms:
          return Qe = !0, A;
      }
      return A;
    }
    function hd(u, f, M, A) {
      var z = u.updateQueue;
      Qe = !1, qt = z.shared;
      var j = z.firstBaseUpdate, ne = z.lastBaseUpdate, se = z.shared.pending;
      if (se !== null) {
        z.shared.pending = null;
        var Se = se, Pe = Se.next;
        Se.next = null, ne === null ? j = Pe : ne.next = Pe, ne = Se;
        var Ge = u.alternate;
        if (Ge !== null) {
          var yt = Ge.updateQueue, It = yt.lastBaseUpdate;
          It !== ne && (It === null ? yt.firstBaseUpdate = Pe : It.next = Pe, yt.lastBaseUpdate = Se);
        }
      }
      if (j !== null) {
        var jt = z.baseState, dn = an, Sn = null, Tr = null, yi = null, Pr = j;
        do {
          var so = Pr.lane, oo = Pr.eventTime;
          if (uc(A, so)) {
            if (yi !== null) {
              var Zt = {
                eventTime: oo,
                lane: Ir,
                tag: Pr.tag,
                payload: Pr.payload,
                callback: Pr.callback,
                next: null
              };
              yi = yi.next = Zt;
            }
            jt = hc(u, z, Pr, jt, f, M);
            var wt = Pr.callback;
            if (wt !== null && Pr.lane !== Ir) {
              u.flags |= ir;
              var En = z.effects;
              En === null ? z.effects = [Pr] : En.push(Pr);
            }
          } else {
            var Et = {
              eventTime: oo,
              lane: so,
              tag: Pr.tag,
              payload: Pr.payload,
              callback: Pr.callback,
              next: null
            };
            yi === null ? (Tr = yi = Et, Sn = jt) : yi = yi.next = Et, dn = zr(dn, so);
          }
          if (Pr = Pr.next, Pr === null) {
            if (se = z.shared.pending, se === null)
              break;
            var yr = se, Un = yr.next;
            yr.next = null, Pr = Un, z.lastBaseUpdate = yr, z.shared.pending = null;
          }
        } while (!0);
        yi === null && (Sn = jt), z.baseState = Sn, z.firstBaseUpdate = Tr, z.lastBaseUpdate = yi;
        var ai = z.shared.interleaved;
        if (ai !== null) {
          var ba = ai;
          do
            dn = zr(dn, ba.lane), ba = ba.next;
          while (ba !== ai);
        } else
          j === null && (z.shared.lanes = an);
        gx(dn), u.lanes = dn, u.memoizedState = jt;
      }
      qt = null;
    }
    function np(u, f) {
      if (typeof u != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + u));
      u.call(f);
    }
    function gr() {
      Qe = !1;
    }
    function Gp() {
      return Qe;
    }
    function km(u, f, M) {
      var A = f.effects;
      if (f.effects = null, A !== null)
        for (var z = 0; z < A.length; z++) {
          var j = A[z], ne = j.callback;
          ne !== null && (j.callback = null, np(ne, M));
        }
    }
    var Of = {}, dg = new r.Component().refs, Xo, qo, rs, Wp, Mh, pc, to, rp, yl, xy;
    {
      Xo = /* @__PURE__ */ new Set(), qo = /* @__PURE__ */ new Set(), rs = /* @__PURE__ */ new Set(), Wp = /* @__PURE__ */ new Set(), rp = /* @__PURE__ */ new Set(), Mh = /* @__PURE__ */ new Set(), yl = /* @__PURE__ */ new Set(), xy = /* @__PURE__ */ new Set();
      var hg = /* @__PURE__ */ new Set();
      to = function(u, f) {
        if (!(u === null || typeof u == "function")) {
          var M = f + "_" + u;
          hg.has(M) || (hg.add(M), m("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, u));
        }
      }, pc = function(u, f) {
        if (f === void 0) {
          var M = at(u) || "Component";
          Mh.has(M) || (Mh.add(M), m("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", M));
        }
      }, Object.defineProperty(Of, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(Of);
    }
    function Fu(u, f, M, A) {
      var z = u.memoizedState, j = M(A, z);
      {
        if (u.mode & Fa) {
          ci(!0);
          try {
            j = M(A, z);
          } finally {
            ci(!1);
          }
        }
        pc(f, j);
      }
      var ne = j == null ? z : _({}, z, j);
      if (u.memoizedState = ne, u.lanes === an) {
        var se = u.updateQueue;
        se.baseState = ne;
      }
    }
    var Vi = {
      isMounted: qa,
      enqueueSetState: function(u, f, M) {
        var A = T(u), z = yc(), j = Wv(A), ne = Er(z, j);
        ne.payload = f, M != null && (to(M, "setState"), ne.callback = M), Ar(A, ne);
        var se = Ml(A, j, z);
        se !== null && Va(se, A, j), Nc(A, j);
      },
      enqueueReplaceState: function(u, f, M) {
        var A = T(u), z = yc(), j = Wv(A), ne = Er(z, j);
        ne.tag = Li, ne.payload = f, M != null && (to(M, "replaceState"), ne.callback = M), Ar(A, ne);
        var se = Ml(A, j, z);
        se !== null && Va(se, A, j), Nc(A, j);
      },
      enqueueForceUpdate: function(u, f) {
        var M = T(u), A = yc(), z = Wv(M), j = Er(A, z);
        j.tag = ms, f != null && (to(f, "forceUpdate"), j.callback = f), Ar(M, j);
        var ne = Ml(M, z, A);
        ne !== null && Va(ne, M, z), jl(M, z);
      }
    };
    function _v(u, f, M, A, z, j, ne) {
      var se = u.stateNode;
      if (typeof se.shouldComponentUpdate == "function") {
        var Se = se.shouldComponentUpdate(A, j, ne);
        {
          if (u.mode & Fa) {
            ci(!0);
            try {
              Se = se.shouldComponentUpdate(A, j, ne);
            } finally {
              ci(!1);
            }
          }
          Se === void 0 && m("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", at(f) || "Component");
        }
        return Se;
      }
      return f.prototype && f.prototype.isPureReactComponent ? !ia(M, A) || !ia(z, j) : !0;
    }
    function Jn(u, f, M) {
      var A = u.stateNode;
      {
        var z = at(f) || "Component", j = A.render;
        j || (f.prototype && typeof f.prototype.render == "function" ? m("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", z) : m("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", z)), A.getInitialState && !A.getInitialState.isReactClassApproved && !A.state && m("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", z), A.getDefaultProps && !A.getDefaultProps.isReactClassApproved && m("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", z), A.propTypes && m("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", z), A.contextType && m("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", z), A.contextTypes && m("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", z), f.contextType && f.contextTypes && !yl.has(f) && (yl.add(f), m("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", z)), typeof A.componentShouldUpdate == "function" && m("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", z), f.prototype && f.prototype.isPureReactComponent && typeof A.shouldComponentUpdate < "u" && m("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", at(f) || "A pure component"), typeof A.componentDidUnmount == "function" && m("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", z), typeof A.componentDidReceiveProps == "function" && m("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", z), typeof A.componentWillRecieveProps == "function" && m("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", z), typeof A.UNSAFE_componentWillRecieveProps == "function" && m("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", z);
        var ne = A.props !== M;
        A.props !== void 0 && ne && m("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", z, z), A.defaultProps && m("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", z, z), typeof A.getSnapshotBeforeUpdate == "function" && typeof A.componentDidUpdate != "function" && !rs.has(f) && (rs.add(f), m("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", at(f))), typeof A.getDerivedStateFromProps == "function" && m("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", z), typeof A.getDerivedStateFromError == "function" && m("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", z), typeof f.getSnapshotBeforeUpdate == "function" && m("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", z);
        var se = A.state;
        se && (typeof se != "object" || Ti(se)) && m("%s.state: must be set to an object or null", z), typeof A.getChildContext == "function" && typeof f.childContextTypes != "object" && m("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", z);
      }
    }
    function Th(u, f) {
      f.updater = Vi, u.stateNode = f, C(f, u), f._reactInternalInstance = Of;
    }
    function Im(u, f, M) {
      var A = !1, z = $n, j = $n, ne = f.contextType;
      if ("contextType" in f) {
        var se = ne === null || ne !== void 0 && ne.$$typeof === ft && ne._context === void 0;
        if (!se && !xy.has(f)) {
          xy.add(f);
          var Se = "";
          ne === void 0 ? Se = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof ne != "object" ? Se = " However, it is set to a " + typeof ne + "." : ne.$$typeof === Qt ? Se = " Did you accidentally pass the Context.Provider instead?" : ne._context !== void 0 ? Se = " Did you accidentally pass the Context.Consumer instead?" : Se = " However, it is set to an object with keys {" + Object.keys(ne).join(", ") + "}.", m("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", at(f) || "Component", Se);
        }
      }
      if (typeof ne == "object" && ne !== null)
        j = bn(ne);
      else {
        z = fs(u, f, !0);
        var Pe = f.contextTypes;
        A = Pe != null, j = A ? Ul(u, z) : $n;
      }
      var Ge = new f(M, j);
      if (u.mode & Fa) {
        ci(!0);
        try {
          Ge = new f(M, j);
        } finally {
          ci(!1);
        }
      }
      var yt = u.memoizedState = Ge.state !== null && Ge.state !== void 0 ? Ge.state : null;
      Th(u, Ge);
      {
        if (typeof f.getDerivedStateFromProps == "function" && yt === null) {
          var It = at(f) || "Component";
          qo.has(It) || (qo.add(It), m("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", It, Ge.state === null ? "null" : "undefined", It));
        }
        if (typeof f.getDerivedStateFromProps == "function" || typeof Ge.getSnapshotBeforeUpdate == "function") {
          var jt = null, dn = null, Sn = null;
          if (typeof Ge.componentWillMount == "function" && Ge.componentWillMount.__suppressDeprecationWarning !== !0 ? jt = "componentWillMount" : typeof Ge.UNSAFE_componentWillMount == "function" && (jt = "UNSAFE_componentWillMount"), typeof Ge.componentWillReceiveProps == "function" && Ge.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? dn = "componentWillReceiveProps" : typeof Ge.UNSAFE_componentWillReceiveProps == "function" && (dn = "UNSAFE_componentWillReceiveProps"), typeof Ge.componentWillUpdate == "function" && Ge.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Sn = "componentWillUpdate" : typeof Ge.UNSAFE_componentWillUpdate == "function" && (Sn = "UNSAFE_componentWillUpdate"), jt !== null || dn !== null || Sn !== null) {
            var Tr = at(f) || "Component", yi = typeof f.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Wp.has(Tr) || (Wp.add(Tr), m(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Tr, yi, jt !== null ? `
  ` + jt : "", dn !== null ? `
  ` + dn : "", Sn !== null ? `
  ` + Sn : ""));
          }
        }
      }
      return A && Hd(u, z, j), Ge;
    }
    function z0(u, f) {
      var M = f.state;
      typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), M !== f.state && (m("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Tt(u) || "Component"), Vi.enqueueReplaceState(f, f.state, null));
    }
    function jp(u, f, M, A) {
      var z = f.state;
      if (typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(M, A), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(M, A), f.state !== z) {
        {
          var j = Tt(u) || "Component";
          Xo.has(j) || (Xo.add(j), m("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", j));
        }
        Vi.enqueueReplaceState(f, f.state, null);
      }
    }
    function ip(u, f, M, A) {
      Jn(u, f, M);
      var z = u.stateNode;
      z.props = M, z.state = u.memoizedState, z.refs = dg, Wn(u);
      var j = f.contextType;
      if (typeof j == "object" && j !== null)
        z.context = bn(j);
      else {
        var ne = fs(u, f, !0);
        z.context = Ul(u, ne);
      }
      {
        if (z.state === M) {
          var se = at(f) || "Component";
          rp.has(se) || (rp.add(se), m("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", se));
        }
        u.mode & Fa && Xl.recordLegacyContextWarning(u, z), Xl.recordUnsafeLifecycleWarnings(u, z);
      }
      z.state = u.memoizedState;
      var Se = f.getDerivedStateFromProps;
      if (typeof Se == "function" && (Fu(u, f, Se, M), z.state = u.memoizedState), typeof f.getDerivedStateFromProps != "function" && typeof z.getSnapshotBeforeUpdate != "function" && (typeof z.UNSAFE_componentWillMount == "function" || typeof z.componentWillMount == "function") && (z0(u, z), hd(u, M, z, A), z.state = u.memoizedState), typeof z.componentDidMount == "function") {
        var Pe = fn;
        Pe |= mn, (u.mode & So) !== Mr && (Pe |= Zn), u.flags |= Pe;
      }
    }
    function Bm(u, f, M, A) {
      var z = u.stateNode, j = u.memoizedProps;
      z.props = j;
      var ne = z.context, se = f.contextType, Se = $n;
      if (typeof se == "object" && se !== null)
        Se = bn(se);
      else {
        var Pe = fs(u, f, !0);
        Se = Ul(u, Pe);
      }
      var Ge = f.getDerivedStateFromProps, yt = typeof Ge == "function" || typeof z.getSnapshotBeforeUpdate == "function";
      !yt && (typeof z.UNSAFE_componentWillReceiveProps == "function" || typeof z.componentWillReceiveProps == "function") && (j !== M || ne !== Se) && jp(u, z, M, Se), gr();
      var It = u.memoizedState, jt = z.state = It;
      if (hd(u, M, z, A), jt = u.memoizedState, j === M && It === jt && !$a() && !Gp()) {
        if (typeof z.componentDidMount == "function") {
          var dn = fn;
          dn |= mn, (u.mode & So) !== Mr && (dn |= Zn), u.flags |= dn;
        }
        return !1;
      }
      typeof Ge == "function" && (Fu(u, f, Ge, M), jt = u.memoizedState);
      var Sn = Gp() || _v(u, f, j, M, It, jt, Se);
      if (Sn) {
        if (!yt && (typeof z.UNSAFE_componentWillMount == "function" || typeof z.componentWillMount == "function") && (typeof z.componentWillMount == "function" && z.componentWillMount(), typeof z.UNSAFE_componentWillMount == "function" && z.UNSAFE_componentWillMount()), typeof z.componentDidMount == "function") {
          var Tr = fn;
          Tr |= mn, (u.mode & So) !== Mr && (Tr |= Zn), u.flags |= Tr;
        }
      } else {
        if (typeof z.componentDidMount == "function") {
          var yi = fn;
          yi |= mn, (u.mode & So) !== Mr && (yi |= Zn), u.flags |= yi;
        }
        u.memoizedProps = M, u.memoizedState = jt;
      }
      return z.props = M, z.state = jt, z.context = Se, Sn;
    }
    function Sy(u, f, M, A, z) {
      var j = f.stateNode;
      Xr(u, f);
      var ne = f.memoizedProps, se = f.type === f.elementType ? ne : ii(f.type, ne);
      j.props = se;
      var Se = f.pendingProps, Pe = j.context, Ge = M.contextType, yt = $n;
      if (typeof Ge == "object" && Ge !== null)
        yt = bn(Ge);
      else {
        var It = fs(f, M, !0);
        yt = Ul(f, It);
      }
      var jt = M.getDerivedStateFromProps, dn = typeof jt == "function" || typeof j.getSnapshotBeforeUpdate == "function";
      !dn && (typeof j.UNSAFE_componentWillReceiveProps == "function" || typeof j.componentWillReceiveProps == "function") && (ne !== Se || Pe !== yt) && jp(f, j, A, yt), gr();
      var Sn = f.memoizedState, Tr = j.state = Sn;
      if (hd(f, A, j, z), Tr = f.memoizedState, ne === Se && Sn === Tr && !$a() && !Gp() && !U)
        return typeof j.componentDidUpdate == "function" && (ne !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= fn), typeof j.getSnapshotBeforeUpdate == "function" && (ne !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= ki), !1;
      typeof jt == "function" && (Fu(f, M, jt, A), Tr = f.memoizedState);
      var yi = Gp() || _v(f, M, se, A, Sn, Tr, yt) || U;
      return yi ? (!dn && (typeof j.UNSAFE_componentWillUpdate == "function" || typeof j.componentWillUpdate == "function") && (typeof j.componentWillUpdate == "function" && j.componentWillUpdate(A, Tr, yt), typeof j.UNSAFE_componentWillUpdate == "function" && j.UNSAFE_componentWillUpdate(A, Tr, yt)), typeof j.componentDidUpdate == "function" && (f.flags |= fn), typeof j.getSnapshotBeforeUpdate == "function" && (f.flags |= ki)) : (typeof j.componentDidUpdate == "function" && (ne !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= fn), typeof j.getSnapshotBeforeUpdate == "function" && (ne !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= ki), f.memoizedProps = A, f.memoizedState = Tr), j.props = A, j.state = Tr, j.context = yt, yi;
    }
    var ap = [], Yp = 0, Xp = null, Jd = 0, no = [], Gi = 0, is = null, To = 1, xl = "";
    function pd(u) {
      return Ch(), (u.flags & yn) !== Ne;
    }
    function Uf(u) {
      return Ch(), Jd;
    }
    function _y() {
      var u = xl, f = To, M = f & ~by(f);
      return M.toString(32) + u;
    }
    function al(u, f) {
      Ch(), ap[Yp++] = Jd, ap[Yp++] = Xp, Xp = u, Jd = f;
    }
    function pg(u, f, M) {
      Ch(), no[Gi++] = To, no[Gi++] = xl, no[Gi++] = is, is = u;
      var A = To, z = xl, j = md(A) - 1, ne = A & ~(1 << j), se = M + 1, Se = md(f) + j;
      if (Se > 30) {
        var Pe = j - j % 5, Ge = (1 << Pe) - 1, yt = (ne & Ge).toString(32), It = ne >> Pe, jt = j - Pe, dn = md(f) + jt, Sn = se << jt, Tr = Sn | It, yi = yt + z;
        To = 1 << dn | Tr, xl = yi;
      } else {
        var Pr = se << j, so = Pr | ne, oo = z;
        To = 1 << Se | so, xl = oo;
      }
    }
    function ql(u) {
      Ch();
      var f = u.return;
      if (f !== null) {
        var M = 1, A = 0;
        al(u, M), pg(u, M, A);
      }
    }
    function md(u) {
      return 32 - td(u);
    }
    function by(u) {
      return 1 << md(u) - 1;
    }
    function bv(u) {
      for (; u === Xp; )
        Xp = ap[--Yp], ap[Yp] = null, Jd = ap[--Yp], ap[Yp] = null;
      for (; u === is; )
        is = no[--Gi], no[Gi] = null, xl = no[--Gi], no[Gi] = null, To = no[--Gi], no[Gi] = null;
    }
    function mg() {
      return Ch(), is !== null ? {
        id: To,
        overflow: xl
      } : null;
    }
    function wv(u, f) {
      Ch(), no[Gi++] = To, no[Gi++] = xl, no[Gi++] = is, To = f.id, xl = f.overflow, is = u;
    }
    function Ch() {
      ha() || m("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var aa = null, Nr = null, ea = !1, Ga = !1, vs = null;
    function Hc() {
      ea && m("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Hm() {
      Ga = !0;
    }
    function sl(u) {
      if (!cs)
        return !1;
      var f = u.stateNode.containerInfo;
      return Nr = Ku(f), aa = u, ea = !0, vs = null, Ga = !1, !0;
    }
    function Vm(u, f, M) {
      return cs ? (Nr = Qh(f), aa = u, ea = !0, vs = null, Ga = !1, M !== null && wv(u, M), !0) : !1;
    }
    function vd(u, f) {
      switch (u.tag) {
        case ie:
          Nd(u.stateNode.containerInfo, f);
          break;
        case ce:
          zp(u.type, u.memoizedProps, u.stateNode, f);
          break;
        case ue:
          var M = u.memoizedState;
          M.dehydrated !== null && Ru(M.dehydrated, f);
          break;
      }
    }
    function Gm(u, f) {
      vd(u, f);
      var M = vE();
      M.stateNode = f, M.return = u;
      var A = u.deletions;
      A === null ? (u.deletions = [M], u.flags |= Wr) : A.push(M);
    }
    function sp(u, f) {
      {
        if (Ga)
          return;
        switch (u.tag) {
          case ie: {
            var M = u.stateNode.containerInfo;
            switch (f.tag) {
              case ce:
                var A = f.type, z = f.pendingProps;
                hl(M, A, z);
                break;
              case Ee:
                var j = f.pendingProps;
                el(M, j);
                break;
              case ue:
                pf(M);
                break;
            }
            break;
          }
          case ce: {
            var ne = u.type, se = u.memoizedProps, Se = u.stateNode;
            switch (f.tag) {
              case ce:
                var Pe = f.type, Ge = f.pendingProps;
                Ol(ne, se, Se, Pe, Ge);
                break;
              case Ee:
                var yt = f.pendingProps;
                ec(ne, se, Se, yt);
                break;
              case ue:
                Oi(ne, se, Se);
                break;
            }
            break;
          }
          case ue: {
            var It = u.memoizedState, jt = It.dehydrated;
            if (jt !== null)
              switch (f.tag) {
                case ce:
                  var dn = f.type, Sn = f.pendingProps;
                  Jf(jt, dn, Sn);
                  break;
                case Ee:
                  var Tr = f.pendingProps;
                  lu(jt, Tr);
                  break;
                case ue:
                  mf(jt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function op(u, f) {
      f.flags = f.flags & ~ni | Pt, sp(u, f);
    }
    function gu(u, f) {
      switch (u.tag) {
        case ce: {
          var M = u.type, A = u.pendingProps, z = za(f, M, A);
          return z !== null ? (u.stateNode = z, aa = u, Nr = $o(z), !0) : !1;
        }
        case Ee: {
          var j = u.pendingProps, ne = Xs(f, j);
          return ne !== null ? (u.stateNode = ne, aa = u, Nr = null, !0) : !1;
        }
        case ue: {
          {
            var se = Jr(f);
            if (se !== null) {
              var Se = {
                dehydrated: se,
                treeContext: mg(),
                retryLane: Hn
              };
              u.memoizedState = Se;
              var Pe = Wa(se);
              return Pe.return = u, u.child = Pe, aa = u, Nr = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Wm(u) {
      return (u.mode & $i) !== Mr && (u.flags & Vn) === Ne;
    }
    function lp(u) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function gd(u) {
      if (!!ea) {
        var f = Nr;
        if (!f) {
          Wm(u) && (sp(aa, u), lp()), op(aa, u), ea = !1, aa = u;
          return;
        }
        var M = f;
        if (!gu(u, f)) {
          Wm(u) && (sp(aa, u), lp()), f = Zf(M);
          var A = aa;
          if (!f || !gu(u, f)) {
            op(aa, u), ea = !1, aa = u;
            return;
          }
          Gm(A, M);
        }
      }
    }
    function vg(u, f, M) {
      if (!cs)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var A = u.stateNode, z = !Ga, j = qi(A, u.type, u.memoizedProps, f, M, u, z);
      return u.updateQueue = j, j !== null;
    }
    function qp(u) {
      if (!cs)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = u.stateNode, M = u.memoizedProps, A = !Ga, z = Cu(f, M, u, A);
      if (z) {
        var j = aa;
        if (j !== null) {
          var ne = (j.mode & $i) !== Mr;
          switch (j.tag) {
            case ie: {
              var se = j.stateNode.containerInfo;
              vh(
                se,
                f,
                M,
                ne
              );
              break;
            }
            case ce: {
              var Se = j.type, Pe = j.memoizedProps, Ge = j.stateNode;
              $u(
                Se,
                Pe,
                Ge,
                f,
                M,
                ne
              );
              break;
            }
          }
        }
      }
      return z;
    }
    function Kd(u) {
      if (!cs)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = u.memoizedState, M = f !== null ? f.dehydrated : null;
      if (!M)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Up(M, u);
    }
    function up(u) {
      if (!cs)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = u.memoizedState, M = f !== null ? f.dehydrated : null;
      if (!M)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return cg(M);
    }
    function Qo(u) {
      for (var f = u.return; f !== null && f.tag !== ce && f.tag !== ie && f.tag !== ue; )
        f = f.return;
      aa = f;
    }
    function cp(u) {
      if (!cs || u !== aa)
        return !1;
      if (!ea)
        return Qo(u), ea = !0, !1;
      if (u.tag !== ie && (u.tag !== ce || Pm(u.type) && !Ju(u.type, u.memoizedProps))) {
        var f = Nr;
        if (f)
          if (Wm(u))
            Ev(u), lp();
          else
            for (; f; )
              Gm(u, f), f = Zf(f);
      }
      return Qo(u), u.tag === ue ? Nr = up(u) : Nr = aa ? Zf(u.stateNode) : null, !0;
    }
    function jm() {
      return ea && Nr !== null;
    }
    function Ev(u) {
      for (var f = Nr; f; )
        vd(u, f), f = Zf(f);
    }
    function Vc() {
      !cs || (aa = null, Nr = null, ea = !1, Ga = !1);
    }
    function fp() {
      vs !== null && (rv(vs), vs = null);
    }
    function ha() {
      return ea;
    }
    function ro(u) {
      vs === null ? vs = [u] : vs.push(u);
    }
    var Sl, Zo, dp, Mv, Qp, gg = function(u, f) {
    };
    Sl = !1, Zo = !1, dp = {}, Mv = {}, Qp = {}, gg = function(u, f) {
      if (!(u === null || typeof u != "object") && !(!u._store || u._store.validated || u.key != null)) {
        if (typeof u._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        u._store.validated = !0;
        var M = Tt(f) || "Component";
        Mv[M] || (Mv[M] = !0, m('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function yu(u, f, M) {
      var A = M.ref;
      if (A !== null && typeof A != "function" && typeof A != "object") {
        if ((u.mode & Fa || V) && !(M._owner && M._self && M._owner.stateNode !== M._self)) {
          var z = Tt(u) || "Component";
          dp[z] || (m('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A), dp[z] = !0);
        }
        if (M._owner) {
          var j = M._owner, ne;
          if (j) {
            var se = j;
            if (se.tag !== W)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            ne = se.stateNode;
          }
          if (!ne)
            throw new Error("Missing owner for string ref " + A + ". This error is likely caused by a bug in React. Please file an issue.");
          var Se = ne;
          fg(A, "ref");
          var Pe = "" + A;
          if (f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === Pe)
            return f.ref;
          var Ge = function(yt) {
            var It = Se.refs;
            It === dg && (It = Se.refs = {}), yt === null ? delete It[Pe] : It[Pe] = yt;
          };
          return Ge._stringRef = Pe, Ge;
        } else {
          if (typeof A != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!M._owner)
            throw new Error("Element ref was specified as a string (" + A + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return A;
    }
    function Tv(u, f) {
      var M = Object.prototype.toString.call(f);
      throw new Error("Objects are not valid as a React child (found: " + (M === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : M) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Rh(u) {
      {
        var f = Tt(u) || "Component";
        if (Qp[f])
          return;
        Qp[f] = !0, m("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Ah(u) {
      var f = u._payload, M = u._init;
      return M(f);
    }
    function yg(u) {
      function f(Et, Zt) {
        if (!!u) {
          var wt = Et.deletions;
          wt === null ? (Et.deletions = [Zt], Et.flags |= Wr) : wt.push(Zt);
        }
      }
      function M(Et, Zt) {
        if (!u)
          return null;
        for (var wt = Zt; wt !== null; )
          f(Et, wt), wt = wt.sibling;
        return null;
      }
      function A(Et, Zt) {
        for (var wt = /* @__PURE__ */ new Map(), En = Zt; En !== null; )
          En.key !== null ? wt.set(En.key, En) : wt.set(En.index, En), En = En.sibling;
        return wt;
      }
      function z(Et, Zt) {
        var wt = oa(Et, Zt);
        return wt.index = 0, wt.sibling = null, wt;
      }
      function j(Et, Zt, wt) {
        if (Et.index = wt, !u)
          return Et.flags |= yn, Zt;
        var En = Et.alternate;
        if (En !== null) {
          var yr = En.index;
          return yr < Zt ? (Et.flags |= Pt, Zt) : yr;
        } else
          return Et.flags |= Pt, Zt;
      }
      function ne(Et) {
        return u && Et.alternate === null && (Et.flags |= Pt), Et;
      }
      function se(Et, Zt, wt, En) {
        if (Zt === null || Zt.tag !== Ee) {
          var yr = lv(wt, Et.mode, En);
          return yr.return = Et, yr;
        } else {
          var Un = z(Zt, wt);
          return Un.return = Et, Un;
        }
      }
      function Se(Et, Zt, wt, En) {
        var yr = wt.type;
        if (yr === mt)
          return Ge(Et, Zt, wt.props.children, En, wt.key);
        if (Zt !== null && (Zt.elementType === yr || u0(Zt, wt) || typeof yr == "object" && yr !== null && yr.$$typeof === oe && Ah(yr) === Zt.type)) {
          var Un = z(Zt, wt.props);
          return Un.ref = yu(Et, Zt, wt), Un.return = Et, Un._debugSource = wt._source, Un._debugOwner = wt._owner, Un;
        }
        var ai = f0(wt, Et.mode, En);
        return ai.ref = yu(Et, Zt, wt), ai.return = Et, ai;
      }
      function Pe(Et, Zt, wt, En) {
        if (Zt === null || Zt.tag !== pe || Zt.stateNode.containerInfo !== wt.containerInfo || Zt.stateNode.implementation !== wt.implementation) {
          var yr = Dn(wt, Et.mode, En);
          return yr.return = Et, yr;
        } else {
          var Un = z(Zt, wt.children || []);
          return Un.return = Et, Un;
        }
      }
      function Ge(Et, Zt, wt, En, yr) {
        if (Zt === null || Zt.tag !== de) {
          var Un = Mp(wt, Et.mode, En, yr);
          return Un.return = Et, Un;
        } else {
          var ai = z(Zt, wt);
          return ai.return = Et, ai;
        }
      }
      function yt(Et, Zt, wt) {
        if (typeof Zt == "string" && Zt !== "" || typeof Zt == "number") {
          var En = lv("" + Zt, Et.mode, wt);
          return En.return = Et, En;
        }
        if (typeof Zt == "object" && Zt !== null) {
          switch (Zt.$$typeof) {
            case He: {
              var yr = f0(Zt, Et.mode, wt);
              return yr.ref = yu(Et, null, Zt), yr.return = Et, yr;
            }
            case et: {
              var Un = Dn(Zt, Et.mode, wt);
              return Un.return = Et, Un;
            }
            case oe: {
              var ai = Zt._payload, ba = Zt._init;
              return yt(Et, ba(ai), wt);
            }
          }
          if (Ti(Zt) || xe(Zt)) {
            var gs = Mp(Zt, Et.mode, wt, null);
            return gs.return = Et, gs;
          }
          Tv(Et, Zt);
        }
        return typeof Zt == "function" && Rh(Et), null;
      }
      function It(Et, Zt, wt, En) {
        var yr = Zt !== null ? Zt.key : null;
        if (typeof wt == "string" && wt !== "" || typeof wt == "number")
          return yr !== null ? null : se(Et, Zt, "" + wt, En);
        if (typeof wt == "object" && wt !== null) {
          switch (wt.$$typeof) {
            case He:
              return wt.key === yr ? Se(Et, Zt, wt, En) : null;
            case et:
              return wt.key === yr ? Pe(Et, Zt, wt, En) : null;
            case oe: {
              var Un = wt._payload, ai = wt._init;
              return It(Et, Zt, ai(Un), En);
            }
          }
          if (Ti(wt) || xe(wt))
            return yr !== null ? null : Ge(Et, Zt, wt, En, null);
          Tv(Et, wt);
        }
        return typeof wt == "function" && Rh(Et), null;
      }
      function jt(Et, Zt, wt, En, yr) {
        if (typeof En == "string" && En !== "" || typeof En == "number") {
          var Un = Et.get(wt) || null;
          return se(Zt, Un, "" + En, yr);
        }
        if (typeof En == "object" && En !== null) {
          switch (En.$$typeof) {
            case He: {
              var ai = Et.get(En.key === null ? wt : En.key) || null;
              return Se(Zt, ai, En, yr);
            }
            case et: {
              var ba = Et.get(En.key === null ? wt : En.key) || null;
              return Pe(Zt, ba, En, yr);
            }
            case oe: {
              var gs = En._payload, Nn = En._init;
              return jt(Et, Zt, wt, Nn(gs), yr);
            }
          }
          if (Ti(En) || xe(En)) {
            var as = Et.get(wt) || null;
            return Ge(Zt, as, En, yr, null);
          }
          Tv(Zt, En);
        }
        return typeof En == "function" && Rh(Zt), null;
      }
      function dn(Et, Zt, wt) {
        {
          if (typeof Et != "object" || Et === null)
            return Zt;
          switch (Et.$$typeof) {
            case He:
            case et:
              gg(Et, wt);
              var En = Et.key;
              if (typeof En != "string")
                break;
              if (Zt === null) {
                Zt = /* @__PURE__ */ new Set(), Zt.add(En);
                break;
              }
              if (!Zt.has(En)) {
                Zt.add(En);
                break;
              }
              m("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", En);
              break;
            case oe: {
              var yr = Et._payload, Un = Et._init;
              dn(Un(yr), Zt, wt);
              break;
            }
          }
        }
        return Zt;
      }
      function Sn(Et, Zt, wt, En) {
        for (var yr = null, Un = 0; Un < wt.length; Un++) {
          var ai = wt[Un];
          yr = dn(ai, yr, Et);
        }
        for (var ba = null, gs = null, Nn = Zt, as = 0, wa = 0, Ei = null; Nn !== null && wa < wt.length; wa++) {
          Nn.index > wa ? (Ei = Nn, Nn = null) : Ei = Nn.sibling;
          var Ao = It(Et, Nn, wt[wa], En);
          if (Ao === null) {
            Nn === null && (Nn = Ei);
            break;
          }
          u && Nn && Ao.alternate === null && f(Et, Nn), as = j(Ao, as, wa), gs === null ? ba = Ao : gs.sibling = Ao, gs = Ao, Nn = Ei;
        }
        if (wa === wt.length) {
          if (M(Et, Nn), ha()) {
            var lo = wa;
            al(Et, lo);
          }
          return ba;
        }
        if (Nn === null) {
          for (; wa < wt.length; wa++) {
            var nh = yt(Et, wt[wa], En);
            nh !== null && (as = j(nh, as, wa), gs === null ? ba = nh : gs.sibling = nh, gs = nh);
          }
          if (ha()) {
            var Su = wa;
            al(Et, Su);
          }
          return ba;
        }
        for (var rh = A(Et, Nn); wa < wt.length; wa++) {
          var Nh = jt(rh, Et, wa, wt[wa], En);
          Nh !== null && (u && Nh.alternate !== null && rh.delete(Nh.key === null ? wa : Nh.key), as = j(Nh, as, wa), gs === null ? ba = Nh : gs.sibling = Nh, gs = Nh);
        }
        if (u && rh.forEach(function(Lx) {
          return f(Et, Lx);
        }), ha()) {
          var cv = wa;
          al(Et, cv);
        }
        return ba;
      }
      function Tr(Et, Zt, wt, En) {
        var yr = xe(wt);
        if (typeof yr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && wt[Symbol.toStringTag] === "Generator" && (Zo || m("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Zo = !0), wt.entries === yr && (Sl || m("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Sl = !0);
          var Un = yr.call(wt);
          if (Un)
            for (var ai = null, ba = Un.next(); !ba.done; ba = Un.next()) {
              var gs = ba.value;
              ai = dn(gs, ai, Et);
            }
        }
        var Nn = yr.call(wt);
        if (Nn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var as = null, wa = null, Ei = Zt, Ao = 0, lo = 0, nh = null, Su = Nn.next(); Ei !== null && !Su.done; lo++, Su = Nn.next()) {
          Ei.index > lo ? (nh = Ei, Ei = null) : nh = Ei.sibling;
          var rh = It(Et, Ei, Su.value, En);
          if (rh === null) {
            Ei === null && (Ei = nh);
            break;
          }
          u && Ei && rh.alternate === null && f(Et, Ei), Ao = j(rh, Ao, lo), wa === null ? as = rh : wa.sibling = rh, wa = rh, Ei = nh;
        }
        if (Su.done) {
          if (M(Et, Ei), ha()) {
            var Nh = lo;
            al(Et, Nh);
          }
          return as;
        }
        if (Ei === null) {
          for (; !Su.done; lo++, Su = Nn.next()) {
            var cv = yt(Et, Su.value, En);
            cv !== null && (Ao = j(cv, Ao, lo), wa === null ? as = cv : wa.sibling = cv, wa = cv);
          }
          if (ha()) {
            var Lx = lo;
            al(Et, Lx);
          }
          return as;
        }
        for (var h0 = A(Et, Ei); !Su.done; lo++, Su = Nn.next()) {
          var ih = jt(h0, Et, lo, Su.value, En);
          ih !== null && (u && ih.alternate !== null && h0.delete(ih.key === null ? lo : ih.key), Ao = j(ih, Ao, lo), wa === null ? as = ih : wa.sibling = ih, wa = ih);
        }
        if (u && h0.forEach(function(sb) {
          return f(Et, sb);
        }), ha()) {
          var Yv = lo;
          al(Et, Yv);
        }
        return as;
      }
      function yi(Et, Zt, wt, En) {
        if (Zt !== null && Zt.tag === Ee) {
          M(Et, Zt.sibling);
          var yr = z(Zt, wt);
          return yr.return = Et, yr;
        }
        M(Et, Zt);
        var Un = lv(wt, Et.mode, En);
        return Un.return = Et, Un;
      }
      function Pr(Et, Zt, wt, En) {
        for (var yr = wt.key, Un = Zt; Un !== null; ) {
          if (Un.key === yr) {
            var ai = wt.type;
            if (ai === mt) {
              if (Un.tag === de) {
                M(Et, Un.sibling);
                var ba = z(Un, wt.props.children);
                return ba.return = Et, ba._debugSource = wt._source, ba._debugOwner = wt._owner, ba;
              }
            } else if (Un.elementType === ai || u0(Un, wt) || typeof ai == "object" && ai !== null && ai.$$typeof === oe && Ah(ai) === Un.type) {
              M(Et, Un.sibling);
              var gs = z(Un, wt.props);
              return gs.ref = yu(Et, Un, wt), gs.return = Et, gs._debugSource = wt._source, gs._debugOwner = wt._owner, gs;
            }
            M(Et, Un);
            break;
          } else
            f(Et, Un);
          Un = Un.sibling;
        }
        if (wt.type === mt) {
          var Nn = Mp(wt.props.children, Et.mode, En, wt.key);
          return Nn.return = Et, Nn;
        } else {
          var as = f0(wt, Et.mode, En);
          return as.ref = yu(Et, Zt, wt), as.return = Et, as;
        }
      }
      function so(Et, Zt, wt, En) {
        for (var yr = wt.key, Un = Zt; Un !== null; ) {
          if (Un.key === yr)
            if (Un.tag === pe && Un.stateNode.containerInfo === wt.containerInfo && Un.stateNode.implementation === wt.implementation) {
              M(Et, Un.sibling);
              var ai = z(Un, wt.children || []);
              return ai.return = Et, ai;
            } else {
              M(Et, Un);
              break;
            }
          else
            f(Et, Un);
          Un = Un.sibling;
        }
        var ba = Dn(wt, Et.mode, En);
        return ba.return = Et, ba;
      }
      function oo(Et, Zt, wt, En) {
        var yr = typeof wt == "object" && wt !== null && wt.type === mt && wt.key === null;
        if (yr && (wt = wt.props.children), typeof wt == "object" && wt !== null) {
          switch (wt.$$typeof) {
            case He:
              return ne(Pr(Et, Zt, wt, En));
            case et:
              return ne(so(Et, Zt, wt, En));
            case oe: {
              var Un = wt._payload, ai = wt._init;
              return oo(Et, Zt, ai(Un), En);
            }
          }
          if (Ti(wt))
            return Sn(Et, Zt, wt, En);
          if (xe(wt))
            return Tr(Et, Zt, wt, En);
          Tv(Et, wt);
        }
        return typeof wt == "string" && wt !== "" || typeof wt == "number" ? ne(yi(Et, Zt, "" + wt, En)) : (typeof wt == "function" && Rh(Et), M(Et, Zt));
      }
      return oo;
    }
    var zf = yg(!0), wy = yg(!1);
    function xg(u, f) {
      if (u !== null && f.child !== u.child)
        throw new Error("Resuming work not yet implemented.");
      if (f.child !== null) {
        var M = f.child, A = oa(M, M.pendingProps);
        for (f.child = A, A.return = f; M.sibling !== null; )
          M = M.sibling, A = A.sibling = oa(M, M.pendingProps), A.return = f;
        A.sibling = null;
      }
    }
    function Ey(u, f) {
      for (var M = u.child; M !== null; )
        Wu(M, f), M = M.sibling;
    }
    var hp = {}, pp = Mn(hp), Cv = Mn(hp), Rv = Mn(hp);
    function Ym(u) {
      if (u === hp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return u;
    }
    function Dh() {
      var u = Ym(Rv.current);
      return u;
    }
    function My(u, f) {
      or(Rv, f, u), or(Cv, u, u), or(pp, hp, u);
      var M = Uo(f);
      Kn(pp, u), or(pp, M, u);
    }
    function Gc(u) {
      Kn(pp, u), Kn(Cv, u), Kn(Rv, u);
    }
    function Zp() {
      var u = Ym(pp.current);
      return u;
    }
    function Is(u) {
      var f = Ym(Rv.current), M = Ym(pp.current), A = Pa(M, u.type, f);
      M !== A && (or(Cv, u, u), or(pp, A, u));
    }
    function Ty(u) {
      Cv.current === u && (Kn(pp, u), Kn(Cv, u));
    }
    var Sg = 0, N0 = 1, F0 = 1, Xm = 2, Wc = Mn(Sg);
    function Cy(u, f) {
      return (u & f) !== 0;
    }
    function _l(u) {
      return u & N0;
    }
    function Av(u, f) {
      return u & N0 | f;
    }
    function _g(u, f) {
      return u | f;
    }
    function ku(u, f) {
      or(Wc, f, u);
    }
    function Lh(u) {
      Kn(Wc, u);
    }
    function Jp(u, f) {
      var M = u.memoizedState;
      return M !== null ? M.dehydrated !== null : (u.memoizedProps, !0);
    }
    function mp(u) {
      for (var f = u; f !== null; ) {
        if (f.tag === ue) {
          var M = f.memoizedState;
          if (M !== null) {
            var A = M.dehydrated;
            if (A === null || xs(A) || va(A))
              return f;
          }
        } else if (f.tag === Ue && f.memoizedProps.revealOrder !== void 0) {
          var z = (f.flags & Vn) !== Ne;
          if (z)
            return f;
        } else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === u)
          return null;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === u)
            return null;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return null;
    }
    var mc = 0, Aa = 1, vp = 2, Ts = 4, bl = 8, Dv = [];
    function bg() {
      for (var u = 0; u < Dv.length; u++) {
        var f = Dv[u];
        go ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null;
      }
      Dv.length = 0;
    }
    function Lv(u, f) {
      var M = f._getVersion, A = M(f._source);
      u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [f, A] : u.mutableSourceEagerHydrationData.push(f, A);
    }
    var On = o.ReactCurrentDispatcher, Iu = o.ReactCurrentBatchConfig, Pv, Kp;
    Pv = /* @__PURE__ */ new Set();
    var Ph = an, sa = null, Cs = null, Co = null, $p = !1, qm = !1, gp = 0, wg = 0, u1 = 25, Wt = null, Nf = null, yd = -1, c = !1;
    function p() {
      {
        var u = Wt;
        Nf === null ? Nf = [u] : Nf.push(u);
      }
    }
    function E() {
      {
        var u = Wt;
        Nf !== null && (yd++, Nf[yd] !== u && G(u));
      }
    }
    function O(u) {
      u != null && !Ti(u) && m("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Wt, typeof u);
    }
    function G(u) {
      {
        var f = Tt(sa);
        if (!Pv.has(f) && (Pv.add(f), Nf !== null)) {
          for (var M = "", A = 30, z = 0; z <= yd; z++) {
            for (var j = Nf[z], ne = z === yd ? u : j, se = z + 1 + ". " + j; se.length < A; )
              se += " ";
            se += ne + `
`, M += se;
          }
          m(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, f, M);
        }
      }
    }
    function Q() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function le(u, f) {
      if (c)
        return !1;
      if (f === null)
        return m("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Wt), !1;
      u.length !== f.length && m(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Wt, "[" + f.join(", ") + "]", "[" + u.join(", ") + "]");
      for (var M = 0; M < f.length && M < u.length; M++)
        if (!Eo(u[M], f[M]))
          return !1;
      return !0;
    }
    function Le(u, f, M, A, z, j) {
      Ph = j, sa = f, Nf = u !== null ? u._debugHookTypes : null, yd = -1, c = u !== null && u.type !== f.type, f.memoizedState = null, f.updateQueue = null, f.lanes = an, u !== null && u.memoizedState !== null ? On.current = Ni : Nf !== null ? On.current = Oy : On.current = q0;
      var ne = M(A, z);
      if (qm) {
        var se = 0;
        do {
          if (qm = !1, gp = 0, se >= u1)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          se += 1, c = !1, Cs = null, Co = null, f.updateQueue = null, yd = -1, On.current = nm, ne = M(A, z);
        } while (qm);
      }
      On.current = X0, f._debugHookTypes = Nf;
      var Se = Cs !== null && Cs.next !== null;
      if (Ph = an, sa = null, Cs = null, Co = null, Wt = null, Nf = null, yd = -1, u !== null && (u.flags & $t) !== (f.flags & $t) && (u.mode & $i) !== Mr && m("Internal React error: Expected static flag was missing. Please notify the React team."), $p = !1, Se)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return ne;
    }
    function Ve() {
      var u = gp !== 0;
      return gp = 0, u;
    }
    function Ct(u, f, M) {
      f.updateQueue = u.updateQueue, (f.mode & So) !== Mr ? f.flags &= ~(nr | Zn | Wi | fn) : f.flags &= ~(Wi | fn), u.lanes = Js(u.lanes, M);
    }
    function un() {
      if (On.current = X0, $p) {
        for (var u = sa.memoizedState; u !== null; ) {
          var f = u.queue;
          f !== null && (f.pending = null), u = u.next;
        }
        $p = !1;
      }
      Ph = an, sa = null, Cs = null, Co = null, Nf = null, yd = -1, Wt = null, io = !1, qm = !1, gp = 0;
    }
    function ln() {
      var u = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Co === null ? sa.memoizedState = Co = u : Co = Co.next = u, Co;
    }
    function nn() {
      var u;
      if (Cs === null) {
        var f = sa.alternate;
        f !== null ? u = f.memoizedState : u = null;
      } else
        u = Cs.next;
      var M;
      if (Co === null ? M = sa.memoizedState : M = Co.next, M !== null)
        Co = M, M = Co.next, Cs = u;
      else {
        if (u === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Cs = u;
        var A = {
          memoizedState: Cs.memoizedState,
          baseState: Cs.baseState,
          baseQueue: Cs.baseQueue,
          queue: Cs.queue,
          next: null
        };
        Co === null ? sa.memoizedState = Co = A : Co = Co.next = A;
      }
      return Co;
    }
    function kn() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function qn(u, f) {
      return typeof f == "function" ? f(u) : f;
    }
    function rr(u, f, M) {
      var A = ln(), z;
      M !== void 0 ? z = M(f) : z = f, A.memoizedState = A.baseState = z;
      var j = {
        pending: null,
        interleaved: null,
        lanes: an,
        dispatch: null,
        lastRenderedReducer: u,
        lastRenderedState: z
      };
      A.queue = j;
      var ne = j.dispatch = Qm.bind(null, sa, j);
      return [A.memoizedState, ne];
    }
    function Bs(u, f, M) {
      var A = nn(), z = A.queue;
      if (z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      z.lastRenderedReducer = u;
      var j = Cs, ne = j.baseQueue, se = z.pending;
      if (se !== null) {
        if (ne !== null) {
          var Se = ne.next, Pe = se.next;
          ne.next = Pe, se.next = Se;
        }
        j.baseQueue !== ne && m("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), j.baseQueue = ne = se, z.pending = null;
      }
      if (ne !== null) {
        var Ge = ne.next, yt = j.baseState, It = null, jt = null, dn = null, Sn = Ge;
        do {
          var Tr = Sn.lane;
          if (uc(Ph, Tr)) {
            if (dn !== null) {
              var Pr = {
                lane: Ir,
                action: Sn.action,
                hasEagerState: Sn.hasEagerState,
                eagerState: Sn.eagerState,
                next: null
              };
              dn = dn.next = Pr;
            }
            if (Sn.hasEagerState)
              yt = Sn.eagerState;
            else {
              var so = Sn.action;
              yt = u(yt, so);
            }
          } else {
            var yi = {
              lane: Tr,
              action: Sn.action,
              hasEagerState: Sn.hasEagerState,
              eagerState: Sn.eagerState,
              next: null
            };
            dn === null ? (jt = dn = yi, It = yt) : dn = dn.next = yi, sa.lanes = zr(sa.lanes, Tr), gx(Tr);
          }
          Sn = Sn.next;
        } while (Sn !== null && Sn !== Ge);
        dn === null ? It = yt : dn.next = jt, Eo(yt, A.memoizedState) || sx(), A.memoizedState = yt, A.baseState = It, A.baseQueue = dn, z.lastRenderedState = yt;
      }
      var oo = z.interleaved;
      if (oo !== null) {
        var Et = oo;
        do {
          var Zt = Et.lane;
          sa.lanes = zr(sa.lanes, Zt), gx(Zt), Et = Et.next;
        } while (Et !== oo);
      } else
        ne === null && (z.lanes = an);
      var wt = z.dispatch;
      return [A.memoizedState, wt];
    }
    function ht(u, f, M) {
      var A = nn(), z = A.queue;
      if (z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      z.lastRenderedReducer = u;
      var j = z.dispatch, ne = z.pending, se = A.memoizedState;
      if (ne !== null) {
        z.pending = null;
        var Se = ne.next, Pe = Se;
        do {
          var Ge = Pe.action;
          se = u(se, Ge), Pe = Pe.next;
        } while (Pe !== Se);
        Eo(se, A.memoizedState) || sx(), A.memoizedState = se, A.baseQueue === null && (A.baseState = se), z.lastRenderedState = se;
      }
      return [se, j];
    }
    function Ze(u, f, M) {
    }
    function gt(u, f, M) {
    }
    function xn(u, f, M) {
      var A = sa, z = ln(), j, ne = ha();
      if (ne) {
        if (M === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        j = M(), Kp || j !== M() && (m("The result of getServerSnapshot should be cached to avoid an infinite loop"), Kp = !0);
      } else {
        if (j = f(), !Kp) {
          var se = f();
          Eo(j, se) || (m("The result of getSnapshot should be cached to avoid an infinite loop"), Kp = !0);
        }
        var Se = z_();
        if (Se === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ho(Se, Ph) || Qn(A, f, j);
      }
      z.memoizedState = j;
      var Pe = {
        value: j,
        getSnapshot: f
      };
      return z.queue = Pe, Ov(Lr.bind(null, A, Pe, u), [u]), A.flags |= Wi, Mg(Aa | bl, pr.bind(null, A, Pe, j, f), void 0, null), j;
    }
    function ar(u, f, M) {
      var A = sa, z = nn(), j = f();
      if (!Kp) {
        var ne = f();
        Eo(j, ne) || (m("The result of getSnapshot should be cached to avoid an infinite loop"), Kp = !0);
      }
      var se = z.memoizedState, Se = !Eo(se, j);
      Se && (z.memoizedState = j, sx());
      var Pe = z.queue;
      if (Bu(Lr.bind(null, A, Pe, u), [u]), Pe.getSnapshot !== f || Se || Co !== null && Co.memoizedState.tag & Aa) {
        A.flags |= Wi, Mg(Aa | bl, pr.bind(null, A, Pe, j, f), void 0, null);
        var Ge = z_();
        if (Ge === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Ho(Ge, Ph) || Qn(A, f, j);
      }
      return j;
    }
    function Qn(u, f, M) {
      u.flags |= Te;
      var A = {
        getSnapshot: f,
        value: M
      }, z = sa.updateQueue;
      if (z === null)
        z = kn(), sa.updateQueue = z, z.stores = [A];
      else {
        var j = z.stores;
        j === null ? z.stores = [A] : j.push(A);
      }
    }
    function pr(u, f, M, A) {
      f.value = M, f.getSnapshot = A, ol(f) && Zi(u);
    }
    function Lr(u, f, M) {
      var A = function() {
        ol(f) && Zi(u);
      };
      return M(A);
    }
    function ol(u) {
      var f = u.getSnapshot, M = u.value;
      try {
        var A = f();
        return !Eo(M, A);
      } catch {
        return !0;
      }
    }
    function Zi(u) {
      Ml(u, Hr, Bi);
    }
    function Ff(u) {
      var f = ln();
      typeof u == "function" && (u = u()), f.memoizedState = f.baseState = u;
      var M = {
        pending: null,
        interleaved: null,
        lanes: an,
        dispatch: null,
        lastRenderedReducer: qn,
        lastRenderedState: u
      };
      f.queue = M;
      var A = M.dispatch = yw.bind(null, sa, M);
      return [f.memoizedState, A];
    }
    function Eg(u) {
      return Bs(qn);
    }
    function k0(u) {
      return ht(qn);
    }
    function Mg(u, f, M, A) {
      var z = {
        tag: u,
        create: f,
        destroy: M,
        deps: A,
        next: null
      }, j = sa.updateQueue;
      if (j === null)
        j = kn(), sa.updateQueue = j, j.lastEffect = z.next = z;
      else {
        var ne = j.lastEffect;
        if (ne === null)
          j.lastEffect = z.next = z;
        else {
          var se = ne.next;
          ne.next = z, z.next = se, j.lastEffect = z;
        }
      }
      return z;
    }
    function I0(u) {
      var f = ln();
      {
        var M = {
          current: u
        };
        return f.memoizedState = M, M;
      }
    }
    function B0(u) {
      var f = nn();
      return f.memoizedState;
    }
    function Ry(u, f, M, A) {
      var z = ln(), j = A === void 0 ? null : A;
      sa.flags |= u, z.memoizedState = Mg(Aa | f, M, void 0, j);
    }
    function Ay(u, f, M, A) {
      var z = nn(), j = A === void 0 ? null : A, ne = void 0;
      if (Cs !== null) {
        var se = Cs.memoizedState;
        if (ne = se.destroy, j !== null) {
          var Se = se.deps;
          if (le(j, Se)) {
            z.memoizedState = Mg(f, M, ne, j);
            return;
          }
        }
      }
      sa.flags |= u, z.memoizedState = Mg(Aa | f, M, ne, j);
    }
    function Ov(u, f) {
      return (sa.mode & So) !== Mr ? Ry(nr | Wi | vn, bl, u, f) : Ry(Wi | vn, bl, u, f);
    }
    function Bu(u, f) {
      return Ay(Wi, bl, u, f);
    }
    function c1(u, f) {
      return Ry(fn, vp, u, f);
    }
    function H0(u, f) {
      return Ay(fn, vp, u, f);
    }
    function em(u, f) {
      var M = fn;
      return M |= mn, (sa.mode & So) !== Mr && (M |= Zn), Ry(M, Ts, u, f);
    }
    function ei(u, f) {
      return Ay(fn, Ts, u, f);
    }
    function KS(u, f) {
      if (typeof f == "function") {
        var M = f, A = u();
        return M(A), function() {
          M(null);
        };
      } else if (f != null) {
        var z = f;
        z.hasOwnProperty("current") || m("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(z).join(", ") + "}");
        var j = u();
        return z.current = j, function() {
          z.current = null;
        };
      }
    }
    function ll(u, f, M) {
      typeof f != "function" && m("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", f !== null ? typeof f : "null");
      var A = M != null ? M.concat([u]) : null, z = fn;
      return z |= mn, (sa.mode & So) !== Mr && (z |= Zn), Ry(z, Ts, KS.bind(null, f, u), A);
    }
    function Rs(u, f, M) {
      typeof f != "function" && m("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", f !== null ? typeof f : "null");
      var A = M != null ? M.concat([u]) : null;
      return Ay(fn, Ts, KS.bind(null, f, u), A);
    }
    function Dy(u, f) {
    }
    var xd = Dy;
    function f1(u, f) {
      var M = ln(), A = f === void 0 ? null : f;
      return M.memoizedState = [u, A], u;
    }
    function V0(u, f) {
      var M = nn(), A = f === void 0 ? null : f, z = M.memoizedState;
      if (z !== null && A !== null) {
        var j = z[1];
        if (le(A, j))
          return z[0];
      }
      return M.memoizedState = [u, A], u;
    }
    function G0(u, f) {
      var M = ln(), A = f === void 0 ? null : f, z = u();
      return M.memoizedState = [z, A], z;
    }
    function W0(u, f) {
      var M = nn(), A = f === void 0 ? null : f, z = M.memoizedState;
      if (z !== null && A !== null) {
        var j = z[1];
        if (le(A, j))
          return z[0];
      }
      var ne = u();
      return M.memoizedState = [ne, A], ne;
    }
    function Tg(u) {
      var f = Ff(u), M = f[0], A = f[1];
      return Ov(function() {
        var z = Iu.transition;
        Iu.transition = {};
        try {
          A(u);
        } finally {
          Iu.transition = z;
        }
      }, [u]), M;
    }
    function tm(u) {
      var f = Eg(), M = f[0], A = f[1];
      return Bu(function() {
        var z = Iu.transition;
        Iu.transition = {};
        try {
          A(u);
        } finally {
          Iu.transition = z;
        }
      }, [u]), M;
    }
    function j0(u) {
      var f = k0(), M = f[0], A = f[1];
      return Bu(function() {
        var z = Iu.transition;
        Iu.transition = {};
        try {
          A(u);
        } finally {
          Iu.transition = z;
        }
      }, [u]), M;
    }
    function yp(u, f, M) {
      var A = rl();
      zs(Uu(A, sd)), u(!0);
      var z = Iu.transition;
      Iu.transition = {};
      var j = Iu.transition;
      Iu.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        u(!1), f();
      } finally {
        if (zs(A), Iu.transition = z, z === null && j._updatedFibers) {
          var ne = j._updatedFibers.size;
          ne > 10 && h("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), j._updatedFibers.clear();
        }
      }
    }
    function Uv() {
      var u = Ff(!1), f = u[0], M = u[1], A = yp.bind(null, M), z = ln();
      return z.memoizedState = A, [f, A];
    }
    function Cg() {
      var u = Eg(), f = u[0], M = nn(), A = M.memoizedState;
      return [f, A];
    }
    function Hs() {
      var u = k0(), f = u[0], M = nn(), A = M.memoizedState;
      return [f, A];
    }
    var io = !1;
    function d1() {
      return io;
    }
    function Y0() {
      var u = ln(), f = z_(), M = f.identifierPrefix, A;
      if (ha()) {
        var z = _y();
        A = ":" + M + "R" + z;
        var j = gp++;
        j > 0 && (A += "H" + j.toString(32)), A += ":";
      } else {
        var ne = wg++;
        A = ":" + M + "r" + ne.toString(32) + ":";
      }
      return u.memoizedState = A, A;
    }
    function Ly() {
      var u = nn(), f = u.memoizedState;
      return f;
    }
    function Qm(u, f, M) {
      typeof arguments[3] == "function" && m("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var A = Wv(u), z = {
        lane: A,
        action: M,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if ($S(u))
        e_(f, z);
      else {
        zv(u, f, z);
        var j = yc(), ne = Ml(u, A, j);
        ne !== null && Zm(ne, f, A);
      }
      Py(u, A);
    }
    function yw(u, f, M) {
      typeof arguments[3] == "function" && m("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var A = Wv(u), z = {
        lane: A,
        action: M,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if ($S(u))
        e_(f, z);
      else {
        zv(u, f, z);
        var j = u.alternate;
        if (u.lanes === an && (j === null || j.lanes === an)) {
          var ne = f.lastRenderedReducer;
          if (ne !== null) {
            var se;
            se = On.current, On.current = jc;
            try {
              var Se = f.lastRenderedState, Pe = ne(Se, M);
              if (z.hasEagerState = !0, z.eagerState = Pe, Eo(Pe, Se))
                return;
            } catch {
            } finally {
              On.current = se;
            }
          }
        }
        var Ge = yc(), yt = Ml(u, A, Ge);
        yt !== null && Zm(yt, f, A);
      }
      Py(u, A);
    }
    function $S(u) {
      var f = u.alternate;
      return u === sa || f !== null && f === sa;
    }
    function e_(u, f) {
      qm = $p = !0;
      var M = u.pending;
      M === null ? f.next = f : (f.next = M.next, M.next = f), u.pending = f;
    }
    function zv(u, f, M, A) {
      if (N_(u)) {
        var z = f.interleaved;
        z === null ? (M.next = M, ur(f)) : (M.next = z.next, z.next = M), f.interleaved = M;
      } else {
        var j = f.pending;
        j === null ? M.next = M : (M.next = j.next, j.next = M), f.pending = M;
      }
    }
    function Zm(u, f, M) {
      if (vl(M)) {
        var A = f.lanes;
        A = ps(A, u.pendingLanes);
        var z = zr(A, M);
        f.lanes = z, bs(u, z);
      }
    }
    function Py(u, f, M) {
      Nc(u, f);
    }
    var X0 = {
      readContext: bn,
      useCallback: Q,
      useContext: Q,
      useEffect: Q,
      useImperativeHandle: Q,
      useInsertionEffect: Q,
      useLayoutEffect: Q,
      useMemo: Q,
      useReducer: Q,
      useRef: Q,
      useState: Q,
      useDebugValue: Q,
      useDeferredValue: Q,
      useTransition: Q,
      useMutableSource: Q,
      useSyncExternalStore: Q,
      useId: Q,
      unstable_isNewReconciler: P
    }, q0 = null, Oy = null, Ni = null, nm = null, Sd = null, jc = null, Uy = null;
    {
      var Q0 = function() {
        m("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Fr = function() {
        m("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      q0 = {
        readContext: function(u) {
          return bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", p(), O(f), f1(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", p(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", p(), O(f), Ov(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", p(), O(M), ll(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", p(), O(f), c1(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", p(), O(f), em(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", p(), O(f);
          var M = On.current;
          On.current = Sd;
          try {
            return G0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", p();
          var A = On.current;
          On.current = Sd;
          try {
            return rr(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", p(), I0(u);
        },
        useState: function(u) {
          Wt = "useState", p();
          var f = On.current;
          On.current = Sd;
          try {
            return Ff(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", p(), void 0;
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", p(), Tg(u);
        },
        useTransition: function() {
          return Wt = "useTransition", p(), Uv();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", p(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", p(), xn(u, f, M);
        },
        useId: function() {
          return Wt = "useId", p(), Y0();
        },
        unstable_isNewReconciler: P
      }, Oy = {
        readContext: function(u) {
          return bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", E(), f1(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", E(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", E(), Ov(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", E(), ll(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", E(), c1(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", E(), em(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", E();
          var M = On.current;
          On.current = Sd;
          try {
            return G0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", E();
          var A = On.current;
          On.current = Sd;
          try {
            return rr(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", E(), I0(u);
        },
        useState: function(u) {
          Wt = "useState", E();
          var f = On.current;
          On.current = Sd;
          try {
            return Ff(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", E(), void 0;
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", E(), Tg(u);
        },
        useTransition: function() {
          return Wt = "useTransition", E(), Uv();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", E(), xn(u, f, M);
        },
        useId: function() {
          return Wt = "useId", E(), Y0();
        },
        unstable_isNewReconciler: P
      }, Ni = {
        readContext: function(u) {
          return bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", E(), V0(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", E(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", E(), Bu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", E(), Rs(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", E(), ei(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", E();
          var M = On.current;
          On.current = jc;
          try {
            return W0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", E();
          var A = On.current;
          On.current = jc;
          try {
            return Bs(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", E(), B0();
        },
        useState: function(u) {
          Wt = "useState", E();
          var f = On.current;
          On.current = jc;
          try {
            return Eg(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", E(), xd();
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", E(), tm(u);
        },
        useTransition: function() {
          return Wt = "useTransition", E(), Cg();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", E(), ar(u, f);
        },
        useId: function() {
          return Wt = "useId", E(), Ly();
        },
        unstable_isNewReconciler: P
      }, nm = {
        readContext: function(u) {
          return bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", E(), V0(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", E(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", E(), Bu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", E(), Rs(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", E(), ei(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", E();
          var M = On.current;
          On.current = Uy;
          try {
            return W0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", E();
          var A = On.current;
          On.current = Uy;
          try {
            return ht(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", E(), B0();
        },
        useState: function(u) {
          Wt = "useState", E();
          var f = On.current;
          On.current = Uy;
          try {
            return k0(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", E(), xd();
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", E(), j0(u);
        },
        useTransition: function() {
          return Wt = "useTransition", E(), Hs();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", E(), ar(u, f);
        },
        useId: function() {
          return Wt = "useId", E(), Ly();
        },
        unstable_isNewReconciler: P
      }, Sd = {
        readContext: function(u) {
          return Q0(), bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", Fr(), p(), f1(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", Fr(), p(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", Fr(), p(), Ov(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", Fr(), p(), ll(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", Fr(), p(), c1(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", Fr(), p(), em(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", Fr(), p();
          var M = On.current;
          On.current = Sd;
          try {
            return G0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", Fr(), p();
          var A = On.current;
          On.current = Sd;
          try {
            return rr(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", Fr(), p(), I0(u);
        },
        useState: function(u) {
          Wt = "useState", Fr(), p();
          var f = On.current;
          On.current = Sd;
          try {
            return Ff(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", Fr(), p(), void 0;
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", Fr(), p(), Tg(u);
        },
        useTransition: function() {
          return Wt = "useTransition", Fr(), p(), Uv();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", Fr(), p(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", Fr(), p(), xn(u, f, M);
        },
        useId: function() {
          return Wt = "useId", Fr(), p(), Y0();
        },
        unstable_isNewReconciler: P
      }, jc = {
        readContext: function(u) {
          return Q0(), bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", Fr(), E(), V0(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", Fr(), E(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", Fr(), E(), Bu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", Fr(), E(), Rs(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", Fr(), E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", Fr(), E(), ei(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", Fr(), E();
          var M = On.current;
          On.current = jc;
          try {
            return W0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", Fr(), E();
          var A = On.current;
          On.current = jc;
          try {
            return Bs(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", Fr(), E(), B0();
        },
        useState: function(u) {
          Wt = "useState", Fr(), E();
          var f = On.current;
          On.current = jc;
          try {
            return Eg(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", Fr(), E(), xd();
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", Fr(), E(), tm(u);
        },
        useTransition: function() {
          return Wt = "useTransition", Fr(), E(), Cg();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", Fr(), E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", Fr(), E(), ar(u, f);
        },
        useId: function() {
          return Wt = "useId", Fr(), E(), Ly();
        },
        unstable_isNewReconciler: P
      }, Uy = {
        readContext: function(u) {
          return Q0(), bn(u);
        },
        useCallback: function(u, f) {
          return Wt = "useCallback", Fr(), E(), V0(u, f);
        },
        useContext: function(u) {
          return Wt = "useContext", Fr(), E(), bn(u);
        },
        useEffect: function(u, f) {
          return Wt = "useEffect", Fr(), E(), Bu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return Wt = "useImperativeHandle", Fr(), E(), Rs(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return Wt = "useInsertionEffect", Fr(), E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return Wt = "useLayoutEffect", Fr(), E(), ei(u, f);
        },
        useMemo: function(u, f) {
          Wt = "useMemo", Fr(), E();
          var M = On.current;
          On.current = jc;
          try {
            return W0(u, f);
          } finally {
            On.current = M;
          }
        },
        useReducer: function(u, f, M) {
          Wt = "useReducer", Fr(), E();
          var A = On.current;
          On.current = jc;
          try {
            return ht(u, f, M);
          } finally {
            On.current = A;
          }
        },
        useRef: function(u) {
          return Wt = "useRef", Fr(), E(), B0();
        },
        useState: function(u) {
          Wt = "useState", Fr(), E();
          var f = On.current;
          On.current = jc;
          try {
            return k0(u);
          } finally {
            On.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return Wt = "useDebugValue", Fr(), E(), xd();
        },
        useDeferredValue: function(u) {
          return Wt = "useDeferredValue", Fr(), E(), j0(u);
        },
        useTransition: function() {
          return Wt = "useTransition", Fr(), E(), Hs();
        },
        useMutableSource: function(u, f, M) {
          return Wt = "useMutableSource", Fr(), E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return Wt = "useSyncExternalStore", Fr(), E(), ar(u, f);
        },
        useId: function() {
          return Wt = "useId", Fr(), E(), Ly();
        },
        unstable_isNewReconciler: P
      };
    }
    var _d = i.unstable_now, xp = 0, qr = -1, Oh = -1, Yc = -1, zy = !1, Z0 = !1;
    function Da() {
      return zy;
    }
    function kf() {
      Z0 = !0;
    }
    function Rg() {
      zy = !1, Z0 = !1;
    }
    function Nv() {
      zy = Z0, Z0 = !1;
    }
    function rm() {
      return xp;
    }
    function h1() {
      xp = _d();
    }
    function im(u) {
      Oh = _d(), u.actualStartTime < 0 && (u.actualStartTime = _d());
    }
    function Jm(u) {
      Oh = -1;
    }
    function Fv(u, f) {
      if (Oh >= 0) {
        var M = _d() - Oh;
        u.actualDuration += M, f && (u.selfBaseDuration = M), Oh = -1;
      }
    }
    function If(u) {
      if (qr >= 0) {
        var f = _d() - qr;
        qr = -1;
        for (var M = u.return; M !== null; ) {
          switch (M.tag) {
            case ie:
              var A = M.stateNode;
              A.effectDuration += f;
              return;
            case fe:
              var z = M.stateNode;
              z.effectDuration += f;
              return;
          }
          M = M.return;
        }
      }
    }
    function Ag(u) {
      if (Yc >= 0) {
        var f = _d() - Yc;
        Yc = -1;
        for (var M = u.return; M !== null; ) {
          switch (M.tag) {
            case ie:
              var A = M.stateNode;
              A !== null && (A.passiveEffectDuration += f);
              return;
            case fe:
              var z = M.stateNode;
              z !== null && (z.passiveEffectDuration += f);
              return;
          }
          M = M.return;
        }
      }
    }
    function vc() {
      qr = _d();
    }
    function J0() {
      Yc = _d();
    }
    function Dg(u) {
      for (var f = u.child; f; )
        u.actualDuration += f.actualDuration, f = f.sibling;
    }
    function Ny(u, f) {
      return {
        value: u,
        source: f,
        stack: Af(f)
      };
    }
    function t_(u, f) {
      return !0;
    }
    function p1(u, f) {
      try {
        var M = t_(u, f);
        if (M === !1)
          return;
        var A = f.value, z = f.source, j = f.stack, ne = j !== null ? j : "";
        if (A != null && A._suppressLogging) {
          if (u.tag === W)
            return;
          console.error(A);
        }
        var se = z ? Tt(z) : null, Se = se ? "The above error occurred in the <" + se + "> component:" : "The above error occurred in one of your React components:", Pe;
        if (u.tag === ie)
          Pe = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Ge = Tt(u) || "Anonymous";
          Pe = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Ge + ".");
        }
        var yt = Se + `
` + ne + `

` + ("" + Pe);
        console.error(yt);
      } catch (It) {
        setTimeout(function() {
          throw It;
        });
      }
    }
    var m1 = typeof WeakMap == "function" ? WeakMap : Map;
    function Fy(u, f, M) {
      var A = Er(Bi, M);
      A.tag = dt, A.payload = {
        element: null
      };
      var z = f.value;
      return A.callback = function() {
        cE(z), p1(u, f);
      }, A;
    }
    function Km(u, f, M) {
      var A = Er(Bi, M);
      A.tag = dt;
      var z = u.type.getDerivedStateFromError;
      if (typeof z == "function") {
        var j = f.value;
        A.payload = function() {
          return z(j);
        }, A.callback = function() {
          zT(u), p1(u, f);
        };
      }
      var ne = u.stateNode;
      return ne !== null && typeof ne.componentDidCatch == "function" && (A.callback = function() {
        zT(u), p1(u, f), typeof z != "function" && lE(this);
        var Se = f.value, Pe = f.stack;
        this.componentDidCatch(Se, {
          componentStack: Pe !== null ? Pe : ""
        }), typeof z != "function" && (Vr(u.lanes, Hr) || m("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Tt(u) || "Unknown"));
      }), A;
    }
    function v1(u, f, M) {
      var A = u.pingCache, z;
      if (A === null ? (A = u.pingCache = new m1(), z = /* @__PURE__ */ new Set(), A.set(f, z)) : (z = A.get(f), z === void 0 && (z = /* @__PURE__ */ new Set(), A.set(f, z))), !z.has(M)) {
        z.add(M);
        var j = Y_.bind(null, u, f, M);
        ns && l0(u, M), f.then(j, j);
      }
    }
    function xw(u, f, M, A) {
      var z = u.updateQueue;
      if (z === null) {
        var j = /* @__PURE__ */ new Set();
        j.add(M), u.updateQueue = j;
      } else
        z.add(M);
    }
    function K0(u, f) {
      var M = u.tag;
      if ((u.mode & $i) === Mr && (M === $ || M === he || M === we)) {
        var A = u.alternate;
        A ? (u.updateQueue = A.updateQueue, u.memoizedState = A.memoizedState, u.lanes = A.lanes) : (u.updateQueue = null, u.memoizedState = null);
      }
    }
    function Ql(u) {
      var f = u;
      do {
        if (f.tag === ue && Jp(f))
          return f;
        f = f.return;
      } while (f !== null);
      return null;
    }
    function Xc(u, f, M, A, z) {
      if ((u.mode & $i) === Mr) {
        if (u === f)
          u.flags |= qe;
        else {
          if (u.flags |= Vn, M.flags |= on, M.flags &= ~(ct | Oe), Ci && D) {
            var j = u.alternate;
            if (j === null) {
              var ne = u.child, se = ne.child;
              if (se !== null) {
                var Se = se.memoizedProps.children, Pe = xo("hidden", Se);
                se.pendingProps = Pe, se.memoizedProps = Pe;
              }
            }
          }
          if (M.tag === W) {
            var Ge = M.alternate;
            if (Ge === null)
              M.tag = Je;
            else {
              var yt = Er(Bi, Hr);
              yt.tag = ms, Ar(M, yt);
            }
          }
          M.lanes = zr(M.lanes, Hr);
        }
        return u;
      }
      return u.flags |= qe, u.lanes = z, u;
    }
    function Sw(u, f, M, A, z) {
      if (M.flags |= Oe, ns && l0(u, z), A !== null && typeof A == "object" && typeof A.then == "function") {
        var j = A;
        K0(M);
        var ne = Ql(f);
        if (ne !== null) {
          ne.flags &= ~jr, Xc(ne, f, M, u, z), ne.mode & $i && v1(u, j, z), xw(ne, u, j);
          return;
        } else {
          if (!Ia(z)) {
            v1(u, j, z), X1();
            return;
          }
          var se = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          A = se;
        }
      } else if (ha() && M.mode & $i) {
        Hm();
        var Se = Ql(f);
        if (Se !== null) {
          (Se.flags & qe) === Ne && (Se.flags |= jr), Xc(Se, f, M, u, z), ro(A);
          return;
        }
      }
      MT(A), A = Ny(A, M);
      var Pe = f;
      do {
        switch (Pe.tag) {
          case ie: {
            var Ge = A;
            Pe.flags |= qe;
            var yt = cu(z);
            Pe.lanes = zr(Pe.lanes, yt);
            var It = Fy(Pe, Ge, yt);
            $r(Pe, It);
            return;
          }
          case W:
            var jt = A, dn = Pe.type, Sn = Pe.stateNode;
            if ((Pe.flags & Vn) === Ne && (typeof dn.getDerivedStateFromError == "function" || Sn !== null && typeof Sn.componentDidCatch == "function" && !j_(Sn))) {
              Pe.flags |= qe;
              var Tr = cu(z);
              Pe.lanes = zr(Pe.lanes, Tr);
              var yi = Km(Pe, jt, Tr);
              $r(Pe, yi);
              return;
            }
            break;
        }
        Pe = Pe.return;
      } while (Pe !== null);
    }
    function _w() {
      return null;
    }
    function Sp(u) {
      u.flags |= fn;
    }
    function g1(u) {
      u.flags |= ti, u.flags |= Rn;
    }
    function n_(u, f) {
      var M = u !== null && u.child === f.child;
      if (M)
        return !0;
      if ((f.flags & Wr) !== Ne)
        return !1;
      for (var A = f.child; A !== null; ) {
        if ((A.flags & Yi) !== Ne || (A.subtreeFlags & Yi) !== Ne)
          return !1;
        A = A.sibling;
      }
      return !0;
    }
    var ky, Iy, By, Lg;
    if (zo)
      ky = function(u, f, M, A) {
        for (var z = f.child; z !== null; ) {
          if (z.tag === ce || z.tag === Ee)
            Al(u, z.stateNode);
          else if (z.tag !== pe) {
            if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z === f)
            return;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === f)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      }, Iy = function(u, f) {
      }, By = function(u, f, M, A, z) {
        var j = u.memoizedProps;
        if (j !== A) {
          var ne = f.stateNode, se = Zp(), Se = Ls(ne, M, j, A, z, se);
          f.updateQueue = Se, Se && Sp(f);
        }
      }, Lg = function(u, f, M, A) {
        M !== A && Sp(f);
      };
    else if (Ci) {
      ky = function(u, f, M, A) {
        for (var z = f.child; z !== null; ) {
          if (z.tag === ce) {
            var j = z.stateNode;
            if (M && A) {
              var ne = z.memoizedProps, se = z.type;
              j = Tu(j, se, ne, z);
            }
            Al(u, j);
          } else if (z.tag === Ee) {
            var Se = z.stateNode;
            if (M && A) {
              var Pe = z.memoizedProps;
              Se = Pl(Se, Pe, z);
            }
            Al(u, Se);
          } else if (z.tag !== pe) {
            if (z.tag === rt && z.memoizedState !== null) {
              var Ge = z.child;
              Ge !== null && (Ge.return = z), ky(u, z, !0, !0);
            } else if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z = z, z === f)
            return;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === f)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      };
      var $0 = function(u, f, M, A) {
        for (var z = f.child; z !== null; ) {
          if (z.tag === ce) {
            var j = z.stateNode;
            if (M && A) {
              var ne = z.memoizedProps, se = z.type;
              j = Tu(j, se, ne, z);
            }
            ou(u, j);
          } else if (z.tag === Ee) {
            var Se = z.stateNode;
            if (M && A) {
              var Pe = z.memoizedProps;
              Se = Pl(Se, Pe, z);
            }
            ou(u, Se);
          } else if (z.tag !== pe) {
            if (z.tag === rt && z.memoizedState !== null) {
              var Ge = z.child;
              Ge !== null && (Ge.return = z), $0(u, z, !0, !0);
            } else if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z = z, z === f)
            return;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === f)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      };
      Iy = function(u, f) {
        var M = f.stateNode, A = n_(u, f);
        if (!A) {
          var z = M.containerInfo, j = ys(z);
          $0(j, f, !1, !1), M.pendingChildren = j, Sp(f), Ua(z, j);
        }
      }, By = function(u, f, M, A, z) {
        var j = u.stateNode, ne = u.memoizedProps, se = n_(u, f);
        if (se && ne === A) {
          f.stateNode = j;
          return;
        }
        var Se = f.stateNode, Pe = Zp(), Ge = null;
        if (ne !== A && (Ge = Ls(Se, M, ne, A, z, Pe)), se && Ge === null) {
          f.stateNode = j;
          return;
        }
        var yt = Oa(j, Ge, M, ne, A, f, se, Se);
        zd(yt, M, A, z, Pe) && Sp(f), f.stateNode = yt, se ? Sp(f) : ky(yt, f, !1, !1);
      }, Lg = function(u, f, M, A) {
        if (M !== A) {
          var z = Dh(), j = Zp();
          f.stateNode = au(A, z, j, f), Sp(f);
        } else
          f.stateNode = u.stateNode;
      };
    } else
      Iy = function(u, f) {
      }, By = function(u, f, M, A, z) {
      }, Lg = function(u, f, M, A) {
      };
    function kv(u, f) {
      if (!ha())
        switch (u.tailMode) {
          case "hidden": {
            for (var M = u.tail, A = null; M !== null; )
              M.alternate !== null && (A = M), M = M.sibling;
            A === null ? u.tail = null : A.sibling = null;
            break;
          }
          case "collapsed": {
            for (var z = u.tail, j = null; z !== null; )
              z.alternate !== null && (j = z), z = z.sibling;
            j === null ? !f && u.tail !== null ? u.tail.sibling = null : u.tail = null : j.sibling = null;
            break;
          }
        }
    }
    function wl(u) {
      var f = u.alternate !== null && u.alternate.child === u.child, M = an, A = Ne;
      if (f) {
        if ((u.mode & Br) !== Mr) {
          for (var Se = u.selfBaseDuration, Pe = u.child; Pe !== null; )
            M = zr(M, zr(Pe.lanes, Pe.childLanes)), A |= Pe.subtreeFlags & $t, A |= Pe.flags & $t, Se += Pe.treeBaseDuration, Pe = Pe.sibling;
          u.treeBaseDuration = Se;
        } else
          for (var Ge = u.child; Ge !== null; )
            M = zr(M, zr(Ge.lanes, Ge.childLanes)), A |= Ge.subtreeFlags & $t, A |= Ge.flags & $t, Ge.return = u, Ge = Ge.sibling;
        u.subtreeFlags |= A;
      } else {
        if ((u.mode & Br) !== Mr) {
          for (var z = u.actualDuration, j = u.selfBaseDuration, ne = u.child; ne !== null; )
            M = zr(M, zr(ne.lanes, ne.childLanes)), A |= ne.subtreeFlags, A |= ne.flags, z += ne.actualDuration, j += ne.treeBaseDuration, ne = ne.sibling;
          u.actualDuration = z, u.treeBaseDuration = j;
        } else
          for (var se = u.child; se !== null; )
            M = zr(M, zr(se.lanes, se.childLanes)), A |= se.subtreeFlags, A |= se.flags, se.return = u, se = se.sibling;
        u.subtreeFlags |= A;
      }
      return u.childLanes = M, f;
    }
    function y1(u, f, M) {
      var A = f.pendingProps;
      switch (bv(f), f.tag) {
        case ee:
        case Xe:
        case we:
        case $:
        case he:
        case de:
        case Fe:
        case fe:
        case Ce:
        case ye:
          return wl(f), null;
        case W: {
          var z = f.type;
          return pl(z) && xi(f), wl(f), null;
        }
        case ie: {
          var j = f.stateNode;
          if (Gc(f), Ec(f), bg(), j.pendingContext && (j.context = j.pendingContext, j.pendingContext = null), u === null || u.child === null) {
            var ne = cp(f);
            if (ne)
              Sp(f);
            else if (u !== null) {
              var se = u.memoizedState;
              (!se.isDehydrated || (f.flags & jr) !== Ne) && (f.flags |= ki, fp());
            }
          }
          return Iy(u, f), wl(f), null;
        }
        case ce: {
          Ty(f);
          var Se = Dh(), Pe = f.type;
          if (u !== null && f.stateNode != null)
            By(u, f, Pe, A, Se), u.ref !== f.ref && g1(f);
          else {
            if (!A) {
              if (f.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return wl(f), null;
            }
            var Ge = Zp(), yt = cp(f);
            if (yt)
              vg(f, Se, Ge) && Sp(f);
            else {
              var It = Wf(Pe, A, Se, Ge, f);
              ky(It, f, !1, !1), f.stateNode = It, zd(It, Pe, A, Se, Ge) && Sp(f);
            }
            f.ref !== null && g1(f);
          }
          return wl(f), null;
        }
        case Ee: {
          var jt = A;
          if (u && f.stateNode != null) {
            var dn = u.memoizedProps;
            Lg(u, f, dn, jt);
          } else {
            if (typeof jt != "string" && f.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Sn = Dh(), Tr = Zp(), yi = cp(f);
            yi ? qp(f) && Sp(f) : f.stateNode = au(jt, Sn, Tr, f);
          }
          return wl(f), null;
        }
        case ue: {
          Lh(f);
          var Pr = f.memoizedState;
          {
            if (jm() && (f.mode & $i) !== Mr && (f.flags & Vn) === Ne)
              return Ev(f), Vc(), f.flags |= jr | Oe | qe, f;
            if (Pr !== null && Pr.dehydrated !== null) {
              var so = cp(f);
              if (u === null) {
                if (!so)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (Kd(f), wl(f), (f.mode & Br) !== Mr) {
                  var oo = Pr !== null;
                  if (oo) {
                    var Et = f.child;
                    Et !== null && (f.treeBaseDuration -= Et.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (Vc(), (f.flags & Vn) === Ne && (f.memoizedState = null), f.flags |= fn, wl(f), (f.mode & Br) !== Mr) {
                  var Zt = Pr !== null;
                  if (Zt) {
                    var wt = f.child;
                    wt !== null && (f.treeBaseDuration -= wt.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            fp();
          }
          if ((f.flags & Vn) !== Ne)
            return f.lanes = M, (f.mode & Br) !== Mr && Dg(f), f;
          var En = Pr !== null, yr = !1;
          if (u === null)
            cp(f);
          else {
            var Un = u.memoizedState;
            yr = Un !== null;
          }
          if (En && !yr) {
            var ai = f.child;
            if (ai.flags |= Si, (f.mode & $i) !== Mr) {
              var ba = u === null && (f.memoizedProps.unstable_avoidThisFallback !== !0 || !k);
              ba || Cy(Wc.current, F0) ? rE() : X1();
            }
          }
          var gs = f.updateQueue;
          if (gs !== null && (f.flags |= fn), wl(f), (f.mode & Br) !== Mr && En) {
            var Nn = f.child;
            Nn !== null && (f.treeBaseDuration -= Nn.treeBaseDuration);
          }
          return null;
        }
        case pe:
          return Gc(f), Iy(u, f), u === null && xr(f.stateNode.containerInfo), wl(f), null;
        case Be:
          var as = f.type._context;
          return te(as, f), wl(f), null;
        case Je: {
          var wa = f.type;
          return pl(wa) && xi(f), wl(f), null;
        }
        case Ue: {
          Lh(f);
          var Ei = f.memoizedState;
          if (Ei === null)
            return wl(f), null;
          var Ao = (f.flags & Vn) !== Ne, lo = Ei.rendering;
          if (lo === null)
            if (Ao)
              kv(Ei, !1);
            else {
              var nh = iE() && (u === null || (u.flags & Vn) === Ne);
              if (!nh)
                for (var Su = f.child; Su !== null; ) {
                  var rh = mp(Su);
                  if (rh !== null) {
                    Ao = !0, f.flags |= Vn, kv(Ei, !1);
                    var Nh = rh.updateQueue;
                    return Nh !== null && (f.updateQueue = Nh, f.flags |= fn), f.subtreeFlags = Ne, Ey(f, M), ku(f, Av(Wc.current, Xm)), f.child;
                  }
                  Su = Su.sibling;
                }
              Ei.tail !== null && da() > Kw() && (f.flags |= Vn, Ao = !0, kv(Ei, !1), f.lanes = ad);
            }
          else {
            if (!Ao) {
              var cv = mp(lo);
              if (cv !== null) {
                f.flags |= Vn, Ao = !0;
                var Lx = cv.updateQueue;
                if (Lx !== null && (f.updateQueue = Lx, f.flags |= fn), kv(Ei, !0), Ei.tail === null && Ei.tailMode === "hidden" && !lo.alternate && !ha())
                  return wl(f), null;
              } else
                da() * 2 - Ei.renderingStartTime > Kw() && M !== Hn && (f.flags |= Vn, Ao = !0, kv(Ei, !1), f.lanes = ad);
            }
            if (Ei.isBackwards)
              lo.sibling = f.child, f.child = lo;
            else {
              var h0 = Ei.last;
              h0 !== null ? h0.sibling = lo : f.child = lo, Ei.last = lo;
            }
          }
          if (Ei.tail !== null) {
            var ih = Ei.tail;
            Ei.rendering = ih, Ei.tail = ih.sibling, Ei.renderingStartTime = da(), ih.sibling = null;
            var Yv = Wc.current;
            return Ao ? Yv = Av(Yv, Xm) : Yv = _l(Yv), ku(f, Yv), ih;
          }
          return wl(f), null;
        }
        case ot:
          break;
        case rt:
        case _t: {
          Y1(f);
          var sb = f.memoizedState, sS = sb !== null;
          if (u !== null) {
            var fv = u.memoizedState, AE = fv !== null;
            AE !== sS && !B && (f.flags |= Si);
          }
          return !sS || (f.mode & $i) === Mr ? wl(f) : Vr(eh, Hn) && (wl(f), zo && f.subtreeFlags & (Pt | fn) && (f.flags |= Si)), null;
        }
        case Rt:
          return null;
        case Ot:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + f.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var am = o.ReactCurrentOwner, qc = !1, x1, Pg, $m, S1, ex, Iv, _1, Hy;
    x1 = {}, Pg = {}, $m = {}, S1 = {}, ex = {}, Iv = !1, _1 = {}, Hy = {};
    function Zl(u, f, M, A) {
      u === null ? f.child = wy(f, null, M, A) : f.child = zf(f, u.child, M, A);
    }
    function Vy(u, f, M, A) {
      f.child = zf(f, u.child, null, A), f.child = zf(f, null, M, A);
    }
    function Gy(u, f, M, A, z) {
      if (f.type !== f.elementType) {
        var j = M.propTypes;
        j && ko(
          j,
          A,
          "prop",
          at(M)
        );
      }
      var ne = M.render, se = f.ref, Se, Pe;
      cn(f, z), zc(f);
      {
        if (am.current = f, eo(!0), Se = Le(u, f, ne, A, se, z), Pe = Ve(), f.mode & Fa) {
          ci(!0);
          try {
            Se = Le(u, f, ne, A, se, z), Pe = Ve();
          } finally {
            ci(!1);
          }
        }
        eo(!1);
      }
      return cc(), u !== null && !qc ? (Ct(u, f, z), sm(u, f, z)) : (ha() && Pe && ql(f), f.flags |= Gt, Zl(u, f, Se, z), f.child);
    }
    function Og(u, f, M, A, z) {
      if (u === null) {
        var j = M.type;
        if (Mx(j) && M.compare === null && M.defaultProps === void 0) {
          var ne = j;
          return ne = Zg(j), f.tag = we, f.type = ne, C1(f, j), Ug(u, f, ne, A, z);
        }
        {
          var se = j.propTypes;
          se && ko(
            se,
            A,
            "prop",
            at(j)
          );
        }
        var Se = Tx(M.type, null, A, f, f.mode, z);
        return Se.ref = f.ref, Se.return = f, f.child = Se, Se;
      }
      {
        var Pe = M.type, Ge = Pe.propTypes;
        Ge && ko(
          Ge,
          A,
          "prop",
          at(Pe)
        );
      }
      var yt = u.child, It = qy(u, z);
      if (!It) {
        var jt = yt.memoizedProps, dn = M.compare;
        if (dn = dn !== null ? dn : ia, dn(jt, A) && u.ref === f.ref)
          return sm(u, f, z);
      }
      f.flags |= Gt;
      var Sn = oa(yt, A);
      return Sn.ref = f.ref, Sn.return = f, f.child = Sn, Sn;
    }
    function Ug(u, f, M, A, z) {
      if (f.type !== f.elementType) {
        var j = f.elementType;
        if (j.$$typeof === oe) {
          var ne = j, se = ne._payload, Se = ne._init;
          try {
            j = Se(se);
          } catch {
            j = null;
          }
          var Pe = j && j.propTypes;
          Pe && ko(
            Pe,
            A,
            "prop",
            at(j)
          );
        }
      }
      if (u !== null) {
        var Ge = u.memoizedProps;
        if (ia(Ge, A) && u.ref === f.ref && f.type === u.type)
          if (qc = !1, qy(u, z))
            (u.flags & on) !== Ne && (qc = !0);
          else
            return f.lanes = u.lanes, sm(u, f, z);
      }
      return a_(u, f, M, A, z);
    }
    function r_(u, f, M) {
      var A = f.pendingProps, z = A.children, j = u !== null ? u.memoizedState : null;
      if (A.mode === "hidden" || B)
        if ((f.mode & $i) === Mr) {
          var ne = {
            baseLanes: an,
            cachePool: null
          };
          f.memoizedState = ne, vx(f, M);
        } else if (Vr(M, Hn)) {
          var yt = {
            baseLanes: an,
            cachePool: null
          };
          f.memoizedState = yt;
          var It = j !== null ? j.baseLanes : M;
          vx(f, It);
        } else {
          var se = null, Se;
          if (j !== null) {
            var Pe = j.baseLanes;
            Se = zr(Pe, M);
          } else
            Se = M;
          f.lanes = f.childLanes = Hn;
          var Ge = {
            baseLanes: Se,
            cachePool: se
          };
          return f.memoizedState = Ge, f.updateQueue = null, vx(f, Se), null;
        }
      else {
        var jt;
        j !== null ? (jt = zr(j.baseLanes, M), f.memoizedState = null) : jt = M, vx(f, jt);
      }
      return Zl(u, f, z, M), f.child;
    }
    function b1(u, f, M) {
      var A = f.pendingProps;
      return Zl(u, f, A, M), f.child;
    }
    function w1(u, f, M) {
      var A = f.pendingProps.children;
      return Zl(u, f, A, M), f.child;
    }
    function bw(u, f, M) {
      {
        f.flags |= fn;
        {
          var A = f.stateNode;
          A.effectDuration = 0, A.passiveEffectDuration = 0;
        }
      }
      var z = f.pendingProps, j = z.children;
      return Zl(u, f, j, M), f.child;
    }
    function i_(u, f) {
      var M = f.ref;
      (u === null && M !== null || u !== null && u.ref !== M) && (f.flags |= ti, f.flags |= Rn);
    }
    function a_(u, f, M, A, z) {
      if (f.type !== f.elementType) {
        var j = M.propTypes;
        j && ko(
          j,
          A,
          "prop",
          at(M)
        );
      }
      var ne;
      {
        var se = fs(f, M, !0);
        ne = Ul(f, se);
      }
      var Se, Pe;
      cn(f, z), zc(f);
      {
        if (am.current = f, eo(!0), Se = Le(u, f, M, A, ne, z), Pe = Ve(), f.mode & Fa) {
          ci(!0);
          try {
            Se = Le(u, f, M, A, ne, z), Pe = Ve();
          } finally {
            ci(!1);
          }
        }
        eo(!1);
      }
      return cc(), u !== null && !qc ? (Ct(u, f, z), sm(u, f, z)) : (ha() && Pe && ql(f), f.flags |= Gt, Zl(u, f, Se, z), f.child);
    }
    function s_(u, f, M, A, z) {
      {
        switch (EE(f)) {
          case !1: {
            var j = f.stateNode, ne = f.type, se = new ne(f.memoizedProps, j.context), Se = se.state;
            j.updater.enqueueSetState(j, Se, null);
            break;
          }
          case !0: {
            f.flags |= Vn, f.flags |= qe;
            var Pe = new Error("Simulated error coming from DevTools"), Ge = cu(z);
            f.lanes = zr(f.lanes, Ge);
            var yt = Km(f, Ny(Pe, f), Ge);
            $r(f, yt);
            break;
          }
        }
        if (f.type !== f.elementType) {
          var It = M.propTypes;
          It && ko(
            It,
            A,
            "prop",
            at(M)
          );
        }
      }
      var jt;
      pl(M) ? (jt = !0, Ca(f)) : jt = !1, cn(f, z);
      var dn = f.stateNode, Sn;
      dn === null ? (u !== null && (u.alternate = null, f.alternate = null, f.flags |= Pt), Im(f, M, A), ip(f, M, A, z), Sn = !0) : u === null ? Sn = Bm(f, M, A, z) : Sn = Sy(u, f, M, A, z);
      var Tr = E1(u, f, M, Sn, jt, z);
      {
        var yi = f.stateNode;
        Sn && yi.props !== A && (Iv || m("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Tt(f) || "a component"), Iv = !0);
      }
      return Tr;
    }
    function E1(u, f, M, A, z, j) {
      i_(u, f);
      var ne = (f.flags & Vn) !== Ne;
      if (!A && !ne)
        return z && Sh(f, M, !1), sm(u, f, j);
      var se = f.stateNode;
      am.current = f;
      var Se;
      if (ne && typeof M.getDerivedStateFromError != "function")
        Se = null, Jm();
      else {
        zc(f);
        {
          if (eo(!0), Se = se.render(), f.mode & Fa) {
            ci(!0);
            try {
              se.render();
            } finally {
              ci(!1);
            }
          }
          eo(!1);
        }
        cc();
      }
      return f.flags |= Gt, u !== null && ne ? Vy(u, f, Se, j) : Zl(u, f, Se, j), f.memoizedState = se.state, z && Sh(f, M, !0), f.child;
    }
    function o_(u) {
      var f = u.stateNode;
      f.pendingContext ? Au(u, f.pendingContext, f.pendingContext !== f.context) : f.context && Au(u, f.context, !1), My(u, f.containerInfo);
    }
    function ww(u, f, M) {
      if (o_(f), u === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var A = f.pendingProps, z = f.memoizedState, j = z.element;
      Xr(u, f), hd(f, A, null, M);
      var ne = f.memoizedState;
      f.stateNode;
      var se = ne.element;
      if (cs && z.isDehydrated) {
        var Se = {
          element: se,
          isDehydrated: !1,
          cache: ne.cache,
          transitions: ne.transitions
        }, Pe = f.updateQueue;
        if (Pe.baseState = Se, f.memoizedState = Se, f.flags & jr) {
          var Ge = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return l_(u, f, se, M, Ge);
        } else if (se !== j) {
          var yt = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return l_(u, f, se, M, yt);
        } else {
          sl(f);
          var It = wy(f, null, se, M);
          f.child = It;
          for (var jt = It; jt; )
            jt.flags = jt.flags & ~Pt | ni, jt = jt.sibling;
        }
      } else {
        if (Vc(), se === j)
          return sm(u, f, M);
        Zl(u, f, se, M);
      }
      return f.child;
    }
    function l_(u, f, M, A, z) {
      return Vc(), ro(z), f.flags |= jr, Zl(u, f, M, A), f.child;
    }
    function Ew(u, f, M) {
      Is(f), u === null && gd(f);
      var A = f.type, z = f.pendingProps, j = u !== null ? u.memoizedProps : null, ne = z.children, se = Ju(A, z);
      return se ? ne = null : j !== null && Ju(A, j) && (f.flags |= Ur), i_(u, f), Zl(u, f, ne, M), f.child;
    }
    function M1(u, f) {
      return u === null && gd(f), null;
    }
    function Mw(u, f, M, A) {
      u !== null && (u.alternate = null, f.alternate = null, f.flags |= Pt);
      var z = f.pendingProps, j = M, ne = j._payload, se = j._init, Se = se(ne);
      f.type = Se;
      var Pe = f.tag = c0(Se), Ge = ii(Se, z), yt;
      switch (Pe) {
        case $:
          return C1(f, Se), f.type = Se = Zg(Se), yt = a_(null, f, Se, Ge, A), yt;
        case W:
          return f.type = Se = pE(Se), yt = s_(null, f, Se, Ge, A), yt;
        case he:
          return f.type = Se = sv(Se), yt = Gy(null, f, Se, Ge, A), yt;
        case ye: {
          if (f.type !== f.elementType) {
            var It = Se.propTypes;
            It && ko(
              It,
              Ge,
              "prop",
              at(Se)
            );
          }
          return yt = Og(
            null,
            f,
            Se,
            ii(Se.type, Ge),
            A
          ), yt;
        }
      }
      var jt = "";
      throw Se !== null && typeof Se == "object" && Se.$$typeof === oe && (jt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + Se + ". " + ("Lazy element type must resolve to a class or function." + jt));
    }
    function Tw(u, f, M, A, z) {
      u !== null && (u.alternate = null, f.alternate = null, f.flags |= Pt), f.tag = W;
      var j;
      return pl(M) ? (j = !0, Ca(f)) : j = !1, cn(f, z), Im(f, M, A), ip(f, M, A, z), E1(null, f, M, !0, j, z);
    }
    function T1(u, f, M, A) {
      u !== null && (u.alternate = null, f.alternate = null, f.flags |= Pt);
      var z = f.pendingProps, j;
      {
        var ne = fs(f, M, !1);
        j = Ul(f, ne);
      }
      cn(f, A);
      var se, Se;
      zc(f);
      {
        if (M.prototype && typeof M.prototype.render == "function") {
          var Pe = at(M) || "Unknown";
          x1[Pe] || (m("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Pe, Pe), x1[Pe] = !0);
        }
        f.mode & Fa && Xl.recordLegacyContextWarning(f, null), eo(!0), am.current = f, se = Le(null, f, M, z, j, A), Se = Ve(), eo(!1);
      }
      if (cc(), f.flags |= Gt, typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0) {
        var Ge = at(M) || "Unknown";
        Pg[Ge] || (m("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ge, Ge, Ge), Pg[Ge] = !0);
      }
      if (typeof se == "object" && se !== null && typeof se.render == "function" && se.$$typeof === void 0) {
        {
          var yt = at(M) || "Unknown";
          Pg[yt] || (m("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", yt, yt, yt), Pg[yt] = !0);
        }
        f.tag = W, f.memoizedState = null, f.updateQueue = null;
        var It = !1;
        return pl(M) ? (It = !0, Ca(f)) : It = !1, f.memoizedState = se.state !== null && se.state !== void 0 ? se.state : null, Wn(f), Th(f, se), ip(f, M, z, A), E1(null, f, M, !0, It, A);
      } else {
        if (f.tag = $, f.mode & Fa) {
          ci(!0);
          try {
            se = Le(null, f, M, z, j, A), Se = Ve();
          } finally {
            ci(!1);
          }
        }
        return ha() && Se && ql(f), Zl(null, f, se, A), C1(f, M), f.child;
      }
    }
    function C1(u, f) {
      {
        if (f && f.childContextTypes && m("%s(...): childContextTypes cannot be defined on a function component.", f.displayName || f.name || "Component"), u.ref !== null) {
          var M = "", A = tp();
          A && (M += `

Check the render method of \`` + A + "`.");
          var z = A || "", j = u._debugSource;
          j && (z = j.fileName + ":" + j.lineNumber), ex[z] || (ex[z] = !0, m("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", M));
        }
        if (typeof f.getDerivedStateFromProps == "function") {
          var ne = at(f) || "Unknown";
          S1[ne] || (m("%s: Function components do not support getDerivedStateFromProps.", ne), S1[ne] = !0);
        }
        if (typeof f.contextType == "object" && f.contextType !== null) {
          var se = at(f) || "Unknown";
          $m[se] || (m("%s: Function components do not support contextType.", se), $m[se] = !0);
        }
      }
    }
    var zg = {
      dehydrated: null,
      treeContext: null,
      retryLane: Ir
    };
    function Wy(u) {
      return {
        baseLanes: u,
        cachePool: _w()
      };
    }
    function u_(u, f) {
      var M = null;
      return {
        baseLanes: zr(u.baseLanes, f),
        cachePool: M
      };
    }
    function Cw(u, f, M, A) {
      if (f !== null) {
        var z = f.memoizedState;
        if (z === null)
          return !1;
      }
      return Cy(u, Xm);
    }
    function c_(u, f) {
      return Js(u.childLanes, f);
    }
    function tx(u, f, M) {
      var A = f.pendingProps;
      TE(f) && (f.flags |= Vn);
      var z = Wc.current, j = !1, ne = (f.flags & Vn) !== Ne;
      if (ne || Cw(z, u) ? (j = !0, f.flags &= ~Vn) : (u === null || u.memoizedState !== null) && (z = _g(z, F0)), z = _l(z), ku(f, z), u === null) {
        gd(f);
        {
          var se = f.memoizedState;
          if (se !== null) {
            var Se = se.dehydrated;
            if (Se !== null)
              return A1(f, Se);
          }
        }
        var Pe = A.children, Ge = A.fallback;
        if (j) {
          var yt = f_(f, Pe, Ge, M), It = f.child;
          return It.memoizedState = Wy(M), f.memoizedState = zg, yt;
        } else
          return jy(f, Pe);
      } else {
        var jt = u.memoizedState;
        if (jt !== null) {
          {
            var dn = jt.dehydrated;
            if (dn !== null)
              if (ne) {
                if (f.flags & jr)
                  return f.flags &= ~jr, rx(u, f, M, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (f.memoizedState !== null)
                  return f.child = u.child, f.flags |= Vn, null;
                var Sn = A.children, Tr = A.fallback, yi = Rw(u, f, Sn, Tr, M), Pr = f.child;
                return Pr.memoizedState = Wy(M), f.memoizedState = zg, yi;
              } else
                return Bf(u, f, dn, jt, M);
          }
          if (j) {
            var so = A.fallback, oo = A.children, Et = nx(u, f, oo, so, M), Zt = f.child, wt = u.child.memoizedState;
            return Zt.memoizedState = wt === null ? Wy(M) : u_(wt, M), Zt.childLanes = c_(u, M), f.memoizedState = zg, Et;
          } else {
            var En = A.children, yr = h_(u, f, En, M);
            return f.memoizedState = null, yr;
          }
        } else if (j) {
          var Un = A.fallback, ai = A.children, ba = nx(u, f, ai, Un, M), gs = f.child, Nn = u.child.memoizedState;
          return gs.memoizedState = Nn === null ? Wy(M) : u_(Nn, M), gs.childLanes = c_(u, M), f.memoizedState = zg, ba;
        } else {
          var as = A.children, wa = h_(u, f, as, M);
          return f.memoizedState = null, wa;
        }
      }
    }
    function jy(u, f, M) {
      var A = u.mode, z = {
        mode: "visible",
        children: f
      }, j = R1(z, A);
      return j.return = u, u.child = j, j;
    }
    function f_(u, f, M, A) {
      var z = u.mode, j = u.child, ne = {
        mode: "hidden",
        children: f
      }, se, Se;
      return (z & $i) === Mr && j !== null ? (se = j, se.childLanes = an, se.pendingProps = ne, u.mode & Br && (se.actualDuration = 0, se.actualStartTime = -1, se.selfBaseDuration = 0, se.treeBaseDuration = 0), Se = Mp(M, z, A, null)) : (se = R1(ne, z), Se = Mp(M, z, A, null)), se.return = u, Se.return = u, se.sibling = Se, u.child = se, Se;
    }
    function R1(u, f, M) {
      return zh(u, f, an, null);
    }
    function d_(u, f) {
      return oa(u, f);
    }
    function h_(u, f, M, A) {
      var z = u.child, j = z.sibling, ne = d_(z, {
        mode: "visible",
        children: M
      });
      if ((f.mode & $i) === Mr && (ne.lanes = A), ne.return = f, ne.sibling = null, j !== null) {
        var se = f.deletions;
        se === null ? (f.deletions = [j], f.flags |= Wr) : se.push(j);
      }
      return f.child = ne, ne;
    }
    function nx(u, f, M, A, z) {
      var j = f.mode, ne = u.child, se = ne.sibling, Se = {
        mode: "hidden",
        children: M
      }, Pe;
      if ((j & $i) === Mr && f.child !== ne) {
        var Ge = f.child;
        Pe = Ge, Pe.childLanes = an, Pe.pendingProps = Se, f.mode & Br && (Pe.actualDuration = 0, Pe.actualStartTime = -1, Pe.selfBaseDuration = ne.selfBaseDuration, Pe.treeBaseDuration = ne.treeBaseDuration), f.deletions = null;
      } else
        Pe = d_(ne, Se), Pe.subtreeFlags = ne.subtreeFlags & $t;
      var yt;
      return se !== null ? yt = oa(se, A) : (yt = Mp(A, j, z, null), yt.flags |= Pt), yt.return = f, Pe.return = f, Pe.sibling = yt, f.child = Pe, yt;
    }
    function rx(u, f, M, A) {
      A !== null && ro(A), zf(f, u.child, null, M);
      var z = f.pendingProps, j = z.children, ne = jy(f, j);
      return ne.flags |= Pt, f.memoizedState = null, ne;
    }
    function Rw(u, f, M, A, z) {
      var j = f.mode, ne = {
        mode: "visible",
        children: M
      }, se = R1(ne, j), Se = Mp(A, j, z, null);
      return Se.flags |= Pt, se.return = f, Se.return = f, se.sibling = Se, f.child = se, (f.mode & $i) !== Mr && zf(f, u.child, null, z), Se;
    }
    function A1(u, f, M) {
      return (u.mode & $i) === Mr ? (m("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), u.lanes = Hr) : va(f) ? u.lanes = ac : u.lanes = Hn, null;
    }
    function Bf(u, f, M, A, z) {
      if (Hc(), (f.mode & $i) === Mr)
        return rx(
          u,
          f,
          z,
          null
        );
      if (va(M))
        return rx(
          u,
          f,
          z,
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var j = Vr(z, u.childLanes);
      if (qc || j) {
        var ne = z_();
        if (ne !== null) {
          var se = gl(ne, z);
          if (se !== Ir && se !== A.retryLane) {
            A.retryLane = se;
            var Se = Bi;
            Ml(u, se, Se);
          }
        }
        return X1(), rx(u, f, z, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (xs(M)) {
        f.flags |= Vn, f.child = u.child;
        var Pe = AT.bind(null, u);
        return qs(M, Pe), null;
      } else {
        Vm(f, M, A.treeContext);
        var Ge = f.pendingProps, yt = Ge.children, It = jy(f, yt);
        return It.flags |= ni, It;
      }
    }
    function ix(u, f, M) {
      u.lanes = zr(u.lanes, f);
      var A = u.alternate;
      A !== null && (A.lanes = zr(A.lanes, f)), Ae(u.return, f, M);
    }
    function Aw(u, f, M) {
      for (var A = f; A !== null; ) {
        if (A.tag === ue) {
          var z = A.memoizedState;
          z !== null && ix(A, M, u);
        } else if (A.tag === Ue)
          ix(A, M, u);
        else if (A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === u)
          return;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === u)
            return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function Dw(u) {
      for (var f = u, M = null; f !== null; ) {
        var A = f.alternate;
        A !== null && mp(A) === null && (M = f), f = f.sibling;
      }
      return M;
    }
    function Lw(u) {
      if (u !== void 0 && u !== "forwards" && u !== "backwards" && u !== "together" && !_1[u])
        if (_1[u] = !0, typeof u == "string")
          switch (u.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              m('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', u, u.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              m('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', u, u.toLowerCase());
              break;
            }
            default:
              m('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', u);
              break;
          }
        else
          m('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', u);
    }
    function Pw(u, f) {
      u !== void 0 && !Hy[u] && (u !== "collapsed" && u !== "hidden" ? (Hy[u] = !0, m('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', u)) : f !== "forwards" && f !== "backwards" && (Hy[u] = !0, m('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', u)));
    }
    function ax(u, f) {
      {
        var M = Ti(u), A = !M && typeof xe(u) == "function";
        if (M || A) {
          var z = M ? "array" : "iterable";
          return m("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", z, f, z), !1;
        }
      }
      return !0;
    }
    function Ow(u, f) {
      if ((f === "forwards" || f === "backwards") && u !== void 0 && u !== null && u !== !1)
        if (Ti(u)) {
          for (var M = 0; M < u.length; M++)
            if (!ax(u[M], M))
              return;
        } else {
          var A = xe(u);
          if (typeof A == "function") {
            var z = A.call(u);
            if (z)
              for (var j = z.next(), ne = 0; !j.done; j = z.next()) {
                if (!ax(j.value, ne))
                  return;
                ne++;
              }
          } else
            m('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', f);
        }
    }
    function Yy(u, f, M, A, z) {
      var j = u.memoizedState;
      j === null ? u.memoizedState = {
        isBackwards: f,
        rendering: null,
        renderingStartTime: 0,
        last: A,
        tail: M,
        tailMode: z
      } : (j.isBackwards = f, j.rendering = null, j.renderingStartTime = 0, j.last = A, j.tail = M, j.tailMode = z);
    }
    function D1(u, f, M) {
      var A = f.pendingProps, z = A.revealOrder, j = A.tail, ne = A.children;
      Lw(z), Pw(j, z), Ow(ne, z), Zl(u, f, ne, M);
      var se = Wc.current, Se = Cy(se, Xm);
      if (Se)
        se = Av(se, Xm), f.flags |= Vn;
      else {
        var Pe = u !== null && (u.flags & Vn) !== Ne;
        Pe && Aw(f, f.child, M), se = _l(se);
      }
      if (ku(f, se), (f.mode & $i) === Mr)
        f.memoizedState = null;
      else
        switch (z) {
          case "forwards": {
            var Ge = Dw(f.child), yt;
            Ge === null ? (yt = f.child, f.child = null) : (yt = Ge.sibling, Ge.sibling = null), Yy(
              f,
              !1,
              yt,
              Ge,
              j
            );
            break;
          }
          case "backwards": {
            var It = null, jt = f.child;
            for (f.child = null; jt !== null; ) {
              var dn = jt.alternate;
              if (dn !== null && mp(dn) === null) {
                f.child = jt;
                break;
              }
              var Sn = jt.sibling;
              jt.sibling = It, It = jt, jt = Sn;
            }
            Yy(
              f,
              !0,
              It,
              null,
              j
            );
            break;
          }
          case "together": {
            Yy(
              f,
              !1,
              null,
              null,
              void 0
            );
            break;
          }
          default:
            f.memoizedState = null;
        }
      return f.child;
    }
    function L1(u, f, M) {
      My(f, f.stateNode.containerInfo);
      var A = f.pendingProps;
      return u === null ? f.child = zf(f, null, A, M) : Zl(u, f, A, M), f.child;
    }
    var p_ = !1;
    function Uw(u, f, M) {
      var A = f.type, z = A._context, j = f.pendingProps, ne = f.memoizedProps, se = j.value;
      {
        "value" in j || p_ || (p_ = !0, m("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var Se = f.type.propTypes;
        Se && ko(Se, j, "prop", "Context.Provider");
      }
      if (q(f, z, se), ne !== null) {
        var Pe = ne.value;
        if (Eo(Pe, se)) {
          if (ne.children === j.children && !$a())
            return sm(u, f, M);
        } else
          Ke(f, z, M);
      }
      var Ge = j.children;
      return Zl(u, f, Ge, M), f.child;
    }
    var Ng = !1;
    function Xy(u, f, M) {
      var A = f.type;
      A._context === void 0 ? A !== A.Consumer && (Ng || (Ng = !0, m("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : A = A._context;
      var z = f.pendingProps, j = z.children;
      typeof j != "function" && m("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), cn(f, M);
      var ne = bn(A);
      zc(f);
      var se;
      return am.current = f, eo(!0), se = j(ne), eo(!1), cc(), f.flags |= Gt, Zl(u, f, se, M), f.child;
    }
    function sx() {
      qc = !0;
    }
    function sm(u, f, M) {
      return u !== null && (f.dependencies = u.dependencies), Jm(), gx(f.lanes), Vr(M, f.childLanes) ? (xg(u, f), f.child) : null;
    }
    function P1(u, f, M) {
      {
        var A = f.return;
        if (A === null)
          throw new Error("Cannot swap the root fiber.");
        if (u.alternate = null, f.alternate = null, M.index = f.index, M.sibling = f.sibling, M.return = f.return, M.ref = f.ref, f === A.child)
          A.child = M;
        else {
          var z = A.child;
          if (z === null)
            throw new Error("Expected parent to have a child.");
          for (; z.sibling !== f; )
            if (z = z.sibling, z === null)
              throw new Error("Expected to find the previous sibling.");
          z.sibling = M;
        }
        var j = A.deletions;
        return j === null ? (A.deletions = [u], A.flags |= Wr) : j.push(u), M.flags |= Pt, M;
      }
    }
    function qy(u, f) {
      var M = u.lanes;
      return !!Vr(M, f);
    }
    function zw(u, f, M) {
      switch (f.tag) {
        case ie:
          o_(f), f.stateNode, Vc();
          break;
        case ce:
          Is(f);
          break;
        case W: {
          var A = f.type;
          pl(A) && Ca(f);
          break;
        }
        case pe:
          My(f, f.stateNode.containerInfo);
          break;
        case Be: {
          var z = f.memoizedProps.value, j = f.type._context;
          q(f, j, z);
          break;
        }
        case fe:
          {
            var ne = Vr(M, f.childLanes);
            ne && (f.flags |= fn);
            {
              var se = f.stateNode;
              se.effectDuration = 0, se.passiveEffectDuration = 0;
            }
          }
          break;
        case ue: {
          var Se = f.memoizedState;
          if (Se !== null) {
            if (Se.dehydrated !== null)
              return ku(f, _l(Wc.current)), f.flags |= Vn, null;
            var Pe = f.child, Ge = Pe.childLanes;
            if (Vr(M, Ge))
              return tx(u, f, M);
            ku(f, _l(Wc.current));
            var yt = sm(u, f, M);
            return yt !== null ? yt.sibling : null;
          } else
            ku(f, _l(Wc.current));
          break;
        }
        case Ue: {
          var It = (u.flags & Vn) !== Ne, jt = Vr(M, f.childLanes);
          if (It) {
            if (jt)
              return D1(u, f, M);
            f.flags |= Vn;
          }
          var dn = f.memoizedState;
          if (dn !== null && (dn.rendering = null, dn.tail = null, dn.lastEffect = null), ku(f, Wc.current), jt)
            break;
          return null;
        }
        case rt:
        case _t:
          return f.lanes = an, r_(u, f, M);
      }
      return sm(u, f, M);
    }
    function m_(u, f, M) {
      if (f._debugNeedsRemount && u !== null)
        return P1(u, f, Tx(f.type, f.key, f.pendingProps, f._debugOwner || null, f.mode, f.lanes));
      if (u !== null) {
        var A = u.memoizedProps, z = f.pendingProps;
        if (A !== z || $a() || f.type !== u.type)
          qc = !0;
        else {
          var j = qy(u, M);
          if (!j && (f.flags & Vn) === Ne)
            return qc = !1, zw(u, f, M);
          (u.flags & on) !== Ne ? qc = !0 : qc = !1;
        }
      } else if (qc = !1, ha() && pd(f)) {
        var ne = f.index, se = Uf();
        pg(f, se, ne);
      }
      switch (f.lanes = an, f.tag) {
        case ee:
          return T1(u, f, f.type, M);
        case Xe: {
          var Se = f.elementType;
          return Mw(u, f, Se, M);
        }
        case $: {
          var Pe = f.type, Ge = f.pendingProps, yt = f.elementType === Pe ? Ge : ii(Pe, Ge);
          return a_(u, f, Pe, yt, M);
        }
        case W: {
          var It = f.type, jt = f.pendingProps, dn = f.elementType === It ? jt : ii(It, jt);
          return s_(u, f, It, dn, M);
        }
        case ie:
          return ww(u, f, M);
        case ce:
          return Ew(u, f, M);
        case Ee:
          return M1(u, f);
        case ue:
          return tx(u, f, M);
        case pe:
          return L1(u, f, M);
        case he: {
          var Sn = f.type, Tr = f.pendingProps, yi = f.elementType === Sn ? Tr : ii(Sn, Tr);
          return Gy(u, f, Sn, yi, M);
        }
        case de:
          return b1(u, f, M);
        case Fe:
          return w1(u, f, M);
        case fe:
          return bw(u, f, M);
        case Be:
          return Uw(u, f, M);
        case Ce:
          return Xy(u, f, M);
        case ye: {
          var Pr = f.type, so = f.pendingProps, oo = ii(Pr, so);
          if (f.type !== f.elementType) {
            var Et = Pr.propTypes;
            Et && ko(
              Et,
              oo,
              "prop",
              at(Pr)
            );
          }
          return oo = ii(Pr.type, oo), Og(u, f, Pr, oo, M);
        }
        case we:
          return Ug(u, f, f.type, f.pendingProps, M);
        case Je: {
          var Zt = f.type, wt = f.pendingProps, En = f.elementType === Zt ? wt : ii(Zt, wt);
          return Tw(u, f, Zt, En, M);
        }
        case Ue:
          return D1(u, f, M);
        case ot:
          break;
        case rt:
          return r_(u, f, M);
      }
      throw new Error("Unknown unit of work tag (" + f.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Nw(u, f, M) {
      switch (bv(f), f.tag) {
        case W: {
          var A = f.type;
          pl(A) && xi(f);
          var z = f.flags;
          return z & qe ? (f.flags = z & ~qe | Vn, (f.mode & Br) !== Mr && Dg(f), f) : null;
        }
        case ie: {
          Gc(f), Ec(f), bg();
          var j = f.flags;
          return (j & qe) !== Ne && (j & Vn) === Ne ? (f.flags = j & ~qe | Vn, f) : null;
        }
        case ce:
          return Ty(f), null;
        case ue: {
          Lh(f);
          {
            var ne = f.memoizedState;
            if (ne !== null && ne.dehydrated !== null) {
              if (f.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              Vc();
            }
          }
          var se = f.flags;
          return se & qe ? (f.flags = se & ~qe | Vn, (f.mode & Br) !== Mr && Dg(f), f) : null;
        }
        case Ue:
          return Lh(f), null;
        case pe:
          return Gc(f), null;
        case Be:
          var Se = f.type._context;
          return te(Se, f), null;
        case rt:
        case _t:
          return Y1(f), null;
        case Rt:
          return null;
        default:
          return null;
      }
    }
    function O1(u, f, M) {
      switch (bv(f), f.tag) {
        case W: {
          var A = f.type.childContextTypes;
          A != null && xi(f);
          break;
        }
        case ie: {
          Gc(f), Ec(f), bg();
          break;
        }
        case ce: {
          Ty(f);
          break;
        }
        case pe:
          Gc(f);
          break;
        case ue:
          Lh(f);
          break;
        case Ue:
          Lh(f);
          break;
        case Be:
          var z = f.type._context;
          te(z, f);
          break;
        case rt:
        case _t:
          Y1(f);
          break;
      }
    }
    function v_(u, f, M, A, z, j, ne, se, Se) {
      var Pe = Array.prototype.slice.call(arguments, 3);
      try {
        f.apply(M, Pe);
      } catch (Ge) {
        this.onError(Ge);
      }
    }
    var g_ = v_;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var U1 = document.createElement("react");
      g_ = function(f, M, A, z, j, ne, se, Se, Pe) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Ge = document.createEvent("Event"), yt = !1, It = !0, jt = window.event, dn = Object.getOwnPropertyDescriptor(window, "event");
        function Sn() {
          U1.removeEventListener(Zt, yi, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = jt);
        }
        var Tr = Array.prototype.slice.call(arguments, 3);
        function yi() {
          yt = !0, Sn(), M.apply(A, Tr), It = !1;
        }
        var Pr, so = !1, oo = !1;
        function Et(wt) {
          if (Pr = wt.error, so = !0, Pr === null && wt.colno === 0 && wt.lineno === 0 && (oo = !0), wt.defaultPrevented && Pr != null && typeof Pr == "object")
            try {
              Pr._suppressLogging = !0;
            } catch {
            }
        }
        var Zt = "react-" + (f || "invokeguardedcallback");
        if (window.addEventListener("error", Et), U1.addEventListener(Zt, yi, !1), Ge.initEvent(Zt, !1, !1), U1.dispatchEvent(Ge), dn && Object.defineProperty(window, "event", dn), yt && It && (so ? oo && (Pr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Pr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Pr)), window.removeEventListener("error", Et), !yt)
          return Sn(), v_.apply(this, arguments);
      };
    }
    var Fw = g_, Qy = !1, ox = null, kw = {
      onError: function(u) {
        Qy = !0, ox = u;
      }
    };
    function y_(u, f, M, A, z, j, ne, se, Se) {
      Qy = !1, ox = null, Fw.apply(kw, arguments);
    }
    function Iw() {
      return Qy;
    }
    function x_() {
      if (Qy) {
        var u = ox;
        return Qy = !1, ox = null, u;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var S_ = null;
    S_ = /* @__PURE__ */ new Set();
    var lx = !1, ev = !1, Bw = typeof WeakSet == "function" ? WeakSet : Set, In = null, Fg = null, Uh = null;
    function g(u) {
      y_(null, function() {
        throw u;
      }), x_();
    }
    var w = function(u, f) {
      if (f.props = u.memoizedProps, f.state = u.memoizedState, u.mode & Br)
        try {
          vc(), f.componentWillUnmount();
        } finally {
          If(u);
        }
      else
        f.componentWillUnmount();
    };
    function N(u, f) {
      try {
        dr(Ts, u);
      } catch (M) {
        g(M), $l(u, f, M);
      }
    }
    function Z(u, f, M) {
      try {
        w(u, M);
      } catch (A) {
        g(A), $l(u, f, A);
      }
    }
    function ae(u, f, M) {
      try {
        M.componentDidMount();
      } catch (A) {
        g(A), $l(u, f, A);
      }
    }
    function be(u, f) {
      try {
        Hu(u);
      } catch (M) {
        g(M), $l(u, f, M);
      }
    }
    function ke(u, f) {
      var M = u.ref;
      if (M !== null)
        if (typeof M == "function") {
          var A;
          try {
            if (X && J && u.mode & Br)
              try {
                vc(), A = M(null);
              } finally {
                If(u);
              }
            else
              A = M(null);
          } catch (z) {
            g(z), $l(u, f, z);
          }
          typeof A == "function" && m("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Tt(u));
        } else
          M.current = null;
    }
    function We(u, f, M) {
      try {
        M();
      } catch (A) {
        g(A), $l(u, f, A);
      }
    }
    var ut = !1;
    function tn(u, f) {
      Rl(u.containerInfo), In = f, Kt();
      var M = ut;
      return ut = !1, M;
    }
    function Kt() {
      for (; In !== null; ) {
        var u = In, f = u.child;
        (u.subtreeFlags & br) !== Ne && f !== null ? (wp(f, u), In = f) : sn();
      }
    }
    function sn() {
      for (; In !== null; ) {
        var u = In;
        wi(u);
        try {
          Cn(u);
        } catch (M) {
          g(M), $l(u, u.return, M);
        }
        Es();
        var f = u.sibling;
        if (f !== null) {
          wp(f, u.return), In = f;
          return;
        }
        In = u.return;
      }
    }
    function Cn(u) {
      var f = u.alternate, M = u.flags;
      if ((M & ki) !== Ne) {
        switch (wi(u), u.tag) {
          case $:
          case he:
          case we:
            break;
          case W: {
            if (f !== null) {
              var A = f.memoizedProps, z = f.memoizedState, j = u.stateNode;
              u.type === u.elementType && !Iv && (j.props !== u.memoizedProps && m("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(u) || "instance"), j.state !== u.memoizedState && m("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(u) || "instance"));
              var ne = j.getSnapshotBeforeUpdate(u.elementType === u.type ? A : ii(u.type, A), z);
              {
                var se = S_;
                ne === void 0 && !se.has(u.type) && (se.add(u.type), m("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Tt(u)));
              }
              j.__reactInternalSnapshotBeforeUpdate = ne;
            }
            break;
          }
          case ie: {
            if (zo) {
              var Se = u.stateNode;
              Mu(Se.containerInfo);
            }
            break;
          }
          case ce:
          case Ee:
          case pe:
          case Je:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Es();
      }
    }
    function Ln(u, f, M) {
      var A = f.updateQueue, z = A !== null ? A.lastEffect : null;
      if (z !== null) {
        var j = z.next, ne = j;
        do {
          if ((ne.tag & u) === u) {
            var se = ne.destroy;
            ne.destroy = void 0, se !== void 0 && ((u & bl) !== mc ? il(f) : (u & Ts) !== mc && Mf(f), We(f, M, se), (u & bl) !== mc ? Fm() : (u & Ts) !== mc && Vl());
          }
          ne = ne.next;
        } while (ne !== j);
      }
    }
    function dr(u, f) {
      var M = f.updateQueue, A = M !== null ? M.lastEffect : null;
      if (A !== null) {
        var z = A.next, j = z;
        do {
          if ((j.tag & u) === u) {
            (u & bl) !== mc ? qd(f) : (u & Ts) !== mc && Ef(f);
            var ne = j.create;
            j.destroy = ne(), (u & bl) !== mc ? ld() : (u & Ts) !== mc && Qd();
            {
              var se = j.destroy;
              if (se !== void 0 && typeof se != "function") {
                var Se = void 0;
                (j.tag & Ts) !== Ne ? Se = "useLayoutEffect" : (j.tag & vp) !== Ne ? Se = "useInsertionEffect" : Se = "useEffect";
                var Pe = void 0;
                se === null ? Pe = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof se.then == "function" ? Pe = `

It looks like you wrote ` + Se + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + Se + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Pe = " You returned: " + se, m("%s must not return anything besides a function, which is used for clean-up.%s", Se, Pe);
              }
            }
          }
          j = j.next;
        } while (j !== z);
      }
    }
    function gi(u, f) {
      if ((f.flags & fn) !== Ne)
        switch (f.tag) {
          case fe: {
            var M = f.stateNode.passiveEffectDuration, A = f.memoizedProps, z = A.id, j = A.onPostCommit, ne = rm(), se = f.alternate === null ? "mount" : "update";
            Da() && (se = "nested-update"), typeof j == "function" && j(z, se, M, ne);
            var Se = f.return;
            e:
              for (; Se !== null; ) {
                switch (Se.tag) {
                  case ie:
                    var Pe = Se.stateNode;
                    Pe.passiveEffectDuration += M;
                    break e;
                  case fe:
                    var Ge = Se.stateNode;
                    Ge.passiveEffectDuration += M;
                    break e;
                }
                Se = Se.return;
              }
            break;
          }
        }
    }
    function kr(u, f, M, A) {
      if ((M.flags & La) !== Ne)
        switch (M.tag) {
          case $:
          case he:
          case we: {
            if (!ev)
              if (M.mode & Br)
                try {
                  vc(), dr(Ts | Aa, M);
                } finally {
                  If(M);
                }
              else
                dr(Ts | Aa, M);
            break;
          }
          case W: {
            var z = M.stateNode;
            if (M.flags & fn && !ev)
              if (f === null)
                if (M.type === M.elementType && !Iv && (z.props !== M.memoizedProps && m("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(M) || "instance"), z.state !== M.memoizedState && m("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(M) || "instance")), M.mode & Br)
                  try {
                    vc(), z.componentDidMount();
                  } finally {
                    If(M);
                  }
                else
                  z.componentDidMount();
              else {
                var j = M.elementType === M.type ? f.memoizedProps : ii(M.type, f.memoizedProps), ne = f.memoizedState;
                if (M.type === M.elementType && !Iv && (z.props !== M.memoizedProps && m("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(M) || "instance"), z.state !== M.memoizedState && m("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(M) || "instance")), M.mode & Br)
                  try {
                    vc(), z.componentDidUpdate(j, ne, z.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    If(M);
                  }
                else
                  z.componentDidUpdate(j, ne, z.__reactInternalSnapshotBeforeUpdate);
              }
            var se = M.updateQueue;
            se !== null && (M.type === M.elementType && !Iv && (z.props !== M.memoizedProps && m("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Tt(M) || "instance"), z.state !== M.memoizedState && m("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Tt(M) || "instance")), km(M, se, z));
            break;
          }
          case ie: {
            var Se = M.updateQueue;
            if (Se !== null) {
              var Pe = null;
              if (M.child !== null)
                switch (M.child.tag) {
                  case ce:
                    Pe = Oo(M.child.stateNode);
                    break;
                  case W:
                    Pe = M.child.stateNode;
                    break;
                }
              km(M, Se, Pe);
            }
            break;
          }
          case ce: {
            var Ge = M.stateNode;
            if (f === null && M.flags & fn) {
              var yt = M.type, It = M.memoizedProps;
              Ii(Ge, yt, It, M);
            }
            break;
          }
          case Ee:
            break;
          case pe:
            break;
          case fe: {
            {
              var jt = M.memoizedProps, dn = jt.onCommit, Sn = jt.onRender, Tr = M.stateNode.effectDuration, yi = rm(), Pr = f === null ? "mount" : "update";
              Da() && (Pr = "nested-update"), typeof Sn == "function" && Sn(M.memoizedProps.id, Pr, M.actualDuration, M.treeBaseDuration, M.actualStartTime, yi);
              {
                typeof dn == "function" && dn(M.memoizedProps.id, Pr, Tr, yi), cR(M);
                var so = M.return;
                e:
                  for (; so !== null; ) {
                    switch (so.tag) {
                      case ie:
                        var oo = so.stateNode;
                        oo.effectDuration += Tr;
                        break e;
                      case fe:
                        var Et = so.stateNode;
                        Et.effectDuration += Tr;
                        break e;
                    }
                    so = so.return;
                  }
              }
            }
            break;
          }
          case ue: {
            __(u, M);
            break;
          }
          case Ue:
          case Je:
          case ot:
          case rt:
          case _t:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      ev || M.flags & ti && Hu(M);
    }
    function Fi(u) {
      switch (u.tag) {
        case $:
        case he:
        case we: {
          if (u.mode & Br)
            try {
              vc(), N(u, u.return);
            } finally {
              If(u);
            }
          else
            N(u, u.return);
          break;
        }
        case W: {
          var f = u.stateNode;
          typeof f.componentDidMount == "function" && ae(u, u.return, f), be(u, u.return);
          break;
        }
        case ce: {
          be(u, u.return);
          break;
        }
      }
    }
    function Ji(u, f) {
      var M = null;
      if (zo)
        for (var A = u; ; ) {
          if (A.tag === ce) {
            if (M === null) {
              M = A;
              var z = A.stateNode;
              f ? qf(z) : Qf(A.stateNode, A.memoizedProps);
            }
          } else if (A.tag === Ee) {
            if (M === null) {
              var j = A.stateNode;
              f ? Fo(j) : Ki(j, A.memoizedProps);
            }
          } else if (!((A.tag === rt || A.tag === _t) && A.memoizedState !== null && A !== u)) {
            if (A.child !== null) {
              A.child.return = A, A = A.child;
              continue;
            }
          }
          if (A === u)
            return;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === u)
              return;
            M === A && (M = null), A = A.return;
          }
          M === A && (M = null), A.sibling.return = A.return, A = A.sibling;
        }
    }
    function Hu(u) {
      var f = u.ref;
      if (f !== null) {
        var M = u.stateNode, A;
        switch (u.tag) {
          case ce:
            A = Oo(M);
            break;
          default:
            A = M;
        }
        if (typeof f == "function") {
          var z;
          if (u.mode & Br)
            try {
              vc(), z = f(A);
            } finally {
              If(u);
            }
          else
            z = f(A);
          typeof z == "function" && m("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Tt(u));
        } else
          f.hasOwnProperty("current") || m("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Tt(u)), f.current = A;
      }
    }
    function Vs(u) {
      var f = u.ref;
      if (f !== null)
        if (typeof f == "function")
          if (u.mode & Br)
            try {
              vc(), f(null);
            } finally {
              If(u);
            }
          else
            f(null);
        else
          f.current = null;
    }
    function gc(u, f, M) {
      switch (Ba(f), f.tag) {
        case $:
        case he:
        case ye:
        case we: {
          var A = f.updateQueue;
          if (A !== null) {
            var z = A.lastEffect;
            if (z !== null) {
              var j = z.next, ne = j;
              do {
                var se = ne, Se = se.destroy, Pe = se.tag;
                Se !== void 0 && ((Pe & vp) !== mc ? We(f, M, Se) : (Pe & Ts) !== mc && (Mf(f), f.mode & Br ? (vc(), We(f, M, Se), If(f)) : We(f, M, Se), Vl())), ne = ne.next;
              } while (ne !== j);
            }
          }
          return;
        }
        case W: {
          ke(f, M);
          var Ge = f.stateNode;
          typeof Ge.componentWillUnmount == "function" && Z(f, M, Ge);
          return;
        }
        case ce: {
          ke(f, M);
          return;
        }
        case pe: {
          zo ? Vw(u, f, M) : Ci && Gu(f);
          return;
        }
        case st:
          return;
        case ot:
          return;
      }
    }
    function Gs(u, f, M) {
      for (var A = f; ; ) {
        if (gc(u, A, M), A.child !== null && (!zo || A.tag !== pe)) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === f)
          return;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === f)
            return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function Jl(u) {
      var f = u.alternate;
      f !== null && (f.return = null), u.return = null;
    }
    function Vu(u) {
      var f = u.alternate;
      f !== null && (u.alternate = null, Vu(f));
      {
        if (u.child = null, u.deletions = null, u.sibling = null, u.tag === ce) {
          var M = u.stateNode;
          M !== null && ua(M);
        }
        u.stateNode = null, u._debugOwner = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
      }
    }
    function Gu(u) {
      if (!!Ci) {
        var f = u.stateNode, M = f.containerInfo, A = ys(M);
        bc(M, A);
      }
    }
    function Hf(u) {
      if (!!Ci) {
        switch (u.tag) {
          case W:
          case ce:
          case Ee:
            return;
          case ie:
          case pe: {
            var f = u.stateNode, M = f.containerInfo, A = f.pendingChildren;
            bc(M, A);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Hw(u) {
      for (var f = u.return; f !== null; ) {
        if ($d(f))
          return f;
        f = f.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function $d(u) {
      return u.tag === ce || u.tag === ie || u.tag === pe;
    }
    function tv(u) {
      var f = u;
      e:
        for (; ; ) {
          for (; f.sibling === null; ) {
            if (f.return === null || $d(f.return))
              return null;
            f = f.return;
          }
          for (f.sibling.return = f.return, f = f.sibling; f.tag !== ce && f.tag !== Ee && f.tag !== st; ) {
            if (f.flags & Pt || f.child === null || f.tag === pe)
              continue e;
            f.child.return = f, f = f.child;
          }
          if (!(f.flags & Pt))
            return f.stateNode;
        }
    }
    function om(u) {
      if (!!zo) {
        var f = Hw(u);
        switch (f.tag) {
          case ce: {
            var M = f.stateNode;
            f.flags & Ur && (Xf(M), f.flags &= ~Ur);
            var A = tv(u);
            kg(u, A, M);
            break;
          }
          case ie:
          case pe: {
            var z = f.stateNode.containerInfo, j = tv(u);
            z1(u, j, z);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function z1(u, f, M) {
      var A = u.tag, z = A === ce || A === Ee;
      if (z) {
        var j = u.stateNode;
        f ? Ps(M, j, f) : hf(M, j);
      } else if (A !== pe) {
        var ne = u.child;
        if (ne !== null) {
          z1(ne, f, M);
          for (var se = ne.sibling; se !== null; )
            z1(se, f, M), se = se.sibling;
        }
      }
    }
    function kg(u, f, M) {
      var A = u.tag, z = A === ce || A === Ee;
      if (z) {
        var j = u.stateNode;
        f ? No(M, j, f) : df(M, j);
      } else if (A !== pe) {
        var ne = u.child;
        if (ne !== null) {
          kg(ne, f, M);
          for (var se = ne.sibling; se !== null; )
            kg(se, f, M), se = se.sibling;
        }
      }
    }
    function Vw(u, f, M) {
      for (var A = f, z = !1, j, ne; ; ) {
        if (!z) {
          var se = A.return;
          e:
            for (; ; ) {
              if (se === null)
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var Se = se.stateNode;
              switch (se.tag) {
                case ce:
                  j = Se, ne = !1;
                  break e;
                case ie:
                  j = Se.containerInfo, ne = !0;
                  break e;
                case pe:
                  j = Se.containerInfo, ne = !0;
                  break e;
              }
              se = se.return;
            }
          z = !0;
        }
        if (A.tag === ce || A.tag === Ee)
          Gs(u, A, M), ne ? Ll(j, A.stateNode) : _c(j, A.stateNode);
        else if (A.tag === st)
          ne ? Lm(j, A.stateNode) : Dm(j, A.stateNode);
        else if (A.tag === pe) {
          if (A.child !== null) {
            j = A.stateNode.containerInfo, ne = !0, A.child.return = A, A = A.child;
            continue;
          }
        } else if (gc(u, A, M), A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === f)
          return;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === f)
            return;
          A = A.return, A.tag === pe && (z = !1);
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function ux(u, f, M) {
      zo ? Vw(u, f, M) : Gs(u, f, M), Jl(f);
    }
    function cx(u, f) {
      if (!zo) {
        switch (f.tag) {
          case $:
          case he:
          case ye:
          case we: {
            if (Ln(vp | Aa, f, f.return), dr(vp | Aa, f), f.mode & Br)
              try {
                vc(), Ln(Ts | Aa, f, f.return);
              } finally {
                If(f);
              }
            else
              Ln(Ts | Aa, f, f.return);
            return;
          }
          case fe:
            return;
          case ue: {
            lm(f), fx(f);
            return;
          }
          case Ue: {
            fx(f);
            return;
          }
          case ie: {
            if (cs && u !== null) {
              var M = u.memoizedState;
              if (M.isDehydrated) {
                var A = f.stateNode;
                Zh(A.containerInfo);
              }
            }
            break;
          }
          case rt:
          case _t:
            return;
        }
        Hf(f);
        return;
      }
      switch (f.tag) {
        case $:
        case he:
        case ye:
        case we: {
          if (Ln(vp | Aa, f, f.return), dr(vp | Aa, f), f.mode & Br)
            try {
              vc(), Ln(Ts | Aa, f, f.return);
            } finally {
              If(f);
            }
          else
            Ln(Ts | Aa, f, f.return);
          return;
        }
        case W:
          return;
        case ce: {
          var z = f.stateNode;
          if (z != null) {
            var j = f.memoizedProps, ne = u !== null ? u.memoizedProps : j, se = f.type, Se = f.updateQueue;
            f.updateQueue = null, Se !== null && Ri(z, Se, se, ne, j, f);
          }
          return;
        }
        case Ee: {
          if (f.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Pe = f.stateNode, Ge = f.memoizedProps, yt = u !== null ? u.memoizedProps : Ge;
          su(Pe, yt, Ge);
          return;
        }
        case ie: {
          if (cs && u !== null) {
            var It = u.memoizedState;
            if (It.isDehydrated) {
              var jt = f.stateNode;
              Zh(jt.containerInfo);
            }
          }
          return;
        }
        case fe:
          return;
        case ue: {
          lm(f), fx(f);
          return;
        }
        case Ue: {
          fx(f);
          return;
        }
        case Je:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function lm(u) {
      u.memoizedState;
    }
    function __(u, f) {
      if (!!cs) {
        var M = f.memoizedState;
        if (M === null) {
          var A = f.alternate;
          if (A !== null) {
            var z = A.memoizedState;
            if (z !== null) {
              var j = z.dehydrated;
              j !== null && Am(j);
            }
          }
        }
      }
    }
    function fx(u) {
      var f = u.updateQueue;
      if (f !== null) {
        u.updateQueue = null;
        var M = u.stateNode;
        M === null && (M = u.stateNode = new Bw()), f.forEach(function(A) {
          var z = DT.bind(null, u, A);
          if (!M.has(A)) {
            if (M.add(A), ns)
              if (Fg !== null && Uh !== null)
                l0(Uh, Fg);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            A.then(z, z);
          }
        });
      }
    }
    function oT(u) {
      !zo || Xf(u.stateNode);
    }
    function lT(u, f, M) {
      Fg = M, Uh = u, In = f, b_(u, M), Fg = null, Uh = null;
    }
    function b_(u, f) {
      for (; In !== null; ) {
        var M = In, A = M.deletions;
        if (A !== null)
          for (var z = 0; z < A.length; z++) {
            var j = A[z];
            try {
              ux(u, j, M);
            } catch (se) {
              g(se), $l(j, M, se);
            }
          }
        var ne = M.child;
        (M.subtreeFlags & Yi) !== Ne && ne !== null ? (wp(ne, M), In = ne) : uT(u, f);
      }
    }
    function uT(u, f) {
      for (; In !== null; ) {
        var M = In;
        wi(M);
        try {
          rR(M, u, f);
        } catch (z) {
          g(z), $l(M, M.return, z);
        }
        Es();
        var A = M.sibling;
        if (A !== null) {
          wp(A, M.return), In = A;
          return;
        }
        In = M.return;
      }
    }
    function rR(u, f, M) {
      var A = u.flags;
      if (A & Ur && oT(u), A & ti) {
        var z = u.alternate;
        z !== null && Vs(z);
      }
      if (A & Si)
        switch (u.tag) {
          case ue: {
            var j = u.memoizedState, ne = j !== null;
            if (ne) {
              var se = u.alternate, Se = se !== null && se.memoizedState !== null;
              Se || W_();
            }
            break;
          }
          case rt: {
            var Pe = u.memoizedState, Ge = Pe !== null, yt = u.alternate, It = yt !== null && yt.memoizedState !== null, jt = u;
            zo && Ji(jt, Ge);
            {
              if (Ge && !It && (jt.mode & $i) !== Mr) {
                In = jt;
                for (var dn = jt.child; dn !== null; )
                  In = dn, Gw(dn), dn = dn.sibling;
              }
              break;
            }
          }
        }
      var Sn = A & (Pt | fn | ni);
      switch (Sn) {
        case Pt: {
          om(u), u.flags &= ~Pt;
          break;
        }
        case Gr: {
          om(u), u.flags &= ~Pt;
          var Tr = u.alternate;
          cx(Tr, u);
          break;
        }
        case ni: {
          u.flags &= ~ni;
          break;
        }
        case ji: {
          u.flags &= ~ni;
          var yi = u.alternate;
          cx(yi, u);
          break;
        }
        case fn: {
          var Pr = u.alternate;
          cx(Pr, u);
          break;
        }
      }
    }
    function Ig(u, f, M) {
      Fg = M, Uh = f, In = u, N1(u, f, M), Fg = null, Uh = null;
    }
    function N1(u, f, M) {
      for (var A = (u.mode & $i) !== Mr; In !== null; ) {
        var z = In, j = z.child;
        if (z.tag === rt && A) {
          var ne = z.memoizedState !== null, se = ne || lx;
          if (se) {
            um(u, f, M);
            continue;
          } else {
            var Se = z.alternate, Pe = Se !== null && Se.memoizedState !== null, Ge = Pe || ev, yt = lx, It = ev;
            lx = se, ev = Ge, ev && !It && (In = z, cT(z));
            for (var jt = j; jt !== null; )
              In = jt, N1(
                jt,
                f,
                M
              ), jt = jt.sibling;
            In = z, lx = yt, ev = It, um(u, f, M);
            continue;
          }
        }
        (z.subtreeFlags & La) !== Ne && j !== null ? (wp(j, z), In = j) : um(u, f, M);
      }
    }
    function um(u, f, M) {
      for (; In !== null; ) {
        var A = In;
        if ((A.flags & La) !== Ne) {
          var z = A.alternate;
          wi(A);
          try {
            kr(f, z, A, M);
          } catch (ne) {
            g(ne), $l(A, A.return, ne);
          }
          Es();
        }
        if (A === u) {
          In = null;
          return;
        }
        var j = A.sibling;
        if (j !== null) {
          wp(j, A.return), In = j;
          return;
        }
        In = A.return;
      }
    }
    function Gw(u) {
      for (; In !== null; ) {
        var f = In, M = f.child;
        switch (f.tag) {
          case $:
          case he:
          case ye:
          case we: {
            if (f.mode & Br)
              try {
                vc(), Ln(Ts, f, f.return);
              } finally {
                If(f);
              }
            else
              Ln(Ts, f, f.return);
            break;
          }
          case W: {
            ke(f, f.return);
            var A = f.stateNode;
            typeof A.componentWillUnmount == "function" && Z(f, f.return, A);
            break;
          }
          case ce: {
            ke(f, f.return);
            break;
          }
          case rt: {
            var z = f.memoizedState !== null;
            if (z) {
              w_(u);
              continue;
            }
            break;
          }
        }
        M !== null ? (M.return = f, In = M) : w_(u);
      }
    }
    function w_(u) {
      for (; In !== null; ) {
        var f = In;
        if (f === u) {
          In = null;
          return;
        }
        var M = f.sibling;
        if (M !== null) {
          M.return = f.return, In = M;
          return;
        }
        In = f.return;
      }
    }
    function cT(u) {
      for (; In !== null; ) {
        var f = In, M = f.child;
        if (f.tag === rt) {
          var A = f.memoizedState !== null;
          if (A) {
            fT(u);
            continue;
          }
        }
        M !== null ? (M.return = f, In = M) : fT(u);
      }
    }
    function fT(u) {
      for (; In !== null; ) {
        var f = In;
        wi(f);
        try {
          Fi(f);
        } catch (A) {
          g(A), $l(f, f.return, A);
        }
        if (Es(), f === u) {
          In = null;
          return;
        }
        var M = f.sibling;
        if (M !== null) {
          M.return = f.return, In = M;
          return;
        }
        In = f.return;
      }
    }
    function dT(u, f) {
      In = f, Bg(f, u);
    }
    function Bg(u, f) {
      for (; In !== null; ) {
        var M = In, A = M.child;
        (M.subtreeFlags & Ys) !== Ne && A !== null ? (wp(A, M), In = A) : dx(u, f);
      }
    }
    function dx(u, f) {
      for (; In !== null; ) {
        var M = In;
        if ((M.flags & Wi) !== Ne) {
          wi(M);
          try {
            hx(f, M);
          } catch (z) {
            g(z), $l(M, M.return, z);
          }
          Es();
        }
        if (M === u) {
          In = null;
          return;
        }
        var A = M.sibling;
        if (A !== null) {
          wp(A, M.return), In = A;
          return;
        }
        In = M.return;
      }
    }
    function hx(u, f) {
      switch (f.tag) {
        case $:
        case he:
        case we: {
          if (f.mode & Br) {
            J0();
            try {
              dr(bl | Aa, f);
            } finally {
              Ag(f);
            }
          } else
            dr(bl | Aa, f);
          break;
        }
      }
    }
    function E_(u) {
      In = u, M_();
    }
    function M_() {
      for (; In !== null; ) {
        var u = In, f = u.child;
        if ((In.flags & Wr) !== Ne) {
          var M = u.deletions;
          if (M !== null) {
            for (var A = 0; A < M.length; A++) {
              var z = M[A];
              In = z, Zy(z, u);
            }
            {
              var j = u.alternate;
              if (j !== null) {
                var ne = j.child;
                if (ne !== null) {
                  j.child = null;
                  do {
                    var se = ne.sibling;
                    ne.sibling = null, ne = se;
                  } while (ne !== null);
                }
              }
            }
            In = u;
          }
        }
        (u.subtreeFlags & Ys) !== Ne && f !== null ? (wp(f, u), In = f) : _p();
      }
    }
    function _p() {
      for (; In !== null; ) {
        var u = In;
        (u.flags & Wi) !== Ne && (wi(u), bp(u), Es());
        var f = u.sibling;
        if (f !== null) {
          wp(f, u.return), In = f;
          return;
        }
        In = u.return;
      }
    }
    function bp(u) {
      switch (u.tag) {
        case $:
        case he:
        case we: {
          u.mode & Br ? (J0(), Ln(bl | Aa, u, u.return), Ag(u)) : Ln(bl | Aa, u, u.return);
          break;
        }
      }
    }
    function Zy(u, f) {
      for (; In !== null; ) {
        var M = In;
        wi(M), Hv(M, f), Es();
        var A = M.child;
        A !== null ? (wp(A, M), In = A) : Bv(u);
      }
    }
    function Bv(u) {
      for (; In !== null; ) {
        var f = In, M = f.sibling, A = f.return;
        if (Vu(f), f === u) {
          In = null;
          return;
        }
        if (M !== null) {
          wp(M, A), In = M;
          return;
        }
        In = A;
      }
    }
    function Hv(u, f) {
      switch (u.tag) {
        case $:
        case he:
        case we: {
          u.mode & Br ? (J0(), Ln(bl, u, f), Ag(u)) : Ln(bl, u, f);
          break;
        }
      }
    }
    var hT = !1;
    function wp(u, f) {
      !hT && u.return !== f && (hT = !0, m("Internal React error: Return pointer is inconsistent with parent.")), u.return = f;
    }
    function iR(u) {
      switch (u.tag) {
        case $:
        case he:
        case we: {
          try {
            dr(Ts | Aa, u);
          } catch (M) {
            g(M), $l(u, u.return, M);
          }
          break;
        }
        case W: {
          var f = u.stateNode;
          try {
            f.componentDidMount();
          } catch (M) {
            g(M), $l(u, u.return, M);
          }
          break;
        }
      }
    }
    function Jy(u) {
      switch (u.tag) {
        case $:
        case he:
        case we: {
          try {
            dr(bl | Aa, u);
          } catch (f) {
            g(f), $l(u, u.return, f);
          }
          break;
        }
      }
    }
    function pT(u) {
      switch (u.tag) {
        case $:
        case he:
        case we: {
          try {
            Ln(Ts | Aa, u, u.return);
          } catch (M) {
            g(M), $l(u, u.return, M);
          }
          break;
        }
        case W: {
          var f = u.stateNode;
          typeof f.componentWillUnmount == "function" && Z(u, u.return, f);
          break;
        }
      }
    }
    function Ww(u) {
      switch (u.tag) {
        case $:
        case he:
        case we:
          try {
            Ln(bl | Aa, u, u.return);
          } catch (f) {
            g(f), $l(u, u.return, f);
          }
      }
    }
    var Ky = 0, T_ = 1, px = 2, C_ = 3, R_ = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var cm = Symbol.for;
      Ky = cm("selector.component"), T_ = cm("selector.has_pseudo_class"), px = cm("selector.role"), C_ = cm("selector.test_id"), R_ = cm("selector.text");
    }
    function Qc(u) {
      return {
        $$typeof: Ky,
        value: u
      };
    }
    function Ep(u) {
      return {
        $$typeof: T_,
        value: u
      };
    }
    function fm(u) {
      return {
        $$typeof: px,
        value: u
      };
    }
    function $y(u) {
      return {
        $$typeof: R_,
        value: u
      };
    }
    function Hg(u) {
      return {
        $$typeof: C_,
        value: u
      };
    }
    function jw(u) {
      var f = Yf(u);
      if (f != null) {
        if (typeof f.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return f;
      } else {
        var M = Ka(u);
        if (M === null)
          throw new Error("Could not find React container within specified host subtree.");
        return M.stateNode.current;
      }
    }
    function A_(u, f) {
      switch (f.$$typeof) {
        case Ky:
          if (u.type === f.value)
            return !0;
          break;
        case T_:
          return aR(u, f.value);
        case px:
          if (u.tag === ce) {
            var M = u.stateNode;
            if (Qa(M, f.value))
              return !0;
          }
          break;
        case R_:
          if (u.tag === ce || u.tag === Ee) {
            var A = Rm(u);
            if (A !== null && A.indexOf(f.value) >= 0)
              return !0;
          }
          break;
        case C_:
          if (u.tag === ce) {
            var z = u.memoizedProps["data-testname"];
            if (typeof z == "string" && z.toLowerCase() === f.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function Yw(u) {
      switch (u.$$typeof) {
        case Ky:
          var f = at(u.value) || "Unknown";
          return "<" + f + ">";
        case T_:
          return ":has(" + (Yw(u) || "") + ")";
        case px:
          return '[role="' + u.value + '"]';
        case R_:
          return '"' + u.value + '"';
        case C_:
          return '[data-testname="' + u.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function mT(u, f) {
      for (var M = [], A = [u, 0], z = 0; z < A.length; ) {
        var j = A[z++], ne = A[z++], se = f[ne];
        if (!(j.tag === ce && mi(j))) {
          for (; se != null && A_(j, se); )
            ne++, se = f[ne];
          if (ne === f.length)
            M.push(j);
          else
            for (var Se = j.child; Se !== null; )
              A.push(Se, ne), Se = Se.sibling;
        }
      }
      return M;
    }
    function aR(u, f) {
      for (var M = [u, 0], A = 0; A < M.length; ) {
        var z = M[A++], j = M[A++], ne = f[j];
        if (!(z.tag === ce && mi(z))) {
          for (; ne != null && A_(z, ne); )
            j++, ne = f[j];
          if (j === f.length)
            return !0;
          for (var se = z.child; se !== null; )
            M.push(se, j), se = se.sibling;
        }
      }
      return !1;
    }
    function F1(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = jw(u), A = mT(M, f), z = [], j = Array.from(A), ne = 0; ne < j.length; ) {
        var se = j[ne++];
        if (se.tag === ce) {
          if (mi(se))
            continue;
          z.push(se.stateNode);
        } else
          for (var Se = se.child; Se !== null; )
            j.push(Se), Se = Se.sibling;
      }
      return z;
    }
    function vT(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = jw(u), A = 0, z = [], j = [M, 0], ne = 0; ne < j.length; ) {
        var se = j[ne++], Se = j[ne++], Pe = f[Se];
        if (!(se.tag === ce && mi(se)) && (A_(se, Pe) && (z.push(Yw(Pe)), Se++, Se > A && (A = Se)), Se < f.length))
          for (var Ge = se.child; Ge !== null; )
            j.push(Ge, Se), Ge = Ge.sibling;
      }
      if (A < f.length) {
        for (var yt = [], It = A; It < f.length; It++)
          yt.push(Yw(f[It]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + z.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + yt.join(" > "));
      }
      return null;
    }
    function Xw(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = F1(u, f), A = [], z = 0; z < M.length; z++)
        A.push(Xi(M[z]));
      for (var j = A.length - 1; j > 0; j--)
        for (var ne = A[j], se = ne.x, Se = se + ne.width, Pe = ne.y, Ge = Pe + ne.height, yt = j - 1; yt >= 0; yt--)
          if (j !== yt) {
            var It = A[yt], jt = It.x, dn = jt + It.width, Sn = It.y, Tr = Sn + It.height;
            if (se >= jt && Pe >= Sn && Se <= dn && Ge <= Tr) {
              A.splice(j, 1);
              break;
            } else if (se === jt && ne.width === It.width && !(Tr < Pe) && !(Sn > Ge)) {
              Sn > Pe && (It.height += Sn - Pe, It.y = Pe), Tr < Ge && (It.height = Ge - Sn), A.splice(j, 1);
              break;
            } else if (Pe === Sn && ne.height === It.height && !(dn < se) && !(jt > Se)) {
              jt > se && (It.width += jt - se, It.x = se), dn < Se && (It.width = Se - jt), A.splice(j, 1);
              break;
            }
          }
      return A;
    }
    function gT(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = jw(u), A = mT(M, f), z = Array.from(A), j = 0; j < z.length; ) {
        var ne = z[j++];
        if (!mi(ne)) {
          if (ne.tag === ce) {
            var se = ne.stateNode;
            if (Sc(se))
              return !0;
          }
          for (var Se = ne.child; Se !== null; )
            z.push(Se), Se = Se.sibling;
        }
      }
      return !1;
    }
    var k1 = [];
    function qw() {
      yo && k1.forEach(function(u) {
        return u();
      });
    }
    function Qw(u, f, M, A) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      var z = F1(u, f), j = dl(z, M, A), ne = j.disconnect, se = j.observe, Se = j.unobserve, Pe = function() {
        var Ge = F1(u, f);
        z.forEach(function(yt) {
          Ge.indexOf(yt) < 0 && Se(yt);
        }), Ge.forEach(function(yt) {
          z.indexOf(yt) < 0 && se(yt);
        });
      };
      return k1.push(Pe), {
        disconnect: function() {
          var Ge = k1.indexOf(Pe);
          Ge >= 0 && k1.splice(Ge, 1), ne();
        }
      };
    }
    var Zw = o.ReactCurrentActQueue;
    function sR(u) {
      {
        var f = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, M = typeof jest < "u";
        return jf && M && f !== !1;
      }
    }
    function yT() {
      {
        var u = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !u && Zw.current !== null && m("The current testing environment is not configured to support act(...)"), u;
      }
    }
    var oR = Math.ceil, Jw = o.ReactCurrentDispatcher, D_ = o.ReactCurrentOwner, ao = o.ReactCurrentBatchConfig, dm = o.ReactCurrentActQueue, Kl = 0, Vg = 1, Zc = 2, Ws = 4, hm = 0, I1 = 1, e0 = 2, L_ = 3, bd = 4, xT = 5, Vv = 6, di = Kl, xu = null, js = null, ul = an, eh = an, t0 = Mn(an), Ro = hm, Gg = null, B1 = an, wd = an, mx = an, n0 = null, Jc = null, Wg = 0, P_ = 500, H1 = 1 / 0, O_ = 500;
    function r0() {
      H1 = da() + O_;
    }
    function Kw() {
      return H1;
    }
    var V1 = !1, G1 = null, jg = null, i0 = !1, Gv = null, nv = an, El = [], a0 = 50, s0 = 0, $w = null, ST = 50, U_ = 0, W1 = Bi, Kc = an;
    function z_() {
      return xu;
    }
    function yc() {
      return (di & (Zc | Ws)) !== Kl ? da() : (W1 !== Bi || (W1 = da()), W1);
    }
    function Wv(u) {
      var f = u.mode;
      if ((f & $i) === Mr)
        return Hr;
      if ((di & Zc) !== Kl && ul !== an)
        return cu(ul);
      var M = Rf() !== Cf;
      if (M) {
        if (ao.transition !== null) {
          var A = ao.transition;
          A._updatedFibers || (A._updatedFibers = /* @__PURE__ */ new Set()), A._updatedFibers.add(u);
        }
        return Kc === Ir && (Kc = bo()), Kc;
      }
      var z = rl();
      if (z !== Ir)
        return z;
      var j = Eu();
      return j;
    }
    function _T(u) {
      var f = u.mode;
      return (f & $i) === Mr ? Hr : Kh();
    }
    function Ml(u, f, M) {
      LT();
      var A = o0(u, f);
      return A === null ? null : (wo(A, f, M), (di & Zc) !== an && A === xu ? bx(u) : (ns && ga(A, u, f), UT(u), A === xu && ((di & Zc) === Kl && (wd = zr(wd, f)), Ro === bd && iv(A, ul)), $c(A, M), f === Hr && di === Kl && (u.mode & $i) === Mr && !dm.isBatchingLegacy && (r0(), Ha())), A);
    }
    function eE(u, f, M) {
      var A = u.current;
      A.lanes = f, wo(u, f, M), $c(u, M);
    }
    function o0(u, f) {
      u.lanes = zr(u.lanes, f);
      var M = u.alternate;
      M !== null && (M.lanes = zr(M.lanes, f)), M === null && (u.flags & (Pt | ni)) !== Ne && Sx(u);
      for (var A = u, z = u.return; z !== null; )
        z.childLanes = zr(z.childLanes, f), M = z.alternate, M !== null ? M.childLanes = zr(M.childLanes, f) : (z.flags & (Pt | ni)) !== Ne && Sx(u), A = z, z = z.return;
      if (A.tag === ie) {
        var j = A.stateNode;
        return j;
      } else
        return null;
    }
    function N_(u, f) {
      return xu !== null && (u.mode & $i) !== Mr && (di & Zc) === Kl;
    }
    function $c(u, f) {
      var M = u.callbackNode;
      hs(u, f);
      var A = zi(u, u === xu ? ul : an);
      if (A === an) {
        M !== null && OT(M), u.callbackNode = null, u.callbackPriority = Ir;
        return;
      }
      var z = lc(A), j = u.callbackPriority;
      if (j === z && !(dm.current !== null && M !== q_)) {
        M == null && j !== Hr && m("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      M != null && OT(M);
      var ne;
      if (z === Hr)
        u.tag === Mc ? (dm.isBatchingLegacy !== null && (dm.didScheduleLegacyUpdate = !0), Fc(bT.bind(null, u))) : lr(bT.bind(null, u)), Cr ? dm.current !== null ? dm.current.push(jo) : fl(function() {
          di === Kl && jo();
        }) : wx(Hi, jo), ne = null;
      else {
        var se;
        switch (Bl(A)) {
          case Us:
            se = Hi;
            break;
          case sd:
            se = wn;
            break;
          case Il:
            se = Qi;
            break;
          case Vo:
            se = ya;
            break;
          default:
            se = Qi;
            break;
        }
        ne = wx(se, F_.bind(null, u));
      }
      u.callbackPriority = z, u.callbackNode = ne;
    }
    function F_(u, f) {
      if (Rg(), W1 = Bi, Kc = an, (di & (Zc | Ws)) !== Kl)
        throw new Error("Should not already be working.");
      var M = u.callbackNode, A = av();
      if (A && u.callbackNode !== M)
        return null;
      var z = zi(u, u === xu ? ul : an);
      if (z === an)
        return null;
      var j = !Ho(u, z) && !Sv(u, z) && !f, ne = j ? uR(u, z) : yx(u, z);
      if (ne !== hm) {
        if (ne === e0) {
          var se = Nl(u);
          se !== an && (z = se, ne = k_(u, se));
        }
        if (ne === I1) {
          var Se = Gg;
          throw jv(u, an), iv(u, z), $c(u, da()), Se;
        }
        if (ne === Vv)
          iv(u, z);
        else {
          var Pe = !Ho(u, z), Ge = u.current.alternate;
          if (Pe && !I_(Ge)) {
            if (ne = yx(u, z), ne === e0) {
              var yt = Nl(u);
              yt !== an && (z = yt, ne = k_(u, yt));
            }
            if (ne === I1) {
              var It = Gg;
              throw jv(u, an), iv(u, z), $c(u, da()), It;
            }
          }
          u.finishedWork = Ge, u.finishedLanes = z, Yg(u, ne, z);
        }
      }
      return $c(u, da()), u.callbackNode === M ? F_.bind(null, u) : null;
    }
    function k_(u, f) {
      var M = n0;
      if (Di(u)) {
        var A = jv(u, f);
        A.flags |= jr, Za(u.containerInfo);
      }
      var z = yx(u, f);
      if (z !== e0) {
        var j = Jc;
        Jc = M, j !== null && rv(j);
      }
      return z;
    }
    function rv(u) {
      Jc === null ? Jc = u : Jc.push.apply(Jc, u);
    }
    function Yg(u, f, M) {
      switch (f) {
        case hm:
        case I1:
          throw new Error("Root did not complete. This is a bug in React.");
        case e0: {
          Xg(u, Jc);
          break;
        }
        case L_: {
          if (iv(u, M), _f(M) && !hE()) {
            var A = Wg + P_ - da();
            if (A > 10) {
              var z = zi(u, an);
              if (z !== an)
                break;
              var j = u.suspendedLanes;
              if (!uc(j, M)) {
                yc(), wh(u, j);
                break;
              }
              u.timeoutHandle = qh(Xg.bind(null, u, Jc), A);
              break;
            }
          }
          Xg(u, Jc);
          break;
        }
        case bd: {
          if (iv(u, M), Wd(M))
            break;
          if (!hE()) {
            var ne = Pc(u, M), se = ne, Se = da() - se, Pe = xx(Se) - Se;
            if (Pe > 10) {
              u.timeoutHandle = qh(Xg.bind(null, u, Jc), Pe);
              break;
            }
          }
          Xg(u, Jc);
          break;
        }
        case xT: {
          Xg(u, Jc);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function I_(u) {
      for (var f = u; ; ) {
        if (f.flags & Te) {
          var M = f.updateQueue;
          if (M !== null) {
            var A = M.stores;
            if (A !== null)
              for (var z = 0; z < A.length; z++) {
                var j = A[z], ne = j.getSnapshot, se = j.value;
                try {
                  if (!Eo(ne(), se))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var Se = f.child;
        if (f.subtreeFlags & Te && Se !== null) {
          Se.return = f, f = Se;
          continue;
        }
        if (f === u)
          return !0;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === u)
            return !0;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return !0;
    }
    function iv(u, f) {
      f = Js(f, mx), f = Js(f, wd), Nm(u, f);
    }
    function bT(u) {
      if (Nv(), (di & (Zc | Ws)) !== Kl)
        throw new Error("Should not already be working.");
      av();
      var f = zi(u, an);
      if (!Vr(f, Hr))
        return $c(u, da()), null;
      var M = yx(u, f);
      if (u.tag !== Mc && M === e0) {
        var A = Nl(u);
        A !== an && (f = A, M = k_(u, A));
      }
      if (M === I1) {
        var z = Gg;
        throw jv(u, an), iv(u, f), $c(u, da()), z;
      }
      if (M === Vv)
        throw new Error("Root did not complete. This is a bug in React.");
      var j = u.current.alternate;
      return u.finishedWork = j, u.finishedLanes = f, Xg(u, Jc), $c(u, da()), null;
    }
    function B_(u, f) {
      f !== an && (bs(u, zr(f, Hr)), $c(u, da()), (di & (Zc | Ws)) === Kl && (r0(), jo()));
    }
    function lR(u) {
      var f = rl(), M = ao.transition;
      try {
        return ao.transition = null, zs(Il), u();
      } finally {
        zs(f), ao.transition = M;
      }
    }
    function wT(u, f) {
      var M = di;
      di |= Vg;
      try {
        return u(f);
      } finally {
        di = M, di === Kl && !dm.isBatchingLegacy && (r0(), Ha());
      }
    }
    function H_(u, f, M, A, z) {
      var j = rl(), ne = ao.transition;
      try {
        return ao.transition = null, zs(Us), u(f, M, A, z);
      } finally {
        zs(j), ao.transition = ne, di === Kl && r0();
      }
    }
    function j1(u) {
      Gv !== null && Gv.tag === Mc && (di & (Zc | Ws)) === Kl && av();
      var f = di;
      di |= Vg;
      var M = ao.transition, A = rl();
      try {
        return ao.transition = null, zs(Us), u ? u() : void 0;
      } finally {
        zs(A), ao.transition = M, di = f, (di & (Zc | Ws)) === Kl && jo();
      }
    }
    function tE() {
      return (di & (Zc | Ws)) !== Kl;
    }
    function ET(u) {
      var f = di;
      di |= Vg;
      var M = ao.transition, A = rl();
      try {
        ao.transition = null, zs(Us), u();
      } finally {
        zs(A), ao.transition = M, di = f, di === Kl && (r0(), jo());
      }
    }
    function vx(u, f) {
      or(t0, eh, u), eh = zr(eh, f);
    }
    function Y1(u) {
      eh = t0.current, Kn(t0, u);
    }
    function jv(u, f) {
      u.finishedWork = null, u.finishedLanes = an;
      var M = u.timeoutHandle;
      if (M !== ri && (u.timeoutHandle = ri, Dl(M)), js !== null)
        for (var A = js.return; A !== null; ) {
          var z = A.alternate;
          O1(z, A), A = A.return;
        }
      xu = u;
      var j = oa(u.current, null);
      return js = j, ul = eh = f, Ro = hm, Gg = null, B1 = an, wd = an, mx = an, n0 = null, Jc = null, _a(), Xl.discardPendingWarnings(), j;
    }
    function V_(u, f) {
      do {
        var M = js;
        try {
          if (x(), un(), Es(), D_.current = null, M === null || M.return === null) {
            Ro = I1, Gg = f, js = null;
            return;
          }
          if (X && M.mode & Br && Fv(M, !0), I)
            if (cc(), f !== null && typeof f == "object" && typeof f.then == "function") {
              var A = f;
              ud(M, A, ul);
            } else
              Gl(M, f, ul);
          Sw(u, M.return, M, f, ul), RT(M);
        } catch (z) {
          f = z, js === M && M !== null ? (M = M.return, js = M) : M = js;
          continue;
        }
        return;
      } while (!0);
    }
    function G_() {
      var u = Jw.current;
      return Jw.current = X0, u === null ? X0 : u;
    }
    function nE(u) {
      Jw.current = u;
    }
    function W_() {
      Wg = da();
    }
    function gx(u) {
      B1 = zr(u, B1);
    }
    function rE() {
      Ro === hm && (Ro = L_);
    }
    function X1() {
      (Ro === hm || Ro === L_ || Ro === e0) && (Ro = bd), xu !== null && (Fl(B1) || Fl(wd)) && iv(xu, ul);
    }
    function MT(u) {
      Ro !== bd && (Ro = e0), n0 === null ? n0 = [u] : n0.push(u);
    }
    function iE() {
      return Ro === hm;
    }
    function yx(u, f) {
      var M = di;
      di |= Zc;
      var A = G_();
      if (xu !== u || ul !== f) {
        if (ns) {
          var z = u.memoizedUpdaters;
          z.size > 0 && (l0(u, ul), z.clear()), fu(u, f);
        }
        jv(u, f);
      }
      Yr(f);
      do
        try {
          TT();
          break;
        } catch (j) {
          V_(u, j);
        }
      while (!0);
      if (x(), di = M, nE(A), js !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return fi(), xu = null, ul = an, Ro;
    }
    function TT() {
      for (; js !== null; )
        aE(js);
    }
    function uR(u, f) {
      var M = di;
      di |= Zc;
      var A = G_();
      if (xu !== u || ul !== f) {
        if (ns) {
          var z = u.memoizedUpdaters;
          z.size > 0 && (l0(u, ul), z.clear()), fu(u, f);
        }
        r0(), jv(u, f);
      }
      Yr(f);
      do
        try {
          CT();
          break;
        } catch (j) {
          V_(u, j);
        }
      while (!0);
      return x(), nE(A), di = M, js !== null ? (fr(), hm) : (fi(), xu = null, ul = an, Ro);
    }
    function CT() {
      for (; js !== null && !Ks(); )
        aE(js);
    }
    function aE(u) {
      var f = u.alternate;
      wi(u);
      var M;
      (u.mode & Br) !== Mr ? (im(u), M = _x(f, u, eh), Fv(u, !0)) : M = _x(f, u, eh), Es(), u.memoizedProps = u.pendingProps, M === null ? RT(u) : js = M, D_.current = null;
    }
    function RT(u) {
      var f = u;
      do {
        var M = f.alternate, A = f.return;
        if ((f.flags & Oe) === Ne) {
          wi(f);
          var z = void 0;
          if ((f.mode & Br) === Mr ? z = y1(M, f, eh) : (im(f), z = y1(M, f, eh), Fv(f, !1)), Es(), z !== null) {
            js = z;
            return;
          }
        } else {
          var j = Nw(M, f);
          if (j !== null) {
            j.flags &= me, js = j;
            return;
          }
          if ((f.mode & Br) !== Mr) {
            Fv(f, !1);
            for (var ne = f.actualDuration, se = f.child; se !== null; )
              ne += se.actualDuration, se = se.sibling;
            f.actualDuration = ne;
          }
          if (A !== null)
            A.flags |= Oe, A.subtreeFlags = Ne, A.deletions = null;
          else {
            Ro = Vv, js = null;
            return;
          }
        }
        var Se = f.sibling;
        if (Se !== null) {
          js = Se;
          return;
        }
        f = A, js = f;
      } while (f !== null);
      Ro === hm && (Ro = xT);
    }
    function Xg(u, f) {
      var M = rl(), A = ao.transition;
      try {
        ao.transition = null, zs(Us), sE(u, f, M);
      } finally {
        ao.transition = A, zs(M);
      }
      return null;
    }
    function sE(u, f, M) {
      do
        av();
      while (Gv !== null);
      if (fR(), (di & (Zc | Ws)) !== Kl)
        throw new Error("Should not already be working.");
      var A = u.finishedWork, z = u.finishedLanes;
      if (ws(z), A === null)
        return Xd(), null;
      if (z === an && m("root.finishedLanes should not be empty during a commit. This is a bug in React."), u.finishedWork = null, u.finishedLanes = an, A === u.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      u.callbackNode = null, u.callbackPriority = Ir;
      var j = zr(A.lanes, A.childLanes);
      Ou(u, j), u === xu && (xu = null, js = null, ul = an), ((A.subtreeFlags & Ys) !== Ne || (A.flags & Ys) !== Ne) && (i0 || (i0 = !0, wx(Qi, function() {
        return av(), null;
      })));
      var ne = (A.subtreeFlags & (br | Yi | La | Ys)) !== Ne, se = (A.flags & (br | Yi | La | Ys)) !== Ne;
      if (ne || se) {
        var Se = ao.transition;
        ao.transition = null;
        var Pe = rl();
        zs(Us);
        var Ge = di;
        di |= Ws, D_.current = null, tn(u, A), h1(), lT(u, A, z), vo(u.containerInfo), u.current = A, Wl(z), Ig(A, u, z), Eh(), Yd(), di = Ge, zs(Pe), ao.transition = Se;
      } else
        u.current = A, h1();
      var yt = i0;
      if (i0 && (i0 = !1, Gv = u, nv = z), j = u.pendingLanes, j === an && (jg = null), yt || PT(u.current, !1), Kr(A.stateNode, M), ns && u.memoizedUpdaters.clear(), qw(), $c(u, da()), f !== null)
        for (var It = u.onRecoverableError, jt = 0; jt < f.length; jt++) {
          var dn = f[jt];
          It(dn);
        }
      if (V1) {
        V1 = !1;
        var Sn = G1;
        throw G1 = null, Sn;
      }
      return Vr(nv, Hr) && u.tag !== Mc && av(), j = u.pendingLanes, Vr(j, Hr) ? (kf(), u === $w ? s0++ : (s0 = 0, $w = u)) : s0 = 0, jo(), Xd(), null;
    }
    function av() {
      if (Gv !== null) {
        var u = Bl(nv), f = Hp(Il, u), M = ao.transition, A = rl();
        try {
          return ao.transition = null, zs(f), oE();
        } finally {
          zs(A), ao.transition = M;
        }
      }
      return !1;
    }
    function cR(u) {
      El.push(u), i0 || (i0 = !0, wx(Qi, function() {
        return av(), null;
      }));
    }
    function oE() {
      if (Gv === null)
        return !1;
      var u = Gv, f = nv;
      if (Gv = null, nv = an, (di & (Zc | Ws)) !== Kl)
        throw new Error("Cannot flush passive effects while already rendering.");
      fc(f);
      var M = di;
      di |= Ws, E_(u.current), dT(u, u.current);
      {
        var A = El;
        El = [];
        for (var z = 0; z < A.length; z++) {
          var j = A[z];
          gi(u, j);
        }
      }
      hr(), PT(u.current, !0), di = M, jo(), U_ = Gv === null ? 0 : U_ + 1, Ra(u);
      {
        var ne = u.current.stateNode;
        ne.effectDuration = 0, ne.passiveEffectDuration = 0;
      }
      return !0;
    }
    function j_(u) {
      return jg !== null && jg.has(u);
    }
    function lE(u) {
      jg === null ? jg = /* @__PURE__ */ new Set([u]) : jg.add(u);
    }
    function uE(u) {
      V1 || (V1 = !0, G1 = u);
    }
    var cE = uE;
    function fE(u, f, M) {
      var A = Ny(M, f), z = Fy(u, A, Hr);
      Ar(u, z);
      var j = yc(), ne = o0(u, Hr);
      ne !== null && (wo(ne, Hr, j), $c(ne, j));
    }
    function $l(u, f, M) {
      if (u.tag === ie) {
        fE(u, u, M);
        return;
      }
      var A = null;
      for (A = f; A !== null; ) {
        if (A.tag === ie) {
          fE(A, u, M);
          return;
        } else if (A.tag === W) {
          var z = A.type, j = A.stateNode;
          if (typeof z.getDerivedStateFromError == "function" || typeof j.componentDidCatch == "function" && !j_(j)) {
            var ne = Ny(M, u), se = Km(A, ne, Hr);
            Ar(A, se);
            var Se = yc(), Pe = o0(A, Hr);
            Pe !== null && (wo(Pe, Hr, Se), $c(Pe, Se));
            return;
          }
        }
        A = A.return;
      }
      m(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, M);
    }
    function Y_(u, f, M) {
      var A = u.pingCache;
      A !== null && A.delete(f);
      var z = yc();
      wh(u, M), Z1(u), xu === u && uc(ul, M) && (Ro === bd || Ro === L_ && _f(ul) && da() - Wg < P_ ? jv(u, an) : mx = zr(mx, M)), $c(u, z);
    }
    function q1(u, f) {
      f === Ir && (f = _T(u));
      var M = yc(), A = o0(u, f);
      A !== null && (wo(A, f, M), $c(A, M));
    }
    function AT(u) {
      var f = u.memoizedState, M = Ir;
      f !== null && (M = f.retryLane), q1(u, M);
    }
    function DT(u, f) {
      var M = Ir, A;
      switch (u.tag) {
        case ue:
          A = u.stateNode;
          var z = u.memoizedState;
          z !== null && (M = z.retryLane);
          break;
        case Ue:
          A = u.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      A !== null && A.delete(f), q1(u, M);
    }
    function xx(u) {
      return u < 120 ? 120 : u < 480 ? 480 : u < 1080 ? 1080 : u < 1920 ? 1920 : u < 3e3 ? 3e3 : u < 4320 ? 4320 : oR(u / 1960) * 1960;
    }
    function LT() {
      if (s0 > a0)
        throw s0 = 0, $w = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      U_ > ST && (U_ = 0, m("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function fR() {
      Xl.flushLegacyContextWarning(), Xl.flushPendingUnsafeLifecycleWarnings();
    }
    function PT(u, f) {
      wi(u), qg(u, Zn, pT), f && qg(u, nr, Ww), qg(u, Zn, iR), f && qg(u, nr, Jy), Es();
    }
    function qg(u, f, M) {
      for (var A = u, z = null; A !== null; ) {
        var j = A.subtreeFlags & f;
        A !== z && A.child !== null && j !== Ne ? A = A.child : ((A.flags & f) !== Ne && M(A), A.sibling !== null ? A = A.sibling : A = z = A.return);
      }
    }
    var pm = null;
    function Sx(u) {
      {
        if ((di & Zc) !== Kl || !(u.mode & $i))
          return;
        var f = u.tag;
        if (f !== ee && f !== ie && f !== W && f !== $ && f !== he && f !== ye && f !== we)
          return;
        var M = Tt(u) || "ReactComponent";
        if (pm !== null) {
          if (pm.has(M))
            return;
          pm.add(M);
        } else
          pm = /* @__PURE__ */ new Set([M]);
        var A = $s;
        try {
          wi(u), m("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          A ? wi(u) : Es();
        }
      }
    }
    var _x;
    {
      var X_ = null;
      _x = function(u, f, M) {
        var A = d0(X_, f);
        try {
          return m_(u, f, M);
        } catch (j) {
          if (j !== null && typeof j == "object" && typeof j.then == "function")
            throw j;
          if (x(), un(), O1(u, f), d0(f, A), f.mode & Br && im(f), y_(null, m_, null, u, f, M), Iw()) {
            var z = x_();
            typeof z == "object" && z !== null && z._suppressLogging && typeof j == "object" && j !== null && !j._suppressLogging && (j._suppressLogging = !0);
          }
          throw j;
        }
      };
    }
    var dE = !1, Q1;
    Q1 = /* @__PURE__ */ new Set();
    function bx(u) {
      if (Yl && !d1())
        switch (u.tag) {
          case $:
          case he:
          case we: {
            var f = js && Tt(js) || "Unknown", M = f;
            if (!Q1.has(M)) {
              Q1.add(M);
              var A = Tt(u) || "Unknown";
              m("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", A, f, f);
            }
            break;
          }
          case W: {
            dE || (m("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), dE = !0);
            break;
          }
        }
    }
    function l0(u, f) {
      if (ns) {
        var M = u.memoizedUpdaters;
        M.forEach(function(A) {
          ga(u, A, f);
        });
      }
    }
    var q_ = {};
    function wx(u, f) {
      {
        var M = dm.current;
        return M !== null ? (M.push(f), q_) : $h(u, f);
      }
    }
    function OT(u) {
      if (u !== q_)
        return bf(u);
    }
    function hE() {
      return dm.current !== null;
    }
    function UT(u) {
      {
        if (u.mode & $i) {
          if (!yT())
            return;
        } else if (!sR() || di !== Kl || u.tag !== $ && u.tag !== he && u.tag !== we)
          return;
        if (dm.current === null) {
          var f = $s;
          try {
            wi(u), m(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Tt(u));
          } finally {
            f ? wi(u) : Es();
          }
        }
      }
    }
    function Z1(u) {
      u.tag !== Mc && yT() && dm.current === null && m(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Tl = null, Qg = null, Ex = function(u) {
      Tl = u;
    };
    function Zg(u) {
      {
        if (Tl === null)
          return u;
        var f = Tl(u);
        return f === void 0 ? u : f.current;
      }
    }
    function pE(u) {
      return Zg(u);
    }
    function sv(u) {
      {
        if (Tl === null)
          return u;
        var f = Tl(u);
        if (f === void 0) {
          if (u != null && typeof u.render == "function") {
            var M = Zg(u.render);
            if (u.render !== M) {
              var A = {
                $$typeof: Vt,
                render: M
              };
              return u.displayName !== void 0 && (A.displayName = u.displayName), A;
            }
          }
          return u;
        }
        return f.current;
      }
    }
    function u0(u, f) {
      {
        if (Tl === null)
          return !1;
        var M = u.elementType, A = f.type, z = !1, j = typeof A == "object" && A !== null ? A.$$typeof : null;
        switch (u.tag) {
          case W: {
            typeof A == "function" && (z = !0);
            break;
          }
          case $: {
            (typeof A == "function" || j === oe) && (z = !0);
            break;
          }
          case he: {
            (j === Vt || j === oe) && (z = !0);
            break;
          }
          case ye:
          case we: {
            (j === Me || j === oe) && (z = !0);
            break;
          }
          default:
            return !1;
        }
        if (z) {
          var ne = Tl(M);
          if (ne !== void 0 && ne === Tl(A))
            return !0;
        }
        return !1;
      }
    }
    function zT(u) {
      {
        if (Tl === null || typeof WeakSet != "function")
          return;
        Qg === null && (Qg = /* @__PURE__ */ new WeakSet()), Qg.add(u);
      }
    }
    var Q_ = function(u, f) {
      {
        if (Tl === null)
          return;
        var M = f.staleFamilies, A = f.updatedFamilies;
        av(), j1(function() {
          eu(u.current, A, M);
        });
      }
    }, th = function(u, f) {
      {
        if (u.context !== $n)
          return;
        av(), j1(function() {
          J_(f, u, null, null);
        });
      }
    };
    function eu(u, f, M) {
      {
        var A = u.alternate, z = u.child, j = u.sibling, ne = u.tag, se = u.type, Se = null;
        switch (ne) {
          case $:
          case we:
          case W:
            Se = se;
            break;
          case he:
            Se = se.render;
            break;
        }
        if (Tl === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Pe = !1, Ge = !1;
        if (Se !== null) {
          var yt = Tl(Se);
          yt !== void 0 && (M.has(yt) ? Ge = !0 : f.has(yt) && (ne === W ? Ge = !0 : Pe = !0));
        }
        Qg !== null && (Qg.has(u) || A !== null && Qg.has(A)) && (Ge = !0), Ge && (u._debugNeedsRemount = !0), (Ge || Pe) && Ml(u, Hr, Bi), z !== null && !Ge && eu(z, f, M), j !== null && eu(j, f, M);
      }
    }
    var ov = function(u, f) {
      {
        var M = /* @__PURE__ */ new Set(), A = new Set(f.map(function(z) {
          return z.current;
        }));
        return tu(u.current, A, M), M;
      }
    };
    function tu(u, f, M) {
      {
        var A = u.child, z = u.sibling, j = u.tag, ne = u.type, se = null;
        switch (j) {
          case $:
          case we:
          case W:
            se = ne;
            break;
          case he:
            se = ne.render;
            break;
        }
        var Se = !1;
        se !== null && f.has(se) && (Se = !0), Se ? ef(u, M) : A !== null && tu(A, f, M), z !== null && tu(z, f, M);
      }
    }
    function ef(u, f) {
      {
        var M = mE(u, f);
        if (M)
          return;
        for (var A = u; ; ) {
          switch (A.tag) {
            case ce:
              f.add(A.stateNode);
              return;
            case pe:
              f.add(A.stateNode.containerInfo);
              return;
            case ie:
              f.add(A.stateNode.containerInfo);
              return;
          }
          if (A.return === null)
            throw new Error("Expected to reach root first.");
          A = A.return;
        }
      }
    }
    function mE(u, f) {
      for (var M = u, A = !1; ; ) {
        if (M.tag === ce)
          A = !0, f.add(M.stateNode);
        else if (M.child !== null) {
          M.child.return = M, M = M.child;
          continue;
        }
        if (M === u)
          return A;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === u)
            return A;
          M = M.return;
        }
        M.sibling.return = M.return, M = M.sibling;
      }
      return !1;
    }
    var J1;
    {
      J1 = !1;
      try {
        var NT = Object.preventExtensions({});
      } catch {
        J1 = !0;
      }
    }
    function jn(u, f, M, A) {
      this.tag = u, this.key = M, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = f, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = A, this.flags = Ne, this.subtreeFlags = Ne, this.deletions = null, this.lanes = an, this.childLanes = an, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !J1 && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var tf = function(u, f, M, A) {
      return new jn(u, f, M, A);
    };
    function K1(u) {
      var f = u.prototype;
      return !!(f && f.isReactComponent);
    }
    function Mx(u) {
      return typeof u == "function" && !K1(u) && u.defaultProps === void 0;
    }
    function c0(u) {
      if (typeof u == "function")
        return K1(u) ? W : $;
      if (u != null) {
        var f = u.$$typeof;
        if (f === Vt)
          return he;
        if (f === Me)
          return ye;
      }
      return ee;
    }
    function oa(u, f) {
      var M = u.alternate;
      M === null ? (M = tf(u.tag, f, u.key, u.mode), M.elementType = u.elementType, M.type = u.type, M.stateNode = u.stateNode, M._debugSource = u._debugSource, M._debugOwner = u._debugOwner, M._debugHookTypes = u._debugHookTypes, M.alternate = u, u.alternate = M) : (M.pendingProps = f, M.type = u.type, M.flags = Ne, M.subtreeFlags = Ne, M.deletions = null, M.actualDuration = 0, M.actualStartTime = -1), M.flags = u.flags & $t, M.childLanes = u.childLanes, M.lanes = u.lanes, M.child = u.child, M.memoizedProps = u.memoizedProps, M.memoizedState = u.memoizedState, M.updateQueue = u.updateQueue;
      var A = u.dependencies;
      switch (M.dependencies = A === null ? null : {
        lanes: A.lanes,
        firstContext: A.firstContext
      }, M.sibling = u.sibling, M.index = u.index, M.ref = u.ref, M.selfBaseDuration = u.selfBaseDuration, M.treeBaseDuration = u.treeBaseDuration, M._debugNeedsRemount = u._debugNeedsRemount, M.tag) {
        case ee:
        case $:
        case we:
          M.type = Zg(u.type);
          break;
        case W:
          M.type = pE(u.type);
          break;
        case he:
          M.type = sv(u.type);
          break;
      }
      return M;
    }
    function Wu(u, f) {
      u.flags &= $t | Pt;
      var M = u.alternate;
      if (M === null)
        u.childLanes = an, u.lanes = f, u.child = null, u.subtreeFlags = Ne, u.memoizedProps = null, u.memoizedState = null, u.updateQueue = null, u.dependencies = null, u.stateNode = null, u.selfBaseDuration = 0, u.treeBaseDuration = 0;
      else {
        u.childLanes = M.childLanes, u.lanes = M.lanes, u.child = M.child, u.subtreeFlags = Ne, u.deletions = null, u.memoizedProps = M.memoizedProps, u.memoizedState = M.memoizedState, u.updateQueue = M.updateQueue, u.type = M.type;
        var A = M.dependencies;
        u.dependencies = A === null ? null : {
          lanes: A.lanes,
          firstContext: A.firstContext
        }, u.selfBaseDuration = M.selfBaseDuration, u.treeBaseDuration = M.treeBaseDuration;
      }
      return u;
    }
    function ju(u, f, M) {
      var A;
      return u === Tc ? (A = $i, f === !0 && (A |= Fa, A |= So)) : A = Mr, ns && (A |= Br), tf(ie, null, null, A);
    }
    function Tx(u, f, M, A, z, j) {
      var ne = ee, se = u;
      if (typeof u == "function")
        K1(u) ? (ne = W, se = pE(se)) : se = Zg(se);
      else if (typeof u == "string")
        ne = ce;
      else {
        e:
          switch (u) {
            case mt:
              return Mp(M.children, z, j, f);
            case vt:
              ne = Fe, z |= Fa, (z & $i) !== Mr && (z |= So);
              break;
            case bt:
              return dR(M, z, j, f);
            case Jt:
              return hR(M, z, j, f);
            case Mt:
              return en(M, z, j, f);
            case zt:
              return zh(M, z, j, f);
            case Nt:
            case je:
            case Ut:
            case tt:
            case lt:
            default: {
              if (typeof u == "object" && u !== null)
                switch (u.$$typeof) {
                  case Qt:
                    ne = Be;
                    break e;
                  case ft:
                    ne = Ce;
                    break e;
                  case Vt:
                    ne = he, se = sv(se);
                    break e;
                  case Me:
                    ne = ye;
                    break e;
                  case oe:
                    ne = Xe, se = null;
                    break e;
                }
              var Se = "";
              {
                (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (Se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Pe = A ? Tt(A) : null;
                Pe && (Se += `

Check the render method of \`` + Pe + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (u == null ? u : typeof u) + "." + Se));
            }
          }
      }
      var Ge = tf(ne, M, f, z);
      return Ge.elementType = u, Ge.type = se, Ge.lanes = j, Ge._debugOwner = A, Ge;
    }
    function f0(u, f, M) {
      var A = null;
      A = u._owner;
      var z = u.type, j = u.key, ne = u.props, se = Tx(z, j, ne, A, f, M);
      return se._debugSource = u._source, se._debugOwner = u._owner, se;
    }
    function Mp(u, f, M, A) {
      var z = tf(de, u, A, f);
      return z.lanes = M, z;
    }
    function dR(u, f, M, A) {
      typeof u.id != "string" && m('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof u.id);
      var z = tf(fe, u, A, f | Br);
      return z.elementType = bt, z.lanes = M, z.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, z;
    }
    function hR(u, f, M, A) {
      var z = tf(ue, u, A, f);
      return z.elementType = Jt, z.lanes = M, z;
    }
    function en(u, f, M, A) {
      var z = tf(Ue, u, A, f);
      return z.elementType = Mt, z.lanes = M, z;
    }
    function zh(u, f, M, A) {
      var z = tf(rt, u, A, f);
      z.elementType = zt, z.lanes = M;
      var j = {};
      return z.stateNode = j, z;
    }
    function lv(u, f, M) {
      var A = tf(Ee, u, null, f);
      return A.lanes = M, A;
    }
    function vE() {
      var u = tf(ce, null, null, Mr);
      return u.elementType = "DELETED", u;
    }
    function Wa(u) {
      var f = tf(st, null, null, Mr);
      return f.stateNode = u, f;
    }
    function Dn(u, f, M) {
      var A = u.children !== null ? u.children : [], z = tf(pe, A, u.key, f);
      return z.lanes = M, z.stateNode = {
        containerInfo: u.containerInfo,
        pendingChildren: null,
        implementation: u.implementation
      }, z;
    }
    function d0(u, f) {
      return u === null && (u = tf(ee, null, null, Mr)), u.tag = f.tag, u.key = f.key, u.elementType = f.elementType, u.type = f.type, u.stateNode = f.stateNode, u.return = f.return, u.child = f.child, u.sibling = f.sibling, u.index = f.index, u.ref = f.ref, u.pendingProps = f.pendingProps, u.memoizedProps = f.memoizedProps, u.updateQueue = f.updateQueue, u.memoizedState = f.memoizedState, u.dependencies = f.dependencies, u.mode = f.mode, u.flags = f.flags, u.subtreeFlags = f.subtreeFlags, u.deletions = f.deletions, u.lanes = f.lanes, u.childLanes = f.childLanes, u.alternate = f.alternate, u.actualDuration = f.actualDuration, u.actualStartTime = f.actualStartTime, u.selfBaseDuration = f.selfBaseDuration, u.treeBaseDuration = f.treeBaseDuration, u._debugSource = f._debugSource, u._debugOwner = f._debugOwner, u._debugNeedsRemount = f._debugNeedsRemount, u._debugHookTypes = f._debugHookTypes, u;
    }
    function pR(u, f, M, A, z) {
      this.tag = f, this.containerInfo = u, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = ri, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Ir, this.eventTimes = kl(an), this.expirationTimes = kl(Bi), this.pendingLanes = an, this.suspendedLanes = an, this.pingedLanes = an, this.expiredLanes = an, this.mutableReadLanes = an, this.finishedLanes = an, this.entangledLanes = an, this.entanglements = kl(an), this.identifierPrefix = A, this.onRecoverableError = z, cs && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var j = this.pendingUpdatersLaneMap = [], ne = 0; ne < nd; ne++)
          j.push(/* @__PURE__ */ new Set());
      }
      switch (f) {
        case Tc:
          this._debugRootType = M ? "hydrateRoot()" : "createRoot()";
          break;
        case Mc:
          this._debugRootType = M ? "hydrate()" : "render()";
          break;
      }
    }
    function nf(u, f, M, A, z, j, ne, se, Se, Pe) {
      var Ge = new pR(u, f, M, se, Se), yt = ju(f, j);
      Ge.current = yt, yt.stateNode = Ge;
      {
        var It = {
          element: A,
          isDehydrated: M,
          cache: null,
          transitions: null
        };
        yt.memoizedState = It;
      }
      return Wn(yt), Ge;
    }
    var gE = "18.0.0-fc46dba67-20220329";
    function Cx(u, f, M) {
      var A = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return vu(A), {
        $$typeof: et,
        key: A == null ? null : "" + A,
        children: u,
        containerInfo: f,
        implementation: M
      };
    }
    var Jg, Z_;
    Jg = !1, Z_ = {};
    function yE(u) {
      if (!u)
        return $n;
      var f = T(u), M = Bp(f);
      if (f.tag === W) {
        var A = f.type;
        if (pl(A))
          return ml(f, A, M);
      }
      return M;
    }
    function uv(u) {
      var f = T(u);
      if (f === void 0) {
        if (typeof u.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var M = Object.keys(u).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + M);
      }
      var A = us(f);
      return A === null ? null : A.stateNode;
    }
    function Tp(u, f) {
      {
        var M = T(u);
        if (M === void 0) {
          if (typeof u.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var A = Object.keys(u).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + A);
        }
        var z = us(M);
        if (z === null)
          return null;
        if (z.mode & Fa) {
          var j = Tt(M) || "Component";
          if (!Z_[j]) {
            Z_[j] = !0;
            var ne = $s;
            try {
              wi(z), M.mode & Fa ? m("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", f, f, j) : m("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", f, f, j);
            } finally {
              ne ? wi(ne) : Es();
            }
          }
        }
        return z.stateNode;
      }
    }
    function FT(u, f, M, A, z, j, ne, se) {
      var Se = !1, Pe = null;
      return nf(u, f, Se, Pe, M, A, z, j, ne);
    }
    function xE(u, f, M, A, z, j, ne, se, Se, Pe) {
      var Ge = !0, yt = nf(M, A, Ge, u, z, j, ne, se, Se);
      yt.context = yE(null);
      var It = yt.current, jt = yc(), dn = Wv(It), Sn = Er(jt, dn);
      return Sn.callback = f != null ? f : null, Ar(It, Sn), eE(yt, dn, jt), yt;
    }
    function J_(u, f, M, A) {
      Sa(f, u);
      var z = f.current, j = yc(), ne = Wv(z);
      Ns(ne);
      var se = yE(M);
      f.context === null ? f.context = se : f.pendingContext = se, Yl && $s !== null && !Jg && (Jg = !0, m(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Tt($s) || "Unknown"));
      var Se = Er(j, ne);
      Se.payload = {
        element: u
      }, A = A === void 0 ? null : A, A !== null && (typeof A != "function" && m("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", A), Se.callback = A), Ar(z, Se);
      var Pe = Ml(z, ne, j);
      return Pe !== null && Va(Pe, z, ne), ne;
    }
    function SE(u) {
      var f = u.current;
      if (!f.child)
        return null;
      switch (f.child.tag) {
        case ce:
          return Oo(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }
    function _E(u) {
      switch (u.tag) {
        case ie:
          var f = u.stateNode;
          if (Di(f)) {
            var M = es(f);
            B_(f, M);
          }
          break;
        case ue:
          var A = yc();
          j1(function() {
            return Ml(u, Hr, A);
          });
          var z = Hr;
          kT(u, z);
          break;
      }
    }
    function mR(u, f) {
      var M = u.memoizedState;
      M !== null && M.dehydrated !== null && (M.retryLane = pn(M.retryLane, f));
    }
    function kT(u, f) {
      mR(u, f);
      var M = u.alternate;
      M && mR(M, f);
    }
    function bE(u) {
      if (u.tag === ue) {
        var f = yc(), M = ve;
        Ml(u, M, f), kT(u, M);
      }
    }
    function K_(u) {
      if (u.tag === ue) {
        var f = yc(), M = Wv(u);
        Ml(u, M, f), kT(u, M);
      }
    }
    function IT(u) {
      var f = pi(u);
      return f === null ? null : f.stateNode;
    }
    var wE = function(u) {
      return null;
    };
    function EE(u) {
      return wE(u);
    }
    var ME = function(u) {
      return !1;
    };
    function TE(u) {
      return ME(u);
    }
    var $1 = null, $_ = null, eb = null, Rx = null, tb = null, eS = null, Ax = null, tS = null, nS = null;
    {
      var Dx = function(u, f, M) {
        var A = f[M], z = Ti(u) ? u.slice() : _({}, u);
        return M + 1 === f.length ? (Ti(z) ? z.splice(A, 1) : delete z[A], z) : (z[A] = Dx(u[A], f, M + 1), z);
      }, nb = function(u, f) {
        return Dx(u, f, 0);
      }, rS = function(u, f, M, A) {
        var z = f[A], j = Ti(u) ? u.slice() : _({}, u);
        if (A + 1 === f.length) {
          var ne = M[A];
          j[ne] = j[z], Ti(j) ? j.splice(z, 1) : delete j[z];
        } else
          j[z] = rS(
            u[z],
            f,
            M,
            A + 1
          );
        return j;
      }, rb = function(u, f, M) {
        if (f.length !== M.length) {
          h("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var A = 0; A < M.length - 1; A++)
            if (f[A] !== M[A]) {
              h("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return rS(u, f, M, 0);
      }, iS = function(u, f, M, A) {
        if (M >= f.length)
          return A;
        var z = f[M], j = Ti(u) ? u.slice() : _({}, u);
        return j[z] = iS(u[z], f, M + 1, A), j;
      }, CE = function(u, f, M) {
        return iS(u, f, 0, M);
      }, aS = function(u, f) {
        for (var M = u.memoizedState; M !== null && f > 0; )
          M = M.next, f--;
        return M;
      };
      $1 = function(u, f, M, A) {
        var z = aS(u, f);
        if (z !== null) {
          var j = CE(z.memoizedState, M, A);
          z.memoizedState = j, z.baseState = j, u.memoizedProps = _({}, u.memoizedProps), Ml(u, Hr, Bi);
        }
      }, $_ = function(u, f, M) {
        var A = aS(u, f);
        if (A !== null) {
          var z = nb(A.memoizedState, M);
          A.memoizedState = z, A.baseState = z, u.memoizedProps = _({}, u.memoizedProps), Ml(u, Hr, Bi);
        }
      }, eb = function(u, f, M, A) {
        var z = aS(u, f);
        if (z !== null) {
          var j = rb(z.memoizedState, M, A);
          z.memoizedState = j, z.baseState = j, u.memoizedProps = _({}, u.memoizedProps), Ml(u, Hr, Bi);
        }
      }, Rx = function(u, f, M) {
        u.pendingProps = CE(u.memoizedProps, f, M), u.alternate && (u.alternate.pendingProps = u.pendingProps), Ml(u, Hr, Bi);
      }, tb = function(u, f) {
        u.pendingProps = nb(u.memoizedProps, f), u.alternate && (u.alternate.pendingProps = u.pendingProps), Ml(u, Hr, Bi);
      }, eS = function(u, f, M) {
        u.pendingProps = rb(u.memoizedProps, f, M), u.alternate && (u.alternate.pendingProps = u.pendingProps), Ml(u, Hr, Bi);
      }, Ax = function(u) {
        Ml(u, Hr, Bi);
      }, tS = function(u) {
        wE = u;
      }, nS = function(u) {
        ME = u;
      };
    }
    function ib(u) {
      var f = us(u);
      return f === null ? null : f.stateNode;
    }
    function vR(u) {
      return null;
    }
    function ab() {
      return $s;
    }
    function RE(u) {
      var f = u.findFiberByHostInstance, M = o.ReactCurrentDispatcher;
      return wf({
        bundleType: u.bundleType,
        version: u.version,
        rendererPackageName: u.rendererPackageName,
        rendererConfig: u.rendererConfig,
        overrideHookState: $1,
        overrideHookStateDeletePath: $_,
        overrideHookStateRenamePath: eb,
        overrideProps: Rx,
        overridePropsDeletePath: tb,
        overridePropsRenamePath: eS,
        setErrorHandler: tS,
        setSuspenseHandler: nS,
        scheduleUpdate: Ax,
        currentDispatcherRef: M,
        findHostInstanceByFiber: ib,
        findFiberByHostInstance: f || vR,
        findHostInstancesForRefresh: ov,
        scheduleRefresh: Q_,
        scheduleRoot: th,
        setRefreshHandler: Ex,
        getCurrentFiber: ab,
        reconcilerVersion: gE
      });
    }
    return t.attemptContinuousHydration = bE, t.attemptHydrationAtCurrentPriority = K_, t.attemptSynchronousHydration = _E, t.batchedUpdates = wT, t.createComponentSelector = Qc, t.createContainer = FT, t.createHasPseudoClassSelector = Ep, t.createHydrationContainer = xE, t.createPortal = Cx, t.createRoleSelector = fm, t.createTestNameSelector = Hg, t.createTextSelector = $y, t.deferredUpdates = lR, t.discreteUpdates = H_, t.findAllNodes = F1, t.findBoundingRects = Xw, t.findHostInstance = uv, t.findHostInstanceWithNoPortals = IT, t.findHostInstanceWithWarning = Tp, t.flushControlled = ET, t.flushPassiveEffects = av, t.flushSync = j1, t.focusWithin = gT, t.getCurrentUpdatePriority = rl, t.getFindAllNodesFailureDescription = vT, t.getPublicRootInstance = SE, t.injectIntoDevTools = RE, t.isAlreadyRendering = tE, t.observeVisibleRects = Qw, t.registerMutableSourceForHydration = Lv, t.runWithPriority = fa, t.shouldError = EE, t.shouldSuspend = TE, t.updateContainer = J_, t;
  })), oD.exports;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = h9() : a.exports = p9();
})(x4);
const m9 = /* @__PURE__ */ y4(x4.exports);
function v9(a, e, t = (r, i) => r === i) {
  if (a === e)
    return !0;
  if (!a || !e)
    return !1;
  const r = a.length;
  if (e.length !== r)
    return !1;
  for (let i = 0; i < r; i++)
    if (!t(a[i], e[i]))
      return !1;
  return !0;
}
const q2 = [];
function g9(a, e, t = !1, r = {}) {
  for (const o of q2)
    if (v9(e, o.keys, o.equal)) {
      if (t)
        return;
      if (Object.prototype.hasOwnProperty.call(o, "error"))
        throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return o.response;
      if (!t)
        throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    promise: a(...e).then((o) => i.response = o).then(() => {
      r.lifespan && r.lifespan > 0 && setTimeout(() => {
        const o = q2.indexOf(i);
        o !== -1 && q2.splice(o, 1);
      }, r.lifespan);
    }).catch((o) => i.error = o)
  };
  if (q2.push(i), !t)
    throw i.promise;
}
const y9 = (a, e, t) => g9(a, e, !1, t);
var KC = { exports: {} }, iM = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iz;
function x9() {
  if (iz)
    return iM;
  iz = 1;
  var a = hh, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(d, h, m) {
    var S, _ = {}, T = null, C = null;
    m !== void 0 && (T = "" + m), h.key !== void 0 && (T = "" + h.key), h.ref !== void 0 && (C = h.ref);
    for (S in h)
      r.call(h, S) && !o.hasOwnProperty(S) && (_[S] = h[S]);
    if (d && d.defaultProps)
      for (S in h = d.defaultProps, h)
        _[S] === void 0 && (_[S] = h[S]);
    return { $$typeof: e, type: d, key: T, ref: C, props: _, _owner: i.current };
  }
  return iM.Fragment = t, iM.jsx = l, iM.jsxs = l, iM;
}
var aM = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var az;
function S9() {
  return az || (az = 1, process.env.NODE_ENV !== "production" && function() {
    var a = hh, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), d = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), S = Symbol.for("react.suspense_list"), _ = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), D = Symbol.iterator, P = "@@iterator";
    function U(me) {
      if (me === null || typeof me != "object")
        return null;
      var Oe = D && me[D] || me[P];
      return typeof Oe == "function" ? Oe : null;
    }
    var B = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function k(me) {
      {
        for (var Oe = arguments.length, qe = new Array(Oe > 1 ? Oe - 1 : 0), on = 1; on < Oe; on++)
          qe[on - 1] = arguments[on];
        V("error", me, qe);
      }
    }
    function V(me, Oe, qe) {
      {
        var on = B.ReactDebugCurrentFrame, yn = on.getStackAddendum();
        yn !== "" && (Oe += "%s", qe = qe.concat([yn]));
        var Rn = qe.map(function(mn) {
          return String(mn);
        });
        Rn.unshift("Warning: " + Oe), Function.prototype.apply.call(console[me], console, Rn);
      }
    }
    var I = !1, X = !1, J = !1, $ = !1, W = !1, ee;
    ee = Symbol.for("react.module.reference");
    function ie(me) {
      return !!(typeof me == "string" || typeof me == "function" || me === r || me === o || W || me === i || me === m || me === S || $ || me === C || I || X || J || typeof me == "object" && me !== null && (me.$$typeof === T || me.$$typeof === _ || me.$$typeof === l || me.$$typeof === d || me.$$typeof === h || me.$$typeof === ee || me.getModuleId !== void 0));
    }
    function pe(me, Oe, qe) {
      var on = me.displayName;
      if (on)
        return on;
      var yn = Oe.displayName || Oe.name || "";
      return yn !== "" ? qe + "(" + yn + ")" : qe;
    }
    function ce(me) {
      return me.displayName || "Context";
    }
    function Ee(me) {
      if (me == null)
        return null;
      if (typeof me.tag == "number" && k("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof me == "function")
        return me.displayName || me.name || null;
      if (typeof me == "string")
        return me;
      switch (me) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case m:
          return "Suspense";
        case S:
          return "SuspenseList";
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case d:
            var Oe = me;
            return ce(Oe) + ".Consumer";
          case l:
            var qe = me;
            return ce(qe._context) + ".Provider";
          case h:
            return pe(me, me.render, "ForwardRef");
          case _:
            var on = me.displayName || null;
            return on !== null ? on : Ee(me.type) || "Memo";
          case T: {
            var yn = me, Rn = yn._payload, mn = yn._init;
            try {
              return Ee(mn(Rn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var de = Object.assign, Fe = 0, Ce, Be, he, fe, ue, ye, we;
    function Xe() {
    }
    Xe.__reactDisabledLog = !0;
    function Je() {
      {
        if (Fe === 0) {
          Ce = console.log, Be = console.info, he = console.warn, fe = console.error, ue = console.group, ye = console.groupCollapsed, we = console.groupEnd;
          var me = {
            configurable: !0,
            enumerable: !0,
            value: Xe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: me,
            log: me,
            warn: me,
            error: me,
            group: me,
            groupCollapsed: me,
            groupEnd: me
          });
        }
        Fe++;
      }
    }
    function st() {
      {
        if (Fe--, Fe === 0) {
          var me = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: de({}, me, {
              value: Ce
            }),
            info: de({}, me, {
              value: Be
            }),
            warn: de({}, me, {
              value: he
            }),
            error: de({}, me, {
              value: fe
            }),
            group: de({}, me, {
              value: ue
            }),
            groupCollapsed: de({}, me, {
              value: ye
            }),
            groupEnd: de({}, me, {
              value: we
            })
          });
        }
        Fe < 0 && k("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ue = B.ReactCurrentDispatcher, ot;
    function rt(me, Oe, qe) {
      {
        if (ot === void 0)
          try {
            throw Error();
          } catch (yn) {
            var on = yn.stack.trim().match(/\n( *(at )?)/);
            ot = on && on[1] || "";
          }
        return `
` + ot + me;
      }
    }
    var _t = !1, Rt;
    {
      var Ot = typeof WeakMap == "function" ? WeakMap : Map;
      Rt = new Ot();
    }
    function He(me, Oe) {
      if (!me || _t)
        return "";
      {
        var qe = Rt.get(me);
        if (qe !== void 0)
          return qe;
      }
      var on;
      _t = !0;
      var yn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Rn;
      Rn = Ue.current, Ue.current = null, Je();
      try {
        if (Oe) {
          var mn = function() {
            throw Error();
          };
          if (Object.defineProperty(mn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(mn, []);
            } catch ($t) {
              on = $t;
            }
            Reflect.construct(me, [], mn);
          } else {
            try {
              mn.call();
            } catch ($t) {
              on = $t;
            }
            me.call(mn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($t) {
            on = $t;
          }
          me();
        }
      } catch ($t) {
        if ($t && on && typeof $t.stack == "string") {
          for (var vn = $t.stack.split(`
`), Zn = on.stack.split(`
`), nr = vn.length - 1, br = Zn.length - 1; nr >= 1 && br >= 0 && vn[nr] !== Zn[br]; )
            br--;
          for (; nr >= 1 && br >= 0; nr--, br--)
            if (vn[nr] !== Zn[br]) {
              if (nr !== 1 || br !== 1)
                do
                  if (nr--, br--, br < 0 || vn[nr] !== Zn[br]) {
                    var Yi = `
` + vn[nr].replace(" at new ", " at ");
                    return me.displayName && Yi.includes("<anonymous>") && (Yi = Yi.replace("<anonymous>", me.displayName)), typeof me == "function" && Rt.set(me, Yi), Yi;
                  }
                while (nr >= 1 && br >= 0);
              break;
            }
        }
      } finally {
        _t = !1, Ue.current = Rn, st(), Error.prepareStackTrace = yn;
      }
      var La = me ? me.displayName || me.name : "", Ys = La ? rt(La) : "";
      return typeof me == "function" && Rt.set(me, Ys), Ys;
    }
    function et(me, Oe, qe) {
      return He(me, !1);
    }
    function mt(me) {
      var Oe = me.prototype;
      return !!(Oe && Oe.isReactComponent);
    }
    function vt(me, Oe, qe) {
      if (me == null)
        return "";
      if (typeof me == "function")
        return He(me, mt(me));
      if (typeof me == "string")
        return rt(me);
      switch (me) {
        case m:
          return rt("Suspense");
        case S:
          return rt("SuspenseList");
      }
      if (typeof me == "object")
        switch (me.$$typeof) {
          case h:
            return et(me.render);
          case _:
            return vt(me.type, Oe, qe);
          case T: {
            var on = me, yn = on._payload, Rn = on._init;
            try {
              return vt(Rn(yn), Oe, qe);
            } catch {
            }
          }
        }
      return "";
    }
    var bt = Object.prototype.hasOwnProperty, Qt = {}, ft = B.ReactDebugCurrentFrame;
    function Vt(me) {
      if (me) {
        var Oe = me._owner, qe = vt(me.type, me._source, Oe ? Oe.type : null);
        ft.setExtraStackFrame(qe);
      } else
        ft.setExtraStackFrame(null);
    }
    function Jt(me, Oe, qe, on, yn) {
      {
        var Rn = Function.call.bind(bt);
        for (var mn in me)
          if (Rn(me, mn)) {
            var vn = void 0;
            try {
              if (typeof me[mn] != "function") {
                var Zn = Error((on || "React class") + ": " + qe + " type `" + mn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof me[mn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Zn.name = "Invariant Violation", Zn;
              }
              vn = me[mn](Oe, mn, on, qe, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (nr) {
              vn = nr;
            }
            vn && !(vn instanceof Error) && (Vt(yn), k("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", on || "React class", qe, mn, typeof vn), Vt(null)), vn instanceof Error && !(vn.message in Qt) && (Qt[vn.message] = !0, Vt(yn), k("Failed %s type: %s", qe, vn.message), Vt(null));
          }
      }
    }
    var Mt = Array.isArray;
    function Me(me) {
      return Mt(me);
    }
    function oe(me) {
      {
        var Oe = typeof Symbol == "function" && Symbol.toStringTag, qe = Oe && me[Symbol.toStringTag] || me.constructor.name || "Object";
        return qe;
      }
    }
    function je(me) {
      try {
        return lt(me), !1;
      } catch {
        return !0;
      }
    }
    function lt(me) {
      return "" + me;
    }
    function zt(me) {
      if (je(me))
        return k("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", oe(me)), lt(me);
    }
    var Nt = B.ReactCurrentOwner, Ut = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, tt, rn, ze;
    ze = {};
    function xe(me) {
      if (bt.call(me, "ref")) {
        var Oe = Object.getOwnPropertyDescriptor(me, "ref").get;
        if (Oe && Oe.isReactWarning)
          return !1;
      }
      return me.ref !== void 0;
    }
    function Ie(me) {
      if (bt.call(me, "key")) {
        var Oe = Object.getOwnPropertyDescriptor(me, "key").get;
        if (Oe && Oe.isReactWarning)
          return !1;
      }
      return me.key !== void 0;
    }
    function it(me, Oe) {
      if (typeof me.ref == "string" && Nt.current && Oe && Nt.current.stateNode !== Oe) {
        var qe = Ee(Nt.current.type);
        ze[qe] || (k('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Ee(Nt.current.type), me.ref), ze[qe] = !0);
      }
    }
    function at(me, Oe) {
      {
        var qe = function() {
          tt || (tt = !0, k("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Oe));
        };
        qe.isReactWarning = !0, Object.defineProperty(me, "key", {
          get: qe,
          configurable: !0
        });
      }
    }
    function hn(me, Oe) {
      {
        var qe = function() {
          rn || (rn = !0, k("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Oe));
        };
        qe.isReactWarning = !0, Object.defineProperty(me, "ref", {
          get: qe,
          configurable: !0
        });
      }
    }
    var De = function(me, Oe, qe, on, yn, Rn, mn) {
      var vn = {
        $$typeof: e,
        type: me,
        key: Oe,
        ref: qe,
        props: mn,
        _owner: Rn
      };
      return vn._store = {}, Object.defineProperty(vn._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(vn, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: on
      }), Object.defineProperty(vn, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: yn
      }), Object.freeze && (Object.freeze(vn.props), Object.freeze(vn)), vn;
    };
    function Tt(me, Oe, qe, on, yn) {
      {
        var Rn, mn = {}, vn = null, Zn = null;
        qe !== void 0 && (zt(qe), vn = "" + qe), Ie(Oe) && (zt(Oe.key), vn = "" + Oe.key), xe(Oe) && (Zn = Oe.ref, it(Oe, yn));
        for (Rn in Oe)
          bt.call(Oe, Rn) && !Ut.hasOwnProperty(Rn) && (mn[Rn] = Oe[Rn]);
        if (me && me.defaultProps) {
          var nr = me.defaultProps;
          for (Rn in nr)
            mn[Rn] === void 0 && (mn[Rn] = nr[Rn]);
        }
        if (vn || Zn) {
          var br = typeof me == "function" ? me.displayName || me.name || "Unknown" : me;
          vn && at(mn, br), Zn && hn(mn, br);
        }
        return De(me, vn, Zn, yn, on, Nt.current, mn);
      }
    }
    var Ne = B.ReactCurrentOwner, Gt = B.ReactDebugCurrentFrame;
    function Pt(me) {
      if (me) {
        var Oe = me._owner, qe = vt(me.type, me._source, Oe ? Oe.type : null);
        Gt.setExtraStackFrame(qe);
      } else
        Gt.setExtraStackFrame(null);
    }
    var fn;
    fn = !1;
    function Gr(me) {
      return typeof me == "object" && me !== null && me.$$typeof === e;
    }
    function Wr() {
      {
        if (Ne.current) {
          var me = Ee(Ne.current.type);
          if (me)
            return `

Check the render method of \`` + me + "`.";
        }
        return "";
      }
    }
    function Ur(me) {
      {
        if (me !== void 0) {
          var Oe = me.fileName.replace(/^.*[\\\/]/, ""), qe = me.lineNumber;
          return `

Check your code at ` + Oe + ":" + qe + ".";
        }
        return "";
      }
    }
    var ir = {};
    function Vn(me) {
      {
        var Oe = Wr();
        if (!Oe) {
          var qe = typeof me == "string" ? me : me.displayName || me.name;
          qe && (Oe = `

Check the top-level render call using <` + qe + ">.");
        }
        return Oe;
      }
    }
    function jr(me, Oe) {
      {
        if (!me._store || me._store.validated || me.key != null)
          return;
        me._store.validated = !0;
        var qe = Vn(Oe);
        if (ir[qe])
          return;
        ir[qe] = !0;
        var on = "";
        me && me._owner && me._owner !== Ne.current && (on = " It was passed a child from " + Ee(me._owner.type) + "."), Pt(me), k('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', qe, on), Pt(null);
      }
    }
    function ti(me, Oe) {
      {
        if (typeof me != "object")
          return;
        if (Me(me))
          for (var qe = 0; qe < me.length; qe++) {
            var on = me[qe];
            Gr(on) && jr(on, Oe);
          }
        else if (Gr(me))
          me._store && (me._store.validated = !0);
        else if (me) {
          var yn = U(me);
          if (typeof yn == "function" && yn !== me.entries)
            for (var Rn = yn.call(me), mn; !(mn = Rn.next()).done; )
              Gr(mn.value) && jr(mn.value, Oe);
        }
      }
    }
    function ki(me) {
      {
        var Oe = me.type;
        if (Oe == null || typeof Oe == "string")
          return;
        var qe;
        if (typeof Oe == "function")
          qe = Oe.propTypes;
        else if (typeof Oe == "object" && (Oe.$$typeof === h || Oe.$$typeof === _))
          qe = Oe.propTypes;
        else
          return;
        if (qe) {
          var on = Ee(Oe);
          Jt(qe, me.props, "prop", on, me);
        } else if (Oe.PropTypes !== void 0 && !fn) {
          fn = !0;
          var yn = Ee(Oe);
          k("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", yn || "Unknown");
        }
        typeof Oe.getDefaultProps == "function" && !Oe.getDefaultProps.isReactClassApproved && k("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Wi(me) {
      {
        for (var Oe = Object.keys(me.props), qe = 0; qe < Oe.length; qe++) {
          var on = Oe[qe];
          if (on !== "children" && on !== "key") {
            Pt(me), k("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", on), Pt(null);
            break;
          }
        }
        me.ref !== null && (Pt(me), k("Invalid attribute `ref` supplied to `React.Fragment`."), Pt(null));
      }
    }
    function ni(me, Oe, qe, on, yn, Rn) {
      {
        var mn = ie(me);
        if (!mn) {
          var vn = "";
          (me === void 0 || typeof me == "object" && me !== null && Object.keys(me).length === 0) && (vn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Zn = Ur(yn);
          Zn ? vn += Zn : vn += Wr();
          var nr;
          me === null ? nr = "null" : Me(me) ? nr = "array" : me !== void 0 && me.$$typeof === e ? (nr = "<" + (Ee(me.type) || "Unknown") + " />", vn = " Did you accidentally export a JSX literal instead of a component?") : nr = typeof me, k("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", nr, vn);
        }
        var br = Tt(me, Oe, qe, yn, Rn);
        if (br == null)
          return br;
        if (mn) {
          var Yi = Oe.children;
          if (Yi !== void 0)
            if (on)
              if (Me(Yi)) {
                for (var La = 0; La < Yi.length; La++)
                  ti(Yi[La], me);
                Object.freeze && Object.freeze(Yi);
              } else
                k("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ti(Yi, me);
        }
        return me === r ? Wi(br) : ki(br), br;
      }
    }
    function ji(me, Oe, qe) {
      return ni(me, Oe, qe, !0);
    }
    function Si(me, Oe, qe) {
      return ni(me, Oe, qe, !1);
    }
    var Te = Si, ct = ji;
    aM.Fragment = r, aM.jsx = Te, aM.jsxs = ct;
  }()), aM;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = x9() : a.exports = S9();
})(KC);
const rT = KC.exports.Fragment, _n = KC.exports.jsx, dh = KC.exports.jsxs;
var sz, oz;
const S4 = (a) => a && a.isOrthographicCamera, _9 = (a) => a && a.hasOwnProperty("current"), iT = typeof window < "u" && ((sz = window.document) != null && sz.createElement || ((oz = window.navigator) == null ? void 0 : oz.product) === "ReactNative") ? Or.useLayoutEffect : Or.useEffect;
function _4(a) {
  const e = Or.useRef(a);
  return iT(() => void (e.current = a), [a]), e;
}
function b9({
  set: a
}) {
  return iT(() => (a(new Promise(() => null)), () => a(!1)), [a]), null;
}
class b4 extends Or.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
b4.getDerivedStateFromError = () => ({
  error: !0
});
const w4 = "__default", w9 = (a) => a && !!a.memoized && !!a.changes;
function E4(a) {
  return Array.isArray(a) ? Math.min(Math.max(a[0], window.devicePixelRatio), a[1]) : a;
}
const sM = (a) => {
  var e;
  return (e = a.__r3f) == null ? void 0 : e.root.getState();
}, qu = {
  obj: (a) => a === Object(a) && !qu.arr(a) && typeof a != "function",
  fun: (a) => typeof a == "function",
  str: (a) => typeof a == "string",
  num: (a) => typeof a == "number",
  boo: (a) => typeof a == "boolean",
  und: (a) => a === void 0,
  arr: (a) => Array.isArray(a),
  equ(a, e, {
    arrays: t = "shallow",
    objects: r = "reference",
    strict: i = !0
  } = {}) {
    if (typeof a != typeof e || !!a != !!e)
      return !1;
    if (qu.str(a) || qu.num(a))
      return a === e;
    const o = qu.obj(a);
    if (o && r === "reference")
      return a === e;
    const l = qu.arr(a);
    if (l && t === "reference")
      return a === e;
    if ((l || o) && a === e)
      return !0;
    let d;
    for (d in a)
      if (!(d in e))
        return !1;
    for (d in i ? e : a)
      if (a[d] !== e[d])
        return !1;
    if (qu.und(d)) {
      if (l && a.length === 0 && e.length === 0 || o && Object.keys(a).length === 0 && Object.keys(e).length === 0)
        return !0;
      if (a !== e)
        return !1;
    }
    return !0;
  }
};
function E9(a) {
  a.dispose && a.type !== "Scene" && a.dispose();
  for (const e in a)
    e.dispose == null || e.dispose(), delete a[e];
}
function Nb(a, e) {
  const t = a;
  return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }), a;
}
function w3(a, e) {
  let t = a;
  if (e.includes("-")) {
    const r = e.split("-"), i = r.pop();
    return t = r.reduce((o, l) => o[l], a), {
      target: t,
      key: i
    };
  } else
    return {
      target: t,
      key: e
    };
}
const lz = /-\d+$/;
function lD(a, e, t) {
  if (qu.str(t)) {
    if (lz.test(t)) {
      const o = t.replace(lz, ""), {
        target: l,
        key: d
      } = w3(a, o);
      Array.isArray(l[d]) || (l[d] = []);
    }
    const {
      target: r,
      key: i
    } = w3(a, t);
    e.__r3f.previousAttach = r[i], r[i] = e;
  } else
    e.__r3f.previousAttach = t(a, e);
}
function uz(a, e, t) {
  var r, i;
  if (qu.str(t)) {
    const {
      target: o,
      key: l
    } = w3(a, t), d = e.__r3f.previousAttach;
    d === void 0 ? delete o[l] : o[l] = d;
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(a, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function M4(a, {
  children: e,
  key: t,
  ref: r,
  ...i
}, {
  children: o,
  key: l,
  ref: d,
  ...h
} = {}, m = !1) {
  var S;
  const _ = (S = a == null ? void 0 : a.__r3f) != null ? S : {}, T = Object.entries(i), C = [];
  if (m) {
    const P = Object.keys(h);
    for (let U = 0; U < P.length; U++)
      i.hasOwnProperty(P[U]) || T.unshift([P[U], w4 + "remove"]);
  }
  T.forEach(([P, U]) => {
    var B;
    if ((B = a.__r3f) != null && B.primitive && P === "object" || qu.equ(U, h[P]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(P))
      return C.push([P, U, !0, []]);
    let k = [];
    P.includes("-") && (k = P.split("-")), C.push([P, U, !1, k]);
  });
  const D = {
    ...i
  };
  return _.memoizedProps && _.memoizedProps.args && (D.args = _.memoizedProps.args), _.memoizedProps && _.memoizedProps.attach && (D.attach = _.memoizedProps.attach), {
    memoized: D,
    changes: C
  };
}
function uD(a, e) {
  var t, r;
  const i = (t = a.__r3f) != null ? t : {}, o = i.root, l = (r = o == null || o.getState == null ? void 0 : o.getState()) != null ? r : {}, {
    memoized: d,
    changes: h
  } = w9(e) ? e : M4(a, e), m = i.eventCount;
  if (a.__r3f && (a.__r3f.memoizedProps = d), h.forEach(([S, _, T, C]) => {
    let D = a, P = D[S];
    if (C.length && (P = C.reduce((k, V) => k[V], a), !(P && P.set))) {
      const [k, ...V] = C.reverse();
      D = V.reverse().reduce((I, X) => I[X], a), S = k;
    }
    if (_ === w4 + "remove")
      if (P && P.constructor) {
        var U;
        _ = new P.constructor(...(U = d.args) != null ? U : []);
      } else if (D.constructor) {
        var B;
        const k = new D.constructor(...(B = D.__r3f.memoizedProps.args) != null ? B : []);
        _ = k[P], k.dispose && k.dispose();
      } else
        _ = 0;
    if (T)
      _ ? i.handlers[S] = _ : delete i.handlers[S], i.eventCount = Object.keys(i.handlers).length;
    else if (P && P.set && (P.copy || P instanceof kS)) {
      if (Array.isArray(_))
        P.fromArray ? P.fromArray(_) : P.set(..._);
      else if (P.copy && _ && _.constructor && P.constructor.name === _.constructor.name)
        P.copy(_);
      else if (_ !== void 0) {
        const k = P instanceof Pn;
        !k && P.setScalar ? P.setScalar(_) : P instanceof kS && _ instanceof kS ? P.mask = _.mask : P.set(_), !("ColorManagement" in RC) && !l.linear && k && P.convertSRGBToLinear();
      }
    } else
      D[S] = _, !l.linear && D[S] instanceof iu && (D[S].encoding = Mi);
    Fb(a);
  }), i.parent && l.internal && a.raycast && m !== i.eventCount) {
    const S = l.internal.interaction.indexOf(a);
    S > -1 && l.internal.interaction.splice(S, 1), i.eventCount && l.internal.interaction.push(a);
  }
  return h.length && a.parent && E3(a), a;
}
function Fb(a) {
  var e, t;
  const r = (e = a.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function E3(a) {
  a.onUpdate == null || a.onUpdate(a);
}
function M9(a, e) {
  a.manual || (S4(a) ? (a.left = e.width / -2, a.right = e.width / 2, a.top = e.height / 2, a.bottom = e.height / -2) : a.aspect = e.width / e.height, a.updateProjectionMatrix(), a.updateMatrixWorld());
}
function T9(a, e, t) {
  const r = t.pop(), i = t.reduce((o, l) => o[l], a);
  return i[r] = e;
}
function cD(a) {
  return (a.eventObject || a.object).uuid + "/" + a.index + a.instanceId;
}
function C9() {
  var a, e;
  switch ((a = window) == null || (e = a.event) == null ? void 0 : e.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Yb.exports.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Yb.exports.ContinuousEventPriority;
    default:
      return Yb.exports.DefaultEventPriority;
  }
}
function T4(a, e, t, r) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (a.delete(r), i.target.releasePointerCapture(r)));
}
function R9(a, e) {
  const {
    internal: t
  } = a.getState();
  t.interaction = t.interaction.filter((r) => r !== e), t.initialHits = t.initialHits.filter((r) => r !== e), t.hovered.forEach((r, i) => {
    (r.eventObject === e || r.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((r, i) => {
    T4(t.capturedMap, e, r, i);
  });
}
function A9(a) {
  function e(h) {
    const {
      internal: m
    } = a.getState(), S = h.offsetX - m.initialClick[0], _ = h.offsetY - m.initialClick[1];
    return Math.round(Math.sqrt(S * S + _ * _));
  }
  function t(h) {
    return h.filter((m) => ["Move", "Over", "Enter", "Out", "Leave"].some((S) => {
      var _;
      return (_ = m.__r3f) == null ? void 0 : _.handlers["onPointer" + S];
    }));
  }
  function r(h, m) {
    const S = a.getState(), _ = /* @__PURE__ */ new Set(), T = [], C = m ? m(S.internal.interaction) : S.internal.interaction;
    C.forEach((U) => {
      const B = sM(U);
      B && (B.raycaster.camera = void 0);
    }), S.previousRoot || S.events.compute == null || S.events.compute(h, S);
    let D = C.flatMap((U) => {
      const B = sM(U);
      if (!B || !B.events.enabled || B.raycaster.camera === null)
        return [];
      if (B.raycaster.camera === void 0) {
        var k;
        B.events.compute == null || B.events.compute(h, B, (k = B.previousRoot) == null ? void 0 : k.getState()), B.raycaster.camera === void 0 && (B.raycaster.camera = null);
      }
      return B.raycaster.camera ? B.raycaster.intersectObject(U, !0) : [];
    }).sort((U, B) => {
      const k = sM(U.object), V = sM(B.object);
      return !k || !V ? 0 : V.events.priority - k.events.priority || U.distance - B.distance;
    }).filter((U) => {
      const B = cD(U);
      return _.has(B) ? !1 : (_.add(B), !0);
    });
    S.events.filter && (D = S.events.filter(D, S));
    for (const U of D) {
      let B = U.object;
      for (; B; ) {
        var P;
        (P = B.__r3f) != null && P.eventCount && T.push({
          ...U,
          eventObject: B
        }), B = B.parent;
      }
    }
    if ("pointerId" in h && S.internal.capturedMap.has(h.pointerId))
      for (let U of S.internal.capturedMap.get(h.pointerId).values())
        T.push(U.intersection);
    return T;
  }
  function i(h, m, S, _) {
    if (h.length) {
      const T = {
        stopped: !1
      };
      for (const C of h) {
        const D = sM(C.object);
        if (D) {
          const {
            raycaster: P,
            pointer: U,
            camera: B,
            internal: k
          } = D, V = new ge(U.x, U.y, 0).unproject(B), I = (ee) => {
            var ie, pe;
            return (ie = (pe = k.capturedMap.get(ee)) == null ? void 0 : pe.has(C.eventObject)) != null ? ie : !1;
          }, X = (ee) => {
            const ie = {
              intersection: C,
              target: m.target
            };
            k.capturedMap.has(ee) ? k.capturedMap.get(ee).set(C.eventObject, ie) : k.capturedMap.set(ee, /* @__PURE__ */ new Map([[C.eventObject, ie]])), m.target.setPointerCapture(ee);
          }, J = (ee) => {
            const ie = k.capturedMap.get(ee);
            ie && T4(k.capturedMap, C.eventObject, ie, ee);
          };
          let $ = {};
          for (let ee in m) {
            let ie = m[ee];
            typeof ie != "function" && ($[ee] = ie);
          }
          let W = {
            ...C,
            ...$,
            pointer: U,
            intersections: h,
            stopped: T.stopped,
            delta: S,
            unprojectedPoint: V,
            ray: P.ray,
            camera: B,
            stopPropagation: () => {
              const ee = "pointerId" in m && k.capturedMap.get(m.pointerId);
              if ((!ee || ee.has(C.eventObject)) && (W.stopped = T.stopped = !0, k.hovered.size && Array.from(k.hovered.values()).find((ie) => ie.eventObject === C.eventObject))) {
                const ie = h.slice(0, h.indexOf(C));
                o([...ie, C]);
              }
            },
            target: {
              hasPointerCapture: I,
              setPointerCapture: X,
              releasePointerCapture: J
            },
            currentTarget: {
              hasPointerCapture: I,
              setPointerCapture: X,
              releasePointerCapture: J
            },
            nativeEvent: m
          };
          if (_(W), T.stopped === !0)
            break;
        }
      }
    }
    return h;
  }
  function o(h) {
    const {
      internal: m
    } = a.getState();
    Array.from(m.hovered.values()).forEach((S) => {
      if (!h.length || !h.find((_) => _.object === S.object && _.index === S.index && _.instanceId === S.instanceId)) {
        const T = S.eventObject.__r3f, C = T == null ? void 0 : T.handlers;
        if (m.hovered.delete(cD(S)), T != null && T.eventCount) {
          const D = {
            ...S,
            intersections: h
          };
          C.onPointerOut == null || C.onPointerOut(D), C.onPointerLeave == null || C.onPointerLeave(D);
        }
      }
    });
  }
  const l = (h) => {
    switch (h) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (m) => {
          const {
            internal: S
          } = a.getState();
          "pointerId" in m && !S.capturedMap.has(m.pointerId) && (S.capturedMap.delete(m.pointerId), o([]));
        };
    }
    return (m) => {
      const {
        onPointerMissed: S,
        internal: _
      } = a.getState();
      _.lastEvent.current = m;
      const T = h === "onPointerMove", C = h === "onClick" || h === "onContextMenu" || h === "onDoubleClick", P = r(m, T ? t : void 0), U = C ? e(m) : 0;
      h === "onPointerDown" && (_.initialClick = [m.offsetX, m.offsetY], _.initialHits = P.map((B) => B.eventObject)), C && !P.length && U <= 2 && (d(m, _.interaction), S && S(m)), T && o(P), i(P, m, U, (B) => {
        const k = B.eventObject, V = k.__r3f, I = V == null ? void 0 : V.handlers;
        if (!!(V != null && V.eventCount))
          if (T) {
            if (I.onPointerOver || I.onPointerEnter || I.onPointerOut || I.onPointerLeave) {
              const X = cD(B), J = _.hovered.get(X);
              J ? J.stopped && B.stopPropagation() : (_.hovered.set(X, B), I.onPointerOver == null || I.onPointerOver(B), I.onPointerEnter == null || I.onPointerEnter(B));
            }
            I.onPointerMove == null || I.onPointerMove(B);
          } else {
            const X = I[h];
            X ? (!C || _.initialHits.includes(k)) && (d(m, _.interaction.filter((J) => !_.initialHits.includes(J))), X(B)) : C && _.initialHits.includes(k) && d(m, _.interaction.filter((J) => !_.initialHits.includes(J)));
          }
      });
    };
  };
  function d(h, m) {
    m.forEach((S) => {
      var _;
      return (_ = S.__r3f) == null || _.handlers.onPointerMissed == null ? void 0 : _.handlers.onPointerMissed(h);
    });
  }
  return {
    handlePointer: l
  };
}
let M3 = {}, D9 = (a) => void (M3 = {
  ...M3,
  ...a
});
function L9(a, e) {
  function t(S, {
    args: _ = [],
    attach: T,
    ...C
  }, D) {
    let P = `${S[0].toUpperCase()}${S.slice(1)}`, U;
    if (S === "primitive") {
      if (C.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const B = C.object;
      U = Nb(B, {
        type: S,
        root: D,
        attach: T,
        primitive: !0
      });
    } else {
      const B = M3[P];
      if (!B)
        throw new Error(`R3F: ${P} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(_))
        throw new Error("R3F: The args prop must be an array!");
      U = Nb(new B(..._), {
        type: S,
        root: D,
        attach: T,
        memoizedProps: {
          args: _
        }
      });
    }
    return U.__r3f.attach === void 0 && (U instanceof ui ? U.__r3f.attach = "geometry" : U instanceof ff && (U.__r3f.attach = "material")), P !== "inject" && uD(U, C), U;
  }
  function r(S, _) {
    let T = !1;
    if (_) {
      var C, D;
      (C = _.__r3f) != null && C.attach ? lD(S, _, _.__r3f.attach) : _.isObject3D && S.isObject3D && (S.add(_), T = !0), T || (D = S.__r3f) == null || D.objects.push(_), _.__r3f || Nb(_, {}), _.__r3f.parent = S, E3(_), Fb(_);
    }
  }
  function i(S, _, T) {
    let C = !1;
    if (_) {
      var D, P;
      if ((D = _.__r3f) != null && D.attach)
        lD(S, _, _.__r3f.attach);
      else if (_.isObject3D && S.isObject3D) {
        _.parent = S, _.dispatchEvent({
          type: "added"
        });
        const U = S.children.filter((k) => k !== _), B = U.indexOf(T);
        S.children = [...U.slice(0, B), _, ...U.slice(B)], C = !0;
      }
      C || (P = S.__r3f) == null || P.objects.push(_), _.__r3f || Nb(_, {}), _.__r3f.parent = S, E3(_), Fb(_);
    }
  }
  function o(S, _, T = !1) {
    S && [...S].forEach((C) => l(_, C, T));
  }
  function l(S, _, T) {
    if (_) {
      var C, D, P;
      if (_.__r3f && (_.__r3f.parent = null), (C = S.__r3f) != null && C.objects && (S.__r3f.objects = S.__r3f.objects.filter((I) => I !== _)), (D = _.__r3f) != null && D.attach)
        uz(S, _, _.__r3f.attach);
      else if (_.isObject3D && S.isObject3D) {
        var U;
        S.remove(_), (U = _.__r3f) != null && U.root && R9(_.__r3f.root, _);
      }
      const k = (P = _.__r3f) == null ? void 0 : P.primitive, V = T === void 0 ? _.dispose !== null && !k : T;
      if (!k) {
        var B;
        o((B = _.__r3f) == null ? void 0 : B.objects, _, V), o(_.children, _, V);
      }
      _.__r3f && (delete _.__r3f.root, delete _.__r3f.objects, delete _.__r3f.handlers, delete _.__r3f.memoizedProps, k || delete _.__r3f), V && _.dispose && _.type !== "Scene" && jM.exports.unstable_scheduleCallback(jM.exports.unstable_IdlePriority, () => {
        try {
          _.dispose();
        } catch {
        }
      }), Fb(S);
    }
  }
  function d(S, _, T, C) {
    var D;
    const P = (D = S.__r3f) == null ? void 0 : D.parent;
    if (!P)
      return;
    const U = t(_, T, S.__r3f.root);
    if (S.children) {
      for (const B of S.children)
        B.__r3f && r(U, B);
      S.children = S.children.filter((B) => !B.__r3f);
    }
    S.__r3f.objects.forEach((B) => r(U, B)), S.__r3f.objects = [], l(P, S), r(P, U), U.raycast && U.__r3f.eventCount && U.__r3f.root.getState().internal.interaction.push(U), [C, C.alternate].forEach((B) => {
      B !== null && (B.stateNode = U, B.ref && (typeof B.ref == "function" ? B.ref(U) : B.ref.current = U));
    });
  }
  const h = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: m9({
      createInstance: t,
      removeChild: l,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (S, _) => {
        if (!_)
          return;
        const T = S.getState().scene;
        !T.__r3f || (T.__r3f.root = S, r(T, _));
      },
      removeChildFromContainer: (S, _) => {
        !_ || l(S.getState().scene, _);
      },
      insertInContainerBefore: (S, _, T) => {
        if (!_ || !T)
          return;
        const C = S.getState().scene;
        !C.__r3f || i(C, _, T);
      },
      getRootHostContext: () => null,
      getChildHostContext: (S) => S,
      finalizeInitialChildren(S) {
        var _;
        const T = (_ = S == null ? void 0 : S.__r3f) != null ? _ : {};
        return Boolean(T.handlers);
      },
      prepareUpdate(S, _, T, C) {
        if (S.__r3f.primitive && C.object && C.object !== S)
          return [!0];
        {
          const {
            args: D = [],
            children: P,
            ...U
          } = C, {
            args: B = [],
            children: k,
            ...V
          } = T;
          if (!Array.isArray(D))
            throw new Error("R3F: the args prop must be an array!");
          if (D.some((X, J) => X !== B[J]))
            return [!0];
          const I = M4(S, U, V, !0);
          return I.changes.length ? [!1, I] : null;
        }
      },
      commitUpdate(S, [_, T], C, D, P, U) {
        _ ? d(S, C, P, U) : uD(S, T);
      },
      commitMount(S, _, T, C) {
        var D;
        const P = (D = S.__r3f) != null ? D : {};
        S.raycast && P.handlers && P.eventCount && S.__r3f.root.getState().internal.interaction.push(S);
      },
      getPublicInstance: (S) => S,
      prepareForCommit: () => null,
      preparePortalMount: (S) => Nb(S.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(S) {
        var _;
        const {
          attach: T,
          parent: C
        } = (_ = S.__r3f) != null ? _ : {};
        T && C && uz(C, S, T), S.isObject3D && (S.visible = !1), Fb(S);
      },
      unhideInstance(S, _) {
        var T;
        const {
          attach: C,
          parent: D
        } = (T = S.__r3f) != null ? T : {};
        C && D && lD(D, S, C), (S.isObject3D && _.visible == null || _.visible) && (S.visible = !0), Fb(S);
      },
      createTextInstance: h,
      hideTextInstance: h,
      unhideTextInstance: h,
      getCurrentEventPriority: () => e ? e() : Yb.exports.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && qu.fun(performance.now) ? performance.now : qu.fun(Date.now) ? Date.now : () => 0,
      scheduleTimeout: qu.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: qu.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: uD
  };
}
const C4 = (a) => !!(a != null && a.render), R4 = /* @__PURE__ */ Or.createContext(null), P9 = (a, e) => {
  const t = c9((d, h) => {
    const m = new ge(), S = new ge(), _ = new ge();
    function T(B = h().camera, k = S, V = h().size) {
      const {
        width: I,
        height: X,
        top: J,
        left: $
      } = V, W = I / X;
      k instanceof ge ? _.copy(k) : _.set(...k);
      const ee = B.getWorldPosition(m).distanceTo(_);
      if (S4(B))
        return {
          width: I / B.zoom,
          height: X / B.zoom,
          top: J,
          left: $,
          factor: 1,
          distance: ee,
          aspect: W
        };
      {
        const ie = B.fov * Math.PI / 180, pe = 2 * Math.tan(ie / 2) * ee, ce = pe * (I / X);
        return {
          width: ce,
          height: pe,
          top: J,
          left: $,
          factor: I / ce,
          distance: ee,
          aspect: W
        };
      }
    }
    let C;
    const D = (B) => d((k) => ({
      performance: {
        ...k.performance,
        current: B
      }
    })), P = new Ft();
    return {
      set: d,
      get: h,
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      invalidate: (B = 1) => a(h(), B),
      advance: (B, k) => e(B, k, h()),
      legacy: !1,
      linear: !1,
      flat: !1,
      scene: Nb(new zM()),
      controls: null,
      clock: new yL(),
      pointer: P,
      mouse: P,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const B = h();
          C && clearTimeout(C), B.performance.current !== B.performance.min && D(B.performance.min), C = setTimeout(() => D(h().performance.max), B.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: T
      },
      setEvents: (B) => d((k) => ({
        ...k,
        events: {
          ...k.events,
          ...B
        }
      })),
      setSize: (B, k, V, I, X) => {
        const J = h().camera, $ = {
          width: B,
          height: k,
          top: I || 0,
          left: X || 0,
          updateStyle: V
        };
        d((W) => ({
          size: $,
          viewport: {
            ...W.viewport,
            ...T(J, S, $)
          }
        }));
      },
      setDpr: (B) => d((k) => {
        const V = E4(B);
        return {
          viewport: {
            ...k.viewport,
            dpr: V,
            initialDpr: k.viewport.initialDpr || V
          }
        };
      }),
      setFrameloop: (B = "always") => {
        const k = h().clock;
        k.stop(), k.elapsedTime = 0, B !== "never" && (k.start(), k.elapsedTime = 0), d(() => ({
          frameloop: B
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ Or.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (B, k, V) => {
          const I = h().internal;
          return I.priority = I.priority + (k > 0 ? 1 : 0), I.subscribers.push({
            ref: B,
            priority: k,
            store: V
          }), I.subscribers = I.subscribers.sort((X, J) => X.priority - J.priority), () => {
            const X = h().internal;
            X != null && X.subscribers && (X.priority = X.priority - (k > 0 ? 1 : 0), X.subscribers = X.subscribers.filter((J) => J.ref !== B));
          };
        }
      }
    };
  }), r = t.getState();
  let i = r.size, o = r.viewport.dpr, l = r.camera;
  return t.subscribe(() => {
    const {
      camera: d,
      size: h,
      viewport: m,
      gl: S,
      set: _
    } = t.getState();
    (h !== i || m.dpr !== o) && (i = h, o = m.dpr, M9(d, h), S.setPixelRatio(m.dpr), S.setSize(h.width, h.height, h.updateStyle)), d !== l && (l = d, _((T) => ({
      viewport: {
        ...T.viewport,
        ...T.viewport.getCurrentViewport(d)
      }
    })));
  }), t.subscribe((d) => a(d)), t;
};
let Q2, O9 = /* @__PURE__ */ new Set(), U9 = /* @__PURE__ */ new Set(), z9 = /* @__PURE__ */ new Set();
function fD(a, e) {
  !a.size || a.forEach(({
    callback: t
  }) => t(e));
}
function oM(a, e) {
  switch (a) {
    case "before":
      return fD(O9, e);
    case "after":
      return fD(U9, e);
    case "tail":
      return fD(z9, e);
  }
}
let dD, hD;
function pD(a, e, t) {
  let r = e.clock.getDelta();
  for (e.frameloop === "never" && typeof a == "number" && (r = a - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = a), dD = e.internal.subscribers, Q2 = 0; Q2 < dD.length; Q2++)
    hD = dD[Q2], hD.ref.current(hD.store.getState(), r, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function N9(a) {
  let e = !1, t, r, i;
  function o(h) {
    if (r = requestAnimationFrame(o), e = !0, t = 0, oM("before", h), a.forEach((m) => {
      var S;
      i = m.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((S = i.gl.xr) != null && S.isPresenting) && (t += pD(h, i));
    }), oM("after", h), t === 0)
      return oM("tail", h), e = !1, cancelAnimationFrame(r);
  }
  function l(h, m = 1) {
    var S;
    if (!h)
      return a.forEach((_) => l(_.store.getState()), m);
    (S = h.gl.xr) != null && S.isPresenting || !h.internal.active || h.frameloop === "never" || (h.internal.frames = Math.min(60, h.internal.frames + m), e || (e = !0, requestAnimationFrame(o)));
  }
  function d(h, m = !0, S, _) {
    m && oM("before", h), S ? pD(h, S, _) : a.forEach((T) => pD(h, T.store.getState())), m && oM("after", h);
  }
  return {
    loop: o,
    invalidate: l,
    advance: d
  };
}
function A4() {
  const a = Or.useContext(R4);
  if (!a)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return a;
}
function Od(a = (t) => t, e) {
  return A4()(a, e);
}
function yy(a, e = 0) {
  const t = A4(), r = t.getState().internal.subscribe, i = _4(a);
  return iT(() => r(i, e, t), [e, r, t]), null;
}
const uw = /* @__PURE__ */ new Map(), {
  invalidate: cz,
  advance: fz
} = N9(uw), {
  reconciler: AC,
  applyProps: Z2
} = L9(uw, C9), Ub = {
  objects: "shallow",
  strict: !1
}, F9 = (a, e) => {
  const t = typeof a == "function" ? a(e) : a;
  return C4(t) ? t : new $3({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...a
  });
};
function k9(a) {
  return a instanceof HTMLCanvasElement;
}
function I9(a, e) {
  if (e)
    return e;
  if (k9(a) && a.parentElement) {
    const {
      width: t,
      height: r,
      top: i,
      left: o
    } = a.parentElement.getBoundingClientRect();
    return {
      width: t,
      height: r,
      top: i,
      left: o
    };
  }
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function B9(a) {
  const e = uw.get(a), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error, o = r || P9(cz, fz), l = t || AC.createContainer(o, Yb.exports.ConcurrentRoot, null, !1, null, "", i, null);
  e || uw.set(a, {
    fiber: l,
    store: o
  });
  let d, h = !1;
  return {
    configure(m = {}) {
      let {
        gl: S,
        size: _,
        events: T,
        onCreated: C,
        shadows: D = !1,
        linear: P = !1,
        flat: U = !1,
        legacy: B = !1,
        orthographic: k = !1,
        frameloop: V = "always",
        dpr: I = [1, 2],
        performance: X,
        raycaster: J,
        camera: $,
        onPointerMissed: W
      } = m, ee = o.getState(), ie = ee.gl;
      ee.gl || ee.set({
        gl: ie = F9(S, a)
      });
      let pe = ee.raycaster;
      pe || ee.set({
        raycaster: pe = new _L()
      });
      const {
        params: ce,
        ...Ee
      } = J || {};
      if (qu.equ(Ee, pe, Ub) || Z2(pe, {
        ...Ee
      }), qu.equ(ce, pe.params, Ub) || Z2(pe, {
        params: {
          ...pe.params,
          ...ce
        }
      }), !ee.camera) {
        const Be = $ instanceof hw, he = Be ? $ : k ? new cy(0, 0, 0, 0, 0.1, 1e3) : new fo(75, 0, 0.1, 1e3);
        Be || (he.position.z = 5, $ && Z2(he, $), $ != null && $.rotation || he.lookAt(0, 0, 0)), ee.set({
          camera: he
        });
      }
      if (!ee.xr) {
        const Be = (ue, ye) => {
          const we = o.getState();
          we.frameloop !== "never" && fz(ue, !0, we, ye);
        }, he = () => {
          const ue = o.getState();
          ue.gl.xr.enabled = ue.gl.xr.isPresenting, ue.gl.xr.setAnimationLoop(ue.gl.xr.isPresenting ? Be : null), ue.gl.xr.isPresenting || cz(ue);
        }, fe = {
          connect() {
            const ue = o.getState().gl;
            ue.xr.addEventListener("sessionstart", he), ue.xr.addEventListener("sessionend", he);
          },
          disconnect() {
            const ue = o.getState().gl;
            ue.xr.removeEventListener("sessionstart", he), ue.xr.removeEventListener("sessionend", he);
          }
        };
        ie.xr && fe.connect(), ee.set({
          xr: fe
        });
      }
      if (ie.shadowMap) {
        const Be = qu.boo(D);
        if (Be && ie.shadowMap.enabled !== D || !qu.equ(D, ie.shadowMap, Ub)) {
          const he = ie.shadowMap.enabled;
          ie.shadowMap.enabled = !!D, Be ? ie.shadowMap.type = H3 : Object.assign(ie.shadowMap, D), he !== ie.shadowMap.enabled && (ie.shadowMap.needsUpdate = !0);
        }
      }
      "ColorManagement" in RC && T9(RC, B, ["ColorManagement", "legacyMode"]);
      const de = P ? yv : Mi, Fe = U ? rg : G3;
      ie.outputEncoding !== de && (ie.outputEncoding = de), ie.toneMapping !== Fe && (ie.toneMapping = Fe), ee.legacy !== B && ee.set(() => ({
        legacy: B
      })), ee.linear !== P && ee.set(() => ({
        linear: P
      })), ee.flat !== U && ee.set(() => ({
        flat: U
      })), S && !qu.fun(S) && !C4(S) && !qu.equ(S, ie, Ub) && Z2(ie, S), T && !ee.events.handlers && ee.set({
        events: T(o)
      }), I && ee.viewport.dpr !== E4(I) && ee.setDpr(I);
      const Ce = I9(a, _);
      return qu.equ(Ce, ee.size, Ub) || ee.setSize(Ce.width, Ce.height, Ce.updateStyle, Ce.top, Ce.left), ee.frameloop !== V && ee.setFrameloop(V), ee.onPointerMissed || ee.set({
        onPointerMissed: W
      }), X && !qu.equ(X, ee.performance, Ub) && ee.set((Be) => ({
        performance: {
          ...Be.performance,
          ...X
        }
      })), d = C, h = !0, this;
    },
    render(m) {
      return h || this.configure(), AC.updateContainer(
        /* @__PURE__ */ _n(H9, {
          store: o,
          children: m,
          onCreated: d,
          rootElement: a
        }),
        l,
        null,
        () => {
        }
      ), o;
    },
    unmount() {
      D4(a);
    }
  };
}
function H9({
  store: a,
  children: e,
  onCreated: t,
  rootElement: r
}) {
  return iT(() => {
    const i = a.getState();
    i.set((o) => ({
      internal: {
        ...o.internal,
        active: !0
      }
    })), t && t(i), a.getState().events.connected || i.events.connect == null || i.events.connect(r);
  }, []), /* @__PURE__ */ Or.createElement(R4.Provider, {
    value: a
  }, e);
}
function D4(a, e) {
  const t = uw.get(a), r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1), AC.updateContainer(null, r, null, () => {
      i && setTimeout(() => {
        try {
          var o, l, d, h;
          i.events.disconnect == null || i.events.disconnect(), (o = i.gl) == null || (l = o.renderLists) == null || l.dispose == null || l.dispose(), (d = i.gl) == null || d.forceContextLoss == null || d.forceContextLoss(), (h = i.gl) != null && h.xr && i.xr.disconnect(), E9(i), uw.delete(a), e && e(a);
        } catch {
        }
      }, 500);
    });
  }
}
AC.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: Or.version
});
function T3(a, e, t) {
  var r, i, o, l, d;
  e == null && (e = 100);
  function h() {
    var S = Date.now() - l;
    S < e && S >= 0 ? r = setTimeout(h, e - S) : (r = null, t || (d = a.apply(o, i), o = i = null));
  }
  var m = function() {
    o = this, i = arguments, l = Date.now();
    var S = t && !r;
    return r || (r = setTimeout(h, e)), S && (d = a.apply(o, i), o = i = null), d;
  };
  return m.clear = function() {
    r && (clearTimeout(r), r = null);
  }, m.flush = function() {
    r && (d = a.apply(o, i), o = i = null, clearTimeout(r), r = null);
  }, m;
}
T3.debounce = T3;
var dz = T3;
function V9(a) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: i
  } = a === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : a;
  const o = r || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!o)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [l, d] = kb({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), h = uo({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: l
  }), m = e ? typeof e == "number" ? e : e.scroll : null, S = e ? typeof e == "number" ? e : e.resize : null, _ = uo(!1);
  fh(() => (_.current = !0, () => void (_.current = !1)));
  const [T, C, D] = qb(() => {
    const k = () => {
      if (!h.current.element)
        return;
      const {
        left: V,
        top: I,
        width: X,
        height: J,
        bottom: $,
        right: W,
        x: ee,
        y: ie
      } = h.current.element.getBoundingClientRect(), pe = {
        left: V,
        top: I,
        width: X,
        height: J,
        bottom: $,
        right: W,
        x: ee,
        y: ie
      };
      h.current.element instanceof HTMLElement && i && (pe.height = h.current.element.offsetHeight, pe.width = h.current.element.offsetWidth), Object.freeze(pe), _.current && !Y9(h.current.lastBounds, pe) && d(h.current.lastBounds = pe);
    };
    return [k, S ? dz(k, S) : k, m ? dz(k, m) : k];
  }, [d, i, m, S]);
  function P() {
    h.current.scrollContainers && (h.current.scrollContainers.forEach((k) => k.removeEventListener("scroll", D, !0)), h.current.scrollContainers = null), h.current.resizeObserver && (h.current.resizeObserver.disconnect(), h.current.resizeObserver = null);
  }
  function U() {
    !h.current.element || (h.current.resizeObserver = new o(D), h.current.resizeObserver.observe(h.current.element), t && h.current.scrollContainers && h.current.scrollContainers.forEach((k) => k.addEventListener("scroll", D, {
      capture: !0,
      passive: !0
    })));
  }
  const B = (k) => {
    !k || k === h.current.element || (P(), h.current.element = k, h.current.scrollContainers = L4(k), U());
  };
  return W9(D, Boolean(t)), G9(C), fh(() => {
    P(), U();
  }, [t, D, C]), fh(() => P, []), [B, l, T];
}
function G9(a) {
  fh(() => {
    const e = a;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [a]);
}
function W9(a, e) {
  fh(() => {
    if (e) {
      const t = a;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [a, e]);
}
function L4(a) {
  const e = [];
  if (!a || a === document.body)
    return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i
  } = window.getComputedStyle(a);
  return [t, r, i].some((o) => o === "auto" || o === "scroll") && e.push(a), [...e, ...L4(a.parentElement)];
}
const j9 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], Y9 = (a, e) => j9.every((t) => a[t] === e[t]), mD = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function X9(a) {
  const {
    handlePointer: e
  } = A9(a);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(mD).reduce((t, r) => ({
      ...t,
      [r]: e(r)
    }), {}),
    connect: (t) => {
      var r;
      const {
        set: i,
        events: o
      } = a.getState();
      o.disconnect == null || o.disconnect(), i((l) => ({
        events: {
          ...l.events,
          connected: t
        }
      })), Object.entries((r = o.handlers) != null ? r : []).forEach(([l, d]) => {
        const [h, m] = mD[l];
        t.addEventListener(h, d, {
          passive: m
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: r
      } = a.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, l]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [d] = mD[o];
            r.connected.removeEventListener(d, l);
          }
        }), t((o) => ({
          events: {
            ...o.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const P4 = /* @__PURE__ */ Or.forwardRef(function({
  children: e,
  fallback: t,
  resize: r,
  style: i,
  gl: o,
  events: l = X9,
  eventSource: d,
  eventPrefix: h,
  shadows: m,
  linear: S,
  flat: _,
  legacy: T,
  orthographic: C,
  frameloop: D,
  dpr: P,
  performance: U,
  raycaster: B,
  camera: k,
  onPointerMissed: V,
  onCreated: I,
  ...X
}, J) {
  Or.useMemo(() => D9(RC), []);
  const [$, W] = V9({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...r
  }), ee = Or.useRef(null), ie = Or.useRef(null), [pe, ce] = Or.useState(null);
  Or.useImperativeHandle(J, () => ee.current);
  const Ee = _4(V), [de, Fe] = Or.useState(!1), [Ce, Be] = Or.useState(!1);
  if (de)
    throw de;
  if (Ce)
    throw Ce;
  const he = Or.useRef(null);
  return W.width > 0 && W.height > 0 && pe && (he.current || (he.current = B9(pe)), he.current.configure({
    gl: o,
    events: l,
    shadows: m,
    linear: S,
    flat: _,
    legacy: T,
    orthographic: C,
    frameloop: D,
    dpr: P,
    performance: U,
    raycaster: B,
    camera: k,
    size: W,
    onPointerMissed: (...ue) => Ee.current == null ? void 0 : Ee.current(...ue),
    onCreated: (ue) => {
      ue.events.connect == null || ue.events.connect(d ? _9(d) ? d.current : d : ie.current), h && ue.setEvents({
        compute: (ye, we) => {
          const Xe = ye[h + "X"], Je = ye[h + "Y"];
          we.pointer.set(Xe / we.size.width * 2 - 1, -(Je / we.size.height) * 2 + 1), we.raycaster.setFromCamera(we.pointer, we.camera);
        }
      }), I == null || I(ue);
    }
  }), he.current.render(
    /* @__PURE__ */ _n(b4, {
      set: Be,
      children: /* @__PURE__ */ _n(Or.Suspense, {
        fallback: /* @__PURE__ */ _n(b9, {
          set: Fe
        }),
        children: e
      })
    })
  )), iT(() => {
    ce(ee.current);
  }, []), Or.useEffect(() => {
    if (pe)
      return () => D4(pe);
  }, [pe]), /* @__PURE__ */ _n("div", {
    ref: ie,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: d ? "none" : "auto",
      ...i
    },
    ...X,
    children: /* @__PURE__ */ _n("div", {
      ref: $,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ _n("canvas", {
        ref: ee,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
});
var BS = [], q9 = function() {
  return BS.some(function(a) {
    return a.activeTargets.length > 0;
  });
}, Q9 = function() {
  return BS.some(function(a) {
    return a.skippedTargets.length > 0;
  });
}, hz = "ResizeObserver loop completed with undelivered notifications.", Z9 = function() {
  var a;
  typeof ErrorEvent == "function" ? a = new ErrorEvent("error", {
    message: hz
  }) : (a = document.createEvent("Event"), a.initEvent("error", !1, !1), a.message = hz), window.dispatchEvent(a);
}, YM;
(function(a) {
  a.BORDER_BOX = "border-box", a.CONTENT_BOX = "content-box", a.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(YM || (YM = {}));
var HS = function(a) {
  return Object.freeze(a);
}, J9 = function() {
  function a(e, t) {
    this.inlineSize = e, this.blockSize = t, HS(this);
  }
  return a;
}(), O4 = function() {
  function a(e, t, r, i) {
    return this.x = e, this.y = t, this.width = r, this.height = i, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, HS(this);
  }
  return a.prototype.toJSON = function() {
    var e = this, t = e.x, r = e.y, i = e.top, o = e.right, l = e.bottom, d = e.left, h = e.width, m = e.height;
    return { x: t, y: r, top: i, right: o, bottom: l, left: d, width: h, height: m };
  }, a.fromRect = function(e) {
    return new a(e.x, e.y, e.width, e.height);
  }, a;
}(), wL = function(a) {
  return a instanceof SVGElement && "getBBox" in a;
}, U4 = function(a) {
  if (wL(a)) {
    var e = a.getBBox(), t = e.width, r = e.height;
    return !t && !r;
  }
  var i = a, o = i.offsetWidth, l = i.offsetHeight;
  return !(o || l || a.getClientRects().length);
}, pz = function(a) {
  var e, t;
  if (a instanceof Element)
    return !0;
  var r = (t = (e = a) === null || e === void 0 ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(r && a instanceof r.Element);
}, K9 = function(a) {
  switch (a.tagName) {
    case "INPUT":
      if (a.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, _M = typeof window < "u" ? window : {}, J2 = /* @__PURE__ */ new WeakMap(), mz = /auto|scroll/, $9 = /^tb|vertical/, ej = /msie|trident/i.test(_M.navigator && _M.navigator.userAgent), ny = function(a) {
  return parseFloat(a || "0");
}, Xb = function(a, e, t) {
  return a === void 0 && (a = 0), e === void 0 && (e = 0), t === void 0 && (t = !1), new J9((t ? e : a) || 0, (t ? a : e) || 0);
}, vz = HS({
  devicePixelContentBoxSize: Xb(),
  borderBoxSize: Xb(),
  contentBoxSize: Xb(),
  contentRect: new O4(0, 0, 0, 0)
}), z4 = function(a, e) {
  if (e === void 0 && (e = !1), J2.has(a) && !e)
    return J2.get(a);
  if (U4(a))
    return J2.set(a, vz), vz;
  var t = getComputedStyle(a), r = wL(a) && a.ownerSVGElement && a.getBBox(), i = !ej && t.boxSizing === "border-box", o = $9.test(t.writingMode || ""), l = !r && mz.test(t.overflowY || ""), d = !r && mz.test(t.overflowX || ""), h = r ? 0 : ny(t.paddingTop), m = r ? 0 : ny(t.paddingRight), S = r ? 0 : ny(t.paddingBottom), _ = r ? 0 : ny(t.paddingLeft), T = r ? 0 : ny(t.borderTopWidth), C = r ? 0 : ny(t.borderRightWidth), D = r ? 0 : ny(t.borderBottomWidth), P = r ? 0 : ny(t.borderLeftWidth), U = _ + m, B = h + S, k = P + C, V = T + D, I = d ? a.offsetHeight - V - a.clientHeight : 0, X = l ? a.offsetWidth - k - a.clientWidth : 0, J = i ? U + k : 0, $ = i ? B + V : 0, W = r ? r.width : ny(t.width) - J - X, ee = r ? r.height : ny(t.height) - $ - I, ie = W + U + X + k, pe = ee + B + I + V, ce = HS({
    devicePixelContentBoxSize: Xb(Math.round(W * devicePixelRatio), Math.round(ee * devicePixelRatio), o),
    borderBoxSize: Xb(ie, pe, o),
    contentBoxSize: Xb(W, ee, o),
    contentRect: new O4(_, h, W, ee)
  });
  return J2.set(a, ce), ce;
}, N4 = function(a, e, t) {
  var r = z4(a, t), i = r.borderBoxSize, o = r.contentBoxSize, l = r.devicePixelContentBoxSize;
  switch (e) {
    case YM.DEVICE_PIXEL_CONTENT_BOX:
      return l;
    case YM.BORDER_BOX:
      return i;
    default:
      return o;
  }
}, tj = function() {
  function a(e) {
    var t = z4(e);
    this.target = e, this.contentRect = t.contentRect, this.borderBoxSize = HS([t.borderBoxSize]), this.contentBoxSize = HS([t.contentBoxSize]), this.devicePixelContentBoxSize = HS([t.devicePixelContentBoxSize]);
  }
  return a;
}(), F4 = function(a) {
  if (U4(a))
    return 1 / 0;
  for (var e = 0, t = a.parentNode; t; )
    e += 1, t = t.parentNode;
  return e;
}, nj = function() {
  var a = 1 / 0, e = [];
  BS.forEach(function(l) {
    if (l.activeTargets.length !== 0) {
      var d = [];
      l.activeTargets.forEach(function(m) {
        var S = new tj(m.target), _ = F4(m.target);
        d.push(S), m.lastReportedSize = N4(m.target, m.observedBox), _ < a && (a = _);
      }), e.push(function() {
        l.callback.call(l.observer, d, l.observer);
      }), l.activeTargets.splice(0, l.activeTargets.length);
    }
  });
  for (var t = 0, r = e; t < r.length; t++) {
    var i = r[t];
    i();
  }
  return a;
}, gz = function(a) {
  BS.forEach(function(t) {
    t.activeTargets.splice(0, t.activeTargets.length), t.skippedTargets.splice(0, t.skippedTargets.length), t.observationTargets.forEach(function(i) {
      i.isActive() && (F4(i.target) > a ? t.activeTargets.push(i) : t.skippedTargets.push(i));
    });
  });
}, rj = function() {
  var a = 0;
  for (gz(a); q9(); )
    a = nj(), gz(a);
  return Q9() && Z9(), a > 0;
}, vD, k4 = [], ij = function() {
  return k4.splice(0).forEach(function(a) {
    return a();
  });
}, aj = function(a) {
  if (!vD) {
    var e = 0, t = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return ij();
    }).observe(t, r), vD = function() {
      t.textContent = "" + (e ? e-- : e++);
    };
  }
  k4.push(a), vD();
}, sj = function(a) {
  aj(function() {
    requestAnimationFrame(a);
  });
}, gC = 0, oj = function() {
  return !!gC;
}, lj = 250, uj = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, yz = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], xz = function(a) {
  return a === void 0 && (a = 0), Date.now() + a;
}, gD = !1, cj = function() {
  function a() {
    var e = this;
    this.stopped = !0, this.listener = function() {
      return e.schedule();
    };
  }
  return a.prototype.run = function(e) {
    var t = this;
    if (e === void 0 && (e = lj), !gD) {
      gD = !0;
      var r = xz(e);
      sj(function() {
        var i = !1;
        try {
          i = rj();
        } finally {
          if (gD = !1, e = r - xz(), !oj())
            return;
          i ? t.run(1e3) : e > 0 ? t.run(e) : t.start();
        }
      });
    }
  }, a.prototype.schedule = function() {
    this.stop(), this.run();
  }, a.prototype.observe = function() {
    var e = this, t = function() {
      return e.observer && e.observer.observe(document.body, uj);
    };
    document.body ? t() : _M.addEventListener("DOMContentLoaded", t);
  }, a.prototype.start = function() {
    var e = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), yz.forEach(function(t) {
      return _M.addEventListener(t, e.listener, !0);
    }));
  }, a.prototype.stop = function() {
    var e = this;
    this.stopped || (this.observer && this.observer.disconnect(), yz.forEach(function(t) {
      return _M.removeEventListener(t, e.listener, !0);
    }), this.stopped = !0);
  }, a;
}(), C3 = new cj(), Sz = function(a) {
  !gC && a > 0 && C3.start(), gC += a, !gC && C3.stop();
}, fj = function(a) {
  return !wL(a) && !K9(a) && getComputedStyle(a).display === "inline";
}, dj = function() {
  function a(e, t) {
    this.target = e, this.observedBox = t || YM.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return a.prototype.isActive = function() {
    var e = N4(this.target, this.observedBox, !0);
    return fj(this.target) && (this.lastReportedSize = e), this.lastReportedSize.inlineSize !== e.inlineSize || this.lastReportedSize.blockSize !== e.blockSize;
  }, a;
}(), hj = function() {
  function a(e, t) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = e, this.callback = t;
  }
  return a;
}(), K2 = /* @__PURE__ */ new WeakMap(), _z = function(a, e) {
  for (var t = 0; t < a.length; t += 1)
    if (a[t].target === e)
      return t;
  return -1;
}, $2 = function() {
  function a() {
  }
  return a.connect = function(e, t) {
    var r = new hj(e, t);
    K2.set(e, r);
  }, a.observe = function(e, t, r) {
    var i = K2.get(e), o = i.observationTargets.length === 0;
    _z(i.observationTargets, t) < 0 && (o && BS.push(i), i.observationTargets.push(new dj(t, r && r.box)), Sz(1), C3.schedule());
  }, a.unobserve = function(e, t) {
    var r = K2.get(e), i = _z(r.observationTargets, t), o = r.observationTargets.length === 1;
    i >= 0 && (o && BS.splice(BS.indexOf(r), 1), r.observationTargets.splice(i, 1), Sz(-1));
  }, a.disconnect = function(e) {
    var t = this, r = K2.get(e);
    r.observationTargets.slice().forEach(function(i) {
      return t.unobserve(e, i.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, a;
}(), I4 = function() {
  function a(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof e != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    $2.connect(this, e);
  }
  return a.prototype.observe = function(e, t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!pz(e))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    $2.observe(this, e, t);
  }, a.prototype.unobserve = function(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!pz(e))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    $2.unobserve(this, e);
  }, a.prototype.disconnect = function() {
    $2.disconnect(this);
  }, a.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, a;
}(), B4 = { exports: {} }, Ap = {}, yD = { exports: {} }, xD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bz;
function pj() {
  return bz || (bz = 1, function(a) {
    function e(he, fe) {
      var ue = he.length;
      he.push(fe);
      e:
        for (; 0 < ue; ) {
          var ye = ue - 1 >>> 1, we = he[ye];
          if (0 < i(we, fe))
            he[ye] = fe, he[ue] = we, ue = ye;
          else
            break e;
        }
    }
    function t(he) {
      return he.length === 0 ? null : he[0];
    }
    function r(he) {
      if (he.length === 0)
        return null;
      var fe = he[0], ue = he.pop();
      if (ue !== fe) {
        he[0] = ue;
        e:
          for (var ye = 0, we = he.length, Xe = we >>> 1; ye < Xe; ) {
            var Je = 2 * (ye + 1) - 1, st = he[Je], Ue = Je + 1, ot = he[Ue];
            if (0 > i(st, ue))
              Ue < we && 0 > i(ot, st) ? (he[ye] = ot, he[Ue] = ue, ye = Ue) : (he[ye] = st, he[Je] = ue, ye = Je);
            else if (Ue < we && 0 > i(ot, ue))
              he[ye] = ot, he[Ue] = ue, ye = Ue;
            else
              break e;
          }
      }
      return fe;
    }
    function i(he, fe) {
      var ue = he.sortIndex - fe.sortIndex;
      return ue !== 0 ? ue : he.id - fe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      a.unstable_now = function() {
        return o.now();
      };
    } else {
      var l = Date, d = l.now();
      a.unstable_now = function() {
        return l.now() - d;
      };
    }
    var h = [], m = [], S = 1, _ = null, T = 3, C = !1, D = !1, P = !1, U = typeof setTimeout == "function" ? setTimeout : null, B = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function V(he) {
      for (var fe = t(m); fe !== null; ) {
        if (fe.callback === null)
          r(m);
        else if (fe.startTime <= he)
          r(m), fe.sortIndex = fe.expirationTime, e(h, fe);
        else
          break;
        fe = t(m);
      }
    }
    function I(he) {
      if (P = !1, V(he), !D)
        if (t(h) !== null)
          D = !0, Ce(X);
        else {
          var fe = t(m);
          fe !== null && Be(I, fe.startTime - he);
        }
    }
    function X(he, fe) {
      D = !1, P && (P = !1, B(W), W = -1), C = !0;
      var ue = T;
      try {
        for (V(fe), _ = t(h); _ !== null && (!(_.expirationTime > fe) || he && !pe()); ) {
          var ye = _.callback;
          if (typeof ye == "function") {
            _.callback = null, T = _.priorityLevel;
            var we = ye(_.expirationTime <= fe);
            fe = a.unstable_now(), typeof we == "function" ? _.callback = we : _ === t(h) && r(h), V(fe);
          } else
            r(h);
          _ = t(h);
        }
        if (_ !== null)
          var Xe = !0;
        else {
          var Je = t(m);
          Je !== null && Be(I, Je.startTime - fe), Xe = !1;
        }
        return Xe;
      } finally {
        _ = null, T = ue, C = !1;
      }
    }
    var J = !1, $ = null, W = -1, ee = 5, ie = -1;
    function pe() {
      return !(a.unstable_now() - ie < ee);
    }
    function ce() {
      if ($ !== null) {
        var he = a.unstable_now();
        ie = he;
        var fe = !0;
        try {
          fe = $(!0, he);
        } finally {
          fe ? Ee() : (J = !1, $ = null);
        }
      } else
        J = !1;
    }
    var Ee;
    if (typeof k == "function")
      Ee = function() {
        k(ce);
      };
    else if (typeof MessageChannel < "u") {
      var de = new MessageChannel(), Fe = de.port2;
      de.port1.onmessage = ce, Ee = function() {
        Fe.postMessage(null);
      };
    } else
      Ee = function() {
        U(ce, 0);
      };
    function Ce(he) {
      $ = he, J || (J = !0, Ee());
    }
    function Be(he, fe) {
      W = U(function() {
        he(a.unstable_now());
      }, fe);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(he) {
      he.callback = null;
    }, a.unstable_continueExecution = function() {
      D || C || (D = !0, Ce(X));
    }, a.unstable_forceFrameRate = function(he) {
      0 > he || 125 < he ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ee = 0 < he ? Math.floor(1e3 / he) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return T;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(h);
    }, a.unstable_next = function(he) {
      switch (T) {
        case 1:
        case 2:
        case 3:
          var fe = 3;
          break;
        default:
          fe = T;
      }
      var ue = T;
      T = fe;
      try {
        return he();
      } finally {
        T = ue;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(he, fe) {
      switch (he) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          he = 3;
      }
      var ue = T;
      T = he;
      try {
        return fe();
      } finally {
        T = ue;
      }
    }, a.unstable_scheduleCallback = function(he, fe, ue) {
      var ye = a.unstable_now();
      switch (typeof ue == "object" && ue !== null ? (ue = ue.delay, ue = typeof ue == "number" && 0 < ue ? ye + ue : ye) : ue = ye, he) {
        case 1:
          var we = -1;
          break;
        case 2:
          we = 250;
          break;
        case 5:
          we = 1073741823;
          break;
        case 4:
          we = 1e4;
          break;
        default:
          we = 5e3;
      }
      return we = ue + we, he = { id: S++, callback: fe, priorityLevel: he, startTime: ue, expirationTime: we, sortIndex: -1 }, ue > ye ? (he.sortIndex = ue, e(m, he), t(h) === null && he === t(m) && (P ? (B(W), W = -1) : P = !0, Be(I, ue - ye))) : (he.sortIndex = we, e(h, he), D || C || (D = !0, Ce(X))), he;
    }, a.unstable_shouldYield = pe, a.unstable_wrapCallback = function(he) {
      var fe = T;
      return function() {
        var ue = T;
        T = fe;
        try {
          return he.apply(this, arguments);
        } finally {
          T = ue;
        }
      };
    };
  }(xD)), xD;
}
var SD = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wz;
function mj() {
  return wz || (wz = 1, function(a) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(ze, xe) {
        var Ie = ze.length;
        ze.push(xe), d(ze, xe, Ie);
      }
      function o(ze) {
        return ze.length === 0 ? null : ze[0];
      }
      function l(ze) {
        if (ze.length === 0)
          return null;
        var xe = ze[0], Ie = ze.pop();
        return Ie !== xe && (ze[0] = Ie, h(ze, Ie, 0)), xe;
      }
      function d(ze, xe, Ie) {
        for (var it = Ie; it > 0; ) {
          var at = it - 1 >>> 1, hn = ze[at];
          if (m(hn, xe) > 0)
            ze[at] = xe, ze[it] = hn, it = at;
          else
            return;
        }
      }
      function h(ze, xe, Ie) {
        for (var it = Ie, at = ze.length, hn = at >>> 1; it < hn; ) {
          var De = (it + 1) * 2 - 1, Tt = ze[De], Ne = De + 1, Gt = ze[Ne];
          if (m(Tt, xe) < 0)
            Ne < at && m(Gt, Tt) < 0 ? (ze[it] = Gt, ze[Ne] = xe, it = Ne) : (ze[it] = Tt, ze[De] = xe, it = De);
          else if (Ne < at && m(Gt, xe) < 0)
            ze[it] = Gt, ze[Ne] = xe, it = Ne;
          else
            return;
        }
      }
      function m(ze, xe) {
        var Ie = ze.sortIndex - xe.sortIndex;
        return Ie !== 0 ? Ie : ze.id - xe.id;
      }
      var S = 1, _ = 2, T = 3, C = 4, D = 5;
      function P(ze, xe) {
      }
      var U = typeof performance == "object" && typeof performance.now == "function";
      if (U) {
        var B = performance;
        a.unstable_now = function() {
          return B.now();
        };
      } else {
        var k = Date, V = k.now();
        a.unstable_now = function() {
          return k.now() - V;
        };
      }
      var I = 1073741823, X = -1, J = 250, $ = 5e3, W = 1e4, ee = I, ie = [], pe = [], ce = 1, Ee = null, de = T, Fe = !1, Ce = !1, Be = !1, he = typeof setTimeout == "function" ? setTimeout : null, fe = typeof clearTimeout == "function" ? clearTimeout : null, ue = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ye(ze) {
        for (var xe = o(pe); xe !== null; ) {
          if (xe.callback === null)
            l(pe);
          else if (xe.startTime <= ze)
            l(pe), xe.sortIndex = xe.expirationTime, i(ie, xe);
          else
            return;
          xe = o(pe);
        }
      }
      function we(ze) {
        if (Be = !1, ye(ze), !Ce)
          if (o(ie) !== null)
            Ce = !0, zt(Xe);
          else {
            var xe = o(pe);
            xe !== null && Nt(we, xe.startTime - ze);
          }
      }
      function Xe(ze, xe) {
        Ce = !1, Be && (Be = !1, Ut()), Fe = !0;
        var Ie = de;
        try {
          var it;
          if (!t)
            return Je(ze, xe);
        } finally {
          Ee = null, de = Ie, Fe = !1;
        }
      }
      function Je(ze, xe) {
        var Ie = xe;
        for (ye(Ie), Ee = o(ie); Ee !== null && !e && !(Ee.expirationTime > Ie && (!ze || Vt())); ) {
          var it = Ee.callback;
          if (typeof it == "function") {
            Ee.callback = null, de = Ee.priorityLevel;
            var at = Ee.expirationTime <= Ie, hn = it(at);
            Ie = a.unstable_now(), typeof hn == "function" ? Ee.callback = hn : Ee === o(ie) && l(ie), ye(Ie);
          } else
            l(ie);
          Ee = o(ie);
        }
        if (Ee !== null)
          return !0;
        var De = o(pe);
        return De !== null && Nt(we, De.startTime - Ie), !1;
      }
      function st(ze, xe) {
        switch (ze) {
          case S:
          case _:
          case T:
          case C:
          case D:
            break;
          default:
            ze = T;
        }
        var Ie = de;
        de = ze;
        try {
          return xe();
        } finally {
          de = Ie;
        }
      }
      function Ue(ze) {
        var xe;
        switch (de) {
          case S:
          case _:
          case T:
            xe = T;
            break;
          default:
            xe = de;
            break;
        }
        var Ie = de;
        de = xe;
        try {
          return ze();
        } finally {
          de = Ie;
        }
      }
      function ot(ze) {
        var xe = de;
        return function() {
          var Ie = de;
          de = xe;
          try {
            return ze.apply(this, arguments);
          } finally {
            de = Ie;
          }
        };
      }
      function rt(ze, xe, Ie) {
        var it = a.unstable_now(), at;
        if (typeof Ie == "object" && Ie !== null) {
          var hn = Ie.delay;
          typeof hn == "number" && hn > 0 ? at = it + hn : at = it;
        } else
          at = it;
        var De;
        switch (ze) {
          case S:
            De = X;
            break;
          case _:
            De = J;
            break;
          case D:
            De = ee;
            break;
          case C:
            De = W;
            break;
          case T:
          default:
            De = $;
            break;
        }
        var Tt = at + De, Ne = {
          id: ce++,
          callback: xe,
          priorityLevel: ze,
          startTime: at,
          expirationTime: Tt,
          sortIndex: -1
        };
        return at > it ? (Ne.sortIndex = at, i(pe, Ne), o(ie) === null && Ne === o(pe) && (Be ? Ut() : Be = !0, Nt(we, at - it))) : (Ne.sortIndex = Tt, i(ie, Ne), !Ce && !Fe && (Ce = !0, zt(Xe))), Ne;
      }
      function _t() {
      }
      function Rt() {
        !Ce && !Fe && (Ce = !0, zt(Xe));
      }
      function Ot() {
        return o(ie);
      }
      function He(ze) {
        ze.callback = null;
      }
      function et() {
        return de;
      }
      var mt = !1, vt = null, bt = -1, Qt = r, ft = -1;
      function Vt() {
        var ze = a.unstable_now() - ft;
        return !(ze < Qt);
      }
      function Jt() {
      }
      function Mt(ze) {
        if (ze < 0 || ze > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ze > 0 ? Qt = Math.floor(1e3 / ze) : Qt = r;
      }
      var Me = function() {
        if (vt !== null) {
          var ze = a.unstable_now();
          ft = ze;
          var xe = !0, Ie = !0;
          try {
            Ie = vt(xe, ze);
          } finally {
            Ie ? oe() : (mt = !1, vt = null);
          }
        } else
          mt = !1;
      }, oe;
      if (typeof ue == "function")
        oe = function() {
          ue(Me);
        };
      else if (typeof MessageChannel < "u") {
        var je = new MessageChannel(), lt = je.port2;
        je.port1.onmessage = Me, oe = function() {
          lt.postMessage(null);
        };
      } else
        oe = function() {
          he(Me, 0);
        };
      function zt(ze) {
        vt = ze, mt || (mt = !0, oe());
      }
      function Nt(ze, xe) {
        bt = he(function() {
          ze(a.unstable_now());
        }, xe);
      }
      function Ut() {
        fe(bt), bt = -1;
      }
      var tt = Jt, rn = null;
      a.unstable_IdlePriority = D, a.unstable_ImmediatePriority = S, a.unstable_LowPriority = C, a.unstable_NormalPriority = T, a.unstable_Profiling = rn, a.unstable_UserBlockingPriority = _, a.unstable_cancelCallback = He, a.unstable_continueExecution = Rt, a.unstable_forceFrameRate = Mt, a.unstable_getCurrentPriorityLevel = et, a.unstable_getFirstCallbackNode = Ot, a.unstable_next = Ue, a.unstable_pauseExecution = _t, a.unstable_requestPaint = tt, a.unstable_runWithPriority = st, a.unstable_scheduleCallback = rt, a.unstable_shouldYield = Vt, a.unstable_wrapCallback = ot, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(SD)), SD;
}
var Ez;
function H4() {
  return Ez || (Ez = 1, function(a) {
    process.env.NODE_ENV === "production" ? a.exports = pj() : a.exports = mj();
  }(yD)), yD.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mz;
function vj() {
  if (Mz)
    return Ap;
  Mz = 1;
  var a = hh, e = H4();
  function t(c) {
    for (var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, E = 1; E < arguments.length; E++)
      p += "&args[]=" + encodeURIComponent(arguments[E]);
    return "Minified React error #" + c + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function o(c, p) {
    l(c, p), l(c + "Capture", p);
  }
  function l(c, p) {
    for (i[c] = p, c = 0; c < p.length; c++)
      r.add(p[c]);
  }
  var d = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), h = Object.prototype.hasOwnProperty, m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, S = {}, _ = {};
  function T(c) {
    return h.call(_, c) ? !0 : h.call(S, c) ? !1 : m.test(c) ? _[c] = !0 : (S[c] = !0, !1);
  }
  function C(c, p, E, O) {
    if (E !== null && E.type === 0)
      return !1;
    switch (typeof p) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return O ? !1 : E !== null ? !E.acceptsBooleans : (c = c.toLowerCase().slice(0, 5), c !== "data-" && c !== "aria-");
      default:
        return !1;
    }
  }
  function D(c, p, E, O) {
    if (p === null || typeof p > "u" || C(c, p, E, O))
      return !0;
    if (O)
      return !1;
    if (E !== null)
      switch (E.type) {
        case 3:
          return !p;
        case 4:
          return p === !1;
        case 5:
          return isNaN(p);
        case 6:
          return isNaN(p) || 1 > p;
      }
    return !1;
  }
  function P(c, p, E, O, G, Q, le) {
    this.acceptsBooleans = p === 2 || p === 3 || p === 4, this.attributeName = O, this.attributeNamespace = G, this.mustUseProperty = E, this.propertyName = c, this.type = p, this.sanitizeURL = Q, this.removeEmptyString = le;
  }
  var U = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(c) {
    U[c] = new P(c, 0, !1, c, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
    var p = c[0];
    U[p] = new P(p, 1, !1, c[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
    U[c] = new P(c, 2, !1, c.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
    U[c] = new P(c, 2, !1, c, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(c) {
    U[c] = new P(c, 3, !1, c.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(c) {
    U[c] = new P(c, 3, !0, c, null, !1, !1);
  }), ["capture", "download"].forEach(function(c) {
    U[c] = new P(c, 4, !1, c, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(c) {
    U[c] = new P(c, 6, !1, c, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(c) {
    U[c] = new P(c, 5, !1, c.toLowerCase(), null, !1, !1);
  });
  var B = /[\-:]([a-z])/g;
  function k(c) {
    return c[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(c) {
    var p = c.replace(
      B,
      k
    );
    U[p] = new P(p, 1, !1, c, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(c) {
    var p = c.replace(B, k);
    U[p] = new P(p, 1, !1, c, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(c) {
    var p = c.replace(B, k);
    U[p] = new P(p, 1, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(c) {
    U[c] = new P(c, 1, !1, c.toLowerCase(), null, !1, !1);
  }), U.xlinkHref = new P("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(c) {
    U[c] = new P(c, 1, !1, c.toLowerCase(), null, !0, !0);
  });
  function V(c, p, E, O) {
    var G = U.hasOwnProperty(p) ? U[p] : null;
    (G !== null ? G.type !== 0 : O || !(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (D(p, E, G, O) && (E = null), O || G === null ? T(p) && (E === null ? c.removeAttribute(p) : c.setAttribute(p, "" + E)) : G.mustUseProperty ? c[G.propertyName] = E === null ? G.type === 3 ? !1 : "" : E : (p = G.attributeName, O = G.attributeNamespace, E === null ? c.removeAttribute(p) : (G = G.type, E = G === 3 || G === 4 && E === !0 ? "" : "" + E, O ? c.setAttributeNS(O, p, E) : c.setAttribute(p, E))));
  }
  var I = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, X = Symbol.for("react.element"), J = Symbol.for("react.portal"), $ = Symbol.for("react.fragment"), W = Symbol.for("react.strict_mode"), ee = Symbol.for("react.profiler"), ie = Symbol.for("react.provider"), pe = Symbol.for("react.context"), ce = Symbol.for("react.forward_ref"), Ee = Symbol.for("react.suspense"), de = Symbol.for("react.suspense_list"), Fe = Symbol.for("react.memo"), Ce = Symbol.for("react.lazy"), Be = Symbol.for("react.offscreen"), he = Symbol.iterator;
  function fe(c) {
    return c === null || typeof c != "object" ? null : (c = he && c[he] || c["@@iterator"], typeof c == "function" ? c : null);
  }
  var ue = Object.assign, ye;
  function we(c) {
    if (ye === void 0)
      try {
        throw Error();
      } catch (E) {
        var p = E.stack.trim().match(/\n( *(at )?)/);
        ye = p && p[1] || "";
      }
    return `
` + ye + c;
  }
  var Xe = !1;
  function Je(c, p) {
    if (!c || Xe)
      return "";
    Xe = !0;
    var E = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (p)
        if (p = function() {
          throw Error();
        }, Object.defineProperty(p.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(p, []);
          } catch (Ct) {
            var O = Ct;
          }
          Reflect.construct(c, [], p);
        } else {
          try {
            p.call();
          } catch (Ct) {
            O = Ct;
          }
          c.call(p.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ct) {
          O = Ct;
        }
        c();
      }
    } catch (Ct) {
      if (Ct && O && typeof Ct.stack == "string") {
        for (var G = Ct.stack.split(`
`), Q = O.stack.split(`
`), le = G.length - 1, Le = Q.length - 1; 1 <= le && 0 <= Le && G[le] !== Q[Le]; )
          Le--;
        for (; 1 <= le && 0 <= Le; le--, Le--)
          if (G[le] !== Q[Le]) {
            if (le !== 1 || Le !== 1)
              do
                if (le--, Le--, 0 > Le || G[le] !== Q[Le]) {
                  var Ve = `
` + G[le].replace(" at new ", " at ");
                  return c.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", c.displayName)), Ve;
                }
              while (1 <= le && 0 <= Le);
            break;
          }
      }
    } finally {
      Xe = !1, Error.prepareStackTrace = E;
    }
    return (c = c ? c.displayName || c.name : "") ? we(c) : "";
  }
  function st(c) {
    switch (c.tag) {
      case 5:
        return we(c.type);
      case 16:
        return we("Lazy");
      case 13:
        return we("Suspense");
      case 19:
        return we("SuspenseList");
      case 0:
      case 2:
      case 15:
        return c = Je(c.type, !1), c;
      case 11:
        return c = Je(c.type.render, !1), c;
      case 1:
        return c = Je(c.type, !0), c;
      default:
        return "";
    }
  }
  function Ue(c) {
    if (c == null)
      return null;
    if (typeof c == "function")
      return c.displayName || c.name || null;
    if (typeof c == "string")
      return c;
    switch (c) {
      case $:
        return "Fragment";
      case J:
        return "Portal";
      case ee:
        return "Profiler";
      case W:
        return "StrictMode";
      case Ee:
        return "Suspense";
      case de:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case pe:
          return (c.displayName || "Context") + ".Consumer";
        case ie:
          return (c._context.displayName || "Context") + ".Provider";
        case ce:
          var p = c.render;
          return c = c.displayName, c || (c = p.displayName || p.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
        case Fe:
          return p = c.displayName || null, p !== null ? p : Ue(c.type) || "Memo";
        case Ce:
          p = c._payload, c = c._init;
          try {
            return Ue(c(p));
          } catch {
          }
      }
    return null;
  }
  function ot(c) {
    var p = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (p.displayName || "Context") + ".Consumer";
      case 10:
        return (p._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return c = p.render, c = c.displayName || c.name || "", p.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return p;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ue(p);
      case 8:
        return p === W ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof p == "function")
          return p.displayName || p.name || null;
        if (typeof p == "string")
          return p;
    }
    return null;
  }
  function rt(c) {
    switch (typeof c) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return c;
      case "object":
        return c;
      default:
        return "";
    }
  }
  function _t(c) {
    var p = c.type;
    return (c = c.nodeName) && c.toLowerCase() === "input" && (p === "checkbox" || p === "radio");
  }
  function Rt(c) {
    var p = _t(c) ? "checked" : "value", E = Object.getOwnPropertyDescriptor(c.constructor.prototype, p), O = "" + c[p];
    if (!c.hasOwnProperty(p) && typeof E < "u" && typeof E.get == "function" && typeof E.set == "function") {
      var G = E.get, Q = E.set;
      return Object.defineProperty(c, p, { configurable: !0, get: function() {
        return G.call(this);
      }, set: function(le) {
        O = "" + le, Q.call(this, le);
      } }), Object.defineProperty(c, p, { enumerable: E.enumerable }), { getValue: function() {
        return O;
      }, setValue: function(le) {
        O = "" + le;
      }, stopTracking: function() {
        c._valueTracker = null, delete c[p];
      } };
    }
  }
  function Ot(c) {
    c._valueTracker || (c._valueTracker = Rt(c));
  }
  function He(c) {
    if (!c)
      return !1;
    var p = c._valueTracker;
    if (!p)
      return !0;
    var E = p.getValue(), O = "";
    return c && (O = _t(c) ? c.checked ? "true" : "false" : c.value), c = O, c !== E ? (p.setValue(c), !0) : !1;
  }
  function et(c) {
    if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u")
      return null;
    try {
      return c.activeElement || c.body;
    } catch {
      return c.body;
    }
  }
  function mt(c, p) {
    var E = p.checked;
    return ue({}, p, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: E != null ? E : c._wrapperState.initialChecked });
  }
  function vt(c, p) {
    var E = p.defaultValue == null ? "" : p.defaultValue, O = p.checked != null ? p.checked : p.defaultChecked;
    E = rt(p.value != null ? p.value : E), c._wrapperState = { initialChecked: O, initialValue: E, controlled: p.type === "checkbox" || p.type === "radio" ? p.checked != null : p.value != null };
  }
  function bt(c, p) {
    p = p.checked, p != null && V(c, "checked", p, !1);
  }
  function Qt(c, p) {
    bt(c, p);
    var E = rt(p.value), O = p.type;
    if (E != null)
      O === "number" ? (E === 0 && c.value === "" || c.value != E) && (c.value = "" + E) : c.value !== "" + E && (c.value = "" + E);
    else if (O === "submit" || O === "reset") {
      c.removeAttribute("value");
      return;
    }
    p.hasOwnProperty("value") ? Vt(c, p.type, E) : p.hasOwnProperty("defaultValue") && Vt(c, p.type, rt(p.defaultValue)), p.checked == null && p.defaultChecked != null && (c.defaultChecked = !!p.defaultChecked);
  }
  function ft(c, p, E) {
    if (p.hasOwnProperty("value") || p.hasOwnProperty("defaultValue")) {
      var O = p.type;
      if (!(O !== "submit" && O !== "reset" || p.value !== void 0 && p.value !== null))
        return;
      p = "" + c._wrapperState.initialValue, E || p === c.value || (c.value = p), c.defaultValue = p;
    }
    E = c.name, E !== "" && (c.name = ""), c.defaultChecked = !!c._wrapperState.initialChecked, E !== "" && (c.name = E);
  }
  function Vt(c, p, E) {
    (p !== "number" || et(c.ownerDocument) !== c) && (E == null ? c.defaultValue = "" + c._wrapperState.initialValue : c.defaultValue !== "" + E && (c.defaultValue = "" + E));
  }
  var Jt = Array.isArray;
  function Mt(c, p, E, O) {
    if (c = c.options, p) {
      p = {};
      for (var G = 0; G < E.length; G++)
        p["$" + E[G]] = !0;
      for (E = 0; E < c.length; E++)
        G = p.hasOwnProperty("$" + c[E].value), c[E].selected !== G && (c[E].selected = G), G && O && (c[E].defaultSelected = !0);
    } else {
      for (E = "" + rt(E), p = null, G = 0; G < c.length; G++) {
        if (c[G].value === E) {
          c[G].selected = !0, O && (c[G].defaultSelected = !0);
          return;
        }
        p !== null || c[G].disabled || (p = c[G]);
      }
      p !== null && (p.selected = !0);
    }
  }
  function Me(c, p) {
    if (p.dangerouslySetInnerHTML != null)
      throw Error(t(91));
    return ue({}, p, { value: void 0, defaultValue: void 0, children: "" + c._wrapperState.initialValue });
  }
  function oe(c, p) {
    var E = p.value;
    if (E == null) {
      if (E = p.children, p = p.defaultValue, E != null) {
        if (p != null)
          throw Error(t(92));
        if (Jt(E)) {
          if (1 < E.length)
            throw Error(t(93));
          E = E[0];
        }
        p = E;
      }
      p == null && (p = ""), E = p;
    }
    c._wrapperState = { initialValue: rt(E) };
  }
  function je(c, p) {
    var E = rt(p.value), O = rt(p.defaultValue);
    E != null && (E = "" + E, E !== c.value && (c.value = E), p.defaultValue == null && c.defaultValue !== E && (c.defaultValue = E)), O != null && (c.defaultValue = "" + O);
  }
  function lt(c) {
    var p = c.textContent;
    p === c._wrapperState.initialValue && p !== "" && p !== null && (c.value = p);
  }
  function zt(c) {
    switch (c) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Nt(c, p) {
    return c == null || c === "http://www.w3.org/1999/xhtml" ? zt(p) : c === "http://www.w3.org/2000/svg" && p === "foreignObject" ? "http://www.w3.org/1999/xhtml" : c;
  }
  var Ut, tt = function(c) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(p, E, O, G) {
      MSApp.execUnsafeLocalFunction(function() {
        return c(p, E, O, G);
      });
    } : c;
  }(function(c, p) {
    if (c.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in c)
      c.innerHTML = p;
    else {
      for (Ut = Ut || document.createElement("div"), Ut.innerHTML = "<svg>" + p.valueOf().toString() + "</svg>", p = Ut.firstChild; c.firstChild; )
        c.removeChild(c.firstChild);
      for (; p.firstChild; )
        c.appendChild(p.firstChild);
    }
  });
  function rn(c, p) {
    if (p) {
      var E = c.firstChild;
      if (E && E === c.lastChild && E.nodeType === 3) {
        E.nodeValue = p;
        return;
      }
    }
    c.textContent = p;
  }
  var ze = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, xe = ["Webkit", "ms", "Moz", "O"];
  Object.keys(ze).forEach(function(c) {
    xe.forEach(function(p) {
      p = p + c.charAt(0).toUpperCase() + c.substring(1), ze[p] = ze[c];
    });
  });
  function Ie(c, p, E) {
    return p == null || typeof p == "boolean" || p === "" ? "" : E || typeof p != "number" || p === 0 || ze.hasOwnProperty(c) && ze[c] ? ("" + p).trim() : p + "px";
  }
  function it(c, p) {
    c = c.style;
    for (var E in p)
      if (p.hasOwnProperty(E)) {
        var O = E.indexOf("--") === 0, G = Ie(E, p[E], O);
        E === "float" && (E = "cssFloat"), O ? c.setProperty(E, G) : c[E] = G;
      }
  }
  var at = ue({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function hn(c, p) {
    if (p) {
      if (at[c] && (p.children != null || p.dangerouslySetInnerHTML != null))
        throw Error(t(137, c));
      if (p.dangerouslySetInnerHTML != null) {
        if (p.children != null)
          throw Error(t(60));
        if (typeof p.dangerouslySetInnerHTML != "object" || !("__html" in p.dangerouslySetInnerHTML))
          throw Error(t(61));
      }
      if (p.style != null && typeof p.style != "object")
        throw Error(t(62));
    }
  }
  function De(c, p) {
    if (c.indexOf("-") === -1)
      return typeof p.is == "string";
    switch (c) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Tt = null;
  function Ne(c) {
    return c = c.target || c.srcElement || window, c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === 3 ? c.parentNode : c;
  }
  var Gt = null, Pt = null, fn = null;
  function Gr(c) {
    if (c = ka(c)) {
      if (typeof Gt != "function")
        throw Error(t(280));
      var p = c.stateNode;
      p && (p = vr(p), Gt(c.stateNode, c.type, p));
    }
  }
  function Wr(c) {
    Pt ? fn ? fn.push(c) : fn = [c] : Pt = c;
  }
  function Ur() {
    if (Pt) {
      var c = Pt, p = fn;
      if (fn = Pt = null, Gr(c), p)
        for (c = 0; c < p.length; c++)
          Gr(p[c]);
    }
  }
  function ir(c, p) {
    return c(p);
  }
  function Vn() {
  }
  var jr = !1;
  function ti(c, p, E) {
    if (jr)
      return c(p, E);
    jr = !0;
    try {
      return ir(c, p, E);
    } finally {
      jr = !1, (Pt !== null || fn !== null) && (Vn(), Ur());
    }
  }
  function ki(c, p) {
    var E = c.stateNode;
    if (E === null)
      return null;
    var O = vr(E);
    if (O === null)
      return null;
    E = O[p];
    e:
      switch (p) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (O = !O.disabled) || (c = c.type, O = !(c === "button" || c === "input" || c === "select" || c === "textarea")), c = !O;
          break e;
        default:
          c = !1;
      }
    if (c)
      return null;
    if (E && typeof E != "function")
      throw Error(t(231, p, typeof E));
    return E;
  }
  var Wi = !1;
  if (d)
    try {
      var ni = {};
      Object.defineProperty(ni, "passive", { get: function() {
        Wi = !0;
      } }), window.addEventListener("test", ni, ni), window.removeEventListener("test", ni, ni);
    } catch {
      Wi = !1;
    }
  function ji(c, p, E, O, G, Q, le, Le, Ve) {
    var Ct = Array.prototype.slice.call(arguments, 3);
    try {
      p.apply(E, Ct);
    } catch (un) {
      this.onError(un);
    }
  }
  var Si = !1, Te = null, ct = !1, me = null, Oe = { onError: function(c) {
    Si = !0, Te = c;
  } };
  function qe(c, p, E, O, G, Q, le, Le, Ve) {
    Si = !1, Te = null, ji.apply(Oe, arguments);
  }
  function on(c, p, E, O, G, Q, le, Le, Ve) {
    if (qe.apply(this, arguments), Si) {
      if (Si) {
        var Ct = Te;
        Si = !1, Te = null;
      } else
        throw Error(t(198));
      ct || (ct = !0, me = Ct);
    }
  }
  function yn(c) {
    var p = c, E = c;
    if (c.alternate)
      for (; p.return; )
        p = p.return;
    else {
      c = p;
      do
        p = c, (p.flags & 4098) !== 0 && (E = p.return), c = p.return;
      while (c);
    }
    return p.tag === 3 ? E : null;
  }
  function Rn(c) {
    if (c.tag === 13) {
      var p = c.memoizedState;
      if (p === null && (c = c.alternate, c !== null && (p = c.memoizedState)), p !== null)
        return p.dehydrated;
    }
    return null;
  }
  function mn(c) {
    if (yn(c) !== c)
      throw Error(t(188));
  }
  function vn(c) {
    var p = c.alternate;
    if (!p) {
      if (p = yn(c), p === null)
        throw Error(t(188));
      return p !== c ? null : c;
    }
    for (var E = c, O = p; ; ) {
      var G = E.return;
      if (G === null)
        break;
      var Q = G.alternate;
      if (Q === null) {
        if (O = G.return, O !== null) {
          E = O;
          continue;
        }
        break;
      }
      if (G.child === Q.child) {
        for (Q = G.child; Q; ) {
          if (Q === E)
            return mn(G), c;
          if (Q === O)
            return mn(G), p;
          Q = Q.sibling;
        }
        throw Error(t(188));
      }
      if (E.return !== O.return)
        E = G, O = Q;
      else {
        for (var le = !1, Le = G.child; Le; ) {
          if (Le === E) {
            le = !0, E = G, O = Q;
            break;
          }
          if (Le === O) {
            le = !0, O = G, E = Q;
            break;
          }
          Le = Le.sibling;
        }
        if (!le) {
          for (Le = Q.child; Le; ) {
            if (Le === E) {
              le = !0, E = Q, O = G;
              break;
            }
            if (Le === O) {
              le = !0, O = Q, E = G;
              break;
            }
            Le = Le.sibling;
          }
          if (!le)
            throw Error(t(189));
        }
      }
      if (E.alternate !== O)
        throw Error(t(190));
    }
    if (E.tag !== 3)
      throw Error(t(188));
    return E.stateNode.current === E ? c : p;
  }
  function Zn(c) {
    return c = vn(c), c !== null ? nr(c) : null;
  }
  function nr(c) {
    if (c.tag === 5 || c.tag === 6)
      return c;
    for (c = c.child; c !== null; ) {
      var p = nr(c);
      if (p !== null)
        return p;
      c = c.sibling;
    }
    return null;
  }
  var br = e.unstable_scheduleCallback, Yi = e.unstable_cancelCallback, La = e.unstable_shouldYield, Ys = e.unstable_requestPaint, $t = e.unstable_now, Zr = e.unstable_getCurrentPriorityLevel, ls = e.unstable_ImmediatePriority, Xn = e.unstable_UserBlockingPriority, qa = e.unstable_NormalPriority, mo = e.unstable_LowPriority, Ds = e.unstable_IdlePriority, us = null, mr = null;
  function pi(c) {
    if (mr && typeof mr.onCommitFiberRoot == "function")
      try {
        mr.onCommitFiberRoot(us, c, void 0, (c.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ea = Math.clz32 ? Math.clz32 : Oo, _i = Math.log, Ti = Math.LN2;
  function Oo(c) {
    return c >>>= 0, c === 0 ? 32 : 31 - (_i(c) / Ti | 0) | 0;
  }
  var Uo = 64, Pa = 4194304;
  function Rl(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function vo(c, p) {
    var E = c.pendingLanes;
    if (E === 0)
      return 0;
    var O = 0, G = c.suspendedLanes, Q = c.pingedLanes, le = E & 268435455;
    if (le !== 0) {
      var Le = le & ~G;
      Le !== 0 ? O = Rl(Le) : (Q &= le, Q !== 0 && (O = Rl(Q)));
    } else
      le = E & ~G, le !== 0 ? O = Rl(le) : Q !== 0 && (O = Rl(Q));
    if (O === 0)
      return 0;
    if (p !== 0 && p !== O && (p & G) === 0 && (G = O & -O, Q = p & -p, G >= Q || G === 16 && (Q & 4194240) !== 0))
      return p;
    if ((O & 4) !== 0 && (O |= E & 16), p = c.entangledLanes, p !== 0)
      for (c = c.entanglements, p &= O; 0 < p; )
        E = 31 - Ea(p), G = 1 << E, O |= c[E], p &= ~G;
    return O;
  }
  function Wf(c, p) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return p + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return p + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Al(c, p) {
    for (var E = c.suspendedLanes, O = c.pingedLanes, G = c.expirationTimes, Q = c.pendingLanes; 0 < Q; ) {
      var le = 31 - Ea(Q), Le = 1 << le, Ve = G[le];
      Ve === -1 ? ((Le & E) === 0 || (Le & O) !== 0) && (G[le] = Wf(Le, p)) : Ve <= p && (c.expiredLanes |= Le), Q &= ~Le;
    }
  }
  function zd(c) {
    return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
  }
  function Ls() {
    var c = Uo;
    return Uo <<= 1, (Uo & 4194240) === 0 && (Uo = 64), c;
  }
  function Ju(c) {
    for (var p = [], E = 0; 31 > E; E++)
      p.push(c);
    return p;
  }
  function au(c, p, E) {
    c.pendingLanes |= p, p !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, p = 31 - Ea(p), c[p] = E;
  }
  function qh(c, p) {
    var E = c.pendingLanes & ~p;
    c.pendingLanes = p, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= p, c.mutableReadLanes &= p, c.entangledLanes &= p, p = c.entanglements;
    var O = c.eventTimes;
    for (c = c.expirationTimes; 0 < E; ) {
      var G = 31 - Ea(E), Q = 1 << G;
      p[G] = 0, O[G] = -1, c[G] = -1, E &= ~Q;
    }
  }
  function Dl(c, p) {
    var E = c.entangledLanes |= p;
    for (c = c.entanglements; E; ) {
      var O = 31 - Ea(E), G = 1 << O;
      G & p | c[O] & p && (c[O] |= p), E &= ~G;
    }
  }
  var ri = 0;
  function go(c) {
    return c &= -c, 1 < c ? 4 < c ? (c & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var jf, zo, Ci, cs, Yf, xr = !1, Eu = [], ua = null, Cr = null, fl = null, yo = /* @__PURE__ */ new Map(), Ka = /* @__PURE__ */ new Map(), Xi = [], Rm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function mi(c, p) {
    switch (c) {
      case "focusin":
      case "focusout":
        ua = null;
        break;
      case "dragenter":
      case "dragleave":
        Cr = null;
        break;
      case "mouseover":
      case "mouseout":
        fl = null;
        break;
      case "pointerover":
      case "pointerout":
        yo.delete(p.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ka.delete(p.pointerId);
    }
  }
  function Qa(c, p, E, O, G, Q) {
    return c === null || c.nativeEvent !== Q ? (c = { blockedOn: p, domEventName: E, eventSystemFlags: O, nativeEvent: Q, targetContainers: [G] }, p !== null && (p = ka(p), p !== null && zo(p)), c) : (c.eventSystemFlags |= O, p = c.targetContainers, G !== null && p.indexOf(G) === -1 && p.push(G), c);
  }
  function Sc(c, p, E, O, G) {
    switch (p) {
      case "focusin":
        return ua = Qa(ua, c, p, E, O, G), !0;
      case "dragenter":
        return Cr = Qa(Cr, c, p, E, O, G), !0;
      case "mouseover":
        return fl = Qa(fl, c, p, E, O, G), !0;
      case "pointerover":
        var Q = G.pointerId;
        return yo.set(Q, Qa(yo.get(Q) || null, c, p, E, O, G)), !0;
      case "gotpointercapture":
        return Q = G.pointerId, Ka.set(Q, Qa(Ka.get(Q) || null, c, p, E, O, G)), !0;
    }
    return !1;
  }
  function dl(c) {
    var p = Zs(c.target);
    if (p !== null) {
      var E = yn(p);
      if (E !== null) {
        if (p = E.tag, p === 13) {
          if (p = Rn(E), p !== null) {
            c.blockedOn = p, Yf(c.priority, function() {
              Ci(E);
            });
            return;
          }
        } else if (p === 3 && E.stateNode.current.memoizedState.isDehydrated) {
          c.blockedOn = E.tag === 3 ? E.stateNode.containerInfo : null;
          return;
        }
      }
    }
    c.blockedOn = null;
  }
  function df(c) {
    if (c.blockedOn !== null)
      return !1;
    for (var p = c.targetContainers; 0 < p.length; ) {
      var E = Fo(c.domEventName, c.eventSystemFlags, p[0], c.nativeEvent);
      if (E === null) {
        E = c.nativeEvent;
        var O = new E.constructor(E.type, E);
        Tt = O, E.target.dispatchEvent(O), Tt = null;
      } else
        return p = ka(E), p !== null && zo(p), c.blockedOn = E, !1;
      p.shift();
    }
    return !0;
  }
  function hf(c, p, E) {
    df(c) && E.delete(p);
  }
  function su() {
    xr = !1, ua !== null && df(ua) && (ua = null), Cr !== null && df(Cr) && (Cr = null), fl !== null && df(fl) && (fl = null), yo.forEach(hf), Ka.forEach(hf);
  }
  function Ii(c, p) {
    c.blockedOn === p && (c.blockedOn = null, xr || (xr = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, su)));
  }
  function Ri(c) {
    function p(G) {
      return Ii(G, c);
    }
    if (0 < Eu.length) {
      Ii(Eu[0], c);
      for (var E = 1; E < Eu.length; E++) {
        var O = Eu[E];
        O.blockedOn === c && (O.blockedOn = null);
      }
    }
    for (ua !== null && Ii(ua, c), Cr !== null && Ii(Cr, c), fl !== null && Ii(fl, c), yo.forEach(p), Ka.forEach(p), E = 0; E < Xi.length; E++)
      O = Xi[E], O.blockedOn === c && (O.blockedOn = null);
    for (; 0 < Xi.length && (E = Xi[0], E.blockedOn === null); )
      dl(E), E.blockedOn === null && Xi.shift();
  }
  var No = I.ReactCurrentBatchConfig, Ps = !0;
  function _c(c, p, E, O) {
    var G = ri, Q = No.transition;
    No.transition = null;
    try {
      ri = 1, Xf(c, p, E, O);
    } finally {
      ri = G, No.transition = Q;
    }
  }
  function Ll(c, p, E, O) {
    var G = ri, Q = No.transition;
    No.transition = null;
    try {
      ri = 4, Xf(c, p, E, O);
    } finally {
      ri = G, No.transition = Q;
    }
  }
  function Xf(c, p, E, O) {
    if (Ps) {
      var G = Fo(c, p, E, O);
      if (G === null)
        Du(c, p, O, qf, E), mi(c, O);
      else if (Sc(G, c, p, E, O))
        O.stopPropagation();
      else if (mi(c, O), p & 4 && -1 < Rm.indexOf(c)) {
        for (; G !== null; ) {
          var Q = ka(G);
          if (Q !== null && jf(Q), Q = Fo(c, p, E, O), Q === null && Du(c, p, O, qf, E), Q === G)
            break;
          G = Q;
        }
        G !== null && O.stopPropagation();
      } else
        Du(c, p, O, null, E);
    }
  }
  var qf = null;
  function Fo(c, p, E, O) {
    if (qf = null, c = Ne(O), c = Zs(c), c !== null)
      if (p = yn(c), p === null)
        c = null;
      else if (E = p.tag, E === 13) {
        if (c = Rn(p), c !== null)
          return c;
        c = null;
      } else if (E === 3) {
        if (p.stateNode.current.memoizedState.isDehydrated)
          return p.tag === 3 ? p.stateNode.containerInfo : null;
        c = null;
      } else
        p !== c && (c = null);
    return qf = c, null;
  }
  function Qf(c) {
    switch (c) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Zr()) {
          case ls:
            return 1;
          case Xn:
            return 4;
          case qa:
          case mo:
            return 16;
          case Ds:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ki = null, Mu = null, Oa = null;
  function ys() {
    if (Oa)
      return Oa;
    var c, p = Mu, E = p.length, O, G = "value" in Ki ? Ki.value : Ki.textContent, Q = G.length;
    for (c = 0; c < E && p[c] === G[c]; c++)
      ;
    var le = E - c;
    for (O = 1; O <= le && p[E - O] === G[Q - O]; O++)
      ;
    return Oa = G.slice(c, 1 < O ? 1 - O : void 0);
  }
  function ou(c) {
    var p = c.keyCode;
    return "charCode" in c ? (c = c.charCode, c === 0 && p === 13 && (c = 13)) : c = p, c === 10 && (c = 13), 32 <= c || c === 13 ? c : 0;
  }
  function Ua() {
    return !0;
  }
  function bc() {
    return !1;
  }
  function xo(c) {
    function p(E, O, G, Q, le) {
      this._reactName = E, this._targetInst = G, this.type = O, this.nativeEvent = Q, this.target = le, this.currentTarget = null;
      for (var Le in c)
        c.hasOwnProperty(Le) && (E = c[Le], this[Le] = E ? E(Q) : Q[Le]);
      return this.isDefaultPrevented = (Q.defaultPrevented != null ? Q.defaultPrevented : Q.returnValue === !1) ? Ua : bc, this.isPropagationStopped = bc, this;
    }
    return ue(p.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var E = this.nativeEvent;
      E && (E.preventDefault ? E.preventDefault() : typeof E.returnValue != "unknown" && (E.returnValue = !1), this.isDefaultPrevented = Ua);
    }, stopPropagation: function() {
      var E = this.nativeEvent;
      E && (E.stopPropagation ? E.stopPropagation() : typeof E.cancelBubble != "unknown" && (E.cancelBubble = !0), this.isPropagationStopped = Ua);
    }, persist: function() {
    }, isPersistent: Ua }), p;
  }
  var Tu = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(c) {
    return c.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Pl = xo(Tu), za = ue({}, Tu, { view: 0, detail: 0 }), Xs = xo(za), Jr, xs, va, qs = ue({}, za, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Nd, button: 0, buttons: 0, relatedTarget: function(c) {
    return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
  }, movementX: function(c) {
    return "movementX" in c ? c.movementX : (c !== va && (va && c.type === "mousemove" ? (Jr = c.screenX - va.screenX, xs = c.screenY - va.screenY) : xs = Jr = 0, va = c), Jr);
  }, movementY: function(c) {
    return "movementY" in c ? c.movementY : xs;
  } }), Zf = xo(qs), $o = ue({}, qs, { dataTransfer: 0 }), Ku = xo($o), Qh = ue({}, za, { relatedTarget: 0 }), qi = xo(Qh), Cu = ue({}, Tu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Up = xo(Cu), cg = ue({}, Tu, { clipboardData: function(c) {
    return "clipboardData" in c ? c.clipboardData : window.clipboardData;
  } }), Zh = xo(cg), Am = ue({}, Tu, { data: 0 }), Dm = xo(Am), Lm = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Pm = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, vh = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function $u(c) {
    var p = this.nativeEvent;
    return p.getModifierState ? p.getModifierState(c) : (c = vh[c]) ? !!p[c] : !1;
  }
  function Nd() {
    return $u;
  }
  var Ru = ue({}, za, { key: function(c) {
    if (c.key) {
      var p = Lm[c.key] || c.key;
      if (p !== "Unidentified")
        return p;
    }
    return c.type === "keypress" ? (c = ou(c), c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? Pm[c.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Nd, charCode: function(c) {
    return c.type === "keypress" ? ou(c) : 0;
  }, keyCode: function(c) {
    return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  }, which: function(c) {
    return c.type === "keypress" ? ou(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  } }), zp = xo(Ru), hl = ue({}, qs, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), el = xo(hl), pf = ue({}, za, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Nd }), Jf = xo(pf), lu = ue({}, Tu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), mf = xo(lu), Ol = ue({}, qs, {
    deltaX: function(c) {
      return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0;
    },
    deltaY: function(c) {
      return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ec = xo(Ol), Oi = [9, 13, 27, 32], Za = d && "CompositionEvent" in window, Ma = null;
  d && "documentMode" in document && (Ma = document.documentMode);
  var ca = d && "TextEvent" in window && !Ma, Fd = d && (!Za || Ma && 8 < Ma && 11 >= Ma), tl = String.fromCharCode(32), Om = !1;
  function Um(c, p) {
    switch (c) {
      case "keyup":
        return Oi.indexOf(p.keyCode) !== -1;
      case "keydown":
        return p.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function gh(c) {
    return c = c.detail, typeof c == "object" && "data" in c ? c.data : null;
  }
  var Kf = !1;
  function kd(c, p) {
    switch (c) {
      case "compositionend":
        return gh(p);
      case "keypress":
        return p.which !== 32 ? null : (Om = !0, tl);
      case "textInput":
        return c = p.data, c === tl && Om ? null : c;
      default:
        return null;
    }
  }
  function Np(c, p) {
    if (Kf)
      return c === "compositionend" || !Za && Um(c, p) ? (c = ys(), Oa = Mu = Ki = null, Kf = !1, c) : null;
    switch (c) {
      case "paste":
        return null;
      case "keypress":
        if (!(p.ctrlKey || p.altKey || p.metaKey) || p.ctrlKey && p.altKey) {
          if (p.char && 1 < p.char.length)
            return p.char;
          if (p.which)
            return String.fromCharCode(p.which);
        }
        return null;
      case "compositionend":
        return Fd && p.locale !== "ko" ? null : p.data;
      default:
        return null;
    }
  }
  var yh = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Id(c) {
    var p = c && c.nodeName && c.nodeName.toLowerCase();
    return p === "input" ? !!yh[c.type] : p === "textarea";
  }
  function $f(c, p, E, O) {
    Wr(O), p = yf(p, "onChange"), 0 < p.length && (E = new Pl("onChange", "change", null, E, O), c.push({ event: E, listeners: p }));
  }
  var Ss = null, tc = null;
  function vf(c) {
    an(c, 0);
  }
  function wc(c) {
    var p = Hn(c);
    if (He(p))
      return c;
  }
  function Fp(c, p) {
    if (c === "change")
      return p;
  }
  var nc = !1;
  if (d) {
    var Na;
    if (d) {
      var Bd = "oninput" in document;
      if (!Bd) {
        var ed = document.createElement("div");
        ed.setAttribute("oninput", "return;"), Bd = typeof ed.oninput == "function";
      }
      Na = Bd;
    } else
      Na = !1;
    nc = Na && (!document.documentMode || 9 < document.documentMode);
  }
  function rc() {
    Ss && (Ss.detachEvent("onpropertychange", kp), tc = Ss = null);
  }
  function kp(c) {
    if (c.propertyName === "value" && wc(tc)) {
      var p = [];
      $f(p, tc, c, Ne(c)), ti(vf, p);
    }
  }
  function xh(c, p, E) {
    c === "focusin" ? (rc(), Ss = p, tc = E, Ss.attachEvent("onpropertychange", kp)) : c === "focusout" && rc();
  }
  function Ip(c) {
    if (c === "selectionchange" || c === "keyup" || c === "keydown")
      return wc(tc);
  }
  function ko(c, p) {
    if (c === "click")
      return wc(p);
  }
  function Ye(c, p) {
    if (c === "input" || c === "change")
      return wc(p);
  }
  function Bt(c, p) {
    return c === p && (c !== 0 || 1 / c === 1 / p) || c !== c && p !== p;
  }
  var pt = typeof Object.is == "function" ? Object.is : Bt;
  function Mn(c, p) {
    if (pt(c, p))
      return !0;
    if (typeof c != "object" || c === null || typeof p != "object" || p === null)
      return !1;
    var E = Object.keys(c), O = Object.keys(p);
    if (E.length !== O.length)
      return !1;
    for (O = 0; O < E.length; O++) {
      var G = E[O];
      if (!h.call(p, G) || !pt(c[G], p[G]))
        return !1;
    }
    return !0;
  }
  function Kn(c) {
    for (; c && c.firstChild; )
      c = c.firstChild;
    return c;
  }
  function or(c, p) {
    var E = Kn(c);
    c = 0;
    for (var O; E; ) {
      if (E.nodeType === 3) {
        if (O = c + E.textContent.length, c <= p && O >= p)
          return { node: E, offset: p - c };
        c = O;
      }
      e: {
        for (; E; ) {
          if (E.nextSibling) {
            E = E.nextSibling;
            break e;
          }
          E = E.parentNode;
        }
        E = void 0;
      }
      E = Kn(E);
    }
  }
  function Ta(c, p) {
    return c && p ? c === p ? !0 : c && c.nodeType === 3 ? !1 : p && p.nodeType === 3 ? Ta(c, p.parentNode) : "contains" in c ? c.contains(p) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(p) & 16) : !1 : !1;
  }
  function $n() {
    for (var c = window, p = et(); p instanceof c.HTMLIFrameElement; ) {
      try {
        var E = typeof p.contentWindow.location.href == "string";
      } catch {
        E = !1;
      }
      if (E)
        c = p.contentWindow;
      else
        break;
      p = et(c.document);
    }
    return p;
  }
  function Ui(c) {
    var p = c && c.nodeName && c.nodeName.toLowerCase();
    return p && (p === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || p === "textarea" || c.contentEditable === "true");
  }
  function ra(c) {
    var p = $n(), E = c.focusedElem, O = c.selectionRange;
    if (p !== E && E && E.ownerDocument && Ta(E.ownerDocument.documentElement, E)) {
      if (O !== null && Ui(E)) {
        if (p = O.start, c = O.end, c === void 0 && (c = p), "selectionStart" in E)
          E.selectionStart = p, E.selectionEnd = Math.min(c, E.value.length);
        else if (c = (p = E.ownerDocument || document) && p.defaultView || window, c.getSelection) {
          c = c.getSelection();
          var G = E.textContent.length, Q = Math.min(O.start, G);
          O = O.end === void 0 ? Q : Math.min(O.end, G), !c.extend && Q > O && (G = O, O = Q, Q = G), G = or(E, Q);
          var le = or(
            E,
            O
          );
          G && le && (c.rangeCount !== 1 || c.anchorNode !== G.node || c.anchorOffset !== G.offset || c.focusNode !== le.node || c.focusOffset !== le.offset) && (p = p.createRange(), p.setStart(G.node, G.offset), c.removeAllRanges(), Q > O ? (c.addRange(p), c.extend(le.node, le.offset)) : (p.setEnd(le.node, le.offset), c.addRange(p)));
        }
      }
      for (p = [], c = E; c = c.parentNode; )
        c.nodeType === 1 && p.push({ element: c, left: c.scrollLeft, top: c.scrollTop });
      for (typeof E.focus == "function" && E.focus(), E = 0; E < p.length; E++)
        c = p[E], c.element.scrollLeft = c.left, c.element.scrollTop = c.top;
    }
  }
  var Io = d && "documentMode" in document && 11 >= document.documentMode, fs = null, Hd = null, Ul = null, $a = !1;
  function pl(c, p, E) {
    var O = E.window === E ? E.document : E.nodeType === 9 ? E : E.ownerDocument;
    $a || fs == null || fs !== et(O) || (O = fs, "selectionStart" in O && Ui(O) ? O = { start: O.selectionStart, end: O.selectionEnd } : (O = (O.ownerDocument && O.ownerDocument.defaultView || window).getSelection(), O = { anchorNode: O.anchorNode, anchorOffset: O.anchorOffset, focusNode: O.focusNode, focusOffset: O.focusOffset }), Ul && Mn(Ul, O) || (Ul = O, O = yf(Hd, "onSelect"), 0 < O.length && (p = new Pl("onSelect", "select", null, p, E), c.push({ event: p, listeners: O }), p.target = fs)));
  }
  function xi(c, p) {
    var E = {};
    return E[c.toLowerCase()] = p.toLowerCase(), E["Webkit" + c] = "webkit" + p, E["Moz" + c] = "moz" + p, E;
  }
  var Ec = { animationend: xi("Animation", "AnimationEnd"), animationiteration: xi("Animation", "AnimationIteration"), animationstart: xi("Animation", "AnimationStart"), transitionend: xi("Transition", "TransitionEnd") }, Au = {}, ml = {};
  d && (ml = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
  function Ca(c) {
    if (Au[c])
      return Au[c];
    if (!Ec[c])
      return c;
    var p = Ec[c], E;
    for (E in p)
      if (p.hasOwnProperty(E) && E in ml)
        return Au[c] = p[E];
    return c;
  }
  var Sh = Ca("animationend"), Bp = Ca("animationiteration"), Mc = Ca("animationstart"), Tc = Ca("transitionend"), Mr = /* @__PURE__ */ new Map(), $i = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Br(c, p) {
    Mr.set(c, p), o(p, [c]);
  }
  for (var Fa = 0; Fa < $i.length; Fa++) {
    var So = $i[Fa], td = So.toLowerCase(), _h = So[0].toUpperCase() + So.slice(1);
    Br(td, "on" + _h);
  }
  Br(Sh, "onAnimationEnd"), Br(Bp, "onAnimationIteration"), Br(Mc, "onAnimationStart"), Br("dblclick", "onDoubleClick"), Br("focusin", "onFocus"), Br("focusout", "onBlur"), Br(Tc, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), o("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), o("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), o("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), o("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), o("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var ic = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), gf = new Set("cancel close invalid load scroll toggle".split(" ").concat(ic));
  function nd(c, p, E) {
    var O = c.type || "unknown-event";
    c.currentTarget = E, on(O, p, void 0, c), c.currentTarget = null;
  }
  function an(c, p) {
    p = (p & 4) !== 0;
    for (var E = 0; E < c.length; E++) {
      var O = c[E], G = O.event;
      O = O.listeners;
      e: {
        var Q = void 0;
        if (p)
          for (var le = O.length - 1; 0 <= le; le--) {
            var Le = O[le], Ve = Le.instance, Ct = Le.currentTarget;
            if (Le = Le.listener, Ve !== Q && G.isPropagationStopped())
              break e;
            nd(G, Le, Ct), Q = Ve;
          }
        else
          for (le = 0; le < O.length; le++) {
            if (Le = O[le], Ve = Le.instance, Ct = Le.currentTarget, Le = Le.listener, Ve !== Q && G.isPropagationStopped())
              break e;
            nd(G, Le, Ct), Q = Ve;
          }
      }
    }
    if (ct)
      throw c = me, ct = !1, me = null, c;
  }
  function Ir(c, p) {
    var E = p[ad];
    E === void 0 && (E = p[ad] = /* @__PURE__ */ new Set());
    var O = c + "__bubble";
    E.has(O) || (ac(p, c, 2, !1), E.add(O));
  }
  function Hr(c, p, E) {
    var O = 0;
    p && (O |= 4), ac(E, c, O, p);
  }
  var Bo = "_reactListening" + Math.random().toString(36).slice(2);
  function nl(c) {
    if (!c[Bo]) {
      c[Bo] = !0, r.forEach(function(E) {
        E !== "selectionchange" && (gf.has(E) || Hr(E, !1, c), Hr(E, !0, c));
      });
      var p = c.nodeType === 9 ? c : c.ownerDocument;
      p === null || p[Bo] || (p[Bo] = !0, Hr("selectionchange", !1, p));
    }
  }
  function ac(c, p, E, O) {
    switch (Qf(p)) {
      case 1:
        var G = _c;
        break;
      case 4:
        G = Ll;
        break;
      default:
        G = Xf;
    }
    E = G.bind(null, p, E, c), G = void 0, !Wi || p !== "touchstart" && p !== "touchmove" && p !== "wheel" || (G = !0), O ? G !== void 0 ? c.addEventListener(p, E, { capture: !0, passive: G }) : c.addEventListener(p, E, !0) : G !== void 0 ? c.addEventListener(p, E, { passive: G }) : c.addEventListener(p, E, !1);
  }
  function Du(c, p, E, O, G) {
    var Q = O;
    if ((p & 1) === 0 && (p & 2) === 0 && O !== null)
      e:
        for (; ; ) {
          if (O === null)
            return;
          var le = O.tag;
          if (le === 3 || le === 4) {
            var Le = O.stateNode.containerInfo;
            if (Le === G || Le.nodeType === 8 && Le.parentNode === G)
              break;
            if (le === 4)
              for (le = O.return; le !== null; ) {
                var Ve = le.tag;
                if ((Ve === 3 || Ve === 4) && (Ve = le.stateNode.containerInfo, Ve === G || Ve.nodeType === 8 && Ve.parentNode === G))
                  return;
                le = le.return;
              }
            for (; Le !== null; ) {
              if (le = Zs(Le), le === null)
                return;
              if (Ve = le.tag, Ve === 5 || Ve === 6) {
                O = Q = le;
                continue e;
              }
              Le = Le.parentNode;
            }
          }
          O = O.return;
        }
    ti(function() {
      var Ct = Q, un = Ne(E), ln = [];
      e: {
        var nn = Mr.get(c);
        if (nn !== void 0) {
          var kn = Pl, qn = c;
          switch (c) {
            case "keypress":
              if (ou(E) === 0)
                break e;
            case "keydown":
            case "keyup":
              kn = zp;
              break;
            case "focusin":
              qn = "focus", kn = qi;
              break;
            case "focusout":
              qn = "blur", kn = qi;
              break;
            case "beforeblur":
            case "afterblur":
              kn = qi;
              break;
            case "click":
              if (E.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              kn = Zf;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              kn = Ku;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              kn = Jf;
              break;
            case Sh:
            case Bp:
            case Mc:
              kn = Up;
              break;
            case Tc:
              kn = mf;
              break;
            case "scroll":
              kn = Xs;
              break;
            case "wheel":
              kn = ec;
              break;
            case "copy":
            case "cut":
            case "paste":
              kn = Zh;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              kn = el;
          }
          var rr = (p & 4) !== 0, Bs = !rr && c === "scroll", ht = rr ? nn !== null ? nn + "Capture" : null : nn;
          rr = [];
          for (var Ze = Ct, gt; Ze !== null; ) {
            gt = Ze;
            var xn = gt.stateNode;
            if (gt.tag === 5 && xn !== null && (gt = xn, ht !== null && (xn = ki(Ze, ht), xn != null && rr.push(Cc(Ze, xn, gt)))), Bs)
              break;
            Ze = Ze.return;
          }
          0 < rr.length && (nn = new kn(nn, qn, null, E, un), ln.push({ event: nn, listeners: rr }));
        }
      }
      if ((p & 7) === 0) {
        e: {
          if (nn = c === "mouseover" || c === "pointerover", kn = c === "mouseout" || c === "pointerout", nn && E !== Tt && (qn = E.relatedTarget || E.fromElement) && (Zs(qn) || qn[_o]))
            break e;
          if ((kn || nn) && (nn = un.window === un ? un : (nn = un.ownerDocument) ? nn.defaultView || nn.parentWindow : window, kn ? (qn = E.relatedTarget || E.toElement, kn = Ct, qn = qn ? Zs(qn) : null, qn !== null && (Bs = yn(qn), qn !== Bs || qn.tag !== 5 && qn.tag !== 6) && (qn = null)) : (kn = null, qn = Ct), kn !== qn)) {
            if (rr = Zf, xn = "onMouseLeave", ht = "onMouseEnter", Ze = "mouse", (c === "pointerout" || c === "pointerover") && (rr = el, xn = "onPointerLeave", ht = "onPointerEnter", Ze = "pointer"), Bs = kn == null ? nn : Hn(kn), gt = qn == null ? nn : Hn(qn), nn = new rr(xn, Ze + "leave", kn, E, un), nn.target = Bs, nn.relatedTarget = gt, xn = null, Zs(un) === Ct && (rr = new rr(ht, Ze + "enter", qn, E, un), rr.target = gt, rr.relatedTarget = Bs, xn = rr), Bs = xn, kn && qn)
              t: {
                for (rr = kn, ht = qn, Ze = 0, gt = rr; gt; gt = sc(gt))
                  Ze++;
                for (gt = 0, xn = ht; xn; xn = sc(xn))
                  gt++;
                for (; 0 < Ze - gt; )
                  rr = sc(rr), Ze--;
                for (; 0 < gt - Ze; )
                  ht = sc(ht), gt--;
                for (; Ze--; ) {
                  if (rr === ht || ht !== null && rr === ht.alternate)
                    break t;
                  rr = sc(rr), ht = sc(ht);
                }
                rr = null;
              }
            else
              rr = null;
            kn !== null && ds(ln, nn, kn, rr, !1), qn !== null && Bs !== null && ds(ln, Bs, qn, rr, !0);
          }
        }
        e: {
          if (nn = Ct ? Hn(Ct) : window, kn = nn.nodeName && nn.nodeName.toLowerCase(), kn === "select" || kn === "input" && nn.type === "file")
            var ar = Fp;
          else if (Id(nn))
            if (nc)
              ar = Ye;
            else {
              ar = Ip;
              var Qn = xh;
            }
          else
            (kn = nn.nodeName) && kn.toLowerCase() === "input" && (nn.type === "checkbox" || nn.type === "radio") && (ar = ko);
          if (ar && (ar = ar(c, Ct))) {
            $f(ln, ar, E, un);
            break e;
          }
          Qn && Qn(c, nn, Ct), c === "focusout" && (Qn = nn._wrapperState) && Qn.controlled && nn.type === "number" && Vt(nn, "number", nn.value);
        }
        switch (Qn = Ct ? Hn(Ct) : window, c) {
          case "focusin":
            (Id(Qn) || Qn.contentEditable === "true") && (fs = Qn, Hd = Ct, Ul = null);
            break;
          case "focusout":
            Ul = Hd = fs = null;
            break;
          case "mousedown":
            $a = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            $a = !1, pl(ln, E, un);
            break;
          case "selectionchange":
            if (Io)
              break;
          case "keydown":
          case "keyup":
            pl(ln, E, un);
        }
        var pr;
        if (Za)
          e: {
            switch (c) {
              case "compositionstart":
                var Lr = "onCompositionStart";
                break e;
              case "compositionend":
                Lr = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Lr = "onCompositionUpdate";
                break e;
            }
            Lr = void 0;
          }
        else
          Kf ? Um(c, E) && (Lr = "onCompositionEnd") : c === "keydown" && E.keyCode === 229 && (Lr = "onCompositionStart");
        Lr && (Fd && E.locale !== "ko" && (Kf || Lr !== "onCompositionStart" ? Lr === "onCompositionEnd" && Kf && (pr = ys()) : (Ki = un, Mu = "value" in Ki ? Ki.value : Ki.textContent, Kf = !0)), Qn = yf(Ct, Lr), 0 < Qn.length && (Lr = new Dm(Lr, c, null, E, un), ln.push({ event: Lr, listeners: Qn }), pr ? Lr.data = pr : (pr = gh(E), pr !== null && (Lr.data = pr)))), (pr = ca ? kd(c, E) : Np(c, E)) && (Ct = yf(Ct, "onBeforeInput"), 0 < Ct.length && (un = new Dm("onBeforeInput", "beforeinput", null, E, un), ln.push({ event: un, listeners: Ct }), un.data = pr));
      }
      an(ln, p);
    });
  }
  function Cc(c, p, E) {
    return { instance: c, listener: p, currentTarget: E };
  }
  function yf(c, p) {
    for (var E = p + "Capture", O = []; c !== null; ) {
      var G = c, Q = G.stateNode;
      G.tag === 5 && Q !== null && (G = Q, Q = ki(c, E), Q != null && O.unshift(Cc(c, Q, G)), Q = ki(c, p), Q != null && O.push(Cc(c, Q, G))), c = c.return;
    }
    return O;
  }
  function sc(c) {
    if (c === null)
      return null;
    do
      c = c.return;
    while (c && c.tag !== 5);
    return c || null;
  }
  function ds(c, p, E, O, G) {
    for (var Q = p._reactName, le = []; E !== null && E !== O; ) {
      var Le = E, Ve = Le.alternate, Ct = Le.stateNode;
      if (Ve !== null && Ve === O)
        break;
      Le.tag === 5 && Ct !== null && (Le = Ct, G ? (Ve = ki(E, Q), Ve != null && le.unshift(Cc(E, Ve, Le))) : G || (Ve = ki(E, Q), Ve != null && le.push(Cc(E, Ve, Le)))), E = E.return;
    }
    le.length !== 0 && c.push({ event: p, listeners: le });
  }
  var Qs = /\r\n?/g, zm = /\u0000|\uFFFD/g;
  function Jh(c) {
    return (typeof c == "string" ? c : "" + c).replace(Qs, `
`).replace(zm, "");
  }
  function Vd(c, p, E) {
    if (p = Jh(p), Jh(c) !== p && E)
      throw Error(t(425));
  }
  function bh() {
  }
  var xf = null, Lu = null;
  function rd(c, p) {
    return c === "textarea" || c === "noscript" || typeof p.children == "string" || typeof p.children == "number" || typeof p.dangerouslySetInnerHTML == "object" && p.dangerouslySetInnerHTML !== null && p.dangerouslySetInnerHTML.__html != null;
  }
  var uu = typeof setTimeout == "function" ? setTimeout : void 0, Sf = typeof clearTimeout == "function" ? clearTimeout : void 0, Rc = typeof Promise == "function" ? Promise : void 0, Gd = typeof queueMicrotask == "function" ? queueMicrotask : typeof Rc < "u" ? function(c) {
    return Rc.resolve(null).then(c).catch(id);
  } : uu;
  function id(c) {
    setTimeout(function() {
      throw c;
    });
  }
  function Ac(c, p) {
    var E = p, O = 0;
    do {
      var G = E.nextSibling;
      if (c.removeChild(E), G && G.nodeType === 8)
        if (E = G.data, E === "/$") {
          if (O === 0) {
            c.removeChild(G), Ri(p);
            return;
          }
          O--;
        } else
          E !== "$" && E !== "$?" && E !== "$!" || O++;
      E = G;
    } while (E);
    Ri(p);
  }
  function zl(c) {
    for (; c != null; c = c.nextSibling) {
      var p = c.nodeType;
      if (p === 1 || p === 3)
        break;
      if (p === 8) {
        if (p = c.data, p === "$" || p === "$!" || p === "$?")
          break;
        if (p === "/$")
          return null;
      }
    }
    return c;
  }
  function Dc(c) {
    c = c.previousSibling;
    for (var p = 0; c; ) {
      if (c.nodeType === 8) {
        var E = c.data;
        if (E === "$" || E === "$!" || E === "$?") {
          if (p === 0)
            return c;
          p--;
        } else
          E === "/$" && p++;
      }
      c = c.previousSibling;
    }
    return null;
  }
  var Lc = Math.random().toString(36).slice(2), Os = "__reactFiber$" + Lc, Pu = "__reactProps$" + Lc, _o = "__reactContainer$" + Lc, ad = "__reactEvents$" + Lc, ve = "__reactListeners$" + Lc, oc = "__reactHandles$" + Lc;
  function Zs(c) {
    var p = c[Os];
    if (p)
      return p;
    for (var E = c.parentNode; E; ) {
      if (p = E[_o] || E[Os]) {
        if (E = p.alternate, p.child !== null || E !== null && E.child !== null)
          for (c = Dc(c); c !== null; ) {
            if (E = c[Os])
              return E;
            c = Dc(c);
          }
        return p;
      }
      c = E, E = c.parentNode;
    }
    return null;
  }
  function ka(c) {
    return c = c[Os] || c[_o], !c || c.tag !== 5 && c.tag !== 6 && c.tag !== 13 && c.tag !== 3 ? null : c;
  }
  function Hn(c) {
    if (c.tag === 5 || c.tag === 6)
      return c.stateNode;
    throw Error(t(33));
  }
  function vr(c) {
    return c[Pu] || null;
  }
  var Bi = [], oi = -1;
  function Gn(c) {
    return { current: c };
  }
  function bi(c) {
    0 > oi || (c.current = Bi[oi], Bi[oi] = null, oi--);
  }
  function zi(c, p) {
    oi++, Bi[oi] = c.current, c.current = p;
  }
  var Pc = {}, Rr = Gn(Pc), hs = Gn(!1), es = Pc;
  function Nl(c, p) {
    var E = c.type.contextTypes;
    if (!E)
      return Pc;
    var O = c.stateNode;
    if (O && O.__reactInternalMemoizedUnmaskedChildContext === p)
      return O.__reactInternalMemoizedMaskedChildContext;
    var G = {}, Q;
    for (Q in E)
      G[Q] = p[Q];
    return O && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = p, c.__reactInternalMemoizedMaskedChildContext = G), G;
  }
  function Ia(c) {
    return c = c.childContextTypes, c != null;
  }
  function Fl() {
    bi(hs), bi(Rr);
  }
  function _f(c, p, E) {
    if (Rr.current !== Pc)
      throw Error(t(168));
    zi(Rr, p), zi(hs, E);
  }
  function Wd(c, p, E) {
    var O = c.stateNode;
    if (p = p.childContextTypes, typeof O.getChildContext != "function")
      return E;
    O = O.getChildContext();
    for (var G in O)
      if (!(G in p))
        throw Error(t(108, ot(c) || "Unknown", G));
    return ue({}, E, O);
  }
  function Ho(c) {
    return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || Pc, es = Rr.current, zi(Rr, c), zi(hs, hs.current), !0;
  }
  function Sv(c, p, E) {
    var O = c.stateNode;
    if (!O)
      throw Error(t(169));
    E ? (c = Wd(c, p, es), O.__reactInternalMemoizedMergedChildContext = c, bi(hs), bi(Rr), zi(Rr, c)) : bi(hs), zi(hs, E);
  }
  var vl = null, bo = !1, Kh = !1;
  function lc(c) {
    vl === null ? vl = [c] : vl.push(c);
  }
  function cu(c) {
    bo = !0, lc(c);
  }
  function _s() {
    if (!Kh && vl !== null) {
      Kh = !0;
      var c = 0, p = ri;
      try {
        var E = vl;
        for (ri = 1; c < E.length; c++) {
          var O = E[c];
          do
            O = O(!0);
          while (O !== null);
        }
        vl = null, bo = !1;
      } catch (G) {
        throw vl !== null && (vl = vl.slice(c + 1)), br(ls, _s), G;
      } finally {
        ri = p, Kh = !1;
      }
    }
    return null;
  }
  var Oc = [], Vr = 0, uc = null, zr = 0, Js = [], ps = 0, Uc = null, pn = 1, kl = "";
  function wo(c, p) {
    Oc[Vr++] = zr, Oc[Vr++] = uc, uc = c, zr = p;
  }
  function Nm(c, p, E) {
    Js[ps++] = pn, Js[ps++] = kl, Js[ps++] = Uc, Uc = c;
    var O = pn;
    c = kl;
    var G = 32 - Ea(O) - 1;
    O &= ~(1 << G), E += 1;
    var Q = 32 - Ea(p) + G;
    if (30 < Q) {
      var le = G - G % 5;
      Q = (O & (1 << le) - 1).toString(32), O >>= le, G -= le, pn = 1 << 32 - Ea(p) + G | E << G | O, kl = Q + c;
    } else
      pn = 1 << Q | E << G | O, kl = c;
  }
  function wh(c) {
    c.return !== null && (wo(c, 1), Nm(c, 1, 0));
  }
  function Ou(c) {
    for (; c === uc; )
      uc = Oc[--Vr], Oc[Vr] = null, zr = Oc[--Vr], Oc[Vr] = null;
    for (; c === Uc; )
      Uc = Js[--ps], Js[ps] = null, kl = Js[--ps], Js[ps] = null, pn = Js[--ps], Js[ps] = null;
  }
  var bs = null, gl = null, ga = !1, fu = null;
  function Us(c, p) {
    var E = _l(5, null, null, 0);
    E.elementType = "DELETED", E.stateNode = p, E.return = c, p = c.deletions, p === null ? (c.deletions = [E], c.flags |= 16) : p.push(E);
  }
  function sd(c, p) {
    switch (c.tag) {
      case 5:
        var E = c.type;
        return p = p.nodeType !== 1 || E.toLowerCase() !== p.nodeName.toLowerCase() ? null : p, p !== null ? (c.stateNode = p, bs = c, gl = zl(p.firstChild), !0) : !1;
      case 6:
        return p = c.pendingProps === "" || p.nodeType !== 3 ? null : p, p !== null ? (c.stateNode = p, bs = c, gl = null, !0) : !1;
      case 13:
        return p = p.nodeType !== 8 ? null : p, p !== null ? (E = Uc !== null ? { id: pn, overflow: kl } : null, c.memoizedState = { dehydrated: p, treeContext: E, retryLane: 1073741824 }, E = _l(18, null, null, 0), E.stateNode = p, E.return = c, c.child = E, bs = c, gl = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Il(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function Vo(c) {
    if (ga) {
      var p = gl;
      if (p) {
        var E = p;
        if (!sd(c, p)) {
          if (Il(c))
            throw Error(t(418));
          p = zl(E.nextSibling);
          var O = bs;
          p && sd(c, p) ? Us(O, E) : (c.flags = c.flags & -4097 | 2, ga = !1, bs = c);
        }
      } else {
        if (Il(c))
          throw Error(t(418));
        c.flags = c.flags & -4097 | 2, ga = !1, bs = c;
      }
    }
  }
  function jd(c) {
    for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; )
      c = c.return;
    bs = c;
  }
  function rl(c) {
    if (c !== bs)
      return !1;
    if (!ga)
      return jd(c), ga = !0, !1;
    var p;
    if ((p = c.tag !== 3) && !(p = c.tag !== 5) && (p = c.type, p = p !== "head" && p !== "body" && !rd(c.type, c.memoizedProps)), p && (p = gl)) {
      if (Il(c))
        throw zs(), Error(t(418));
      for (; p; )
        Us(c, p), p = zl(p.nextSibling);
    }
    if (jd(c), c.tag === 13) {
      if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c)
        throw Error(t(317));
      e: {
        for (c = c.nextSibling, p = 0; c; ) {
          if (c.nodeType === 8) {
            var E = c.data;
            if (E === "/$") {
              if (p === 0) {
                gl = zl(c.nextSibling);
                break e;
              }
              p--;
            } else
              E !== "$" && E !== "$!" && E !== "$?" || p++;
          }
          c = c.nextSibling;
        }
        gl = null;
      }
    } else
      gl = bs ? zl(c.stateNode.nextSibling) : null;
    return !0;
  }
  function zs() {
    for (var c = gl; c; )
      c = zl(c.nextSibling);
  }
  function fa() {
    gl = bs = null, ga = !1;
  }
  function Uu(c) {
    fu === null ? fu = [c] : fu.push(c);
  }
  var Hp = I.ReactCurrentBatchConfig;
  function du(c, p) {
    if (c && c.defaultProps) {
      p = ue({}, p), c = c.defaultProps;
      for (var E in c)
        p[E] === void 0 && (p[E] = c[E]);
      return p;
    }
    return p;
  }
  var Bl = Gn(null), $h = null, bf = null, Ks = null;
  function Yd() {
    Ks = bf = $h = null;
  }
  function da(c) {
    var p = Bl.current;
    bi(Bl), c._currentValue = p;
  }
  function Hi(c, p, E) {
    for (; c !== null; ) {
      var O = c.alternate;
      if ((c.childLanes & p) !== p ? (c.childLanes |= p, O !== null && (O.childLanes |= p)) : O !== null && (O.childLanes & p) !== p && (O.childLanes |= p), c === E)
        break;
      c = c.return;
    }
  }
  function wn(c, p) {
    $h = c, Ks = bf = null, c = c.dependencies, c !== null && c.firstContext !== null && ((c.lanes & p) !== 0 && (Tn = !0), c.firstContext = null);
  }
  function Qi(c) {
    var p = c._currentValue;
    if (Ks !== c)
      if (c = { context: c, memoizedValue: p, next: null }, bf === null) {
        if ($h === null)
          throw Error(t(308));
        bf = c, $h.dependencies = { lanes: 0, firstContext: c };
      } else
        bf = bf.next = c;
    return p;
  }
  var ya = null;
  function ep(c) {
    ya === null ? ya = [c] : ya.push(c);
  }
  function Go(c, p, E, O) {
    var G = p.interleaved;
    return G === null ? (E.next = E, ep(p)) : (E.next = G.next, G.next = E), p.interleaved = E, Wo(c, O);
  }
  function Wo(c, p) {
    c.lanes |= p;
    var E = c.alternate;
    for (E !== null && (E.lanes |= p), E = c, c = c.return; c !== null; )
      c.childLanes |= p, E = c.alternate, E !== null && (E.childLanes |= p), E = c, c = c.return;
    return E.tag === 3 ? E.stateNode : null;
  }
  var ts = !1;
  function An(c) {
    c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function xa(c, p) {
    c = c.updateQueue, p.updateQueue === c && (p.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects });
  }
  function ns(c, p) {
    return { eventTime: c, lane: p, tag: 0, payload: null, callback: null, next: null };
  }
  function wf(c, p, E) {
    var O = c.updateQueue;
    if (O === null)
      return null;
    if (O = O.shared, (Nr & 2) !== 0) {
      var G = O.pending;
      return G === null ? p.next = p : (p.next = G.next, G.next = p), O.pending = p, Wo(c, E);
    }
    return G = O.interleaved, G === null ? (p.next = p, ep(O)) : (p.next = G.next, G.next = p), O.interleaved = p, Wo(c, E);
  }
  function Sa(c, p, E) {
    if (p = p.updateQueue, p !== null && (p = p.shared, (E & 4194240) !== 0)) {
      var O = p.lanes;
      O &= c.pendingLanes, E |= O, p.lanes = E, Dl(c, E);
    }
  }
  function Kr(c, p) {
    var E = c.updateQueue, O = c.alternate;
    if (O !== null && (O = O.updateQueue, E === O)) {
      var G = null, Q = null;
      if (E = E.firstBaseUpdate, E !== null) {
        do {
          var le = { eventTime: E.eventTime, lane: E.lane, tag: E.tag, payload: E.payload, callback: E.callback, next: null };
          Q === null ? G = Q = le : Q = Q.next = le, E = E.next;
        } while (E !== null);
        Q === null ? G = Q = p : Q = Q.next = p;
      } else
        G = Q = p;
      E = { baseState: O.baseState, firstBaseUpdate: G, lastBaseUpdate: Q, shared: O.shared, effects: O.effects }, c.updateQueue = E;
      return;
    }
    c = E.lastBaseUpdate, c === null ? E.firstBaseUpdate = p : c.next = p, E.lastBaseUpdate = p;
  }
  function Ra(c, p, E, O) {
    var G = c.updateQueue;
    ts = !1;
    var Q = G.firstBaseUpdate, le = G.lastBaseUpdate, Le = G.shared.pending;
    if (Le !== null) {
      G.shared.pending = null;
      var Ve = Le, Ct = Ve.next;
      Ve.next = null, le === null ? Q = Ct : le.next = Ct, le = Ve;
      var un = c.alternate;
      un !== null && (un = un.updateQueue, Le = un.lastBaseUpdate, Le !== le && (Le === null ? un.firstBaseUpdate = Ct : Le.next = Ct, un.lastBaseUpdate = Ve));
    }
    if (Q !== null) {
      var ln = G.baseState;
      le = 0, un = Ct = Ve = null, Le = Q;
      do {
        var nn = Le.lane, kn = Le.eventTime;
        if ((O & nn) === nn) {
          un !== null && (un = un.next = {
            eventTime: kn,
            lane: 0,
            tag: Le.tag,
            payload: Le.payload,
            callback: Le.callback,
            next: null
          });
          e: {
            var qn = c, rr = Le;
            switch (nn = p, kn = E, rr.tag) {
              case 1:
                if (qn = rr.payload, typeof qn == "function") {
                  ln = qn.call(kn, ln, nn);
                  break e;
                }
                ln = qn;
                break e;
              case 3:
                qn.flags = qn.flags & -65537 | 128;
              case 0:
                if (qn = rr.payload, nn = typeof qn == "function" ? qn.call(kn, ln, nn) : qn, nn == null)
                  break e;
                ln = ue({}, ln, nn);
                break e;
              case 2:
                ts = !0;
            }
          }
          Le.callback !== null && Le.lane !== 0 && (c.flags |= 64, nn = G.effects, nn === null ? G.effects = [Le] : nn.push(Le));
        } else
          kn = { eventTime: kn, lane: nn, tag: Le.tag, payload: Le.payload, callback: Le.callback, next: null }, un === null ? (Ct = un = kn, Ve = ln) : un = un.next = kn, le |= nn;
        if (Le = Le.next, Le === null) {
          if (Le = G.shared.pending, Le === null)
            break;
          nn = Le, Le = nn.next, nn.next = null, G.lastBaseUpdate = nn, G.shared.pending = null;
        }
      } while (1);
      if (un === null && (Ve = ln), G.baseState = Ve, G.firstBaseUpdate = Ct, G.lastBaseUpdate = un, p = G.shared.interleaved, p !== null) {
        G = p;
        do
          le |= G.lane, G = G.next;
        while (G !== p);
      } else
        Q === null && (G.shared.lanes = 0);
      vd |= le, c.lanes = le, c.memoizedState = ln;
    }
  }
  function Ba(c, p, E) {
    if (c = p.effects, p.effects = null, c !== null)
      for (p = 0; p < c.length; p++) {
        var O = c[p], G = O.callback;
        if (G !== null) {
          if (O.callback = null, O = E, typeof G != "function")
            throw Error(t(191, G));
          G.call(O);
        }
      }
  }
  var ci = new a.Component().refs;
  function Hl(c, p, E, O) {
    p = c.memoizedState, E = E(O, p), E = E == null ? p : ue({}, p, E), c.memoizedState = E, c.lanes === 0 && (c.updateQueue.baseState = E);
  }
  var od = { isMounted: function(c) {
    return (c = c._reactInternals) ? yn(c) === c : !1;
  }, enqueueSetState: function(c, p, E) {
    c = c._reactInternals;
    var O = ha(), G = ro(c), Q = ns(O, G);
    Q.payload = p, E != null && (Q.callback = E), p = wf(c, Q, G), p !== null && (Sl(p, c, G, O), Sa(p, c, G));
  }, enqueueReplaceState: function(c, p, E) {
    c = c._reactInternals;
    var O = ha(), G = ro(c), Q = ns(O, G);
    Q.tag = 1, Q.payload = p, E != null && (Q.callback = E), p = wf(c, Q, G), p !== null && (Sl(p, c, G, O), Sa(p, c, G));
  }, enqueueForceUpdate: function(c, p) {
    c = c._reactInternals;
    var E = ha(), O = ro(c), G = ns(E, O);
    G.tag = 2, p != null && (G.callback = p), p = wf(c, G, O), p !== null && (Sl(p, c, O, E), Sa(p, c, O));
  } };
  function ws(c, p, E, O, G, Q, le) {
    return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(O, Q, le) : p.prototype && p.prototype.isPureReactComponent ? !Mn(E, O) || !Mn(G, Q) : !0;
  }
  function Xd(c, p, E) {
    var O = !1, G = Pc, Q = p.contextType;
    return typeof Q == "object" && Q !== null ? Q = Qi(Q) : (G = Ia(p) ? es : Rr.current, O = p.contextTypes, Q = (O = O != null) ? Nl(c, G) : Pc), p = new p(E, Q), c.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = od, c.stateNode = p, p._reactInternals = c, O && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = G, c.__reactInternalMemoizedMaskedChildContext = Q), p;
  }
  function zc(c, p, E, O) {
    c = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(E, O), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(E, O), p.state !== c && od.enqueueReplaceState(p, p.state, null);
  }
  function cc(c, p, E, O) {
    var G = c.stateNode;
    G.props = E, G.state = c.memoizedState, G.refs = ci, An(c);
    var Q = p.contextType;
    typeof Q == "object" && Q !== null ? G.context = Qi(Q) : (Q = Ia(p) ? es : Rr.current, G.context = Nl(c, Q)), G.state = c.memoizedState, Q = p.getDerivedStateFromProps, typeof Q == "function" && (Hl(c, p, Q, E), G.state = c.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof G.getSnapshotBeforeUpdate == "function" || typeof G.UNSAFE_componentWillMount != "function" && typeof G.componentWillMount != "function" || (p = G.state, typeof G.componentWillMount == "function" && G.componentWillMount(), typeof G.UNSAFE_componentWillMount == "function" && G.UNSAFE_componentWillMount(), p !== G.state && od.enqueueReplaceState(G, G.state, null), Ra(c, E, G, O), G.state = c.memoizedState), typeof G.componentDidMount == "function" && (c.flags |= 4194308);
  }
  function qd(c, p, E) {
    if (c = E.ref, c !== null && typeof c != "function" && typeof c != "object") {
      if (E._owner) {
        if (E = E._owner, E) {
          if (E.tag !== 1)
            throw Error(t(309));
          var O = E.stateNode;
        }
        if (!O)
          throw Error(t(147, c));
        var G = O, Q = "" + c;
        return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === Q ? p.ref : (p = function(le) {
          var Le = G.refs;
          Le === ci && (Le = G.refs = {}), le === null ? delete Le[Q] : Le[Q] = le;
        }, p._stringRef = Q, p);
      }
      if (typeof c != "string")
        throw Error(t(284));
      if (!E._owner)
        throw Error(t(290, c));
    }
    return c;
  }
  function ld(c, p) {
    throw c = Object.prototype.toString.call(p), Error(t(31, c === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : c));
  }
  function il(c) {
    var p = c._init;
    return p(c._payload);
  }
  function Fm(c) {
    function p(ht, Ze) {
      if (c) {
        var gt = ht.deletions;
        gt === null ? (ht.deletions = [Ze], ht.flags |= 16) : gt.push(Ze);
      }
    }
    function E(ht, Ze) {
      if (!c)
        return null;
      for (; Ze !== null; )
        p(ht, Ze), Ze = Ze.sibling;
      return null;
    }
    function O(ht, Ze) {
      for (ht = /* @__PURE__ */ new Map(); Ze !== null; )
        Ze.key !== null ? ht.set(Ze.key, Ze) : ht.set(Ze.index, Ze), Ze = Ze.sibling;
      return ht;
    }
    function G(ht, Ze) {
      return ht = ku(ht, Ze), ht.index = 0, ht.sibling = null, ht;
    }
    function Q(ht, Ze, gt) {
      return ht.index = gt, c ? (gt = ht.alternate, gt !== null ? (gt = gt.index, gt < Ze ? (ht.flags |= 2, Ze) : gt) : (ht.flags |= 2, Ze)) : (ht.flags |= 1048576, Ze);
    }
    function le(ht) {
      return c && ht.alternate === null && (ht.flags |= 2), ht;
    }
    function Le(ht, Ze, gt, xn) {
      return Ze === null || Ze.tag !== 6 ? (Ze = mc(gt, ht.mode, xn), Ze.return = ht, Ze) : (Ze = G(Ze, gt), Ze.return = ht, Ze);
    }
    function Ve(ht, Ze, gt, xn) {
      var ar = gt.type;
      return ar === $ ? un(ht, Ze, gt.props.children, xn, gt.key) : Ze !== null && (Ze.elementType === ar || typeof ar == "object" && ar !== null && ar.$$typeof === Ce && il(ar) === Ze.type) ? (xn = G(Ze, gt.props), xn.ref = qd(ht, Ze, gt), xn.return = ht, xn) : (xn = Lh(gt.type, gt.key, gt.props, null, ht.mode, xn), xn.ref = qd(ht, Ze, gt), xn.return = ht, xn);
    }
    function Ct(ht, Ze, gt, xn) {
      return Ze === null || Ze.tag !== 4 || Ze.stateNode.containerInfo !== gt.containerInfo || Ze.stateNode.implementation !== gt.implementation ? (Ze = Aa(gt, ht.mode, xn), Ze.return = ht, Ze) : (Ze = G(Ze, gt.children || []), Ze.return = ht, Ze);
    }
    function un(ht, Ze, gt, xn, ar) {
      return Ze === null || Ze.tag !== 7 ? (Ze = Jp(gt, ht.mode, xn, ar), Ze.return = ht, Ze) : (Ze = G(Ze, gt), Ze.return = ht, Ze);
    }
    function ln(ht, Ze, gt) {
      if (typeof Ze == "string" && Ze !== "" || typeof Ze == "number")
        return Ze = mc("" + Ze, ht.mode, gt), Ze.return = ht, Ze;
      if (typeof Ze == "object" && Ze !== null) {
        switch (Ze.$$typeof) {
          case X:
            return gt = Lh(Ze.type, Ze.key, Ze.props, null, ht.mode, gt), gt.ref = qd(ht, null, Ze), gt.return = ht, gt;
          case J:
            return Ze = Aa(Ze, ht.mode, gt), Ze.return = ht, Ze;
          case Ce:
            var xn = Ze._init;
            return ln(ht, xn(Ze._payload), gt);
        }
        if (Jt(Ze) || fe(Ze))
          return Ze = Jp(Ze, ht.mode, gt, null), Ze.return = ht, Ze;
        ld(ht, Ze);
      }
      return null;
    }
    function nn(ht, Ze, gt, xn) {
      var ar = Ze !== null ? Ze.key : null;
      if (typeof gt == "string" && gt !== "" || typeof gt == "number")
        return ar !== null ? null : Le(ht, Ze, "" + gt, xn);
      if (typeof gt == "object" && gt !== null) {
        switch (gt.$$typeof) {
          case X:
            return gt.key === ar ? Ve(ht, Ze, gt, xn) : null;
          case J:
            return gt.key === ar ? Ct(ht, Ze, gt, xn) : null;
          case Ce:
            return ar = gt._init, nn(
              ht,
              Ze,
              ar(gt._payload),
              xn
            );
        }
        if (Jt(gt) || fe(gt))
          return ar !== null ? null : un(ht, Ze, gt, xn, null);
        ld(ht, gt);
      }
      return null;
    }
    function kn(ht, Ze, gt, xn, ar) {
      if (typeof xn == "string" && xn !== "" || typeof xn == "number")
        return ht = ht.get(gt) || null, Le(Ze, ht, "" + xn, ar);
      if (typeof xn == "object" && xn !== null) {
        switch (xn.$$typeof) {
          case X:
            return ht = ht.get(xn.key === null ? gt : xn.key) || null, Ve(Ze, ht, xn, ar);
          case J:
            return ht = ht.get(xn.key === null ? gt : xn.key) || null, Ct(Ze, ht, xn, ar);
          case Ce:
            var Qn = xn._init;
            return kn(ht, Ze, gt, Qn(xn._payload), ar);
        }
        if (Jt(xn) || fe(xn))
          return ht = ht.get(gt) || null, un(Ze, ht, xn, ar, null);
        ld(Ze, xn);
      }
      return null;
    }
    function qn(ht, Ze, gt, xn) {
      for (var ar = null, Qn = null, pr = Ze, Lr = Ze = 0, ol = null; pr !== null && Lr < gt.length; Lr++) {
        pr.index > Lr ? (ol = pr, pr = null) : ol = pr.sibling;
        var Zi = nn(ht, pr, gt[Lr], xn);
        if (Zi === null) {
          pr === null && (pr = ol);
          break;
        }
        c && pr && Zi.alternate === null && p(ht, pr), Ze = Q(Zi, Ze, Lr), Qn === null ? ar = Zi : Qn.sibling = Zi, Qn = Zi, pr = ol;
      }
      if (Lr === gt.length)
        return E(ht, pr), ga && wo(ht, Lr), ar;
      if (pr === null) {
        for (; Lr < gt.length; Lr++)
          pr = ln(ht, gt[Lr], xn), pr !== null && (Ze = Q(pr, Ze, Lr), Qn === null ? ar = pr : Qn.sibling = pr, Qn = pr);
        return ga && wo(ht, Lr), ar;
      }
      for (pr = O(ht, pr); Lr < gt.length; Lr++)
        ol = kn(pr, ht, Lr, gt[Lr], xn), ol !== null && (c && ol.alternate !== null && pr.delete(ol.key === null ? Lr : ol.key), Ze = Q(ol, Ze, Lr), Qn === null ? ar = ol : Qn.sibling = ol, Qn = ol);
      return c && pr.forEach(function(Ff) {
        return p(ht, Ff);
      }), ga && wo(ht, Lr), ar;
    }
    function rr(ht, Ze, gt, xn) {
      var ar = fe(gt);
      if (typeof ar != "function")
        throw Error(t(150));
      if (gt = ar.call(gt), gt == null)
        throw Error(t(151));
      for (var Qn = ar = null, pr = Ze, Lr = Ze = 0, ol = null, Zi = gt.next(); pr !== null && !Zi.done; Lr++, Zi = gt.next()) {
        pr.index > Lr ? (ol = pr, pr = null) : ol = pr.sibling;
        var Ff = nn(ht, pr, Zi.value, xn);
        if (Ff === null) {
          pr === null && (pr = ol);
          break;
        }
        c && pr && Ff.alternate === null && p(ht, pr), Ze = Q(Ff, Ze, Lr), Qn === null ? ar = Ff : Qn.sibling = Ff, Qn = Ff, pr = ol;
      }
      if (Zi.done)
        return E(
          ht,
          pr
        ), ga && wo(ht, Lr), ar;
      if (pr === null) {
        for (; !Zi.done; Lr++, Zi = gt.next())
          Zi = ln(ht, Zi.value, xn), Zi !== null && (Ze = Q(Zi, Ze, Lr), Qn === null ? ar = Zi : Qn.sibling = Zi, Qn = Zi);
        return ga && wo(ht, Lr), ar;
      }
      for (pr = O(ht, pr); !Zi.done; Lr++, Zi = gt.next())
        Zi = kn(pr, ht, Lr, Zi.value, xn), Zi !== null && (c && Zi.alternate !== null && pr.delete(Zi.key === null ? Lr : Zi.key), Ze = Q(Zi, Ze, Lr), Qn === null ? ar = Zi : Qn.sibling = Zi, Qn = Zi);
      return c && pr.forEach(function(Eg) {
        return p(ht, Eg);
      }), ga && wo(ht, Lr), ar;
    }
    function Bs(ht, Ze, gt, xn) {
      if (typeof gt == "object" && gt !== null && gt.type === $ && gt.key === null && (gt = gt.props.children), typeof gt == "object" && gt !== null) {
        switch (gt.$$typeof) {
          case X:
            e: {
              for (var ar = gt.key, Qn = Ze; Qn !== null; ) {
                if (Qn.key === ar) {
                  if (ar = gt.type, ar === $) {
                    if (Qn.tag === 7) {
                      E(ht, Qn.sibling), Ze = G(Qn, gt.props.children), Ze.return = ht, ht = Ze;
                      break e;
                    }
                  } else if (Qn.elementType === ar || typeof ar == "object" && ar !== null && ar.$$typeof === Ce && il(ar) === Qn.type) {
                    E(ht, Qn.sibling), Ze = G(Qn, gt.props), Ze.ref = qd(ht, Qn, gt), Ze.return = ht, ht = Ze;
                    break e;
                  }
                  E(ht, Qn);
                  break;
                } else
                  p(ht, Qn);
                Qn = Qn.sibling;
              }
              gt.type === $ ? (Ze = Jp(gt.props.children, ht.mode, xn, gt.key), Ze.return = ht, ht = Ze) : (xn = Lh(gt.type, gt.key, gt.props, null, ht.mode, xn), xn.ref = qd(ht, Ze, gt), xn.return = ht, ht = xn);
            }
            return le(ht);
          case J:
            e: {
              for (Qn = gt.key; Ze !== null; ) {
                if (Ze.key === Qn)
                  if (Ze.tag === 4 && Ze.stateNode.containerInfo === gt.containerInfo && Ze.stateNode.implementation === gt.implementation) {
                    E(ht, Ze.sibling), Ze = G(Ze, gt.children || []), Ze.return = ht, ht = Ze;
                    break e;
                  } else {
                    E(ht, Ze);
                    break;
                  }
                else
                  p(ht, Ze);
                Ze = Ze.sibling;
              }
              Ze = Aa(gt, ht.mode, xn), Ze.return = ht, ht = Ze;
            }
            return le(ht);
          case Ce:
            return Qn = gt._init, Bs(ht, Ze, Qn(gt._payload), xn);
        }
        if (Jt(gt))
          return qn(ht, Ze, gt, xn);
        if (fe(gt))
          return rr(ht, Ze, gt, xn);
        ld(ht, gt);
      }
      return typeof gt == "string" && gt !== "" || typeof gt == "number" ? (gt = "" + gt, Ze !== null && Ze.tag === 6 ? (E(ht, Ze.sibling), Ze = G(Ze, gt), Ze.return = ht, ht = Ze) : (E(ht, Ze), Ze = mc(gt, ht.mode, xn), Ze.return = ht, ht = Ze), le(ht)) : E(ht, Ze);
    }
    return Bs;
  }
  var Ef = Fm(!0), Qd = Fm(!1), Mf = {}, Vl = Gn(Mf), Gl = Gn(Mf), ud = Gn(Mf);
  function Wl(c) {
    if (c === Mf)
      throw Error(t(174));
    return c;
  }
  function Eh(c, p) {
    switch (zi(ud, p), zi(Gl, c), zi(Vl, Mf), c = p.nodeType, c) {
      case 9:
      case 11:
        p = (p = p.documentElement) ? p.namespaceURI : Nt(null, "");
        break;
      default:
        c = c === 8 ? p.parentNode : p, p = c.namespaceURI || null, c = c.tagName, p = Nt(p, c);
    }
    bi(Vl), zi(Vl, p);
  }
  function fc() {
    bi(Vl), bi(Gl), bi(ud);
  }
  function hr(c) {
    Wl(ud.current);
    var p = Wl(Vl.current), E = Nt(p, c.type);
    p !== E && (zi(Gl, c), zi(Vl, E));
  }
  function Yr(c) {
    Gl.current === c && (bi(Vl), bi(Gl));
  }
  var fr = Gn(0);
  function fi(c) {
    for (var p = c; p !== null; ) {
      if (p.tag === 13) {
        var E = p.memoizedState;
        if (E !== null && (E = E.dehydrated, E === null || E.data === "$?" || E.data === "$!"))
          return p;
      } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
        if ((p.flags & 128) !== 0)
          return p;
      } else if (p.child !== null) {
        p.child.return = p, p = p.child;
        continue;
      }
      if (p === c)
        break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === c)
          return null;
        p = p.return;
      }
      p.sibling.return = p.return, p = p.sibling;
    }
    return null;
  }
  var Ns = [];
  function jl() {
    for (var c = 0; c < Ns.length; c++)
      Ns[c]._workInProgressVersionPrimary = null;
    Ns.length = 0;
  }
  var Nc = I.ReactCurrentDispatcher, Sr = I.ReactCurrentBatchConfig, Eo = 0, Ai = null, Ht = null, vi = null, lr = !1, Fc = !1, Ha = 0, jo = 0;
  function Di() {
    throw Error(t(321));
  }
  function Tf(c, p) {
    if (p === null)
      return !1;
    for (var E = 0; E < p.length && E < c.length; E++)
      if (!pt(c[E], p[E]))
        return !1;
    return !0;
  }
  function Cf(c, p, E, O, G, Q) {
    if (Eo = Q, Ai = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, Nc.current = c === null || c.memoizedState === null ? x : L, c = E(O, G), Fc) {
      Q = 0;
      do {
        if (Fc = !1, Ha = 0, 25 <= Q)
          throw Error(t(301));
        Q += 1, vi = Ht = null, p.updateQueue = null, Nc.current = H, c = E(O, G);
      } while (Fc);
    }
    if (Nc.current = y, p = Ht !== null && Ht.next !== null, Eo = 0, vi = Ht = Ai = null, lr = !1, p)
      throw Error(t(300));
    return c;
  }
  function Rf() {
    var c = Ha !== 0;
    return Ha = 0, c;
  }
  function ia() {
    var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return vi === null ? Ai.memoizedState = vi = c : vi = vi.next = c, vi;
  }
  function Fs() {
    if (Ht === null) {
      var c = Ai.alternate;
      c = c !== null ? c.memoizedState : null;
    } else
      c = Ht.next;
    var p = vi === null ? Ai.memoizedState : vi.next;
    if (p !== null)
      vi = p, Ht = c;
    else {
      if (c === null)
        throw Error(t(310));
      Ht = c, c = { memoizedState: Ht.memoizedState, baseState: Ht.baseState, baseQueue: Ht.baseQueue, queue: Ht.queue, next: null }, vi === null ? Ai.memoizedState = vi = c : vi = vi.next = c;
    }
    return vi;
  }
  function Af(c, p) {
    return typeof p == "function" ? p(c) : p;
  }
  function Zd(c) {
    var p = Fs(), E = p.queue;
    if (E === null)
      throw Error(t(311));
    E.lastRenderedReducer = c;
    var O = Ht, G = O.baseQueue, Q = E.pending;
    if (Q !== null) {
      if (G !== null) {
        var le = G.next;
        G.next = Q.next, Q.next = le;
      }
      O.baseQueue = G = Q, E.pending = null;
    }
    if (G !== null) {
      Q = G.next, O = O.baseState;
      var Le = le = null, Ve = null, Ct = Q;
      do {
        var un = Ct.lane;
        if ((Eo & un) === un)
          Ve !== null && (Ve = Ve.next = { lane: 0, action: Ct.action, hasEagerState: Ct.hasEagerState, eagerState: Ct.eagerState, next: null }), O = Ct.hasEagerState ? Ct.eagerState : c(O, Ct.action);
        else {
          var ln = {
            lane: un,
            action: Ct.action,
            hasEagerState: Ct.hasEagerState,
            eagerState: Ct.eagerState,
            next: null
          };
          Ve === null ? (Le = Ve = ln, le = O) : Ve = Ve.next = ln, Ai.lanes |= un, vd |= un;
        }
        Ct = Ct.next;
      } while (Ct !== null && Ct !== Q);
      Ve === null ? le = O : Ve.next = Le, pt(O, p.memoizedState) || (Tn = !0), p.memoizedState = O, p.baseState = le, p.baseQueue = Ve, E.lastRenderedState = O;
    }
    if (c = E.interleaved, c !== null) {
      G = c;
      do
        Q = G.lane, Ai.lanes |= Q, vd |= Q, G = G.next;
      while (G !== c);
    } else
      G === null && (E.lanes = 0);
    return [p.memoizedState, E.dispatch];
  }
  function $s(c) {
    var p = Fs(), E = p.queue;
    if (E === null)
      throw Error(t(311));
    E.lastRenderedReducer = c;
    var O = E.dispatch, G = E.pending, Q = p.memoizedState;
    if (G !== null) {
      E.pending = null;
      var le = G = G.next;
      do
        Q = c(Q, le.action), le = le.next;
      while (le !== G);
      pt(Q, p.memoizedState) || (Tn = !0), p.memoizedState = Q, p.baseQueue === null && (p.baseState = Q), E.lastRenderedState = Q;
    }
    return [Q, O];
  }
  function Yl() {
  }
  function tp(c, p) {
    var E = Ai, O = Fs(), G = p(), Q = !pt(O.memoizedState, G);
    if (Q && (O.memoizedState = G, Tn = !0), O = O.queue, Bc(wi.bind(null, E, O, c), [c]), O.getSnapshot !== p || Q || vi !== null && vi.memoizedState.tag & 1) {
      if (E.flags |= 2048, hu(9, Es.bind(null, E, O, G, p), void 0, null), ea === null)
        throw Error(t(349));
      (Eo & 30) !== 0 || kc(E, p, G);
    }
    return G;
  }
  function kc(c, p, E) {
    c.flags |= 16384, c = { getSnapshot: p, value: E }, p = Ai.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, Ai.updateQueue = p, p.stores = [c]) : (E = p.stores, E === null ? p.stores = [c] : E.push(c));
  }
  function Es(c, p, E, O) {
    p.value = E, p.getSnapshot = O, eo(p) && Xl(c);
  }
  function wi(c, p, E) {
    return E(function() {
      eo(p) && Xl(c);
    });
  }
  function eo(c) {
    var p = c.getSnapshot;
    c = c.value;
    try {
      var E = p();
      return !pt(c, E);
    } catch {
      return !0;
    }
  }
  function Xl(c) {
    var p = Wo(c, 1);
    p !== null && Sl(p, c, 1, -1);
  }
  function Ic(c) {
    var p = ia();
    return typeof c == "function" && (c = c()), p.memoizedState = p.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Af, lastRenderedState: c }, p.queue = c, c = c.dispatch = Lf.bind(null, Ai, c), [p.memoizedState, c];
  }
  function hu(c, p, E, O) {
    return c = { tag: c, create: p, destroy: E, deps: O, next: null }, p = Ai.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, Ai.updateQueue = p, p.lastEffect = c.next = c) : (E = p.lastEffect, E === null ? p.lastEffect = c.next = c : (O = E.next, E.next = c, c.next = O, p.lastEffect = c)), c;
  }
  function Df() {
    return Fs().memoizedState;
  }
  function pu(c, p, E, O) {
    var G = ia();
    Ai.flags |= c, G.memoizedState = hu(1 | p, E, void 0, O === void 0 ? null : O);
  }
  function zu(c, p, E, O) {
    var G = Fs();
    O = O === void 0 ? null : O;
    var Q = void 0;
    if (Ht !== null) {
      var le = Ht.memoizedState;
      if (Q = le.destroy, O !== null && Tf(O, le.deps)) {
        G.memoizedState = hu(p, E, Q, O);
        return;
      }
    }
    Ai.flags |= c, G.memoizedState = hu(1 | p, E, Q, O);
  }
  function Mo(c, p) {
    return pu(8390656, 8, c, p);
  }
  function Bc(c, p) {
    return zu(2048, 8, c, p);
  }
  function cd(c, p) {
    return zu(4, 2, c, p);
  }
  function Yo(c, p) {
    return zu(4, 4, c, p);
  }
  function fd(c, p) {
    if (typeof p == "function")
      return c = c(), p(c), function() {
        p(null);
      };
    if (p != null)
      return c = c(), p.current = c, function() {
        p.current = null;
      };
  }
  function mu(c, p, E) {
    return E = E != null ? E.concat([c]) : null, zu(4, 4, fd.bind(null, p, c), E);
  }
  function dd() {
  }
  function Ms(c, p) {
    var E = Fs();
    p = p === void 0 ? null : p;
    var O = E.memoizedState;
    return O !== null && p !== null && Tf(p, O[1]) ? O[0] : (E.memoizedState = [c, p], c);
  }
  function ks(c, p) {
    var E = Fs();
    p = p === void 0 ? null : p;
    var O = E.memoizedState;
    return O !== null && p !== null && Tf(p, O[1]) ? O[0] : (c = c(), E.memoizedState = [c, p], c);
  }
  function vu(c, p, E) {
    return (Eo & 21) === 0 ? (c.baseState && (c.baseState = !1, Tn = !0), c.memoizedState = E) : (pt(E, p) || (E = Ls(), Ai.lanes |= E, vd |= E, c.baseState = !0), p);
  }
  function fg(c, p) {
    var E = ri;
    ri = E !== 0 && 4 > E ? E : 4, c(!0);
    var O = Sr.transition;
    Sr.transition = {};
    try {
      c(!1), p();
    } finally {
      ri = E, Sr.transition = O;
    }
  }
  function ii() {
    return Fs().memoizedState;
  }
  function Nu(c, p, E) {
    var O = ro(c);
    if (E = { lane: O, action: E, hasEagerState: !1, eagerState: null, next: null }, dc(c))
      Pf(p, E);
    else if (E = Go(c, p, E, O), E !== null) {
      var G = ha();
      Sl(E, c, O, G), Vp(E, p, O);
    }
  }
  function Lf(c, p, E) {
    var O = ro(c), G = { lane: O, action: E, hasEagerState: !1, eagerState: null, next: null };
    if (dc(c))
      Pf(p, G);
    else {
      var Q = c.alternate;
      if (c.lanes === 0 && (Q === null || Q.lanes === 0) && (Q = p.lastRenderedReducer, Q !== null))
        try {
          var le = p.lastRenderedState, Le = Q(le, E);
          if (G.hasEagerState = !0, G.eagerState = Le, pt(Le, le)) {
            var Ve = p.interleaved;
            Ve === null ? (G.next = G, ep(p)) : (G.next = Ve.next, Ve.next = G), p.interleaved = G;
            return;
          }
        } catch {
        } finally {
        }
      E = Go(c, p, G, O), E !== null && (G = ha(), Sl(E, c, O, G), Vp(E, p, O));
    }
  }
  function dc(c) {
    var p = c.alternate;
    return c === Ai || p !== null && p === Ai;
  }
  function Pf(c, p) {
    Fc = lr = !0;
    var E = c.pending;
    E === null ? p.next = p : (p.next = E.next, E.next = p), c.pending = p;
  }
  function Vp(c, p, E) {
    if ((E & 4194240) !== 0) {
      var O = p.lanes;
      O &= c.pendingLanes, E |= O, p.lanes = E, Dl(c, E);
    }
  }
  var y = { readContext: Qi, useCallback: Di, useContext: Di, useEffect: Di, useImperativeHandle: Di, useInsertionEffect: Di, useLayoutEffect: Di, useMemo: Di, useReducer: Di, useRef: Di, useState: Di, useDebugValue: Di, useDeferredValue: Di, useTransition: Di, useMutableSource: Di, useSyncExternalStore: Di, useId: Di, unstable_isNewReconciler: !1 }, x = { readContext: Qi, useCallback: function(c, p) {
    return ia().memoizedState = [c, p === void 0 ? null : p], c;
  }, useContext: Qi, useEffect: Mo, useImperativeHandle: function(c, p, E) {
    return E = E != null ? E.concat([c]) : null, pu(
      4194308,
      4,
      fd.bind(null, p, c),
      E
    );
  }, useLayoutEffect: function(c, p) {
    return pu(4194308, 4, c, p);
  }, useInsertionEffect: function(c, p) {
    return pu(4, 2, c, p);
  }, useMemo: function(c, p) {
    var E = ia();
    return p = p === void 0 ? null : p, c = c(), E.memoizedState = [c, p], c;
  }, useReducer: function(c, p, E) {
    var O = ia();
    return p = E !== void 0 ? E(p) : p, O.memoizedState = O.baseState = p, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: p }, O.queue = c, c = c.dispatch = Nu.bind(null, Ai, c), [O.memoizedState, c];
  }, useRef: function(c) {
    var p = ia();
    return c = { current: c }, p.memoizedState = c;
  }, useState: Ic, useDebugValue: dd, useDeferredValue: function(c) {
    return ia().memoizedState = c;
  }, useTransition: function() {
    var c = Ic(!1), p = c[0];
    return c = fg.bind(null, c[1]), ia().memoizedState = c, [p, c];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(c, p, E) {
    var O = Ai, G = ia();
    if (ga) {
      if (E === void 0)
        throw Error(t(407));
      E = E();
    } else {
      if (E = p(), ea === null)
        throw Error(t(349));
      (Eo & 30) !== 0 || kc(O, p, E);
    }
    G.memoizedState = E;
    var Q = { value: E, getSnapshot: p };
    return G.queue = Q, Mo(wi.bind(
      null,
      O,
      Q,
      c
    ), [c]), O.flags |= 2048, hu(9, Es.bind(null, O, Q, E, p), void 0, null), E;
  }, useId: function() {
    var c = ia(), p = ea.identifierPrefix;
    if (ga) {
      var E = kl, O = pn;
      E = (O & ~(1 << 32 - Ea(O) - 1)).toString(32) + E, p = ":" + p + "R" + E, E = Ha++, 0 < E && (p += "H" + E.toString(32)), p += ":";
    } else
      E = jo++, p = ":" + p + "r" + E.toString(32) + ":";
    return c.memoizedState = p;
  }, unstable_isNewReconciler: !1 }, L = {
    readContext: Qi,
    useCallback: Ms,
    useContext: Qi,
    useEffect: Bc,
    useImperativeHandle: mu,
    useInsertionEffect: cd,
    useLayoutEffect: Yo,
    useMemo: ks,
    useReducer: Zd,
    useRef: Df,
    useState: function() {
      return Zd(Af);
    },
    useDebugValue: dd,
    useDeferredValue: function(c) {
      var p = Fs();
      return vu(p, Ht.memoizedState, c);
    },
    useTransition: function() {
      var c = Zd(Af)[0], p = Fs().memoizedState;
      return [c, p];
    },
    useMutableSource: Yl,
    useSyncExternalStore: tp,
    useId: ii,
    unstable_isNewReconciler: !1
  }, H = { readContext: Qi, useCallback: Ms, useContext: Qi, useEffect: Bc, useImperativeHandle: mu, useInsertionEffect: cd, useLayoutEffect: Yo, useMemo: ks, useReducer: $s, useRef: Df, useState: function() {
    return $s(Af);
  }, useDebugValue: dd, useDeferredValue: function(c) {
    var p = Fs();
    return Ht === null ? p.memoizedState = c : vu(p, Ht.memoizedState, c);
  }, useTransition: function() {
    var c = $s(Af)[0], p = Fs().memoizedState;
    return [c, p];
  }, useMutableSource: Yl, useSyncExternalStore: tp, useId: ii, unstable_isNewReconciler: !1 };
  function q(c, p) {
    try {
      var E = "", O = p;
      do
        E += st(O), O = O.return;
      while (O);
      var G = E;
    } catch (Q) {
      G = `
Error generating stack: ` + Q.message + `
` + Q.stack;
    }
    return { value: c, source: p, stack: G, digest: null };
  }
  function te(c, p, E) {
    return { value: c, source: null, stack: E != null ? E : null, digest: p != null ? p : null };
  }
  function Ae(c, p) {
    try {
      console.error(p.value);
    } catch (E) {
      setTimeout(function() {
        throw E;
      });
    }
  }
  var Ke = typeof WeakMap == "function" ? WeakMap : Map;
  function kt(c, p, E) {
    E = ns(-1, E), E.tag = 3, E.payload = { element: null };
    var O = p.value;
    return E.callback = function() {
      vg || (vg = !0, qp = O), Ae(c, p);
    }, E;
  }
  function cn(c, p, E) {
    E = ns(-1, E), E.tag = 3;
    var O = c.type.getDerivedStateFromError;
    if (typeof O == "function") {
      var G = p.value;
      E.payload = function() {
        return O(G);
      }, E.callback = function() {
        Ae(c, p);
      };
    }
    var Q = c.stateNode;
    return Q !== null && typeof Q.componentDidCatch == "function" && (E.callback = function() {
      Ae(c, p), typeof O != "function" && (Kd === null ? Kd = /* @__PURE__ */ new Set([this]) : Kd.add(this));
      var le = p.stack;
      this.componentDidCatch(p.value, { componentStack: le !== null ? le : "" });
    }), E;
  }
  function bn(c, p, E) {
    var O = c.pingCache;
    if (O === null) {
      O = c.pingCache = new Ke();
      var G = /* @__PURE__ */ new Set();
      O.set(p, G);
    } else
      G = O.get(p), G === void 0 && (G = /* @__PURE__ */ new Set(), O.set(p, G));
    G.has(E) || (G.add(E), c = Ty.bind(null, c, p, E), p.then(c, c));
  }
  function wr(c) {
    do {
      var p;
      if ((p = c.tag === 13) && (p = c.memoizedState, p = p !== null ? p.dehydrated !== null : !0), p)
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function ur(c, p, E, O, G) {
    return (c.mode & 1) === 0 ? (c === p ? c.flags |= 65536 : (c.flags |= 128, E.flags |= 131072, E.flags &= -52805, E.tag === 1 && (E.alternate === null ? E.tag = 17 : (p = ns(-1, 1), p.tag = 2, wf(E, p, 1))), E.lanes |= 1), c) : (c.flags |= 65536, c.lanes = G, c);
  }
  var _a = I.ReactCurrentOwner, Tn = !1;
  function Li(c, p, E, O) {
    p.child = c === null ? Qd(p, null, E, O) : Ef(p, c.child, E, O);
  }
  function ms(c, p, E, O, G) {
    E = E.render;
    var Q = p.ref;
    return wn(p, G), O = Cf(c, p, E, O, Q, G), E = Rf(), c !== null && !Tn ? (p.updateQueue = c.updateQueue, p.flags &= -2053, c.lanes &= ~G, qo(c, p, G)) : (ga && E && wh(p), p.flags |= 1, Li(c, p, O, G), p.child);
  }
  function dt(c, p, E, O, G) {
    if (c === null) {
      var Q = E.type;
      return typeof Q == "function" && !Av(Q) && Q.defaultProps === void 0 && E.compare === null && E.defaultProps === void 0 ? (p.tag = 15, p.type = Q, Qe(c, p, Q, O, G)) : (c = Lh(E.type, null, O, p, p.mode, G), c.ref = p.ref, c.return = p, p.child = c);
    }
    if (Q = c.child, (c.lanes & G) === 0) {
      var le = Q.memoizedProps;
      if (E = E.compare, E = E !== null ? E : Mn, E(le, O) && c.ref === p.ref)
        return qo(c, p, G);
    }
    return p.flags |= 1, c = ku(Q, O), c.ref = p.ref, c.return = p, p.child = c;
  }
  function Qe(c, p, E, O, G) {
    if (c !== null) {
      var Q = c.memoizedProps;
      if (Mn(Q, O) && c.ref === p.ref)
        if (Tn = !1, p.pendingProps = O = Q, (c.lanes & G) !== 0)
          (c.flags & 131072) !== 0 && (Tn = !0);
        else
          return p.lanes = c.lanes, qo(c, p, G);
    }
    return Wn(c, p, E, O, G);
  }
  function At(c, p, E) {
    var O = p.pendingProps, G = O.children, Q = c !== null ? c.memoizedState : null;
    if (O.mode === "hidden")
      if ((p.mode & 1) === 0)
        p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, zi(Hm, Hc), Hc |= E;
      else {
        if ((E & 1073741824) === 0)
          return c = Q !== null ? Q.baseLanes | E : E, p.lanes = p.childLanes = 1073741824, p.memoizedState = { baseLanes: c, cachePool: null, transitions: null }, p.updateQueue = null, zi(Hm, Hc), Hc |= c, null;
        p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, O = Q !== null ? Q.baseLanes : E, zi(Hm, Hc), Hc |= O;
      }
    else
      Q !== null ? (O = Q.baseLanes | E, p.memoizedState = null) : O = E, zi(Hm, Hc), Hc |= O;
    return Li(c, p, G, E), p.child;
  }
  function qt(c, p) {
    var E = p.ref;
    (c === null && E !== null || c !== null && c.ref !== E) && (p.flags |= 512, p.flags |= 2097152);
  }
  function Wn(c, p, E, O, G) {
    var Q = Ia(E) ? es : Rr.current;
    return Q = Nl(p, Q), wn(p, G), E = Cf(c, p, E, O, Q, G), O = Rf(), c !== null && !Tn ? (p.updateQueue = c.updateQueue, p.flags &= -2053, c.lanes &= ~G, qo(c, p, G)) : (ga && O && wh(p), p.flags |= 1, Li(c, p, E, G), p.child);
  }
  function Xr(c, p, E, O, G) {
    if (Ia(E)) {
      var Q = !0;
      Ho(p);
    } else
      Q = !1;
    if (wn(p, G), p.stateNode === null)
      Xo(c, p), Xd(p, E, O), cc(p, E, O, G), O = !0;
    else if (c === null) {
      var le = p.stateNode, Le = p.memoizedProps;
      le.props = Le;
      var Ve = le.context, Ct = E.contextType;
      typeof Ct == "object" && Ct !== null ? Ct = Qi(Ct) : (Ct = Ia(E) ? es : Rr.current, Ct = Nl(p, Ct));
      var un = E.getDerivedStateFromProps, ln = typeof un == "function" || typeof le.getSnapshotBeforeUpdate == "function";
      ln || typeof le.UNSAFE_componentWillReceiveProps != "function" && typeof le.componentWillReceiveProps != "function" || (Le !== O || Ve !== Ct) && zc(p, le, O, Ct), ts = !1;
      var nn = p.memoizedState;
      le.state = nn, Ra(p, O, le, G), Ve = p.memoizedState, Le !== O || nn !== Ve || hs.current || ts ? (typeof un == "function" && (Hl(p, E, un, O), Ve = p.memoizedState), (Le = ts || ws(p, E, Le, O, nn, Ve, Ct)) ? (ln || typeof le.UNSAFE_componentWillMount != "function" && typeof le.componentWillMount != "function" || (typeof le.componentWillMount == "function" && le.componentWillMount(), typeof le.UNSAFE_componentWillMount == "function" && le.UNSAFE_componentWillMount()), typeof le.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof le.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = O, p.memoizedState = Ve), le.props = O, le.state = Ve, le.context = Ct, O = Le) : (typeof le.componentDidMount == "function" && (p.flags |= 4194308), O = !1);
    } else {
      le = p.stateNode, xa(c, p), Le = p.memoizedProps, Ct = p.type === p.elementType ? Le : du(p.type, Le), le.props = Ct, ln = p.pendingProps, nn = le.context, Ve = E.contextType, typeof Ve == "object" && Ve !== null ? Ve = Qi(Ve) : (Ve = Ia(E) ? es : Rr.current, Ve = Nl(p, Ve));
      var kn = E.getDerivedStateFromProps;
      (un = typeof kn == "function" || typeof le.getSnapshotBeforeUpdate == "function") || typeof le.UNSAFE_componentWillReceiveProps != "function" && typeof le.componentWillReceiveProps != "function" || (Le !== ln || nn !== Ve) && zc(p, le, O, Ve), ts = !1, nn = p.memoizedState, le.state = nn, Ra(p, O, le, G);
      var qn = p.memoizedState;
      Le !== ln || nn !== qn || hs.current || ts ? (typeof kn == "function" && (Hl(p, E, kn, O), qn = p.memoizedState), (Ct = ts || ws(p, E, Ct, O, nn, qn, Ve) || !1) ? (un || typeof le.UNSAFE_componentWillUpdate != "function" && typeof le.componentWillUpdate != "function" || (typeof le.componentWillUpdate == "function" && le.componentWillUpdate(O, qn, Ve), typeof le.UNSAFE_componentWillUpdate == "function" && le.UNSAFE_componentWillUpdate(O, qn, Ve)), typeof le.componentDidUpdate == "function" && (p.flags |= 4), typeof le.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof le.componentDidUpdate != "function" || Le === c.memoizedProps && nn === c.memoizedState || (p.flags |= 4), typeof le.getSnapshotBeforeUpdate != "function" || Le === c.memoizedProps && nn === c.memoizedState || (p.flags |= 1024), p.memoizedProps = O, p.memoizedState = qn), le.props = O, le.state = qn, le.context = Ve, O = Ct) : (typeof le.componentDidUpdate != "function" || Le === c.memoizedProps && nn === c.memoizedState || (p.flags |= 4), typeof le.getSnapshotBeforeUpdate != "function" || Le === c.memoizedProps && nn === c.memoizedState || (p.flags |= 1024), O = !1);
    }
    return Er(c, p, E, O, Q, G);
  }
  function Er(c, p, E, O, G, Q) {
    qt(c, p);
    var le = (p.flags & 128) !== 0;
    if (!O && !le)
      return G && Sv(p, E, !1), qo(c, p, Q);
    O = p.stateNode, _a.current = p;
    var Le = le && typeof E.getDerivedStateFromError != "function" ? null : O.render();
    return p.flags |= 1, c !== null && le ? (p.child = Ef(p, c.child, null, Q), p.child = Ef(p, null, Le, Q)) : Li(c, p, Le, Q), p.memoizedState = O.state, G && Sv(p, E, !0), p.child;
  }
  function Ar(c) {
    var p = c.stateNode;
    p.pendingContext ? _f(c, p.pendingContext, p.pendingContext !== p.context) : p.context && _f(c, p.context, !1), Eh(c, p.containerInfo);
  }
  function Va(c, p, E, O, G) {
    return fa(), Uu(G), p.flags |= 256, Li(c, p, E, O), p.child;
  }
  var $r = { dehydrated: null, treeContext: null, retryLane: 0 };
  function hc(c) {
    return { baseLanes: c, cachePool: null, transitions: null };
  }
  function hd(c, p, E) {
    var O = p.pendingProps, G = fr.current, Q = !1, le = (p.flags & 128) !== 0, Le;
    if ((Le = le) || (Le = c !== null && c.memoizedState === null ? !1 : (G & 2) !== 0), Le ? (Q = !0, p.flags &= -129) : (c === null || c.memoizedState !== null) && (G |= 1), zi(fr, G & 1), c === null)
      return Vo(p), c = p.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? ((p.mode & 1) === 0 ? p.lanes = 1 : c.data === "$!" ? p.lanes = 8 : p.lanes = 1073741824, null) : (le = O.children, c = O.fallback, Q ? (O = p.mode, Q = p.child, le = { mode: "hidden", children: le }, (O & 1) === 0 && Q !== null ? (Q.childLanes = 0, Q.pendingProps = le) : Q = mp(le, O, 0, null), c = Jp(c, O, E, null), Q.return = p, c.return = p, Q.sibling = c, p.child = Q, p.child.memoizedState = hc(E), p.memoizedState = $r, c) : np(p, le));
    if (G = c.memoizedState, G !== null && (Le = G.dehydrated, Le !== null))
      return Gp(c, p, le, O, Le, G, E);
    if (Q) {
      Q = O.fallback, le = p.mode, G = c.child, Le = G.sibling;
      var Ve = { mode: "hidden", children: O.children };
      return (le & 1) === 0 && p.child !== G ? (O = p.child, O.childLanes = 0, O.pendingProps = Ve, p.deletions = null) : (O = ku(G, Ve), O.subtreeFlags = G.subtreeFlags & 14680064), Le !== null ? Q = ku(Le, Q) : (Q = Jp(Q, le, E, null), Q.flags |= 2), Q.return = p, O.return = p, O.sibling = Q, p.child = O, O = Q, Q = p.child, le = c.child.memoizedState, le = le === null ? hc(E) : { baseLanes: le.baseLanes | E, cachePool: null, transitions: le.transitions }, Q.memoizedState = le, Q.childLanes = c.childLanes & ~E, p.memoizedState = $r, O;
    }
    return Q = c.child, c = Q.sibling, O = ku(Q, { mode: "visible", children: O.children }), (p.mode & 1) === 0 && (O.lanes = E), O.return = p, O.sibling = null, c !== null && (E = p.deletions, E === null ? (p.deletions = [c], p.flags |= 16) : E.push(c)), p.child = O, p.memoizedState = null, O;
  }
  function np(c, p) {
    return p = mp({ mode: "visible", children: p }, c.mode, 0, null), p.return = c, c.child = p;
  }
  function gr(c, p, E, O) {
    return O !== null && Uu(O), Ef(p, c.child, null, E), c = np(p, p.pendingProps.children), c.flags |= 2, p.memoizedState = null, c;
  }
  function Gp(c, p, E, O, G, Q, le) {
    if (E)
      return p.flags & 256 ? (p.flags &= -257, O = te(Error(t(422))), gr(c, p, le, O)) : p.memoizedState !== null ? (p.child = c.child, p.flags |= 128, null) : (Q = O.fallback, G = p.mode, O = mp({ mode: "visible", children: O.children }, G, 0, null), Q = Jp(Q, G, le, null), Q.flags |= 2, O.return = p, Q.return = p, O.sibling = Q, p.child = O, (p.mode & 1) !== 0 && Ef(p, c.child, null, le), p.child.memoizedState = hc(le), p.memoizedState = $r, Q);
    if ((p.mode & 1) === 0)
      return gr(c, p, le, null);
    if (G.data === "$!") {
      if (O = G.nextSibling && G.nextSibling.dataset, O)
        var Le = O.dgst;
      return O = Le, Q = Error(t(419)), O = te(Q, O, void 0), gr(c, p, le, O);
    }
    if (Le = (le & c.childLanes) !== 0, Tn || Le) {
      if (O = ea, O !== null) {
        switch (le & -le) {
          case 4:
            G = 2;
            break;
          case 16:
            G = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            G = 32;
            break;
          case 536870912:
            G = 268435456;
            break;
          default:
            G = 0;
        }
        G = (G & (O.suspendedLanes | le)) !== 0 ? 0 : G, G !== 0 && G !== Q.retryLane && (Q.retryLane = G, Wo(c, G), Sl(O, c, G, -1));
      }
      return Ey(), O = te(Error(t(421))), gr(c, p, le, O);
    }
    return G.data === "$?" ? (p.flags |= 128, p.child = c.child, p = N0.bind(null, c), G._reactRetry = p, null) : (c = Q.treeContext, gl = zl(G.nextSibling), bs = p, ga = !0, fu = null, c !== null && (Js[ps++] = pn, Js[ps++] = kl, Js[ps++] = Uc, pn = c.id, kl = c.overflow, Uc = p), p = np(p, O.children), p.flags |= 4096, p);
  }
  function km(c, p, E) {
    c.lanes |= p;
    var O = c.alternate;
    O !== null && (O.lanes |= p), Hi(c.return, p, E);
  }
  function Of(c, p, E, O, G) {
    var Q = c.memoizedState;
    Q === null ? c.memoizedState = { isBackwards: p, rendering: null, renderingStartTime: 0, last: O, tail: E, tailMode: G } : (Q.isBackwards = p, Q.rendering = null, Q.renderingStartTime = 0, Q.last = O, Q.tail = E, Q.tailMode = G);
  }
  function dg(c, p, E) {
    var O = p.pendingProps, G = O.revealOrder, Q = O.tail;
    if (Li(c, p, O.children, E), O = fr.current, (O & 2) !== 0)
      O = O & 1 | 2, p.flags |= 128;
    else {
      if (c !== null && (c.flags & 128) !== 0)
        e:
          for (c = p.child; c !== null; ) {
            if (c.tag === 13)
              c.memoizedState !== null && km(c, E, p);
            else if (c.tag === 19)
              km(c, E, p);
            else if (c.child !== null) {
              c.child.return = c, c = c.child;
              continue;
            }
            if (c === p)
              break e;
            for (; c.sibling === null; ) {
              if (c.return === null || c.return === p)
                break e;
              c = c.return;
            }
            c.sibling.return = c.return, c = c.sibling;
          }
      O &= 1;
    }
    if (zi(fr, O), (p.mode & 1) === 0)
      p.memoizedState = null;
    else
      switch (G) {
        case "forwards":
          for (E = p.child, G = null; E !== null; )
            c = E.alternate, c !== null && fi(c) === null && (G = E), E = E.sibling;
          E = G, E === null ? (G = p.child, p.child = null) : (G = E.sibling, E.sibling = null), Of(p, !1, G, E, Q);
          break;
        case "backwards":
          for (E = null, G = p.child, p.child = null; G !== null; ) {
            if (c = G.alternate, c !== null && fi(c) === null) {
              p.child = G;
              break;
            }
            c = G.sibling, G.sibling = E, E = G, G = c;
          }
          Of(p, !0, E, null, Q);
          break;
        case "together":
          Of(p, !1, null, null, void 0);
          break;
        default:
          p.memoizedState = null;
      }
    return p.child;
  }
  function Xo(c, p) {
    (p.mode & 1) === 0 && c !== null && (c.alternate = null, p.alternate = null, p.flags |= 2);
  }
  function qo(c, p, E) {
    if (c !== null && (p.dependencies = c.dependencies), vd |= p.lanes, (E & p.childLanes) === 0)
      return null;
    if (c !== null && p.child !== c.child)
      throw Error(t(153));
    if (p.child !== null) {
      for (c = p.child, E = ku(c, c.pendingProps), p.child = E, E.return = p; c.sibling !== null; )
        c = c.sibling, E = E.sibling = ku(c, c.pendingProps), E.return = p;
      E.sibling = null;
    }
    return p.child;
  }
  function rs(c, p, E) {
    switch (p.tag) {
      case 3:
        Ar(p), fa();
        break;
      case 5:
        hr(p);
        break;
      case 1:
        Ia(p.type) && Ho(p);
        break;
      case 4:
        Eh(p, p.stateNode.containerInfo);
        break;
      case 10:
        var O = p.type._context, G = p.memoizedProps.value;
        zi(Bl, O._currentValue), O._currentValue = G;
        break;
      case 13:
        if (O = p.memoizedState, O !== null)
          return O.dehydrated !== null ? (zi(fr, fr.current & 1), p.flags |= 128, null) : (E & p.child.childLanes) !== 0 ? hd(c, p, E) : (zi(fr, fr.current & 1), c = qo(c, p, E), c !== null ? c.sibling : null);
        zi(fr, fr.current & 1);
        break;
      case 19:
        if (O = (E & p.childLanes) !== 0, (c.flags & 128) !== 0) {
          if (O)
            return dg(c, p, E);
          p.flags |= 128;
        }
        if (G = p.memoizedState, G !== null && (G.rendering = null, G.tail = null, G.lastEffect = null), zi(fr, fr.current), O)
          break;
        return null;
      case 22:
      case 23:
        return p.lanes = 0, At(c, p, E);
    }
    return qo(c, p, E);
  }
  var Wp, Mh, pc, to;
  Wp = function(c, p) {
    for (var E = p.child; E !== null; ) {
      if (E.tag === 5 || E.tag === 6)
        c.appendChild(E.stateNode);
      else if (E.tag !== 4 && E.child !== null) {
        E.child.return = E, E = E.child;
        continue;
      }
      if (E === p)
        break;
      for (; E.sibling === null; ) {
        if (E.return === null || E.return === p)
          return;
        E = E.return;
      }
      E.sibling.return = E.return, E = E.sibling;
    }
  }, Mh = function() {
  }, pc = function(c, p, E, O) {
    var G = c.memoizedProps;
    if (G !== O) {
      c = p.stateNode, Wl(Vl.current);
      var Q = null;
      switch (E) {
        case "input":
          G = mt(c, G), O = mt(c, O), Q = [];
          break;
        case "select":
          G = ue({}, G, { value: void 0 }), O = ue({}, O, { value: void 0 }), Q = [];
          break;
        case "textarea":
          G = Me(c, G), O = Me(c, O), Q = [];
          break;
        default:
          typeof G.onClick != "function" && typeof O.onClick == "function" && (c.onclick = bh);
      }
      hn(E, O);
      var le;
      E = null;
      for (Ct in G)
        if (!O.hasOwnProperty(Ct) && G.hasOwnProperty(Ct) && G[Ct] != null)
          if (Ct === "style") {
            var Le = G[Ct];
            for (le in Le)
              Le.hasOwnProperty(le) && (E || (E = {}), E[le] = "");
          } else
            Ct !== "dangerouslySetInnerHTML" && Ct !== "children" && Ct !== "suppressContentEditableWarning" && Ct !== "suppressHydrationWarning" && Ct !== "autoFocus" && (i.hasOwnProperty(Ct) ? Q || (Q = []) : (Q = Q || []).push(Ct, null));
      for (Ct in O) {
        var Ve = O[Ct];
        if (Le = G != null ? G[Ct] : void 0, O.hasOwnProperty(Ct) && Ve !== Le && (Ve != null || Le != null))
          if (Ct === "style")
            if (Le) {
              for (le in Le)
                !Le.hasOwnProperty(le) || Ve && Ve.hasOwnProperty(le) || (E || (E = {}), E[le] = "");
              for (le in Ve)
                Ve.hasOwnProperty(le) && Le[le] !== Ve[le] && (E || (E = {}), E[le] = Ve[le]);
            } else
              E || (Q || (Q = []), Q.push(
                Ct,
                E
              )), E = Ve;
          else
            Ct === "dangerouslySetInnerHTML" ? (Ve = Ve ? Ve.__html : void 0, Le = Le ? Le.__html : void 0, Ve != null && Le !== Ve && (Q = Q || []).push(Ct, Ve)) : Ct === "children" ? typeof Ve != "string" && typeof Ve != "number" || (Q = Q || []).push(Ct, "" + Ve) : Ct !== "suppressContentEditableWarning" && Ct !== "suppressHydrationWarning" && (i.hasOwnProperty(Ct) ? (Ve != null && Ct === "onScroll" && Ir("scroll", c), Q || Le === Ve || (Q = [])) : (Q = Q || []).push(Ct, Ve));
      }
      E && (Q = Q || []).push("style", E);
      var Ct = Q;
      (p.updateQueue = Ct) && (p.flags |= 4);
    }
  }, to = function(c, p, E, O) {
    E !== O && (p.flags |= 4);
  };
  function rp(c, p) {
    if (!ga)
      switch (c.tailMode) {
        case "hidden":
          p = c.tail;
          for (var E = null; p !== null; )
            p.alternate !== null && (E = p), p = p.sibling;
          E === null ? c.tail = null : E.sibling = null;
          break;
        case "collapsed":
          E = c.tail;
          for (var O = null; E !== null; )
            E.alternate !== null && (O = E), E = E.sibling;
          O === null ? p || c.tail === null ? c.tail = null : c.tail.sibling = null : O.sibling = null;
      }
  }
  function yl(c) {
    var p = c.alternate !== null && c.alternate.child === c.child, E = 0, O = 0;
    if (p)
      for (var G = c.child; G !== null; )
        E |= G.lanes | G.childLanes, O |= G.subtreeFlags & 14680064, O |= G.flags & 14680064, G.return = c, G = G.sibling;
    else
      for (G = c.child; G !== null; )
        E |= G.lanes | G.childLanes, O |= G.subtreeFlags, O |= G.flags, G.return = c, G = G.sibling;
    return c.subtreeFlags |= O, c.childLanes = E, p;
  }
  function xy(c, p, E) {
    var O = p.pendingProps;
    switch (Ou(p), p.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return yl(p), null;
      case 1:
        return Ia(p.type) && Fl(), yl(p), null;
      case 3:
        return O = p.stateNode, fc(), bi(hs), bi(Rr), jl(), O.pendingContext && (O.context = O.pendingContext, O.pendingContext = null), (c === null || c.child === null) && (rl(p) ? p.flags |= 4 : c === null || c.memoizedState.isDehydrated && (p.flags & 256) === 0 || (p.flags |= 1024, fu !== null && (Qp(fu), fu = null))), Mh(c, p), yl(p), null;
      case 5:
        Yr(p);
        var G = Wl(ud.current);
        if (E = p.type, c !== null && p.stateNode != null)
          pc(c, p, E, O, G), c.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152);
        else {
          if (!O) {
            if (p.stateNode === null)
              throw Error(t(166));
            return yl(p), null;
          }
          if (c = Wl(Vl.current), rl(p)) {
            O = p.stateNode, E = p.type;
            var Q = p.memoizedProps;
            switch (O[Os] = p, O[Pu] = Q, c = (p.mode & 1) !== 0, E) {
              case "dialog":
                Ir("cancel", O), Ir("close", O);
                break;
              case "iframe":
              case "object":
              case "embed":
                Ir("load", O);
                break;
              case "video":
              case "audio":
                for (G = 0; G < ic.length; G++)
                  Ir(ic[G], O);
                break;
              case "source":
                Ir("error", O);
                break;
              case "img":
              case "image":
              case "link":
                Ir(
                  "error",
                  O
                ), Ir("load", O);
                break;
              case "details":
                Ir("toggle", O);
                break;
              case "input":
                vt(O, Q), Ir("invalid", O);
                break;
              case "select":
                O._wrapperState = { wasMultiple: !!Q.multiple }, Ir("invalid", O);
                break;
              case "textarea":
                oe(O, Q), Ir("invalid", O);
            }
            hn(E, Q), G = null;
            for (var le in Q)
              if (Q.hasOwnProperty(le)) {
                var Le = Q[le];
                le === "children" ? typeof Le == "string" ? O.textContent !== Le && (Q.suppressHydrationWarning !== !0 && Vd(O.textContent, Le, c), G = ["children", Le]) : typeof Le == "number" && O.textContent !== "" + Le && (Q.suppressHydrationWarning !== !0 && Vd(
                  O.textContent,
                  Le,
                  c
                ), G = ["children", "" + Le]) : i.hasOwnProperty(le) && Le != null && le === "onScroll" && Ir("scroll", O);
              }
            switch (E) {
              case "input":
                Ot(O), ft(O, Q, !0);
                break;
              case "textarea":
                Ot(O), lt(O);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof Q.onClick == "function" && (O.onclick = bh);
            }
            O = G, p.updateQueue = O, O !== null && (p.flags |= 4);
          } else {
            le = G.nodeType === 9 ? G : G.ownerDocument, c === "http://www.w3.org/1999/xhtml" && (c = zt(E)), c === "http://www.w3.org/1999/xhtml" ? E === "script" ? (c = le.createElement("div"), c.innerHTML = "<script><\/script>", c = c.removeChild(c.firstChild)) : typeof O.is == "string" ? c = le.createElement(E, { is: O.is }) : (c = le.createElement(E), E === "select" && (le = c, O.multiple ? le.multiple = !0 : O.size && (le.size = O.size))) : c = le.createElementNS(c, E), c[Os] = p, c[Pu] = O, Wp(c, p, !1, !1), p.stateNode = c;
            e: {
              switch (le = De(E, O), E) {
                case "dialog":
                  Ir("cancel", c), Ir("close", c), G = O;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Ir("load", c), G = O;
                  break;
                case "video":
                case "audio":
                  for (G = 0; G < ic.length; G++)
                    Ir(ic[G], c);
                  G = O;
                  break;
                case "source":
                  Ir("error", c), G = O;
                  break;
                case "img":
                case "image":
                case "link":
                  Ir(
                    "error",
                    c
                  ), Ir("load", c), G = O;
                  break;
                case "details":
                  Ir("toggle", c), G = O;
                  break;
                case "input":
                  vt(c, O), G = mt(c, O), Ir("invalid", c);
                  break;
                case "option":
                  G = O;
                  break;
                case "select":
                  c._wrapperState = { wasMultiple: !!O.multiple }, G = ue({}, O, { value: void 0 }), Ir("invalid", c);
                  break;
                case "textarea":
                  oe(c, O), G = Me(c, O), Ir("invalid", c);
                  break;
                default:
                  G = O;
              }
              hn(E, G), Le = G;
              for (Q in Le)
                if (Le.hasOwnProperty(Q)) {
                  var Ve = Le[Q];
                  Q === "style" ? it(c, Ve) : Q === "dangerouslySetInnerHTML" ? (Ve = Ve ? Ve.__html : void 0, Ve != null && tt(c, Ve)) : Q === "children" ? typeof Ve == "string" ? (E !== "textarea" || Ve !== "") && rn(c, Ve) : typeof Ve == "number" && rn(c, "" + Ve) : Q !== "suppressContentEditableWarning" && Q !== "suppressHydrationWarning" && Q !== "autoFocus" && (i.hasOwnProperty(Q) ? Ve != null && Q === "onScroll" && Ir("scroll", c) : Ve != null && V(c, Q, Ve, le));
                }
              switch (E) {
                case "input":
                  Ot(c), ft(c, O, !1);
                  break;
                case "textarea":
                  Ot(c), lt(c);
                  break;
                case "option":
                  O.value != null && c.setAttribute("value", "" + rt(O.value));
                  break;
                case "select":
                  c.multiple = !!O.multiple, Q = O.value, Q != null ? Mt(c, !!O.multiple, Q, !1) : O.defaultValue != null && Mt(
                    c,
                    !!O.multiple,
                    O.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof G.onClick == "function" && (c.onclick = bh);
              }
              switch (E) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  O = !!O.autoFocus;
                  break e;
                case "img":
                  O = !0;
                  break e;
                default:
                  O = !1;
              }
            }
            O && (p.flags |= 4);
          }
          p.ref !== null && (p.flags |= 512, p.flags |= 2097152);
        }
        return yl(p), null;
      case 6:
        if (c && p.stateNode != null)
          to(c, p, c.memoizedProps, O);
        else {
          if (typeof O != "string" && p.stateNode === null)
            throw Error(t(166));
          if (E = Wl(ud.current), Wl(Vl.current), rl(p)) {
            if (O = p.stateNode, E = p.memoizedProps, O[Os] = p, (Q = O.nodeValue !== E) && (c = bs, c !== null))
              switch (c.tag) {
                case 3:
                  Vd(O.nodeValue, E, (c.mode & 1) !== 0);
                  break;
                case 5:
                  c.memoizedProps.suppressHydrationWarning !== !0 && Vd(O.nodeValue, E, (c.mode & 1) !== 0);
              }
            Q && (p.flags |= 4);
          } else
            O = (E.nodeType === 9 ? E : E.ownerDocument).createTextNode(O), O[Os] = p, p.stateNode = O;
        }
        return yl(p), null;
      case 13:
        if (bi(fr), O = p.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
          if (ga && gl !== null && (p.mode & 1) !== 0 && (p.flags & 128) === 0)
            zs(), fa(), p.flags |= 98560, Q = !1;
          else if (Q = rl(p), O !== null && O.dehydrated !== null) {
            if (c === null) {
              if (!Q)
                throw Error(t(318));
              if (Q = p.memoizedState, Q = Q !== null ? Q.dehydrated : null, !Q)
                throw Error(t(317));
              Q[Os] = p;
            } else
              fa(), (p.flags & 128) === 0 && (p.memoizedState = null), p.flags |= 4;
            yl(p), Q = !1;
          } else
            fu !== null && (Qp(fu), fu = null), Q = !0;
          if (!Q)
            return p.flags & 65536 ? p : null;
        }
        return (p.flags & 128) !== 0 ? (p.lanes = E, p) : (O = O !== null, O !== (c !== null && c.memoizedState !== null) && O && (p.child.flags |= 8192, (p.mode & 1) !== 0 && (c === null || (fr.current & 1) !== 0 ? sl === 0 && (sl = 3) : Ey())), p.updateQueue !== null && (p.flags |= 4), yl(p), null);
      case 4:
        return fc(), Mh(c, p), c === null && nl(p.stateNode.containerInfo), yl(p), null;
      case 10:
        return da(p.type._context), yl(p), null;
      case 17:
        return Ia(p.type) && Fl(), yl(p), null;
      case 19:
        if (bi(fr), Q = p.memoizedState, Q === null)
          return yl(p), null;
        if (O = (p.flags & 128) !== 0, le = Q.rendering, le === null)
          if (O)
            rp(Q, !1);
          else {
            if (sl !== 0 || c !== null && (c.flags & 128) !== 0)
              for (c = p.child; c !== null; ) {
                if (le = fi(c), le !== null) {
                  for (p.flags |= 128, rp(Q, !1), O = le.updateQueue, O !== null && (p.updateQueue = O, p.flags |= 4), p.subtreeFlags = 0, O = E, E = p.child; E !== null; )
                    Q = E, c = O, Q.flags &= 14680066, le = Q.alternate, le === null ? (Q.childLanes = 0, Q.lanes = c, Q.child = null, Q.subtreeFlags = 0, Q.memoizedProps = null, Q.memoizedState = null, Q.updateQueue = null, Q.dependencies = null, Q.stateNode = null) : (Q.childLanes = le.childLanes, Q.lanes = le.lanes, Q.child = le.child, Q.subtreeFlags = 0, Q.deletions = null, Q.memoizedProps = le.memoizedProps, Q.memoizedState = le.memoizedState, Q.updateQueue = le.updateQueue, Q.type = le.type, c = le.dependencies, Q.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }), E = E.sibling;
                  return zi(fr, fr.current & 1 | 2), p.child;
                }
                c = c.sibling;
              }
            Q.tail !== null && $t() > lp && (p.flags |= 128, O = !0, rp(Q, !1), p.lanes = 4194304);
          }
        else {
          if (!O)
            if (c = fi(le), c !== null) {
              if (p.flags |= 128, O = !0, E = c.updateQueue, E !== null && (p.updateQueue = E, p.flags |= 4), rp(Q, !0), Q.tail === null && Q.tailMode === "hidden" && !le.alternate && !ga)
                return yl(p), null;
            } else
              2 * $t() - Q.renderingStartTime > lp && E !== 1073741824 && (p.flags |= 128, O = !0, rp(Q, !1), p.lanes = 4194304);
          Q.isBackwards ? (le.sibling = p.child, p.child = le) : (E = Q.last, E !== null ? E.sibling = le : p.child = le, Q.last = le);
        }
        return Q.tail !== null ? (p = Q.tail, Q.rendering = p, Q.tail = p.sibling, Q.renderingStartTime = $t(), p.sibling = null, E = fr.current, zi(fr, O ? E & 1 | 2 : E & 1), p) : (yl(p), null);
      case 22:
      case 23:
        return yg(), O = p.memoizedState !== null, c !== null && c.memoizedState !== null !== O && (p.flags |= 8192), O && (p.mode & 1) !== 0 ? (Hc & 1073741824) !== 0 && (yl(p), p.subtreeFlags & 6 && (p.flags |= 8192)) : yl(p), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, p.tag));
  }
  function hg(c, p) {
    switch (Ou(p), p.tag) {
      case 1:
        return Ia(p.type) && Fl(), c = p.flags, c & 65536 ? (p.flags = c & -65537 | 128, p) : null;
      case 3:
        return fc(), bi(hs), bi(Rr), jl(), c = p.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (p.flags = c & -65537 | 128, p) : null;
      case 5:
        return Yr(p), null;
      case 13:
        if (bi(fr), c = p.memoizedState, c !== null && c.dehydrated !== null) {
          if (p.alternate === null)
            throw Error(t(340));
          fa();
        }
        return c = p.flags, c & 65536 ? (p.flags = c & -65537 | 128, p) : null;
      case 19:
        return bi(fr), null;
      case 4:
        return fc(), null;
      case 10:
        return da(p.type._context), null;
      case 22:
      case 23:
        return yg(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Fu = !1, Vi = !1, _v = typeof WeakSet == "function" ? WeakSet : Set, Jn = null;
  function Th(c, p) {
    var E = c.ref;
    if (E !== null)
      if (typeof E == "function")
        try {
          E(null);
        } catch (O) {
          Is(c, p, O);
        }
      else
        E.current = null;
  }
  function Im(c, p, E) {
    try {
      E();
    } catch (O) {
      Is(c, p, O);
    }
  }
  var z0 = !1;
  function jp(c, p) {
    if (xf = Ps, c = $n(), Ui(c)) {
      if ("selectionStart" in c)
        var E = { start: c.selectionStart, end: c.selectionEnd };
      else
        e: {
          E = (E = c.ownerDocument) && E.defaultView || window;
          var O = E.getSelection && E.getSelection();
          if (O && O.rangeCount !== 0) {
            E = O.anchorNode;
            var G = O.anchorOffset, Q = O.focusNode;
            O = O.focusOffset;
            try {
              E.nodeType, Q.nodeType;
            } catch {
              E = null;
              break e;
            }
            var le = 0, Le = -1, Ve = -1, Ct = 0, un = 0, ln = c, nn = null;
            t:
              for (; ; ) {
                for (var kn; ln !== E || G !== 0 && ln.nodeType !== 3 || (Le = le + G), ln !== Q || O !== 0 && ln.nodeType !== 3 || (Ve = le + O), ln.nodeType === 3 && (le += ln.nodeValue.length), (kn = ln.firstChild) !== null; )
                  nn = ln, ln = kn;
                for (; ; ) {
                  if (ln === c)
                    break t;
                  if (nn === E && ++Ct === G && (Le = le), nn === Q && ++un === O && (Ve = le), (kn = ln.nextSibling) !== null)
                    break;
                  ln = nn, nn = ln.parentNode;
                }
                ln = kn;
              }
            E = Le === -1 || Ve === -1 ? null : { start: Le, end: Ve };
          } else
            E = null;
        }
      E = E || { start: 0, end: 0 };
    } else
      E = null;
    for (Lu = { focusedElem: c, selectionRange: E }, Ps = !1, Jn = p; Jn !== null; )
      if (p = Jn, c = p.child, (p.subtreeFlags & 1028) !== 0 && c !== null)
        c.return = p, Jn = c;
      else
        for (; Jn !== null; ) {
          p = Jn;
          try {
            var qn = p.alternate;
            if ((p.flags & 1024) !== 0)
              switch (p.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (qn !== null) {
                    var rr = qn.memoizedProps, Bs = qn.memoizedState, ht = p.stateNode, Ze = ht.getSnapshotBeforeUpdate(p.elementType === p.type ? rr : du(p.type, rr), Bs);
                    ht.__reactInternalSnapshotBeforeUpdate = Ze;
                  }
                  break;
                case 3:
                  var gt = p.stateNode.containerInfo;
                  gt.nodeType === 1 ? gt.textContent = "" : gt.nodeType === 9 && gt.documentElement && gt.removeChild(gt.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (xn) {
            Is(p, p.return, xn);
          }
          if (c = p.sibling, c !== null) {
            c.return = p.return, Jn = c;
            break;
          }
          Jn = p.return;
        }
    return qn = z0, z0 = !1, qn;
  }
  function ip(c, p, E) {
    var O = p.updateQueue;
    if (O = O !== null ? O.lastEffect : null, O !== null) {
      var G = O = O.next;
      do {
        if ((G.tag & c) === c) {
          var Q = G.destroy;
          G.destroy = void 0, Q !== void 0 && Im(p, E, Q);
        }
        G = G.next;
      } while (G !== O);
    }
  }
  function Bm(c, p) {
    if (p = p.updateQueue, p = p !== null ? p.lastEffect : null, p !== null) {
      var E = p = p.next;
      do {
        if ((E.tag & c) === c) {
          var O = E.create;
          E.destroy = O();
        }
        E = E.next;
      } while (E !== p);
    }
  }
  function Sy(c) {
    var p = c.ref;
    if (p !== null) {
      var E = c.stateNode;
      switch (c.tag) {
        case 5:
          c = E;
          break;
        default:
          c = E;
      }
      typeof p == "function" ? p(c) : p.current = c;
    }
  }
  function ap(c) {
    var p = c.alternate;
    p !== null && (c.alternate = null, ap(p)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (p = c.stateNode, p !== null && (delete p[Os], delete p[Pu], delete p[ad], delete p[ve], delete p[oc])), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
  }
  function Yp(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function Xp(c) {
    e:
      for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || Yp(c.return))
            return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2 || c.child === null || c.tag === 4)
            continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2))
          return c.stateNode;
      }
  }
  function Jd(c, p, E) {
    var O = c.tag;
    if (O === 5 || O === 6)
      c = c.stateNode, p ? E.nodeType === 8 ? E.parentNode.insertBefore(c, p) : E.insertBefore(c, p) : (E.nodeType === 8 ? (p = E.parentNode, p.insertBefore(c, E)) : (p = E, p.appendChild(c)), E = E._reactRootContainer, E != null || p.onclick !== null || (p.onclick = bh));
    else if (O !== 4 && (c = c.child, c !== null))
      for (Jd(c, p, E), c = c.sibling; c !== null; )
        Jd(c, p, E), c = c.sibling;
  }
  function no(c, p, E) {
    var O = c.tag;
    if (O === 5 || O === 6)
      c = c.stateNode, p ? E.insertBefore(c, p) : E.appendChild(c);
    else if (O !== 4 && (c = c.child, c !== null))
      for (no(c, p, E), c = c.sibling; c !== null; )
        no(c, p, E), c = c.sibling;
  }
  var Gi = null, is = !1;
  function To(c, p, E) {
    for (E = E.child; E !== null; )
      xl(c, p, E), E = E.sibling;
  }
  function xl(c, p, E) {
    if (mr && typeof mr.onCommitFiberUnmount == "function")
      try {
        mr.onCommitFiberUnmount(us, E);
      } catch {
      }
    switch (E.tag) {
      case 5:
        Vi || Th(E, p);
      case 6:
        var O = Gi, G = is;
        Gi = null, To(c, p, E), Gi = O, is = G, Gi !== null && (is ? (c = Gi, E = E.stateNode, c.nodeType === 8 ? c.parentNode.removeChild(E) : c.removeChild(E)) : Gi.removeChild(E.stateNode));
        break;
      case 18:
        Gi !== null && (is ? (c = Gi, E = E.stateNode, c.nodeType === 8 ? Ac(c.parentNode, E) : c.nodeType === 1 && Ac(c, E), Ri(c)) : Ac(Gi, E.stateNode));
        break;
      case 4:
        O = Gi, G = is, Gi = E.stateNode.containerInfo, is = !0, To(c, p, E), Gi = O, is = G;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Vi && (O = E.updateQueue, O !== null && (O = O.lastEffect, O !== null))) {
          G = O = O.next;
          do {
            var Q = G, le = Q.destroy;
            Q = Q.tag, le !== void 0 && ((Q & 2) !== 0 || (Q & 4) !== 0) && Im(E, p, le), G = G.next;
          } while (G !== O);
        }
        To(c, p, E);
        break;
      case 1:
        if (!Vi && (Th(E, p), O = E.stateNode, typeof O.componentWillUnmount == "function"))
          try {
            O.props = E.memoizedProps, O.state = E.memoizedState, O.componentWillUnmount();
          } catch (Le) {
            Is(E, p, Le);
          }
        To(c, p, E);
        break;
      case 21:
        To(c, p, E);
        break;
      case 22:
        E.mode & 1 ? (Vi = (O = Vi) || E.memoizedState !== null, To(c, p, E), Vi = O) : To(c, p, E);
        break;
      default:
        To(c, p, E);
    }
  }
  function pd(c) {
    var p = c.updateQueue;
    if (p !== null) {
      c.updateQueue = null;
      var E = c.stateNode;
      E === null && (E = c.stateNode = new _v()), p.forEach(function(O) {
        var G = F0.bind(null, c, O);
        E.has(O) || (E.add(O), O.then(G, G));
      });
    }
  }
  function Uf(c, p) {
    var E = p.deletions;
    if (E !== null)
      for (var O = 0; O < E.length; O++) {
        var G = E[O];
        try {
          var Q = c, le = p, Le = le;
          e:
            for (; Le !== null; ) {
              switch (Le.tag) {
                case 5:
                  Gi = Le.stateNode, is = !1;
                  break e;
                case 3:
                  Gi = Le.stateNode.containerInfo, is = !0;
                  break e;
                case 4:
                  Gi = Le.stateNode.containerInfo, is = !0;
                  break e;
              }
              Le = Le.return;
            }
          if (Gi === null)
            throw Error(t(160));
          xl(Q, le, G), Gi = null, is = !1;
          var Ve = G.alternate;
          Ve !== null && (Ve.return = null), G.return = null;
        } catch (Ct) {
          Is(G, p, Ct);
        }
      }
    if (p.subtreeFlags & 12854)
      for (p = p.child; p !== null; )
        _y(p, c), p = p.sibling;
  }
  function _y(c, p) {
    var E = c.alternate, O = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Uf(p, c), al(c), O & 4) {
          try {
            ip(3, c, c.return), Bm(3, c);
          } catch (rr) {
            Is(c, c.return, rr);
          }
          try {
            ip(5, c, c.return);
          } catch (rr) {
            Is(c, c.return, rr);
          }
        }
        break;
      case 1:
        Uf(p, c), al(c), O & 512 && E !== null && Th(E, E.return);
        break;
      case 5:
        if (Uf(p, c), al(c), O & 512 && E !== null && Th(E, E.return), c.flags & 32) {
          var G = c.stateNode;
          try {
            rn(G, "");
          } catch (rr) {
            Is(c, c.return, rr);
          }
        }
        if (O & 4 && (G = c.stateNode, G != null)) {
          var Q = c.memoizedProps, le = E !== null ? E.memoizedProps : Q, Le = c.type, Ve = c.updateQueue;
          if (c.updateQueue = null, Ve !== null)
            try {
              Le === "input" && Q.type === "radio" && Q.name != null && bt(G, Q), De(Le, le);
              var Ct = De(Le, Q);
              for (le = 0; le < Ve.length; le += 2) {
                var un = Ve[le], ln = Ve[le + 1];
                un === "style" ? it(G, ln) : un === "dangerouslySetInnerHTML" ? tt(G, ln) : un === "children" ? rn(G, ln) : V(G, un, ln, Ct);
              }
              switch (Le) {
                case "input":
                  Qt(G, Q);
                  break;
                case "textarea":
                  je(G, Q);
                  break;
                case "select":
                  var nn = G._wrapperState.wasMultiple;
                  G._wrapperState.wasMultiple = !!Q.multiple;
                  var kn = Q.value;
                  kn != null ? Mt(G, !!Q.multiple, kn, !1) : nn !== !!Q.multiple && (Q.defaultValue != null ? Mt(
                    G,
                    !!Q.multiple,
                    Q.defaultValue,
                    !0
                  ) : Mt(G, !!Q.multiple, Q.multiple ? [] : "", !1));
              }
              G[Pu] = Q;
            } catch (rr) {
              Is(c, c.return, rr);
            }
        }
        break;
      case 6:
        if (Uf(p, c), al(c), O & 4) {
          if (c.stateNode === null)
            throw Error(t(162));
          G = c.stateNode, Q = c.memoizedProps;
          try {
            G.nodeValue = Q;
          } catch (rr) {
            Is(c, c.return, rr);
          }
        }
        break;
      case 3:
        if (Uf(p, c), al(c), O & 4 && E !== null && E.memoizedState.isDehydrated)
          try {
            Ri(p.containerInfo);
          } catch (rr) {
            Is(c, c.return, rr);
          }
        break;
      case 4:
        Uf(p, c), al(c);
        break;
      case 13:
        Uf(p, c), al(c), G = c.child, G.flags & 8192 && (Q = G.memoizedState !== null, G.stateNode.isHidden = Q, !Q || G.alternate !== null && G.alternate.memoizedState !== null || (Wm = $t())), O & 4 && pd(c);
        break;
      case 22:
        if (un = E !== null && E.memoizedState !== null, c.mode & 1 ? (Vi = (Ct = Vi) || un, Uf(p, c), Vi = Ct) : Uf(p, c), al(c), O & 8192) {
          if (Ct = c.memoizedState !== null, (c.stateNode.isHidden = Ct) && !un && (c.mode & 1) !== 0)
            for (Jn = c, un = c.child; un !== null; ) {
              for (ln = Jn = un; Jn !== null; ) {
                switch (nn = Jn, kn = nn.child, nn.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    ip(4, nn, nn.return);
                    break;
                  case 1:
                    Th(nn, nn.return);
                    var qn = nn.stateNode;
                    if (typeof qn.componentWillUnmount == "function") {
                      O = nn, E = nn.return;
                      try {
                        p = O, qn.props = p.memoizedProps, qn.state = p.memoizedState, qn.componentWillUnmount();
                      } catch (rr) {
                        Is(O, E, rr);
                      }
                    }
                    break;
                  case 5:
                    Th(nn, nn.return);
                    break;
                  case 22:
                    if (nn.memoizedState !== null) {
                      by(ln);
                      continue;
                    }
                }
                kn !== null ? (kn.return = nn, Jn = kn) : by(ln);
              }
              un = un.sibling;
            }
          e:
            for (un = null, ln = c; ; ) {
              if (ln.tag === 5) {
                if (un === null) {
                  un = ln;
                  try {
                    G = ln.stateNode, Ct ? (Q = G.style, typeof Q.setProperty == "function" ? Q.setProperty("display", "none", "important") : Q.display = "none") : (Le = ln.stateNode, Ve = ln.memoizedProps.style, le = Ve != null && Ve.hasOwnProperty("display") ? Ve.display : null, Le.style.display = Ie("display", le));
                  } catch (rr) {
                    Is(c, c.return, rr);
                  }
                }
              } else if (ln.tag === 6) {
                if (un === null)
                  try {
                    ln.stateNode.nodeValue = Ct ? "" : ln.memoizedProps;
                  } catch (rr) {
                    Is(c, c.return, rr);
                  }
              } else if ((ln.tag !== 22 && ln.tag !== 23 || ln.memoizedState === null || ln === c) && ln.child !== null) {
                ln.child.return = ln, ln = ln.child;
                continue;
              }
              if (ln === c)
                break e;
              for (; ln.sibling === null; ) {
                if (ln.return === null || ln.return === c)
                  break e;
                un === ln && (un = null), ln = ln.return;
              }
              un === ln && (un = null), ln.sibling.return = ln.return, ln = ln.sibling;
            }
        }
        break;
      case 19:
        Uf(p, c), al(c), O & 4 && pd(c);
        break;
      case 21:
        break;
      default:
        Uf(
          p,
          c
        ), al(c);
    }
  }
  function al(c) {
    var p = c.flags;
    if (p & 2) {
      try {
        e: {
          for (var E = c.return; E !== null; ) {
            if (Yp(E)) {
              var O = E;
              break e;
            }
            E = E.return;
          }
          throw Error(t(160));
        }
        switch (O.tag) {
          case 5:
            var G = O.stateNode;
            O.flags & 32 && (rn(G, ""), O.flags &= -33);
            var Q = Xp(c);
            no(c, Q, G);
            break;
          case 3:
          case 4:
            var le = O.stateNode.containerInfo, Le = Xp(c);
            Jd(c, Le, le);
            break;
          default:
            throw Error(t(161));
        }
      } catch (Ve) {
        Is(c, c.return, Ve);
      }
      c.flags &= -3;
    }
    p & 4096 && (c.flags &= -4097);
  }
  function pg(c, p, E) {
    Jn = c, ql(c);
  }
  function ql(c, p, E) {
    for (var O = (c.mode & 1) !== 0; Jn !== null; ) {
      var G = Jn, Q = G.child;
      if (G.tag === 22 && O) {
        var le = G.memoizedState !== null || Fu;
        if (!le) {
          var Le = G.alternate, Ve = Le !== null && Le.memoizedState !== null || Vi;
          Le = Fu;
          var Ct = Vi;
          if (Fu = le, (Vi = Ve) && !Ct)
            for (Jn = G; Jn !== null; )
              le = Jn, Ve = le.child, le.tag === 22 && le.memoizedState !== null ? bv(G) : Ve !== null ? (Ve.return = le, Jn = Ve) : bv(G);
          for (; Q !== null; )
            Jn = Q, ql(Q), Q = Q.sibling;
          Jn = G, Fu = Le, Vi = Ct;
        }
        md(c);
      } else
        (G.subtreeFlags & 8772) !== 0 && Q !== null ? (Q.return = G, Jn = Q) : md(c);
    }
  }
  function md(c) {
    for (; Jn !== null; ) {
      var p = Jn;
      if ((p.flags & 8772) !== 0) {
        var E = p.alternate;
        try {
          if ((p.flags & 8772) !== 0)
            switch (p.tag) {
              case 0:
              case 11:
              case 15:
                Vi || Bm(5, p);
                break;
              case 1:
                var O = p.stateNode;
                if (p.flags & 4 && !Vi)
                  if (E === null)
                    O.componentDidMount();
                  else {
                    var G = p.elementType === p.type ? E.memoizedProps : du(p.type, E.memoizedProps);
                    O.componentDidUpdate(G, E.memoizedState, O.__reactInternalSnapshotBeforeUpdate);
                  }
                var Q = p.updateQueue;
                Q !== null && Ba(p, Q, O);
                break;
              case 3:
                var le = p.updateQueue;
                if (le !== null) {
                  if (E = null, p.child !== null)
                    switch (p.child.tag) {
                      case 5:
                        E = p.child.stateNode;
                        break;
                      case 1:
                        E = p.child.stateNode;
                    }
                  Ba(p, le, E);
                }
                break;
              case 5:
                var Le = p.stateNode;
                if (E === null && p.flags & 4) {
                  E = Le;
                  var Ve = p.memoizedProps;
                  switch (p.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Ve.autoFocus && E.focus();
                      break;
                    case "img":
                      Ve.src && (E.src = Ve.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (p.memoizedState === null) {
                  var Ct = p.alternate;
                  if (Ct !== null) {
                    var un = Ct.memoizedState;
                    if (un !== null) {
                      var ln = un.dehydrated;
                      ln !== null && Ri(ln);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          Vi || p.flags & 512 && Sy(p);
        } catch (nn) {
          Is(p, p.return, nn);
        }
      }
      if (p === c) {
        Jn = null;
        break;
      }
      if (E = p.sibling, E !== null) {
        E.return = p.return, Jn = E;
        break;
      }
      Jn = p.return;
    }
  }
  function by(c) {
    for (; Jn !== null; ) {
      var p = Jn;
      if (p === c) {
        Jn = null;
        break;
      }
      var E = p.sibling;
      if (E !== null) {
        E.return = p.return, Jn = E;
        break;
      }
      Jn = p.return;
    }
  }
  function bv(c) {
    for (; Jn !== null; ) {
      var p = Jn;
      try {
        switch (p.tag) {
          case 0:
          case 11:
          case 15:
            var E = p.return;
            try {
              Bm(4, p);
            } catch (Ve) {
              Is(p, E, Ve);
            }
            break;
          case 1:
            var O = p.stateNode;
            if (typeof O.componentDidMount == "function") {
              var G = p.return;
              try {
                O.componentDidMount();
              } catch (Ve) {
                Is(p, G, Ve);
              }
            }
            var Q = p.return;
            try {
              Sy(p);
            } catch (Ve) {
              Is(p, Q, Ve);
            }
            break;
          case 5:
            var le = p.return;
            try {
              Sy(p);
            } catch (Ve) {
              Is(p, le, Ve);
            }
        }
      } catch (Ve) {
        Is(p, p.return, Ve);
      }
      if (p === c) {
        Jn = null;
        break;
      }
      var Le = p.sibling;
      if (Le !== null) {
        Le.return = p.return, Jn = Le;
        break;
      }
      Jn = p.return;
    }
  }
  var mg = Math.ceil, wv = I.ReactCurrentDispatcher, Ch = I.ReactCurrentOwner, aa = I.ReactCurrentBatchConfig, Nr = 0, ea = null, Ga = null, vs = 0, Hc = 0, Hm = Gn(0), sl = 0, Vm = null, vd = 0, Gm = 0, sp = 0, op = null, gu = null, Wm = 0, lp = 1 / 0, gd = null, vg = !1, qp = null, Kd = null, up = !1, Qo = null, cp = 0, jm = 0, Ev = null, Vc = -1, fp = 0;
  function ha() {
    return (Nr & 6) !== 0 ? $t() : Vc !== -1 ? Vc : Vc = $t();
  }
  function ro(c) {
    return (c.mode & 1) === 0 ? 1 : (Nr & 2) !== 0 && vs !== 0 ? vs & -vs : Hp.transition !== null ? (fp === 0 && (fp = Ls()), fp) : (c = ri, c !== 0 || (c = window.event, c = c === void 0 ? 16 : Qf(c.type)), c);
  }
  function Sl(c, p, E, O) {
    if (50 < jm)
      throw jm = 0, Ev = null, Error(t(185));
    au(c, E, O), ((Nr & 2) === 0 || c !== ea) && (c === ea && ((Nr & 2) === 0 && (Gm |= E), sl === 4 && yu(c, vs)), Zo(c, O), E === 1 && Nr === 0 && (p.mode & 1) === 0 && (lp = $t() + 500, bo && _s()));
  }
  function Zo(c, p) {
    var E = c.callbackNode;
    Al(c, p);
    var O = vo(c, c === ea ? vs : 0);
    if (O === 0)
      E !== null && Yi(E), c.callbackNode = null, c.callbackPriority = 0;
    else if (p = O & -O, c.callbackPriority !== p) {
      if (E != null && Yi(E), p === 1)
        c.tag === 0 ? cu(Tv.bind(null, c)) : lc(Tv.bind(null, c)), Gd(function() {
          (Nr & 6) === 0 && _s();
        }), E = null;
      else {
        switch (go(O)) {
          case 1:
            E = ls;
            break;
          case 4:
            E = Xn;
            break;
          case 16:
            E = qa;
            break;
          case 536870912:
            E = Ds;
            break;
          default:
            E = qa;
        }
        E = Wc(E, dp.bind(null, c));
      }
      c.callbackPriority = p, c.callbackNode = E;
    }
  }
  function dp(c, p) {
    if (Vc = -1, fp = 0, (Nr & 6) !== 0)
      throw Error(t(327));
    var E = c.callbackNode;
    if (Gc() && c.callbackNode !== E)
      return null;
    var O = vo(c, c === ea ? vs : 0);
    if (O === 0)
      return null;
    if ((O & 30) !== 0 || (O & c.expiredLanes) !== 0 || p)
      p = hp(c, O);
    else {
      p = O;
      var G = Nr;
      Nr |= 2;
      var Q = xg();
      (ea !== c || vs !== p) && (gd = null, lp = $t() + 500, zf(c, p));
      do
        try {
          Cv();
          break;
        } catch (Le) {
          wy(c, Le);
        }
      while (1);
      Yd(), wv.current = Q, Nr = G, Ga !== null ? p = 0 : (ea = null, vs = 0, p = sl);
    }
    if (p !== 0) {
      if (p === 2 && (G = zd(c), G !== 0 && (O = G, p = Mv(c, G))), p === 1)
        throw E = Vm, zf(c, 0), yu(c, O), Zo(c, $t()), E;
      if (p === 6)
        yu(c, O);
      else {
        if (G = c.current.alternate, (O & 30) === 0 && !gg(G) && (p = hp(c, O), p === 2 && (Q = zd(c), Q !== 0 && (O = Q, p = Mv(c, Q))), p === 1))
          throw E = Vm, zf(c, 0), yu(c, O), Zo(c, $t()), E;
        switch (c.finishedWork = G, c.finishedLanes = O, p) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Dh(c, gu, gd);
            break;
          case 3:
            if (yu(c, O), (O & 130023424) === O && (p = Wm + 500 - $t(), 10 < p)) {
              if (vo(c, 0) !== 0)
                break;
              if (G = c.suspendedLanes, (G & O) !== O) {
                ha(), c.pingedLanes |= c.suspendedLanes & G;
                break;
              }
              c.timeoutHandle = uu(Dh.bind(null, c, gu, gd), p);
              break;
            }
            Dh(c, gu, gd);
            break;
          case 4:
            if (yu(c, O), (O & 4194240) === O)
              break;
            for (p = c.eventTimes, G = -1; 0 < O; ) {
              var le = 31 - Ea(O);
              Q = 1 << le, le = p[le], le > G && (G = le), O &= ~Q;
            }
            if (O = G, O = $t() - O, O = (120 > O ? 120 : 480 > O ? 480 : 1080 > O ? 1080 : 1920 > O ? 1920 : 3e3 > O ? 3e3 : 4320 > O ? 4320 : 1960 * mg(O / 1960)) - O, 10 < O) {
              c.timeoutHandle = uu(Dh.bind(null, c, gu, gd), O);
              break;
            }
            Dh(c, gu, gd);
            break;
          case 5:
            Dh(c, gu, gd);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return Zo(c, $t()), c.callbackNode === E ? dp.bind(null, c) : null;
  }
  function Mv(c, p) {
    var E = op;
    return c.current.memoizedState.isDehydrated && (zf(c, p).flags |= 256), c = hp(c, p), c !== 2 && (p = gu, gu = E, p !== null && Qp(p)), c;
  }
  function Qp(c) {
    gu === null ? gu = c : gu.push.apply(gu, c);
  }
  function gg(c) {
    for (var p = c; ; ) {
      if (p.flags & 16384) {
        var E = p.updateQueue;
        if (E !== null && (E = E.stores, E !== null))
          for (var O = 0; O < E.length; O++) {
            var G = E[O], Q = G.getSnapshot;
            G = G.value;
            try {
              if (!pt(Q(), G))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (E = p.child, p.subtreeFlags & 16384 && E !== null)
        E.return = p, p = E;
      else {
        if (p === c)
          break;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === c)
            return !0;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    return !0;
  }
  function yu(c, p) {
    for (p &= ~sp, p &= ~Gm, c.suspendedLanes |= p, c.pingedLanes &= ~p, c = c.expirationTimes; 0 < p; ) {
      var E = 31 - Ea(p), O = 1 << E;
      c[E] = -1, p &= ~O;
    }
  }
  function Tv(c) {
    if ((Nr & 6) !== 0)
      throw Error(t(327));
    Gc();
    var p = vo(c, 0);
    if ((p & 1) === 0)
      return Zo(c, $t()), null;
    var E = hp(c, p);
    if (c.tag !== 0 && E === 2) {
      var O = zd(c);
      O !== 0 && (p = O, E = Mv(c, O));
    }
    if (E === 1)
      throw E = Vm, zf(c, 0), yu(c, p), Zo(c, $t()), E;
    if (E === 6)
      throw Error(t(345));
    return c.finishedWork = c.current.alternate, c.finishedLanes = p, Dh(c, gu, gd), Zo(c, $t()), null;
  }
  function Rh(c, p) {
    var E = Nr;
    Nr |= 1;
    try {
      return c(p);
    } finally {
      Nr = E, Nr === 0 && (lp = $t() + 500, bo && _s());
    }
  }
  function Ah(c) {
    Qo !== null && Qo.tag === 0 && (Nr & 6) === 0 && Gc();
    var p = Nr;
    Nr |= 1;
    var E = aa.transition, O = ri;
    try {
      if (aa.transition = null, ri = 1, c)
        return c();
    } finally {
      ri = O, aa.transition = E, Nr = p, (Nr & 6) === 0 && _s();
    }
  }
  function yg() {
    Hc = Hm.current, bi(Hm);
  }
  function zf(c, p) {
    c.finishedWork = null, c.finishedLanes = 0;
    var E = c.timeoutHandle;
    if (E !== -1 && (c.timeoutHandle = -1, Sf(E)), Ga !== null)
      for (E = Ga.return; E !== null; ) {
        var O = E;
        switch (Ou(O), O.tag) {
          case 1:
            O = O.type.childContextTypes, O != null && Fl();
            break;
          case 3:
            fc(), bi(hs), bi(Rr), jl();
            break;
          case 5:
            Yr(O);
            break;
          case 4:
            fc();
            break;
          case 13:
            bi(fr);
            break;
          case 19:
            bi(fr);
            break;
          case 10:
            da(O.type._context);
            break;
          case 22:
          case 23:
            yg();
        }
        E = E.return;
      }
    if (ea = c, Ga = c = ku(c.current, null), vs = Hc = p, sl = 0, Vm = null, sp = Gm = vd = 0, gu = op = null, ya !== null) {
      for (p = 0; p < ya.length; p++)
        if (E = ya[p], O = E.interleaved, O !== null) {
          E.interleaved = null;
          var G = O.next, Q = E.pending;
          if (Q !== null) {
            var le = Q.next;
            Q.next = G, O.next = le;
          }
          E.pending = O;
        }
      ya = null;
    }
    return c;
  }
  function wy(c, p) {
    do {
      var E = Ga;
      try {
        if (Yd(), Nc.current = y, lr) {
          for (var O = Ai.memoizedState; O !== null; ) {
            var G = O.queue;
            G !== null && (G.pending = null), O = O.next;
          }
          lr = !1;
        }
        if (Eo = 0, vi = Ht = Ai = null, Fc = !1, Ha = 0, Ch.current = null, E === null || E.return === null) {
          sl = 1, Vm = p, Ga = null;
          break;
        }
        e: {
          var Q = c, le = E.return, Le = E, Ve = p;
          if (p = vs, Le.flags |= 32768, Ve !== null && typeof Ve == "object" && typeof Ve.then == "function") {
            var Ct = Ve, un = Le, ln = un.tag;
            if ((un.mode & 1) === 0 && (ln === 0 || ln === 11 || ln === 15)) {
              var nn = un.alternate;
              nn ? (un.updateQueue = nn.updateQueue, un.memoizedState = nn.memoizedState, un.lanes = nn.lanes) : (un.updateQueue = null, un.memoizedState = null);
            }
            var kn = wr(le);
            if (kn !== null) {
              kn.flags &= -257, ur(kn, le, Le, Q, p), kn.mode & 1 && bn(Q, Ct, p), p = kn, Ve = Ct;
              var qn = p.updateQueue;
              if (qn === null) {
                var rr = /* @__PURE__ */ new Set();
                rr.add(Ve), p.updateQueue = rr;
              } else
                qn.add(Ve);
              break e;
            } else {
              if ((p & 1) === 0) {
                bn(Q, Ct, p), Ey();
                break e;
              }
              Ve = Error(t(426));
            }
          } else if (ga && Le.mode & 1) {
            var Bs = wr(le);
            if (Bs !== null) {
              (Bs.flags & 65536) === 0 && (Bs.flags |= 256), ur(Bs, le, Le, Q, p), Uu(q(Ve, Le));
              break e;
            }
          }
          Q = Ve = q(Ve, Le), sl !== 4 && (sl = 2), op === null ? op = [Q] : op.push(Q), Q = le;
          do {
            switch (Q.tag) {
              case 3:
                Q.flags |= 65536, p &= -p, Q.lanes |= p;
                var ht = kt(Q, Ve, p);
                Kr(Q, ht);
                break e;
              case 1:
                Le = Ve;
                var Ze = Q.type, gt = Q.stateNode;
                if ((Q.flags & 128) === 0 && (typeof Ze.getDerivedStateFromError == "function" || gt !== null && typeof gt.componentDidCatch == "function" && (Kd === null || !Kd.has(gt)))) {
                  Q.flags |= 65536, p &= -p, Q.lanes |= p;
                  var xn = cn(Q, Le, p);
                  Kr(Q, xn);
                  break e;
                }
            }
            Q = Q.return;
          } while (Q !== null);
        }
        Ym(E);
      } catch (ar) {
        p = ar, Ga === E && E !== null && (Ga = E = E.return);
        continue;
      }
      break;
    } while (1);
  }
  function xg() {
    var c = wv.current;
    return wv.current = y, c === null ? y : c;
  }
  function Ey() {
    (sl === 0 || sl === 3 || sl === 2) && (sl = 4), ea === null || (vd & 268435455) === 0 && (Gm & 268435455) === 0 || yu(ea, vs);
  }
  function hp(c, p) {
    var E = Nr;
    Nr |= 2;
    var O = xg();
    (ea !== c || vs !== p) && (gd = null, zf(c, p));
    do
      try {
        pp();
        break;
      } catch (G) {
        wy(c, G);
      }
    while (1);
    if (Yd(), Nr = E, wv.current = O, Ga !== null)
      throw Error(t(261));
    return ea = null, vs = 0, sl;
  }
  function pp() {
    for (; Ga !== null; )
      Rv(Ga);
  }
  function Cv() {
    for (; Ga !== null && !La(); )
      Rv(Ga);
  }
  function Rv(c) {
    var p = Xm(c.alternate, c, Hc);
    c.memoizedProps = c.pendingProps, p === null ? Ym(c) : Ga = p, Ch.current = null;
  }
  function Ym(c) {
    var p = c;
    do {
      var E = p.alternate;
      if (c = p.return, (p.flags & 32768) === 0) {
        if (E = xy(E, p, Hc), E !== null) {
          Ga = E;
          return;
        }
      } else {
        if (E = hg(E, p), E !== null) {
          E.flags &= 32767, Ga = E;
          return;
        }
        if (c !== null)
          c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
        else {
          sl = 6, Ga = null;
          return;
        }
      }
      if (p = p.sibling, p !== null) {
        Ga = p;
        return;
      }
      Ga = p = c;
    } while (p !== null);
    sl === 0 && (sl = 5);
  }
  function Dh(c, p, E) {
    var O = ri, G = aa.transition;
    try {
      aa.transition = null, ri = 1, My(c, p, E, O);
    } finally {
      aa.transition = G, ri = O;
    }
    return null;
  }
  function My(c, p, E, O) {
    do
      Gc();
    while (Qo !== null);
    if ((Nr & 6) !== 0)
      throw Error(t(327));
    E = c.finishedWork;
    var G = c.finishedLanes;
    if (E === null)
      return null;
    if (c.finishedWork = null, c.finishedLanes = 0, E === c.current)
      throw Error(t(177));
    c.callbackNode = null, c.callbackPriority = 0;
    var Q = E.lanes | E.childLanes;
    if (qh(c, Q), c === ea && (Ga = ea = null, vs = 0), (E.subtreeFlags & 2064) === 0 && (E.flags & 2064) === 0 || up || (up = !0, Wc(qa, function() {
      return Gc(), null;
    })), Q = (E.flags & 15990) !== 0, (E.subtreeFlags & 15990) !== 0 || Q) {
      Q = aa.transition, aa.transition = null;
      var le = ri;
      ri = 1;
      var Le = Nr;
      Nr |= 4, Ch.current = null, jp(c, E), _y(E, c), ra(Lu), Ps = !!xf, Lu = xf = null, c.current = E, pg(E), Ys(), Nr = Le, ri = le, aa.transition = Q;
    } else
      c.current = E;
    if (up && (up = !1, Qo = c, cp = G), Q = c.pendingLanes, Q === 0 && (Kd = null), pi(E.stateNode), Zo(c, $t()), p !== null)
      for (O = c.onRecoverableError, E = 0; E < p.length; E++)
        G = p[E], O(G.value, { componentStack: G.stack, digest: G.digest });
    if (vg)
      throw vg = !1, c = qp, qp = null, c;
    return (cp & 1) !== 0 && c.tag !== 0 && Gc(), Q = c.pendingLanes, (Q & 1) !== 0 ? c === Ev ? jm++ : (jm = 0, Ev = c) : jm = 0, _s(), null;
  }
  function Gc() {
    if (Qo !== null) {
      var c = go(cp), p = aa.transition, E = ri;
      try {
        if (aa.transition = null, ri = 16 > c ? 16 : c, Qo === null)
          var O = !1;
        else {
          if (c = Qo, Qo = null, cp = 0, (Nr & 6) !== 0)
            throw Error(t(331));
          var G = Nr;
          for (Nr |= 4, Jn = c.current; Jn !== null; ) {
            var Q = Jn, le = Q.child;
            if ((Jn.flags & 16) !== 0) {
              var Le = Q.deletions;
              if (Le !== null) {
                for (var Ve = 0; Ve < Le.length; Ve++) {
                  var Ct = Le[Ve];
                  for (Jn = Ct; Jn !== null; ) {
                    var un = Jn;
                    switch (un.tag) {
                      case 0:
                      case 11:
                      case 15:
                        ip(8, un, Q);
                    }
                    var ln = un.child;
                    if (ln !== null)
                      ln.return = un, Jn = ln;
                    else
                      for (; Jn !== null; ) {
                        un = Jn;
                        var nn = un.sibling, kn = un.return;
                        if (ap(un), un === Ct) {
                          Jn = null;
                          break;
                        }
                        if (nn !== null) {
                          nn.return = kn, Jn = nn;
                          break;
                        }
                        Jn = kn;
                      }
                  }
                }
                var qn = Q.alternate;
                if (qn !== null) {
                  var rr = qn.child;
                  if (rr !== null) {
                    qn.child = null;
                    do {
                      var Bs = rr.sibling;
                      rr.sibling = null, rr = Bs;
                    } while (rr !== null);
                  }
                }
                Jn = Q;
              }
            }
            if ((Q.subtreeFlags & 2064) !== 0 && le !== null)
              le.return = Q, Jn = le;
            else
              e:
                for (; Jn !== null; ) {
                  if (Q = Jn, (Q.flags & 2048) !== 0)
                    switch (Q.tag) {
                      case 0:
                      case 11:
                      case 15:
                        ip(9, Q, Q.return);
                    }
                  var ht = Q.sibling;
                  if (ht !== null) {
                    ht.return = Q.return, Jn = ht;
                    break e;
                  }
                  Jn = Q.return;
                }
          }
          var Ze = c.current;
          for (Jn = Ze; Jn !== null; ) {
            le = Jn;
            var gt = le.child;
            if ((le.subtreeFlags & 2064) !== 0 && gt !== null)
              gt.return = le, Jn = gt;
            else
              e:
                for (le = Ze; Jn !== null; ) {
                  if (Le = Jn, (Le.flags & 2048) !== 0)
                    try {
                      switch (Le.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Bm(9, Le);
                      }
                    } catch (ar) {
                      Is(Le, Le.return, ar);
                    }
                  if (Le === le) {
                    Jn = null;
                    break e;
                  }
                  var xn = Le.sibling;
                  if (xn !== null) {
                    xn.return = Le.return, Jn = xn;
                    break e;
                  }
                  Jn = Le.return;
                }
          }
          if (Nr = G, _s(), mr && typeof mr.onPostCommitFiberRoot == "function")
            try {
              mr.onPostCommitFiberRoot(us, c);
            } catch {
            }
          O = !0;
        }
        return O;
      } finally {
        ri = E, aa.transition = p;
      }
    }
    return !1;
  }
  function Zp(c, p, E) {
    p = q(E, p), p = kt(c, p, 1), c = wf(c, p, 1), p = ha(), c !== null && (au(c, 1, p), Zo(c, p));
  }
  function Is(c, p, E) {
    if (c.tag === 3)
      Zp(c, c, E);
    else
      for (; p !== null; ) {
        if (p.tag === 3) {
          Zp(p, c, E);
          break;
        } else if (p.tag === 1) {
          var O = p.stateNode;
          if (typeof p.type.getDerivedStateFromError == "function" || typeof O.componentDidCatch == "function" && (Kd === null || !Kd.has(O))) {
            c = q(E, c), c = cn(p, c, 1), p = wf(p, c, 1), c = ha(), p !== null && (au(p, 1, c), Zo(p, c));
            break;
          }
        }
        p = p.return;
      }
  }
  function Ty(c, p, E) {
    var O = c.pingCache;
    O !== null && O.delete(p), p = ha(), c.pingedLanes |= c.suspendedLanes & E, ea === c && (vs & E) === E && (sl === 4 || sl === 3 && (vs & 130023424) === vs && 500 > $t() - Wm ? zf(c, 0) : sp |= E), Zo(c, p);
  }
  function Sg(c, p) {
    p === 0 && ((c.mode & 1) === 0 ? p = 1 : (p = Pa, Pa <<= 1, (Pa & 130023424) === 0 && (Pa = 4194304)));
    var E = ha();
    c = Wo(c, p), c !== null && (au(c, p, E), Zo(c, E));
  }
  function N0(c) {
    var p = c.memoizedState, E = 0;
    p !== null && (E = p.retryLane), Sg(c, E);
  }
  function F0(c, p) {
    var E = 0;
    switch (c.tag) {
      case 13:
        var O = c.stateNode, G = c.memoizedState;
        G !== null && (E = G.retryLane);
        break;
      case 19:
        O = c.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    O !== null && O.delete(p), Sg(c, E);
  }
  var Xm;
  Xm = function(c, p, E) {
    if (c !== null)
      if (c.memoizedProps !== p.pendingProps || hs.current)
        Tn = !0;
      else {
        if ((c.lanes & E) === 0 && (p.flags & 128) === 0)
          return Tn = !1, rs(c, p, E);
        Tn = (c.flags & 131072) !== 0;
      }
    else
      Tn = !1, ga && (p.flags & 1048576) !== 0 && Nm(p, zr, p.index);
    switch (p.lanes = 0, p.tag) {
      case 2:
        var O = p.type;
        Xo(c, p), c = p.pendingProps;
        var G = Nl(p, Rr.current);
        wn(p, E), G = Cf(null, p, O, c, G, E);
        var Q = Rf();
        return p.flags |= 1, typeof G == "object" && G !== null && typeof G.render == "function" && G.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, Ia(O) ? (Q = !0, Ho(p)) : Q = !1, p.memoizedState = G.state !== null && G.state !== void 0 ? G.state : null, An(p), G.updater = od, p.stateNode = G, G._reactInternals = p, cc(p, O, c, E), p = Er(null, p, O, !0, Q, E)) : (p.tag = 0, ga && Q && wh(p), Li(null, p, G, E), p = p.child), p;
      case 16:
        O = p.elementType;
        e: {
          switch (Xo(c, p), c = p.pendingProps, G = O._init, O = G(O._payload), p.type = O, G = p.tag = _g(O), c = du(O, c), G) {
            case 0:
              p = Wn(null, p, O, c, E);
              break e;
            case 1:
              p = Xr(null, p, O, c, E);
              break e;
            case 11:
              p = ms(null, p, O, c, E);
              break e;
            case 14:
              p = dt(null, p, O, du(O.type, c), E);
              break e;
          }
          throw Error(t(
            306,
            O,
            ""
          ));
        }
        return p;
      case 0:
        return O = p.type, G = p.pendingProps, G = p.elementType === O ? G : du(O, G), Wn(c, p, O, G, E);
      case 1:
        return O = p.type, G = p.pendingProps, G = p.elementType === O ? G : du(O, G), Xr(c, p, O, G, E);
      case 3:
        e: {
          if (Ar(p), c === null)
            throw Error(t(387));
          O = p.pendingProps, Q = p.memoizedState, G = Q.element, xa(c, p), Ra(p, O, null, E);
          var le = p.memoizedState;
          if (O = le.element, Q.isDehydrated)
            if (Q = { element: O, isDehydrated: !1, cache: le.cache, pendingSuspenseBoundaries: le.pendingSuspenseBoundaries, transitions: le.transitions }, p.updateQueue.baseState = Q, p.memoizedState = Q, p.flags & 256) {
              G = q(Error(t(423)), p), p = Va(c, p, O, E, G);
              break e;
            } else if (O !== G) {
              G = q(Error(t(424)), p), p = Va(c, p, O, E, G);
              break e;
            } else
              for (gl = zl(p.stateNode.containerInfo.firstChild), bs = p, ga = !0, fu = null, E = Qd(p, null, O, E), p.child = E; E; )
                E.flags = E.flags & -3 | 4096, E = E.sibling;
          else {
            if (fa(), O === G) {
              p = qo(c, p, E);
              break e;
            }
            Li(c, p, O, E);
          }
          p = p.child;
        }
        return p;
      case 5:
        return hr(p), c === null && Vo(p), O = p.type, G = p.pendingProps, Q = c !== null ? c.memoizedProps : null, le = G.children, rd(O, G) ? le = null : Q !== null && rd(O, Q) && (p.flags |= 32), qt(c, p), Li(c, p, le, E), p.child;
      case 6:
        return c === null && Vo(p), null;
      case 13:
        return hd(c, p, E);
      case 4:
        return Eh(p, p.stateNode.containerInfo), O = p.pendingProps, c === null ? p.child = Ef(p, null, O, E) : Li(c, p, O, E), p.child;
      case 11:
        return O = p.type, G = p.pendingProps, G = p.elementType === O ? G : du(O, G), ms(c, p, O, G, E);
      case 7:
        return Li(c, p, p.pendingProps, E), p.child;
      case 8:
        return Li(c, p, p.pendingProps.children, E), p.child;
      case 12:
        return Li(c, p, p.pendingProps.children, E), p.child;
      case 10:
        e: {
          if (O = p.type._context, G = p.pendingProps, Q = p.memoizedProps, le = G.value, zi(Bl, O._currentValue), O._currentValue = le, Q !== null)
            if (pt(Q.value, le)) {
              if (Q.children === G.children && !hs.current) {
                p = qo(c, p, E);
                break e;
              }
            } else
              for (Q = p.child, Q !== null && (Q.return = p); Q !== null; ) {
                var Le = Q.dependencies;
                if (Le !== null) {
                  le = Q.child;
                  for (var Ve = Le.firstContext; Ve !== null; ) {
                    if (Ve.context === O) {
                      if (Q.tag === 1) {
                        Ve = ns(-1, E & -E), Ve.tag = 2;
                        var Ct = Q.updateQueue;
                        if (Ct !== null) {
                          Ct = Ct.shared;
                          var un = Ct.pending;
                          un === null ? Ve.next = Ve : (Ve.next = un.next, un.next = Ve), Ct.pending = Ve;
                        }
                      }
                      Q.lanes |= E, Ve = Q.alternate, Ve !== null && (Ve.lanes |= E), Hi(
                        Q.return,
                        E,
                        p
                      ), Le.lanes |= E;
                      break;
                    }
                    Ve = Ve.next;
                  }
                } else if (Q.tag === 10)
                  le = Q.type === p.type ? null : Q.child;
                else if (Q.tag === 18) {
                  if (le = Q.return, le === null)
                    throw Error(t(341));
                  le.lanes |= E, Le = le.alternate, Le !== null && (Le.lanes |= E), Hi(le, E, p), le = Q.sibling;
                } else
                  le = Q.child;
                if (le !== null)
                  le.return = Q;
                else
                  for (le = Q; le !== null; ) {
                    if (le === p) {
                      le = null;
                      break;
                    }
                    if (Q = le.sibling, Q !== null) {
                      Q.return = le.return, le = Q;
                      break;
                    }
                    le = le.return;
                  }
                Q = le;
              }
          Li(c, p, G.children, E), p = p.child;
        }
        return p;
      case 9:
        return G = p.type, O = p.pendingProps.children, wn(p, E), G = Qi(G), O = O(G), p.flags |= 1, Li(c, p, O, E), p.child;
      case 14:
        return O = p.type, G = du(O, p.pendingProps), G = du(O.type, G), dt(c, p, O, G, E);
      case 15:
        return Qe(c, p, p.type, p.pendingProps, E);
      case 17:
        return O = p.type, G = p.pendingProps, G = p.elementType === O ? G : du(O, G), Xo(c, p), p.tag = 1, Ia(O) ? (c = !0, Ho(p)) : c = !1, wn(p, E), Xd(p, O, G), cc(p, O, G, E), Er(null, p, O, !0, c, E);
      case 19:
        return dg(c, p, E);
      case 22:
        return At(c, p, E);
    }
    throw Error(t(156, p.tag));
  };
  function Wc(c, p) {
    return br(c, p);
  }
  function Cy(c, p, E, O) {
    this.tag = c, this.key = E, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = O, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function _l(c, p, E, O) {
    return new Cy(c, p, E, O);
  }
  function Av(c) {
    return c = c.prototype, !(!c || !c.isReactComponent);
  }
  function _g(c) {
    if (typeof c == "function")
      return Av(c) ? 1 : 0;
    if (c != null) {
      if (c = c.$$typeof, c === ce)
        return 11;
      if (c === Fe)
        return 14;
    }
    return 2;
  }
  function ku(c, p) {
    var E = c.alternate;
    return E === null ? (E = _l(c.tag, p, c.key, c.mode), E.elementType = c.elementType, E.type = c.type, E.stateNode = c.stateNode, E.alternate = c, c.alternate = E) : (E.pendingProps = p, E.type = c.type, E.flags = 0, E.subtreeFlags = 0, E.deletions = null), E.flags = c.flags & 14680064, E.childLanes = c.childLanes, E.lanes = c.lanes, E.child = c.child, E.memoizedProps = c.memoizedProps, E.memoizedState = c.memoizedState, E.updateQueue = c.updateQueue, p = c.dependencies, E.dependencies = p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }, E.sibling = c.sibling, E.index = c.index, E.ref = c.ref, E;
  }
  function Lh(c, p, E, O, G, Q) {
    var le = 2;
    if (O = c, typeof c == "function")
      Av(c) && (le = 1);
    else if (typeof c == "string")
      le = 5;
    else
      e:
        switch (c) {
          case $:
            return Jp(E.children, G, Q, p);
          case W:
            le = 8, G |= 8;
            break;
          case ee:
            return c = _l(12, E, p, G | 2), c.elementType = ee, c.lanes = Q, c;
          case Ee:
            return c = _l(13, E, p, G), c.elementType = Ee, c.lanes = Q, c;
          case de:
            return c = _l(19, E, p, G), c.elementType = de, c.lanes = Q, c;
          case Be:
            return mp(E, G, Q, p);
          default:
            if (typeof c == "object" && c !== null)
              switch (c.$$typeof) {
                case ie:
                  le = 10;
                  break e;
                case pe:
                  le = 9;
                  break e;
                case ce:
                  le = 11;
                  break e;
                case Fe:
                  le = 14;
                  break e;
                case Ce:
                  le = 16, O = null;
                  break e;
              }
            throw Error(t(130, c == null ? c : typeof c, ""));
        }
    return p = _l(le, E, p, G), p.elementType = c, p.type = O, p.lanes = Q, p;
  }
  function Jp(c, p, E, O) {
    return c = _l(7, c, O, p), c.lanes = E, c;
  }
  function mp(c, p, E, O) {
    return c = _l(22, c, O, p), c.elementType = Be, c.lanes = E, c.stateNode = { isHidden: !1 }, c;
  }
  function mc(c, p, E) {
    return c = _l(6, c, null, p), c.lanes = E, c;
  }
  function Aa(c, p, E) {
    return p = _l(4, c.children !== null ? c.children : [], c.key, p), p.lanes = E, p.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, p;
  }
  function vp(c, p, E, O, G) {
    this.tag = p, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ju(0), this.expirationTimes = Ju(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ju(0), this.identifierPrefix = O, this.onRecoverableError = G, this.mutableSourceEagerHydrationData = null;
  }
  function Ts(c, p, E, O, G, Q, le, Le, Ve) {
    return c = new vp(c, p, E, Le, Ve), p === 1 ? (p = 1, Q === !0 && (p |= 8)) : p = 0, Q = _l(3, null, null, p), c.current = Q, Q.stateNode = c, Q.memoizedState = { element: O, isDehydrated: E, cache: null, transitions: null, pendingSuspenseBoundaries: null }, An(Q), c;
  }
  function bl(c, p, E) {
    var O = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: J, key: O == null ? null : "" + O, children: c, containerInfo: p, implementation: E };
  }
  function Dv(c) {
    if (!c)
      return Pc;
    c = c._reactInternals;
    e: {
      if (yn(c) !== c || c.tag !== 1)
        throw Error(t(170));
      var p = c;
      do {
        switch (p.tag) {
          case 3:
            p = p.stateNode.context;
            break e;
          case 1:
            if (Ia(p.type)) {
              p = p.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        p = p.return;
      } while (p !== null);
      throw Error(t(171));
    }
    if (c.tag === 1) {
      var E = c.type;
      if (Ia(E))
        return Wd(c, E, p);
    }
    return p;
  }
  function bg(c, p, E, O, G, Q, le, Le, Ve) {
    return c = Ts(E, O, !0, c, G, Q, le, Le, Ve), c.context = Dv(null), E = c.current, O = ha(), G = ro(E), Q = ns(O, G), Q.callback = p != null ? p : null, wf(E, Q, G), c.current.lanes = G, au(c, G, O), Zo(c, O), c;
  }
  function Lv(c, p, E, O) {
    var G = p.current, Q = ha(), le = ro(G);
    return E = Dv(E), p.context === null ? p.context = E : p.pendingContext = E, p = ns(Q, le), p.payload = { element: c }, O = O === void 0 ? null : O, O !== null && (p.callback = O), c = wf(G, p, le), c !== null && (Sl(c, G, le, Q), Sa(c, G, le)), le;
  }
  function On(c) {
    if (c = c.current, !c.child)
      return null;
    switch (c.child.tag) {
      case 5:
        return c.child.stateNode;
      default:
        return c.child.stateNode;
    }
  }
  function Iu(c, p) {
    if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
      var E = c.retryLane;
      c.retryLane = E !== 0 && E < p ? E : p;
    }
  }
  function Pv(c, p) {
    Iu(c, p), (c = c.alternate) && Iu(c, p);
  }
  function Kp() {
    return null;
  }
  var Ph = typeof reportError == "function" ? reportError : function(c) {
    console.error(c);
  };
  function sa(c) {
    this._internalRoot = c;
  }
  Cs.prototype.render = sa.prototype.render = function(c) {
    var p = this._internalRoot;
    if (p === null)
      throw Error(t(409));
    Lv(c, p, null, null);
  }, Cs.prototype.unmount = sa.prototype.unmount = function() {
    var c = this._internalRoot;
    if (c !== null) {
      this._internalRoot = null;
      var p = c.containerInfo;
      Ah(function() {
        Lv(null, c, null, null);
      }), p[_o] = null;
    }
  };
  function Cs(c) {
    this._internalRoot = c;
  }
  Cs.prototype.unstable_scheduleHydration = function(c) {
    if (c) {
      var p = cs();
      c = { blockedOn: null, target: c, priority: p };
      for (var E = 0; E < Xi.length && p !== 0 && p < Xi[E].priority; E++)
        ;
      Xi.splice(E, 0, c), E === 0 && dl(c);
    }
  };
  function Co(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11);
  }
  function $p(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11 && (c.nodeType !== 8 || c.nodeValue !== " react-mount-point-unstable "));
  }
  function qm() {
  }
  function gp(c, p, E, O, G) {
    if (G) {
      if (typeof O == "function") {
        var Q = O;
        O = function() {
          var Ct = On(le);
          Q.call(Ct);
        };
      }
      var le = bg(p, O, c, 0, null, !1, !1, "", qm);
      return c._reactRootContainer = le, c[_o] = le.current, nl(c.nodeType === 8 ? c.parentNode : c), Ah(), le;
    }
    for (; G = c.lastChild; )
      c.removeChild(G);
    if (typeof O == "function") {
      var Le = O;
      O = function() {
        var Ct = On(Ve);
        Le.call(Ct);
      };
    }
    var Ve = Ts(c, 0, !1, null, null, !1, !1, "", qm);
    return c._reactRootContainer = Ve, c[_o] = Ve.current, nl(c.nodeType === 8 ? c.parentNode : c), Ah(function() {
      Lv(p, Ve, E, O);
    }), Ve;
  }
  function wg(c, p, E, O, G) {
    var Q = E._reactRootContainer;
    if (Q) {
      var le = Q;
      if (typeof G == "function") {
        var Le = G;
        G = function() {
          var Ve = On(le);
          Le.call(Ve);
        };
      }
      Lv(p, le, c, G);
    } else
      le = gp(E, p, c, G, O);
    return On(le);
  }
  jf = function(c) {
    switch (c.tag) {
      case 3:
        var p = c.stateNode;
        if (p.current.memoizedState.isDehydrated) {
          var E = Rl(p.pendingLanes);
          E !== 0 && (Dl(p, E | 1), Zo(p, $t()), (Nr & 6) === 0 && (lp = $t() + 500, _s()));
        }
        break;
      case 13:
        Ah(function() {
          var O = Wo(c, 1);
          if (O !== null) {
            var G = ha();
            Sl(O, c, 1, G);
          }
        }), Pv(c, 1);
    }
  }, zo = function(c) {
    if (c.tag === 13) {
      var p = Wo(c, 134217728);
      if (p !== null) {
        var E = ha();
        Sl(p, c, 134217728, E);
      }
      Pv(c, 134217728);
    }
  }, Ci = function(c) {
    if (c.tag === 13) {
      var p = ro(c), E = Wo(c, p);
      if (E !== null) {
        var O = ha();
        Sl(E, c, p, O);
      }
      Pv(c, p);
    }
  }, cs = function() {
    return ri;
  }, Yf = function(c, p) {
    var E = ri;
    try {
      return ri = c, p();
    } finally {
      ri = E;
    }
  }, Gt = function(c, p, E) {
    switch (p) {
      case "input":
        if (Qt(c, E), p = E.name, E.type === "radio" && p != null) {
          for (E = c; E.parentNode; )
            E = E.parentNode;
          for (E = E.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), p = 0; p < E.length; p++) {
            var O = E[p];
            if (O !== c && O.form === c.form) {
              var G = vr(O);
              if (!G)
                throw Error(t(90));
              He(O), Qt(O, G);
            }
          }
        }
        break;
      case "textarea":
        je(c, E);
        break;
      case "select":
        p = E.value, p != null && Mt(c, !!E.multiple, p, !1);
    }
  }, ir = Rh, Vn = Ah;
  var u1 = { usingClientEntryPoint: !1, Events: [ka, Hn, vr, Wr, Ur, Rh] }, Wt = { findFiberByHostInstance: Zs, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Nf = { bundleType: Wt.bundleType, version: Wt.version, rendererPackageName: Wt.rendererPackageName, rendererConfig: Wt.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: I.ReactCurrentDispatcher, findHostInstanceByFiber: function(c) {
    return c = Zn(c), c === null ? null : c.stateNode;
  }, findFiberByHostInstance: Wt.findFiberByHostInstance || Kp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var yd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!yd.isDisabled && yd.supportsFiber)
      try {
        us = yd.inject(Nf), mr = yd;
      } catch {
      }
  }
  return Ap.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = u1, Ap.createPortal = function(c, p) {
    var E = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Co(p))
      throw Error(t(200));
    return bl(c, p, null, E);
  }, Ap.createRoot = function(c, p) {
    if (!Co(c))
      throw Error(t(299));
    var E = !1, O = "", G = Ph;
    return p != null && (p.unstable_strictMode === !0 && (E = !0), p.identifierPrefix !== void 0 && (O = p.identifierPrefix), p.onRecoverableError !== void 0 && (G = p.onRecoverableError)), p = Ts(c, 1, !1, null, null, E, !1, O, G), c[_o] = p.current, nl(c.nodeType === 8 ? c.parentNode : c), new sa(p);
  }, Ap.findDOMNode = function(c) {
    if (c == null)
      return null;
    if (c.nodeType === 1)
      return c;
    var p = c._reactInternals;
    if (p === void 0)
      throw typeof c.render == "function" ? Error(t(188)) : (c = Object.keys(c).join(","), Error(t(268, c)));
    return c = Zn(p), c = c === null ? null : c.stateNode, c;
  }, Ap.flushSync = function(c) {
    return Ah(c);
  }, Ap.hydrate = function(c, p, E) {
    if (!$p(p))
      throw Error(t(200));
    return wg(null, c, p, !0, E);
  }, Ap.hydrateRoot = function(c, p, E) {
    if (!Co(c))
      throw Error(t(405));
    var O = E != null && E.hydratedSources || null, G = !1, Q = "", le = Ph;
    if (E != null && (E.unstable_strictMode === !0 && (G = !0), E.identifierPrefix !== void 0 && (Q = E.identifierPrefix), E.onRecoverableError !== void 0 && (le = E.onRecoverableError)), p = bg(p, null, c, 1, E != null ? E : null, G, !1, Q, le), c[_o] = p.current, nl(c), O)
      for (c = 0; c < O.length; c++)
        E = O[c], G = E._getVersion, G = G(E._source), p.mutableSourceEagerHydrationData == null ? p.mutableSourceEagerHydrationData = [E, G] : p.mutableSourceEagerHydrationData.push(
          E,
          G
        );
    return new Cs(p);
  }, Ap.render = function(c, p, E) {
    if (!$p(p))
      throw Error(t(200));
    return wg(null, c, p, !1, E);
  }, Ap.unmountComponentAtNode = function(c) {
    if (!$p(c))
      throw Error(t(40));
    return c._reactRootContainer ? (Ah(function() {
      wg(null, null, c, !1, function() {
        c._reactRootContainer = null, c[_o] = null;
      });
    }), !0) : !1;
  }, Ap.unstable_batchedUpdates = Rh, Ap.unstable_renderSubtreeIntoContainer = function(c, p, E, O) {
    if (!$p(E))
      throw Error(t(200));
    if (c == null || c._reactInternals === void 0)
      throw Error(t(38));
    return wg(c, p, E, !1, O);
  }, Ap.version = "18.2.0-next-9e3b772b8-20220608", Ap;
}
var Dp = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tz;
function gj() {
  return Tz || (Tz = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var a = hh, e = H4(), t = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function i(n) {
      r = n;
    }
    function o(n) {
      if (!r) {
        for (var s = arguments.length, v = new Array(s > 1 ? s - 1 : 0), b = 1; b < s; b++)
          v[b - 1] = arguments[b];
        d("warn", n, v);
      }
    }
    function l(n) {
      if (!r) {
        for (var s = arguments.length, v = new Array(s > 1 ? s - 1 : 0), b = 1; b < s; b++)
          v[b - 1] = arguments[b];
        d("error", n, v);
      }
    }
    function d(n, s, v) {
      {
        var b = t.ReactDebugCurrentFrame, R = b.getStackAddendum();
        R !== "" && (s += "%s", v = v.concat([R]));
        var F = v.map(function(Y) {
          return String(Y);
        });
        F.unshift("Warning: " + s), Function.prototype.apply.call(console[n], console, F);
      }
    }
    var h = 0, m = 1, S = 2, _ = 3, T = 4, C = 5, D = 6, P = 7, U = 8, B = 9, k = 10, V = 11, I = 12, X = 13, J = 14, $ = 15, W = 16, ee = 17, ie = 18, pe = 19, ce = 21, Ee = 22, de = 23, Fe = 24, Ce = 25, Be = !0, he = !1, fe = !1, ue = !1, ye = !1, we = !0, Xe = !1, Je = !1, st = !0, Ue = !0, ot = !0, rt = /* @__PURE__ */ new Set(), _t = {}, Rt = {};
    function Ot(n, s) {
      He(n, s), He(n + "Capture", s);
    }
    function He(n, s) {
      _t[n] && l("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", n), _t[n] = s;
      {
        var v = n.toLowerCase();
        Rt[v] = n, n === "onDoubleClick" && (Rt.ondblclick = n);
      }
      for (var b = 0; b < s.length; b++)
        rt.add(s[b]);
    }
    var et = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", mt = Object.prototype.hasOwnProperty;
    function vt(n) {
      {
        var s = typeof Symbol == "function" && Symbol.toStringTag, v = s && n[Symbol.toStringTag] || n.constructor.name || "Object";
        return v;
      }
    }
    function bt(n) {
      try {
        return Qt(n), !1;
      } catch {
        return !0;
      }
    }
    function Qt(n) {
      return "" + n;
    }
    function ft(n, s) {
      if (bt(n))
        return l("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", s, vt(n)), Qt(n);
    }
    function Vt(n) {
      if (bt(n))
        return l("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", vt(n)), Qt(n);
    }
    function Jt(n, s) {
      if (bt(n))
        return l("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", s, vt(n)), Qt(n);
    }
    function Mt(n, s) {
      if (bt(n))
        return l("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", s, vt(n)), Qt(n);
    }
    function Me(n) {
      if (bt(n))
        return l("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", vt(n)), Qt(n);
    }
    function oe(n) {
      if (bt(n))
        return l("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", vt(n)), Qt(n);
    }
    var je = 0, lt = 1, zt = 2, Nt = 3, Ut = 4, tt = 5, rn = 6, ze = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", xe = ze + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ie = new RegExp("^[" + ze + "][" + xe + "]*$"), it = {}, at = {};
    function hn(n) {
      return mt.call(at, n) ? !0 : mt.call(it, n) ? !1 : Ie.test(n) ? (at[n] = !0, !0) : (it[n] = !0, l("Invalid attribute name: `%s`", n), !1);
    }
    function De(n, s, v) {
      return s !== null ? s.type === je : v ? !1 : n.length > 2 && (n[0] === "o" || n[0] === "O") && (n[1] === "n" || n[1] === "N");
    }
    function Tt(n, s, v, b) {
      if (v !== null && v.type === je)
        return !1;
      switch (typeof s) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (b)
            return !1;
          if (v !== null)
            return !v.acceptsBooleans;
          var R = n.toLowerCase().slice(0, 5);
          return R !== "data-" && R !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Ne(n, s, v, b) {
      if (s === null || typeof s > "u" || Tt(n, s, v, b))
        return !0;
      if (b)
        return !1;
      if (v !== null)
        switch (v.type) {
          case Nt:
            return !s;
          case Ut:
            return s === !1;
          case tt:
            return isNaN(s);
          case rn:
            return isNaN(s) || s < 1;
        }
      return !1;
    }
    function Gt(n) {
      return fn.hasOwnProperty(n) ? fn[n] : null;
    }
    function Pt(n, s, v, b, R, F, Y) {
      this.acceptsBooleans = s === zt || s === Nt || s === Ut, this.attributeName = b, this.attributeNamespace = R, this.mustUseProperty = v, this.propertyName = n, this.type = s, this.sanitizeURL = F, this.removeEmptyString = Y;
    }
    var fn = {}, Gr = [
      "children",
      "dangerouslySetInnerHTML",
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Gr.forEach(function(n) {
      fn[n] = new Pt(
        n,
        je,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
      var s = n[0], v = n[1];
      fn[s] = new Pt(
        s,
        lt,
        !1,
        v,
        null,
        !1,
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
      fn[n] = new Pt(
        n,
        zt,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
      fn[n] = new Pt(
        n,
        zt,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      "itemScope"
    ].forEach(function(n) {
      fn[n] = new Pt(
        n,
        Nt,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    }), [
      "checked",
      "multiple",
      "muted",
      "selected"
    ].forEach(function(n) {
      fn[n] = new Pt(
        n,
        Nt,
        !0,
        n,
        null,
        !1,
        !1
      );
    }), [
      "capture",
      "download"
    ].forEach(function(n) {
      fn[n] = new Pt(
        n,
        Ut,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
    ].forEach(function(n) {
      fn[n] = new Pt(
        n,
        rn,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), ["rowSpan", "start"].forEach(function(n) {
      fn[n] = new Pt(
        n,
        tt,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    });
    var Wr = /[\-\:]([a-z])/g, Ur = function(n) {
      return n[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
    ].forEach(function(n) {
      var s = n.replace(Wr, Ur);
      fn[s] = new Pt(
        s,
        lt,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
    ].forEach(function(n) {
      var s = n.replace(Wr, Ur);
      fn[s] = new Pt(
        s,
        lt,
        !1,
        n,
        "http://www.w3.org/1999/xlink",
        !1,
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
    ].forEach(function(n) {
      var s = n.replace(Wr, Ur);
      fn[s] = new Pt(
        s,
        lt,
        !1,
        n,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(n) {
      fn[n] = new Pt(
        n,
        lt,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    });
    var ir = "xlinkHref";
    fn[ir] = new Pt(
      "xlinkHref",
      lt,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(n) {
      fn[n] = new Pt(
        n,
        lt,
        !1,
        n.toLowerCase(),
        null,
        !0,
        !0
      );
    });
    var Vn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, jr = !1;
    function ti(n) {
      !jr && Vn.test(n) && (jr = !0, l("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(n)));
    }
    function ki(n, s, v, b) {
      if (b.mustUseProperty) {
        var R = b.propertyName;
        return n[R];
      } else {
        ft(v, s), b.sanitizeURL && ti("" + v);
        var F = b.attributeName, Y = null;
        if (b.type === Ut) {
          if (n.hasAttribute(F)) {
            var K = n.getAttribute(F);
            return K === "" ? !0 : Ne(s, v, b, !1) ? K : K === "" + v ? v : K;
          }
        } else if (n.hasAttribute(F)) {
          if (Ne(s, v, b, !1))
            return n.getAttribute(F);
          if (b.type === Nt)
            return v;
          Y = n.getAttribute(F);
        }
        return Ne(s, v, b, !1) ? Y === null ? v : Y : Y === "" + v ? v : Y;
      }
    }
    function Wi(n, s, v, b) {
      {
        if (!hn(s))
          return;
        if (!n.hasAttribute(s))
          return v === void 0 ? void 0 : null;
        var R = n.getAttribute(s);
        return ft(v, s), R === "" + v ? v : R;
      }
    }
    function ni(n, s, v, b) {
      var R = Gt(s);
      if (!De(s, R, b)) {
        if (Ne(s, v, R, b) && (v = null), b || R === null) {
          if (hn(s)) {
            var F = s;
            v === null ? n.removeAttribute(F) : (ft(v, s), n.setAttribute(F, "" + v));
          }
          return;
        }
        var Y = R.mustUseProperty;
        if (Y) {
          var K = R.propertyName;
          if (v === null) {
            var re = R.type;
            n[K] = re === Nt ? !1 : "";
          } else
            n[K] = v;
          return;
        }
        var _e = R.attributeName, Re = R.attributeNamespace;
        if (v === null)
          n.removeAttribute(_e);
        else {
          var nt = R.type, $e;
          nt === Nt || nt === Ut && v === !0 ? $e = "" : (ft(v, _e), $e = "" + v, R.sanitizeURL && ti($e.toString())), Re ? n.setAttributeNS(Re, _e, $e) : n.setAttribute(_e, $e);
        }
      }
    }
    var ji = Symbol.for("react.element"), Si = Symbol.for("react.portal"), Te = Symbol.for("react.fragment"), ct = Symbol.for("react.strict_mode"), me = Symbol.for("react.profiler"), Oe = Symbol.for("react.provider"), qe = Symbol.for("react.context"), on = Symbol.for("react.forward_ref"), yn = Symbol.for("react.suspense"), Rn = Symbol.for("react.suspense_list"), mn = Symbol.for("react.memo"), vn = Symbol.for("react.lazy"), Zn = Symbol.for("react.scope"), nr = Symbol.for("react.debug_trace_mode"), br = Symbol.for("react.offscreen"), Yi = Symbol.for("react.legacy_hidden"), La = Symbol.for("react.cache"), Ys = Symbol.for("react.tracing_marker"), $t = Symbol.iterator, Zr = "@@iterator";
    function ls(n) {
      if (n === null || typeof n != "object")
        return null;
      var s = $t && n[$t] || n[Zr];
      return typeof s == "function" ? s : null;
    }
    var Xn = Object.assign, qa = 0, mo, Ds, us, mr, pi, Ea, _i;
    function Ti() {
    }
    Ti.__reactDisabledLog = !0;
    function Oo() {
      {
        if (qa === 0) {
          mo = console.log, Ds = console.info, us = console.warn, mr = console.error, pi = console.group, Ea = console.groupCollapsed, _i = console.groupEnd;
          var n = {
            configurable: !0,
            enumerable: !0,
            value: Ti,
            writable: !0
          };
          Object.defineProperties(console, {
            info: n,
            log: n,
            warn: n,
            error: n,
            group: n,
            groupCollapsed: n,
            groupEnd: n
          });
        }
        qa++;
      }
    }
    function Uo() {
      {
        if (qa--, qa === 0) {
          var n = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Xn({}, n, {
              value: mo
            }),
            info: Xn({}, n, {
              value: Ds
            }),
            warn: Xn({}, n, {
              value: us
            }),
            error: Xn({}, n, {
              value: mr
            }),
            group: Xn({}, n, {
              value: pi
            }),
            groupCollapsed: Xn({}, n, {
              value: Ea
            }),
            groupEnd: Xn({}, n, {
              value: _i
            })
          });
        }
        qa < 0 && l("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Pa = t.ReactCurrentDispatcher, Rl;
    function vo(n, s, v) {
      {
        if (Rl === void 0)
          try {
            throw Error();
          } catch (R) {
            var b = R.stack.trim().match(/\n( *(at )?)/);
            Rl = b && b[1] || "";
          }
        return `
` + Rl + n;
      }
    }
    var Wf = !1, Al;
    {
      var zd = typeof WeakMap == "function" ? WeakMap : Map;
      Al = new zd();
    }
    function Ls(n, s) {
      if (!n || Wf)
        return "";
      {
        var v = Al.get(n);
        if (v !== void 0)
          return v;
      }
      var b;
      Wf = !0;
      var R = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var F;
      F = Pa.current, Pa.current = null, Oo();
      try {
        if (s) {
          var Y = function() {
            throw Error();
          };
          if (Object.defineProperty(Y.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Y, []);
            } catch (Lt) {
              b = Lt;
            }
            Reflect.construct(n, [], Y);
          } else {
            try {
              Y.call();
            } catch (Lt) {
              b = Lt;
            }
            n.call(Y.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Lt) {
            b = Lt;
          }
          n();
        }
      } catch (Lt) {
        if (Lt && b && typeof Lt.stack == "string") {
          for (var K = Lt.stack.split(`
`), re = b.stack.split(`
`), _e = K.length - 1, Re = re.length - 1; _e >= 1 && Re >= 0 && K[_e] !== re[Re]; )
            Re--;
          for (; _e >= 1 && Re >= 0; _e--, Re--)
            if (K[_e] !== re[Re]) {
              if (_e !== 1 || Re !== 1)
                do
                  if (_e--, Re--, Re < 0 || K[_e] !== re[Re]) {
                    var nt = `
` + K[_e].replace(" at new ", " at ");
                    return n.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", n.displayName)), typeof n == "function" && Al.set(n, nt), nt;
                  }
                while (_e >= 1 && Re >= 0);
              break;
            }
        }
      } finally {
        Wf = !1, Pa.current = F, Uo(), Error.prepareStackTrace = R;
      }
      var $e = n ? n.displayName || n.name : "", Dt = $e ? vo($e) : "";
      return typeof n == "function" && Al.set(n, Dt), Dt;
    }
    function Ju(n, s, v) {
      return Ls(n, !0);
    }
    function au(n, s, v) {
      return Ls(n, !1);
    }
    function qh(n) {
      var s = n.prototype;
      return !!(s && s.isReactComponent);
    }
    function Dl(n, s, v) {
      if (n == null)
        return "";
      if (typeof n == "function")
        return Ls(n, qh(n));
      if (typeof n == "string")
        return vo(n);
      switch (n) {
        case yn:
          return vo("Suspense");
        case Rn:
          return vo("SuspenseList");
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case on:
            return au(n.render);
          case mn:
            return Dl(n.type, s, v);
          case vn: {
            var b = n, R = b._payload, F = b._init;
            try {
              return Dl(F(R), s, v);
            } catch {
            }
          }
        }
      return "";
    }
    function ri(n) {
      switch (n._debugOwner && n._debugOwner.type, n._debugSource, n.tag) {
        case C:
          return vo(n.type);
        case W:
          return vo("Lazy");
        case X:
          return vo("Suspense");
        case pe:
          return vo("SuspenseList");
        case h:
        case S:
        case $:
          return au(n.type);
        case V:
          return au(n.type.render);
        case m:
          return Ju(n.type);
        default:
          return "";
      }
    }
    function go(n) {
      try {
        var s = "", v = n;
        do
          s += ri(v), v = v.return;
        while (v);
        return s;
      } catch (b) {
        return `
Error generating stack: ` + b.message + `
` + b.stack;
      }
    }
    function jf(n, s, v) {
      var b = n.displayName;
      if (b)
        return b;
      var R = s.displayName || s.name || "";
      return R !== "" ? v + "(" + R + ")" : v;
    }
    function zo(n) {
      return n.displayName || "Context";
    }
    function Ci(n) {
      if (n == null)
        return null;
      if (typeof n.tag == "number" && l("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof n == "function")
        return n.displayName || n.name || null;
      if (typeof n == "string")
        return n;
      switch (n) {
        case Te:
          return "Fragment";
        case Si:
          return "Portal";
        case me:
          return "Profiler";
        case ct:
          return "StrictMode";
        case yn:
          return "Suspense";
        case Rn:
          return "SuspenseList";
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case qe:
            var s = n;
            return zo(s) + ".Consumer";
          case Oe:
            var v = n;
            return zo(v._context) + ".Provider";
          case on:
            return jf(n, n.render, "ForwardRef");
          case mn:
            var b = n.displayName || null;
            return b !== null ? b : Ci(n.type) || "Memo";
          case vn: {
            var R = n, F = R._payload, Y = R._init;
            try {
              return Ci(Y(F));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function cs(n, s, v) {
      var b = s.displayName || s.name || "";
      return n.displayName || (b !== "" ? v + "(" + b + ")" : v);
    }
    function Yf(n) {
      return n.displayName || "Context";
    }
    function xr(n) {
      var s = n.tag, v = n.type;
      switch (s) {
        case Fe:
          return "Cache";
        case B:
          var b = v;
          return Yf(b) + ".Consumer";
        case k:
          var R = v;
          return Yf(R._context) + ".Provider";
        case ie:
          return "DehydratedFragment";
        case V:
          return cs(v, v.render, "ForwardRef");
        case P:
          return "Fragment";
        case C:
          return v;
        case T:
          return "Portal";
        case _:
          return "Root";
        case D:
          return "Text";
        case W:
          return Ci(v);
        case U:
          return v === ct ? "StrictMode" : "Mode";
        case Ee:
          return "Offscreen";
        case I:
          return "Profiler";
        case ce:
          return "Scope";
        case X:
          return "Suspense";
        case pe:
          return "SuspenseList";
        case Ce:
          return "TracingMarker";
        case m:
        case h:
        case ee:
        case S:
        case J:
        case $:
          if (typeof v == "function")
            return v.displayName || v.name || null;
          if (typeof v == "string")
            return v;
          break;
      }
      return null;
    }
    var Eu = t.ReactDebugCurrentFrame, ua = null, Cr = !1;
    function fl() {
      {
        if (ua === null)
          return null;
        var n = ua._debugOwner;
        if (n !== null && typeof n < "u")
          return xr(n);
      }
      return null;
    }
    function yo() {
      return ua === null ? "" : go(ua);
    }
    function Ka() {
      Eu.getCurrentStack = null, ua = null, Cr = !1;
    }
    function Xi(n) {
      Eu.getCurrentStack = n === null ? null : yo, ua = n, Cr = !1;
    }
    function Rm() {
      return ua;
    }
    function mi(n) {
      Cr = n;
    }
    function Qa(n) {
      return "" + n;
    }
    function Sc(n) {
      switch (typeof n) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return n;
        case "object":
          return oe(n), n;
        default:
          return "";
      }
    }
    var dl = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function df(n, s) {
      dl[s.type] || s.onChange || s.onInput || s.readOnly || s.disabled || s.value == null || l("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), s.onChange || s.readOnly || s.disabled || s.checked == null || l("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function hf(n) {
      var s = n.type, v = n.nodeName;
      return v && v.toLowerCase() === "input" && (s === "checkbox" || s === "radio");
    }
    function su(n) {
      return n._valueTracker;
    }
    function Ii(n) {
      n._valueTracker = null;
    }
    function Ri(n) {
      var s = "";
      return n && (hf(n) ? s = n.checked ? "true" : "false" : s = n.value), s;
    }
    function No(n) {
      var s = hf(n) ? "checked" : "value", v = Object.getOwnPropertyDescriptor(n.constructor.prototype, s);
      oe(n[s]);
      var b = "" + n[s];
      if (!(n.hasOwnProperty(s) || typeof v > "u" || typeof v.get != "function" || typeof v.set != "function")) {
        var R = v.get, F = v.set;
        Object.defineProperty(n, s, {
          configurable: !0,
          get: function() {
            return R.call(this);
          },
          set: function(K) {
            oe(K), b = "" + K, F.call(this, K);
          }
        }), Object.defineProperty(n, s, {
          enumerable: v.enumerable
        });
        var Y = {
          getValue: function() {
            return b;
          },
          setValue: function(K) {
            oe(K), b = "" + K;
          },
          stopTracking: function() {
            Ii(n), delete n[s];
          }
        };
        return Y;
      }
    }
    function Ps(n) {
      su(n) || (n._valueTracker = No(n));
    }
    function _c(n) {
      if (!n)
        return !1;
      var s = su(n);
      if (!s)
        return !0;
      var v = s.getValue(), b = Ri(n);
      return b !== v ? (s.setValue(b), !0) : !1;
    }
    function Ll(n) {
      if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
        return null;
      try {
        return n.activeElement || n.body;
      } catch {
        return n.body;
      }
    }
    var Xf = !1, qf = !1, Fo = !1, Qf = !1;
    function Ki(n) {
      var s = n.type === "checkbox" || n.type === "radio";
      return s ? n.checked != null : n.value != null;
    }
    function Mu(n, s) {
      var v = n, b = s.checked, R = Xn({}, s, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: b != null ? b : v._wrapperState.initialChecked
      });
      return R;
    }
    function Oa(n, s) {
      df("input", s), s.checked !== void 0 && s.defaultChecked !== void 0 && !qf && (l("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", fl() || "A component", s.type), qf = !0), s.value !== void 0 && s.defaultValue !== void 0 && !Xf && (l("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", fl() || "A component", s.type), Xf = !0);
      var v = n, b = s.defaultValue == null ? "" : s.defaultValue;
      v._wrapperState = {
        initialChecked: s.checked != null ? s.checked : s.defaultChecked,
        initialValue: Sc(s.value != null ? s.value : b),
        controlled: Ki(s)
      };
    }
    function ys(n, s) {
      var v = n, b = s.checked;
      b != null && ni(v, "checked", b, !1);
    }
    function ou(n, s) {
      var v = n;
      {
        var b = Ki(s);
        !v._wrapperState.controlled && b && !Qf && (l("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Qf = !0), v._wrapperState.controlled && !b && !Fo && (l("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Fo = !0);
      }
      ys(n, s);
      var R = Sc(s.value), F = s.type;
      if (R != null)
        F === "number" ? (R === 0 && v.value === "" || v.value != R) && (v.value = Qa(R)) : v.value !== Qa(R) && (v.value = Qa(R));
      else if (F === "submit" || F === "reset") {
        v.removeAttribute("value");
        return;
      }
      s.hasOwnProperty("value") ? Tu(v, s.type, R) : s.hasOwnProperty("defaultValue") && Tu(v, s.type, Sc(s.defaultValue)), s.checked == null && s.defaultChecked != null && (v.defaultChecked = !!s.defaultChecked);
    }
    function Ua(n, s, v) {
      var b = n;
      if (s.hasOwnProperty("value") || s.hasOwnProperty("defaultValue")) {
        var R = s.type, F = R === "submit" || R === "reset";
        if (F && (s.value === void 0 || s.value === null))
          return;
        var Y = Qa(b._wrapperState.initialValue);
        v || Y !== b.value && (b.value = Y), b.defaultValue = Y;
      }
      var K = b.name;
      K !== "" && (b.name = ""), b.defaultChecked = !b.defaultChecked, b.defaultChecked = !!b._wrapperState.initialChecked, K !== "" && (b.name = K);
    }
    function bc(n, s) {
      var v = n;
      ou(v, s), xo(v, s);
    }
    function xo(n, s) {
      var v = s.name;
      if (s.type === "radio" && v != null) {
        for (var b = n; b.parentNode; )
          b = b.parentNode;
        ft(v, "name");
        for (var R = b.querySelectorAll("input[name=" + JSON.stringify("" + v) + '][type="radio"]'), F = 0; F < R.length; F++) {
          var Y = R[F];
          if (!(Y === n || Y.form !== n.form)) {
            var K = dr(Y);
            if (!K)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            _c(Y), ou(Y, K);
          }
        }
      }
    }
    function Tu(n, s, v) {
      (s !== "number" || Ll(n.ownerDocument) !== n) && (v == null ? n.defaultValue = Qa(n._wrapperState.initialValue) : n.defaultValue !== Qa(v) && (n.defaultValue = Qa(v)));
    }
    var Pl = !1, za = !1, Xs = !1;
    function Jr(n, s) {
      s.value == null && (typeof s.children == "object" && s.children !== null ? a.Children.forEach(s.children, function(v) {
        v != null && (typeof v == "string" || typeof v == "number" || za || (za = !0, l("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : s.dangerouslySetInnerHTML != null && (Xs || (Xs = !0, l("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), s.selected != null && !Pl && (l("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Pl = !0);
    }
    function xs(n, s) {
      s.value != null && n.setAttribute("value", Qa(Sc(s.value)));
    }
    var va = Array.isArray;
    function qs(n) {
      return va(n);
    }
    var Zf;
    Zf = !1;
    function $o() {
      var n = fl();
      return n ? `

Check the render method of \`` + n + "`." : "";
    }
    var Ku = ["value", "defaultValue"];
    function Qh(n) {
      {
        df("select", n);
        for (var s = 0; s < Ku.length; s++) {
          var v = Ku[s];
          if (n[v] != null) {
            var b = qs(n[v]);
            n.multiple && !b ? l("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", v, $o()) : !n.multiple && b && l("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", v, $o());
          }
        }
      }
    }
    function qi(n, s, v, b) {
      var R = n.options;
      if (s) {
        for (var F = v, Y = {}, K = 0; K < F.length; K++)
          Y["$" + F[K]] = !0;
        for (var re = 0; re < R.length; re++) {
          var _e = Y.hasOwnProperty("$" + R[re].value);
          R[re].selected !== _e && (R[re].selected = _e), _e && b && (R[re].defaultSelected = !0);
        }
      } else {
        for (var Re = Qa(Sc(v)), nt = null, $e = 0; $e < R.length; $e++) {
          if (R[$e].value === Re) {
            R[$e].selected = !0, b && (R[$e].defaultSelected = !0);
            return;
          }
          nt === null && !R[$e].disabled && (nt = R[$e]);
        }
        nt !== null && (nt.selected = !0);
      }
    }
    function Cu(n, s) {
      return Xn({}, s, {
        value: void 0
      });
    }
    function Up(n, s) {
      var v = n;
      Qh(s), v._wrapperState = {
        wasMultiple: !!s.multiple
      }, s.value !== void 0 && s.defaultValue !== void 0 && !Zf && (l("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Zf = !0);
    }
    function cg(n, s) {
      var v = n;
      v.multiple = !!s.multiple;
      var b = s.value;
      b != null ? qi(v, !!s.multiple, b, !1) : s.defaultValue != null && qi(v, !!s.multiple, s.defaultValue, !0);
    }
    function Zh(n, s) {
      var v = n, b = v._wrapperState.wasMultiple;
      v._wrapperState.wasMultiple = !!s.multiple;
      var R = s.value;
      R != null ? qi(v, !!s.multiple, R, !1) : b !== !!s.multiple && (s.defaultValue != null ? qi(v, !!s.multiple, s.defaultValue, !0) : qi(v, !!s.multiple, s.multiple ? [] : "", !1));
    }
    function Am(n, s) {
      var v = n, b = s.value;
      b != null && qi(v, !!s.multiple, b, !1);
    }
    var Dm = !1;
    function Lm(n, s) {
      var v = n;
      if (s.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var b = Xn({}, s, {
        value: void 0,
        defaultValue: void 0,
        children: Qa(v._wrapperState.initialValue)
      });
      return b;
    }
    function Pm(n, s) {
      var v = n;
      df("textarea", s), s.value !== void 0 && s.defaultValue !== void 0 && !Dm && (l("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", fl() || "A component"), Dm = !0);
      var b = s.value;
      if (b == null) {
        var R = s.children, F = s.defaultValue;
        if (R != null) {
          l("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (F != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (qs(R)) {
              if (R.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              R = R[0];
            }
            F = R;
          }
        }
        F == null && (F = ""), b = F;
      }
      v._wrapperState = {
        initialValue: Sc(b)
      };
    }
    function vh(n, s) {
      var v = n, b = Sc(s.value), R = Sc(s.defaultValue);
      if (b != null) {
        var F = Qa(b);
        F !== v.value && (v.value = F), s.defaultValue == null && v.defaultValue !== F && (v.defaultValue = F);
      }
      R != null && (v.defaultValue = Qa(R));
    }
    function $u(n, s) {
      var v = n, b = v.textContent;
      b === v._wrapperState.initialValue && b !== "" && b !== null && (v.value = b);
    }
    function Nd(n, s) {
      vh(n, s);
    }
    var Ru = "http://www.w3.org/1999/xhtml", zp = "http://www.w3.org/1998/Math/MathML", hl = "http://www.w3.org/2000/svg";
    function el(n) {
      switch (n) {
        case "svg":
          return hl;
        case "math":
          return zp;
        default:
          return Ru;
      }
    }
    function pf(n, s) {
      return n == null || n === Ru ? el(s) : n === hl && s === "foreignObject" ? Ru : n;
    }
    var Jf = function(n) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(s, v, b, R) {
        MSApp.execUnsafeLocalFunction(function() {
          return n(s, v, b, R);
        });
      } : n;
    }, lu, mf = Jf(function(n, s) {
      if (n.namespaceURI === hl && !("innerHTML" in n)) {
        lu = lu || document.createElement("div"), lu.innerHTML = "<svg>" + s.valueOf().toString() + "</svg>";
        for (var v = lu.firstChild; n.firstChild; )
          n.removeChild(n.firstChild);
        for (; v.firstChild; )
          n.appendChild(v.firstChild);
        return;
      }
      n.innerHTML = s;
    }), Ol = 1, ec = 3, Oi = 8, Za = 9, Ma = 11, ca = function(n, s) {
      if (s) {
        var v = n.firstChild;
        if (v && v === n.lastChild && v.nodeType === ec) {
          v.nodeValue = s;
          return;
        }
      }
      n.textContent = s;
    }, Fd = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, tl = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Om(n, s) {
      return n + s.charAt(0).toUpperCase() + s.substring(1);
    }
    var Um = ["Webkit", "ms", "Moz", "O"];
    Object.keys(tl).forEach(function(n) {
      Um.forEach(function(s) {
        tl[Om(s, n)] = tl[n];
      });
    });
    function gh(n, s, v) {
      var b = s == null || typeof s == "boolean" || s === "";
      return b ? "" : !v && typeof s == "number" && s !== 0 && !(tl.hasOwnProperty(n) && tl[n]) ? s + "px" : (Mt(s, n), ("" + s).trim());
    }
    var Kf = /([A-Z])/g, kd = /^ms-/;
    function Np(n) {
      return n.replace(Kf, "-$1").toLowerCase().replace(kd, "-ms-");
    }
    var yh = function() {
    };
    {
      var Id = /^(?:webkit|moz|o)[A-Z]/, $f = /^-ms-/, Ss = /-(.)/g, tc = /;\s*$/, vf = {}, wc = {}, Fp = !1, nc = !1, Na = function(n) {
        return n.replace(Ss, function(s, v) {
          return v.toUpperCase();
        });
      }, Bd = function(n) {
        vf.hasOwnProperty(n) && vf[n] || (vf[n] = !0, l(
          "Unsupported style property %s. Did you mean %s?",
          n,
          Na(n.replace($f, "ms-"))
        ));
      }, ed = function(n) {
        vf.hasOwnProperty(n) && vf[n] || (vf[n] = !0, l("Unsupported vendor-prefixed style property %s. Did you mean %s?", n, n.charAt(0).toUpperCase() + n.slice(1)));
      }, rc = function(n, s) {
        wc.hasOwnProperty(s) && wc[s] || (wc[s] = !0, l(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, n, s.replace(tc, "")));
      }, kp = function(n, s) {
        Fp || (Fp = !0, l("`NaN` is an invalid value for the `%s` css style property.", n));
      }, xh = function(n, s) {
        nc || (nc = !0, l("`Infinity` is an invalid value for the `%s` css style property.", n));
      };
      yh = function(n, s) {
        n.indexOf("-") > -1 ? Bd(n) : Id.test(n) ? ed(n) : tc.test(s) && rc(n, s), typeof s == "number" && (isNaN(s) ? kp(n, s) : isFinite(s) || xh(n, s));
      };
    }
    var Ip = yh;
    function ko(n) {
      {
        var s = "", v = "";
        for (var b in n)
          if (!!n.hasOwnProperty(b)) {
            var R = n[b];
            if (R != null) {
              var F = b.indexOf("--") === 0;
              s += v + (F ? b : Np(b)) + ":", s += gh(b, R, F), v = ";";
            }
          }
        return s || null;
      }
    }
    function Ye(n, s) {
      var v = n.style;
      for (var b in s)
        if (!!s.hasOwnProperty(b)) {
          var R = b.indexOf("--") === 0;
          R || Ip(b, s[b]);
          var F = gh(b, s[b], R);
          b === "float" && (b = "cssFloat"), R ? v.setProperty(b, F) : v[b] = F;
        }
    }
    function Bt(n) {
      return n == null || typeof n == "boolean" || n === "";
    }
    function pt(n) {
      var s = {};
      for (var v in n)
        for (var b = Fd[v] || [v], R = 0; R < b.length; R++)
          s[b[R]] = v;
      return s;
    }
    function Mn(n, s) {
      {
        if (!s)
          return;
        var v = pt(n), b = pt(s), R = {};
        for (var F in v) {
          var Y = v[F], K = b[F];
          if (K && Y !== K) {
            var re = Y + "," + K;
            if (R[re])
              continue;
            R[re] = !0, l("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Bt(n[Y]) ? "Removing" : "Updating", Y, K);
          }
        }
      }
    }
    var Kn = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
    }, or = Xn({
      menuitem: !0
    }, Kn), Ta = "__html";
    function $n(n, s) {
      if (!!s) {
        if (or[n] && (s.children != null || s.dangerouslySetInnerHTML != null))
          throw new Error(n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (s.dangerouslySetInnerHTML != null) {
          if (s.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof s.dangerouslySetInnerHTML != "object" || !(Ta in s.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!s.suppressContentEditableWarning && s.contentEditable && s.children != null && l("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), s.style != null && typeof s.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Ui(n, s) {
      if (n.indexOf("-") === -1)
        return typeof s.is == "string";
      switch (n) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ra = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Io = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, fs = {}, Hd = new RegExp("^(aria)-[" + xe + "]*$"), Ul = new RegExp("^(aria)[A-Z][" + xe + "]*$");
    function $a(n, s) {
      {
        if (mt.call(fs, s) && fs[s])
          return !0;
        if (Ul.test(s)) {
          var v = "aria-" + s.slice(4).toLowerCase(), b = Io.hasOwnProperty(v) ? v : null;
          if (b == null)
            return l("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", s), fs[s] = !0, !0;
          if (s !== b)
            return l("Invalid ARIA attribute `%s`. Did you mean `%s`?", s, b), fs[s] = !0, !0;
        }
        if (Hd.test(s)) {
          var R = s.toLowerCase(), F = Io.hasOwnProperty(R) ? R : null;
          if (F == null)
            return fs[s] = !0, !1;
          if (s !== F)
            return l("Unknown ARIA attribute `%s`. Did you mean `%s`?", s, F), fs[s] = !0, !0;
        }
      }
      return !0;
    }
    function pl(n, s) {
      {
        var v = [];
        for (var b in s) {
          var R = $a(n, b);
          R || v.push(b);
        }
        var F = v.map(function(Y) {
          return "`" + Y + "`";
        }).join(", ");
        v.length === 1 ? l("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", F, n) : v.length > 1 && l("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", F, n);
      }
    }
    function xi(n, s) {
      Ui(n, s) || pl(n, s);
    }
    var Ec = !1;
    function Au(n, s) {
      {
        if (n !== "input" && n !== "textarea" && n !== "select")
          return;
        s != null && s.value === null && !Ec && (Ec = !0, n === "select" && s.multiple ? l("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", n) : l("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", n));
      }
    }
    var ml = function() {
    };
    {
      var Ca = {}, Sh = /^on./, Bp = /^on[^A-Z]/, Mc = new RegExp("^(aria)-[" + xe + "]*$"), Tc = new RegExp("^(aria)[A-Z][" + xe + "]*$");
      ml = function(n, s, v, b) {
        if (mt.call(Ca, s) && Ca[s])
          return !0;
        var R = s.toLowerCase();
        if (R === "onfocusin" || R === "onfocusout")
          return l("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Ca[s] = !0, !0;
        if (b != null) {
          var F = b.registrationNameDependencies, Y = b.possibleRegistrationNames;
          if (F.hasOwnProperty(s))
            return !0;
          var K = Y.hasOwnProperty(R) ? Y[R] : null;
          if (K != null)
            return l("Invalid event handler property `%s`. Did you mean `%s`?", s, K), Ca[s] = !0, !0;
          if (Sh.test(s))
            return l("Unknown event handler property `%s`. It will be ignored.", s), Ca[s] = !0, !0;
        } else if (Sh.test(s))
          return Bp.test(s) && l("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", s), Ca[s] = !0, !0;
        if (Mc.test(s) || Tc.test(s))
          return !0;
        if (R === "innerhtml")
          return l("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Ca[s] = !0, !0;
        if (R === "aria")
          return l("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Ca[s] = !0, !0;
        if (R === "is" && v !== null && v !== void 0 && typeof v != "string")
          return l("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof v), Ca[s] = !0, !0;
        if (typeof v == "number" && isNaN(v))
          return l("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", s), Ca[s] = !0, !0;
        var re = Gt(s), _e = re !== null && re.type === je;
        if (ra.hasOwnProperty(R)) {
          var Re = ra[R];
          if (Re !== s)
            return l("Invalid DOM property `%s`. Did you mean `%s`?", s, Re), Ca[s] = !0, !0;
        } else if (!_e && s !== R)
          return l("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", s, R), Ca[s] = !0, !0;
        return typeof v == "boolean" && Tt(s, v, re, !1) ? (v ? l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', v, s, s, v, s) : l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', v, s, s, v, s, s, s), Ca[s] = !0, !0) : _e ? !0 : Tt(s, v, re, !1) ? (Ca[s] = !0, !1) : ((v === "false" || v === "true") && re !== null && re.type === Nt && (l("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", v, s, v === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', s, v), Ca[s] = !0), !0);
      };
    }
    var Mr = function(n, s, v) {
      {
        var b = [];
        for (var R in s) {
          var F = ml(n, R, s[R], v);
          F || b.push(R);
        }
        var Y = b.map(function(K) {
          return "`" + K + "`";
        }).join(", ");
        b.length === 1 ? l("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Y, n) : b.length > 1 && l("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", Y, n);
      }
    };
    function $i(n, s, v) {
      Ui(n, s) || Mr(n, s, v);
    }
    var Br = 1, Fa = 1 << 1, So = 1 << 2, td = Br | Fa | So, _h = null;
    function ic(n) {
      _h !== null && l("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), _h = n;
    }
    function gf() {
      _h === null && l("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), _h = null;
    }
    function nd(n) {
      return n === _h;
    }
    function an(n) {
      var s = n.target || n.srcElement || window;
      return s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === ec ? s.parentNode : s;
    }
    var Ir = null, Hr = null, Bo = null;
    function nl(n) {
      var s = Cn(n);
      if (!!s) {
        if (typeof Ir != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var v = s.stateNode;
        if (v) {
          var b = dr(v);
          Ir(s.stateNode, s.type, b);
        }
      }
    }
    function ac(n) {
      Ir = n;
    }
    function Du(n) {
      Hr ? Bo ? Bo.push(n) : Bo = [n] : Hr = n;
    }
    function Cc() {
      return Hr !== null || Bo !== null;
    }
    function yf() {
      if (!!Hr) {
        var n = Hr, s = Bo;
        if (Hr = null, Bo = null, nl(n), s)
          for (var v = 0; v < s.length; v++)
            nl(s[v]);
      }
    }
    var sc = function(n, s) {
      return n(s);
    }, ds = function() {
    }, Qs = !1;
    function zm() {
      var n = Cc();
      n && (ds(), yf());
    }
    function Jh(n, s, v) {
      if (Qs)
        return n(s, v);
      Qs = !0;
      try {
        return sc(n, s, v);
      } finally {
        Qs = !1, zm();
      }
    }
    function Vd(n, s, v) {
      sc = n, ds = v;
    }
    function bh(n) {
      return n === "button" || n === "input" || n === "select" || n === "textarea";
    }
    function xf(n, s, v) {
      switch (n) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(v.disabled && bh(s));
        default:
          return !1;
      }
    }
    function Lu(n, s) {
      var v = n.stateNode;
      if (v === null)
        return null;
      var b = dr(v);
      if (b === null)
        return null;
      var R = b[s];
      if (xf(s, n.type, b))
        return null;
      if (R && typeof R != "function")
        throw new Error("Expected `" + s + "` listener to be a function, instead got a value of `" + typeof R + "` type.");
      return R;
    }
    var rd = !1;
    if (et)
      try {
        var uu = {};
        Object.defineProperty(uu, "passive", {
          get: function() {
            rd = !0;
          }
        }), window.addEventListener("test", uu, uu), window.removeEventListener("test", uu, uu);
      } catch {
        rd = !1;
      }
    function Sf(n, s, v, b, R, F, Y, K, re) {
      var _e = Array.prototype.slice.call(arguments, 3);
      try {
        s.apply(v, _e);
      } catch (Re) {
        this.onError(Re);
      }
    }
    var Rc = Sf;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Gd = document.createElement("react");
      Rc = function(s, v, b, R, F, Y, K, re, _e) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Re = document.createEvent("Event"), nt = !1, $e = !0, Dt = window.event, Lt = Object.getOwnPropertyDescriptor(window, "event");
        function Yt() {
          Gd.removeEventListener(Xt, Dr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Dt);
        }
        var er = Array.prototype.slice.call(arguments, 3);
        function Dr() {
          nt = !0, Yt(), v.apply(b, er), $e = !1;
        }
        var _r, ma = !1, ta = !1;
        function xt(St) {
          if (_r = St.error, ma = !0, _r === null && St.colno === 0 && St.lineno === 0 && (ta = !0), St.defaultPrevented && _r != null && typeof _r == "object")
            try {
              _r._suppressLogging = !0;
            } catch {
            }
        }
        var Xt = "react-" + (s || "invokeguardedcallback");
        if (window.addEventListener("error", xt), Gd.addEventListener(Xt, Dr, !1), Re.initEvent(Xt, !1, !1), Gd.dispatchEvent(Re), Lt && Object.defineProperty(window, "event", Lt), nt && $e && (ma ? ta && (_r = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : _r = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(_r)), window.removeEventListener("error", xt), !nt)
          return Yt(), Sf.apply(this, arguments);
      };
    }
    var id = Rc, Ac = !1, zl = null, Dc = !1, Lc = null, Os = {
      onError: function(n) {
        Ac = !0, zl = n;
      }
    };
    function Pu(n, s, v, b, R, F, Y, K, re) {
      Ac = !1, zl = null, id.apply(Os, arguments);
    }
    function _o(n, s, v, b, R, F, Y, K, re) {
      if (Pu.apply(this, arguments), Ac) {
        var _e = oc();
        Dc || (Dc = !0, Lc = _e);
      }
    }
    function ad() {
      if (Dc) {
        var n = Lc;
        throw Dc = !1, Lc = null, n;
      }
    }
    function ve() {
      return Ac;
    }
    function oc() {
      if (Ac) {
        var n = zl;
        return Ac = !1, zl = null, n;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Zs(n) {
      return n._reactInternals;
    }
    function ka(n) {
      return n._reactInternals !== void 0;
    }
    function Hn(n, s) {
      n._reactInternals = s;
    }
    var vr = 0, Bi = 1, oi = 2, Gn = 4, bi = 16, zi = 32, Pc = 64, Rr = 128, hs = 256, es = 512, Nl = 1024, Ia = 2048, Fl = 4096, _f = 8192, Wd = 16384, Ho = Ia | Gn | Pc | es | Nl | Wd, Sv = 32767, vl = 32768, bo = 65536, Kh = 131072, lc = 1048576, cu = 2097152, _s = 4194304, Oc = 8388608, Vr = 16777216, uc = 33554432, zr = Gn | Nl | 0, Js = oi | Gn | bi | zi | es | Fl | _f, ps = Gn | Pc | es | _f, Uc = Ia | bi, pn = _s | Oc | cu, kl = t.ReactCurrentOwner;
    function wo(n) {
      var s = n, v = n;
      if (n.alternate)
        for (; s.return; )
          s = s.return;
      else {
        var b = s;
        do
          s = b, (s.flags & (oi | Fl)) !== vr && (v = s.return), b = s.return;
        while (b);
      }
      return s.tag === _ ? v : null;
    }
    function Nm(n) {
      if (n.tag === X) {
        var s = n.memoizedState;
        if (s === null) {
          var v = n.alternate;
          v !== null && (s = v.memoizedState);
        }
        if (s !== null)
          return s.dehydrated;
      }
      return null;
    }
    function wh(n) {
      return n.tag === _ ? n.stateNode.containerInfo : null;
    }
    function Ou(n) {
      return wo(n) === n;
    }
    function bs(n) {
      {
        var s = kl.current;
        if (s !== null && s.tag === m) {
          var v = s, b = v.stateNode;
          b._warnedAboutRefsInRender || l("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", xr(v) || "A component"), b._warnedAboutRefsInRender = !0;
        }
      }
      var R = Zs(n);
      return R ? wo(R) === R : !1;
    }
    function gl(n) {
      if (wo(n) !== n)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function ga(n) {
      var s = n.alternate;
      if (!s) {
        var v = wo(n);
        if (v === null)
          throw new Error("Unable to find node on an unmounted component.");
        return v !== n ? null : n;
      }
      for (var b = n, R = s; ; ) {
        var F = b.return;
        if (F === null)
          break;
        var Y = F.alternate;
        if (Y === null) {
          var K = F.return;
          if (K !== null) {
            b = R = K;
            continue;
          }
          break;
        }
        if (F.child === Y.child) {
          for (var re = F.child; re; ) {
            if (re === b)
              return gl(F), n;
            if (re === R)
              return gl(F), s;
            re = re.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (b.return !== R.return)
          b = F, R = Y;
        else {
          for (var _e = !1, Re = F.child; Re; ) {
            if (Re === b) {
              _e = !0, b = F, R = Y;
              break;
            }
            if (Re === R) {
              _e = !0, R = F, b = Y;
              break;
            }
            Re = Re.sibling;
          }
          if (!_e) {
            for (Re = Y.child; Re; ) {
              if (Re === b) {
                _e = !0, b = Y, R = F;
                break;
              }
              if (Re === R) {
                _e = !0, R = Y, b = F;
                break;
              }
              Re = Re.sibling;
            }
            if (!_e)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (b.alternate !== R)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (b.tag !== _)
        throw new Error("Unable to find node on an unmounted component.");
      return b.stateNode.current === b ? n : s;
    }
    function fu(n) {
      var s = ga(n);
      return s !== null ? Us(s) : null;
    }
    function Us(n) {
      if (n.tag === C || n.tag === D)
        return n;
      for (var s = n.child; s !== null; ) {
        var v = Us(s);
        if (v !== null)
          return v;
        s = s.sibling;
      }
      return null;
    }
    function sd(n) {
      var s = ga(n);
      return s !== null ? Il(s) : null;
    }
    function Il(n) {
      if (n.tag === C || n.tag === D)
        return n;
      for (var s = n.child; s !== null; ) {
        if (s.tag !== T) {
          var v = Il(s);
          if (v !== null)
            return v;
        }
        s = s.sibling;
      }
      return null;
    }
    var Vo = e.unstable_scheduleCallback, jd = e.unstable_cancelCallback, rl = e.unstable_shouldYield, zs = e.unstable_requestPaint, fa = e.unstable_now, Uu = e.unstable_getCurrentPriorityLevel, Hp = e.unstable_ImmediatePriority, du = e.unstable_UserBlockingPriority, Bl = e.unstable_NormalPriority, $h = e.unstable_LowPriority, bf = e.unstable_IdlePriority, Ks = e.unstable_yieldValue, Yd = e.unstable_setDisableYieldValue, da = null, Hi = null, wn = null, Qi = !1, ya = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function ep(n) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var s = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (s.isDisabled)
        return !0;
      if (!s.supportsFiber)
        return l("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        st && (n = Xn({}, n, {
          getLaneLabelMap: wf,
          injectProfilingHooks: ns
        })), da = s.inject(n), Hi = s;
      } catch (v) {
        l("React instrumentation encountered an error: %s.", v);
      }
      return !!s.checkDCE;
    }
    function Go(n, s) {
      if (Hi && typeof Hi.onScheduleFiberRoot == "function")
        try {
          Hi.onScheduleFiberRoot(da, n, s);
        } catch (v) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", v));
        }
    }
    function Wo(n, s) {
      if (Hi && typeof Hi.onCommitFiberRoot == "function")
        try {
          var v = (n.current.flags & Rr) === Rr;
          if (Ue) {
            var b;
            switch (s) {
              case Xo:
                b = Hp;
                break;
              case qo:
                b = du;
                break;
              case rs:
                b = Bl;
                break;
              case Wp:
                b = bf;
                break;
              default:
                b = Bl;
                break;
            }
            Hi.onCommitFiberRoot(da, n, b, v);
          }
        } catch (R) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", R));
        }
    }
    function ts(n) {
      if (Hi && typeof Hi.onPostCommitFiberRoot == "function")
        try {
          Hi.onPostCommitFiberRoot(da, n);
        } catch (s) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", s));
        }
    }
    function An(n) {
      if (Hi && typeof Hi.onCommitFiberUnmount == "function")
        try {
          Hi.onCommitFiberUnmount(da, n);
        } catch (s) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", s));
        }
    }
    function xa(n) {
      if (typeof Ks == "function" && (Yd(n), i(n)), Hi && typeof Hi.setStrictMode == "function")
        try {
          Hi.setStrictMode(da, n);
        } catch (s) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", s));
        }
    }
    function ns(n) {
      wn = n;
    }
    function wf() {
      {
        for (var n = /* @__PURE__ */ new Map(), s = 1, v = 0; v < Ai; v++) {
          var b = fg(s);
          n.set(s, b), s *= 2;
        }
        return n;
      }
    }
    function Sa(n) {
      wn !== null && typeof wn.markCommitStarted == "function" && wn.markCommitStarted(n);
    }
    function Kr() {
      wn !== null && typeof wn.markCommitStopped == "function" && wn.markCommitStopped();
    }
    function Ra(n) {
      wn !== null && typeof wn.markComponentRenderStarted == "function" && wn.markComponentRenderStarted(n);
    }
    function Ba() {
      wn !== null && typeof wn.markComponentRenderStopped == "function" && wn.markComponentRenderStopped();
    }
    function ci(n) {
      wn !== null && typeof wn.markComponentPassiveEffectMountStarted == "function" && wn.markComponentPassiveEffectMountStarted(n);
    }
    function Hl() {
      wn !== null && typeof wn.markComponentPassiveEffectMountStopped == "function" && wn.markComponentPassiveEffectMountStopped();
    }
    function od(n) {
      wn !== null && typeof wn.markComponentPassiveEffectUnmountStarted == "function" && wn.markComponentPassiveEffectUnmountStarted(n);
    }
    function ws() {
      wn !== null && typeof wn.markComponentPassiveEffectUnmountStopped == "function" && wn.markComponentPassiveEffectUnmountStopped();
    }
    function Xd(n) {
      wn !== null && typeof wn.markComponentLayoutEffectMountStarted == "function" && wn.markComponentLayoutEffectMountStarted(n);
    }
    function zc() {
      wn !== null && typeof wn.markComponentLayoutEffectMountStopped == "function" && wn.markComponentLayoutEffectMountStopped();
    }
    function cc(n) {
      wn !== null && typeof wn.markComponentLayoutEffectUnmountStarted == "function" && wn.markComponentLayoutEffectUnmountStarted(n);
    }
    function qd() {
      wn !== null && typeof wn.markComponentLayoutEffectUnmountStopped == "function" && wn.markComponentLayoutEffectUnmountStopped();
    }
    function ld(n, s, v) {
      wn !== null && typeof wn.markComponentErrored == "function" && wn.markComponentErrored(n, s, v);
    }
    function il(n, s, v) {
      wn !== null && typeof wn.markComponentSuspended == "function" && wn.markComponentSuspended(n, s, v);
    }
    function Fm(n) {
      wn !== null && typeof wn.markLayoutEffectsStarted == "function" && wn.markLayoutEffectsStarted(n);
    }
    function Ef() {
      wn !== null && typeof wn.markLayoutEffectsStopped == "function" && wn.markLayoutEffectsStopped();
    }
    function Qd(n) {
      wn !== null && typeof wn.markPassiveEffectsStarted == "function" && wn.markPassiveEffectsStarted(n);
    }
    function Mf() {
      wn !== null && typeof wn.markPassiveEffectsStopped == "function" && wn.markPassiveEffectsStopped();
    }
    function Vl(n) {
      wn !== null && typeof wn.markRenderStarted == "function" && wn.markRenderStarted(n);
    }
    function Gl() {
      wn !== null && typeof wn.markRenderYielded == "function" && wn.markRenderYielded();
    }
    function ud() {
      wn !== null && typeof wn.markRenderStopped == "function" && wn.markRenderStopped();
    }
    function Wl(n) {
      wn !== null && typeof wn.markRenderScheduled == "function" && wn.markRenderScheduled(n);
    }
    function Eh(n, s) {
      wn !== null && typeof wn.markForceUpdateScheduled == "function" && wn.markForceUpdateScheduled(n, s);
    }
    function fc(n, s) {
      wn !== null && typeof wn.markStateUpdateScheduled == "function" && wn.markStateUpdateScheduled(n, s);
    }
    var hr = 0, Yr = 1, fr = 2, fi = 8, Ns = 16, jl = Math.clz32 ? Math.clz32 : Eo, Nc = Math.log, Sr = Math.LN2;
    function Eo(n) {
      var s = n >>> 0;
      return s === 0 ? 32 : 31 - (Nc(s) / Sr | 0) | 0;
    }
    var Ai = 31, Ht = 0, vi = 0, lr = 1, Fc = 2, Ha = 4, jo = 8, Di = 16, Tf = 32, Cf = 4194240, Rf = 64, ia = 128, Fs = 256, Af = 512, Zd = 1024, $s = 2048, Yl = 4096, tp = 8192, kc = 16384, Es = 32768, wi = 65536, eo = 131072, Xl = 262144, Ic = 524288, hu = 1048576, Df = 2097152, pu = 130023424, zu = 4194304, Mo = 8388608, Bc = 16777216, cd = 33554432, Yo = 67108864, fd = zu, mu = 134217728, dd = 268435455, Ms = 268435456, ks = 536870912, vu = 1073741824;
    function fg(n) {
      {
        if (n & lr)
          return "Sync";
        if (n & Fc)
          return "InputContinuousHydration";
        if (n & Ha)
          return "InputContinuous";
        if (n & jo)
          return "DefaultHydration";
        if (n & Di)
          return "Default";
        if (n & Tf)
          return "TransitionHydration";
        if (n & Cf)
          return "Transition";
        if (n & pu)
          return "Retry";
        if (n & mu)
          return "SelectiveHydration";
        if (n & Ms)
          return "IdleHydration";
        if (n & ks)
          return "Idle";
        if (n & vu)
          return "Offscreen";
      }
    }
    var ii = -1, Nu = Rf, Lf = zu;
    function dc(n) {
      switch (Tn(n)) {
        case lr:
          return lr;
        case Fc:
          return Fc;
        case Ha:
          return Ha;
        case jo:
          return jo;
        case Di:
          return Di;
        case Tf:
          return Tf;
        case Rf:
        case ia:
        case Fs:
        case Af:
        case Zd:
        case $s:
        case Yl:
        case tp:
        case kc:
        case Es:
        case wi:
        case eo:
        case Xl:
        case Ic:
        case hu:
        case Df:
          return n & Cf;
        case zu:
        case Mo:
        case Bc:
        case cd:
        case Yo:
          return n & pu;
        case mu:
          return mu;
        case Ms:
          return Ms;
        case ks:
          return ks;
        case vu:
          return vu;
        default:
          return l("Should have found matching lanes. This is a bug in React."), n;
      }
    }
    function Pf(n, s) {
      var v = n.pendingLanes;
      if (v === Ht)
        return Ht;
      var b = Ht, R = n.suspendedLanes, F = n.pingedLanes, Y = v & dd;
      if (Y !== Ht) {
        var K = Y & ~R;
        if (K !== Ht)
          b = dc(K);
        else {
          var re = Y & F;
          re !== Ht && (b = dc(re));
        }
      } else {
        var _e = v & ~R;
        _e !== Ht ? b = dc(_e) : F !== Ht && (b = dc(F));
      }
      if (b === Ht)
        return Ht;
      if (s !== Ht && s !== b && (s & R) === Ht) {
        var Re = Tn(b), nt = Tn(s);
        if (Re >= nt || Re === Di && (nt & Cf) !== Ht)
          return s;
      }
      (b & Ha) !== Ht && (b |= v & Di);
      var $e = n.entangledLanes;
      if ($e !== Ht)
        for (var Dt = n.entanglements, Lt = b & $e; Lt > 0; ) {
          var Yt = ms(Lt), er = 1 << Yt;
          b |= Dt[Yt], Lt &= ~er;
        }
      return b;
    }
    function Vp(n, s) {
      for (var v = n.eventTimes, b = ii; s > 0; ) {
        var R = ms(s), F = 1 << R, Y = v[R];
        Y > b && (b = Y), s &= ~F;
      }
      return b;
    }
    function y(n, s) {
      switch (n) {
        case lr:
        case Fc:
        case Ha:
          return s + 250;
        case jo:
        case Di:
        case Tf:
        case Rf:
        case ia:
        case Fs:
        case Af:
        case Zd:
        case $s:
        case Yl:
        case tp:
        case kc:
        case Es:
        case wi:
        case eo:
        case Xl:
        case Ic:
        case hu:
        case Df:
          return s + 5e3;
        case zu:
        case Mo:
        case Bc:
        case cd:
        case Yo:
          return ii;
        case mu:
        case Ms:
        case ks:
        case vu:
          return ii;
        default:
          return l("Should have found matching lanes. This is a bug in React."), ii;
      }
    }
    function x(n, s) {
      for (var v = n.pendingLanes, b = n.suspendedLanes, R = n.pingedLanes, F = n.expirationTimes, Y = v; Y > 0; ) {
        var K = ms(Y), re = 1 << K, _e = F[K];
        _e === ii ? ((re & b) === Ht || (re & R) !== Ht) && (F[K] = y(re, s)) : _e <= s && (n.expiredLanes |= re), Y &= ~re;
      }
    }
    function L(n) {
      return dc(n.pendingLanes);
    }
    function H(n) {
      var s = n.pendingLanes & ~vu;
      return s !== Ht ? s : s & vu ? vu : Ht;
    }
    function q(n) {
      return (n & lr) !== Ht;
    }
    function te(n) {
      return (n & dd) !== Ht;
    }
    function Ae(n) {
      return (n & pu) === n;
    }
    function Ke(n) {
      var s = lr | Ha | Di;
      return (n & s) === Ht;
    }
    function kt(n) {
      return (n & Cf) === n;
    }
    function cn(n, s) {
      var v = Fc | Ha | jo | Di;
      return (s & v) !== Ht;
    }
    function bn(n, s) {
      return (s & n.expiredLanes) !== Ht;
    }
    function wr(n) {
      return (n & Cf) !== Ht;
    }
    function ur() {
      var n = Nu;
      return Nu <<= 1, (Nu & Cf) === Ht && (Nu = Rf), n;
    }
    function _a() {
      var n = Lf;
      return Lf <<= 1, (Lf & pu) === Ht && (Lf = zu), n;
    }
    function Tn(n) {
      return n & -n;
    }
    function Li(n) {
      return Tn(n);
    }
    function ms(n) {
      return 31 - jl(n);
    }
    function dt(n) {
      return ms(n);
    }
    function Qe(n, s) {
      return (n & s) !== Ht;
    }
    function At(n, s) {
      return (n & s) === s;
    }
    function qt(n, s) {
      return n | s;
    }
    function Wn(n, s) {
      return n & ~s;
    }
    function Xr(n, s) {
      return n & s;
    }
    function Er(n) {
      return n;
    }
    function Ar(n, s) {
      return n !== vi && n < s ? n : s;
    }
    function Va(n) {
      for (var s = [], v = 0; v < Ai; v++)
        s.push(n);
      return s;
    }
    function $r(n, s, v) {
      n.pendingLanes |= s, s !== ks && (n.suspendedLanes = Ht, n.pingedLanes = Ht);
      var b = n.eventTimes, R = dt(s);
      b[R] = v;
    }
    function hc(n, s) {
      n.suspendedLanes |= s, n.pingedLanes &= ~s;
      for (var v = n.expirationTimes, b = s; b > 0; ) {
        var R = ms(b), F = 1 << R;
        v[R] = ii, b &= ~F;
      }
    }
    function hd(n, s, v) {
      n.pingedLanes |= n.suspendedLanes & s;
    }
    function np(n, s) {
      var v = n.pendingLanes & ~s;
      n.pendingLanes = s, n.suspendedLanes = Ht, n.pingedLanes = Ht, n.expiredLanes &= s, n.mutableReadLanes &= s, n.entangledLanes &= s;
      for (var b = n.entanglements, R = n.eventTimes, F = n.expirationTimes, Y = v; Y > 0; ) {
        var K = ms(Y), re = 1 << K;
        b[K] = Ht, R[K] = ii, F[K] = ii, Y &= ~re;
      }
    }
    function gr(n, s) {
      for (var v = n.entangledLanes |= s, b = n.entanglements, R = v; R; ) {
        var F = ms(R), Y = 1 << F;
        Y & s | b[F] & s && (b[F] |= s), R &= ~Y;
      }
    }
    function Gp(n, s) {
      var v = Tn(s), b;
      switch (v) {
        case Ha:
          b = Fc;
          break;
        case Di:
          b = jo;
          break;
        case Rf:
        case ia:
        case Fs:
        case Af:
        case Zd:
        case $s:
        case Yl:
        case tp:
        case kc:
        case Es:
        case wi:
        case eo:
        case Xl:
        case Ic:
        case hu:
        case Df:
        case zu:
        case Mo:
        case Bc:
        case cd:
        case Yo:
          b = Tf;
          break;
        case ks:
          b = Ms;
          break;
        default:
          b = vi;
          break;
      }
      return (b & (n.suspendedLanes | s)) !== vi ? vi : b;
    }
    function km(n, s, v) {
      if (!!ya)
        for (var b = n.pendingUpdatersLaneMap; v > 0; ) {
          var R = dt(v), F = 1 << R, Y = b[R];
          Y.add(s), v &= ~F;
        }
    }
    function Of(n, s) {
      if (!!ya)
        for (var v = n.pendingUpdatersLaneMap, b = n.memoizedUpdaters; s > 0; ) {
          var R = dt(s), F = 1 << R, Y = v[R];
          Y.size > 0 && (Y.forEach(function(K) {
            var re = K.alternate;
            (re === null || !b.has(re)) && b.add(K);
          }), Y.clear()), s &= ~F;
        }
    }
    function dg(n, s) {
      return null;
    }
    var Xo = lr, qo = Ha, rs = Di, Wp = ks, Mh = vi;
    function pc() {
      return Mh;
    }
    function to(n) {
      Mh = n;
    }
    function rp(n, s) {
      var v = Mh;
      try {
        return Mh = n, s();
      } finally {
        Mh = v;
      }
    }
    function yl(n, s) {
      return n !== 0 && n < s ? n : s;
    }
    function xy(n, s) {
      return n === 0 || n > s ? n : s;
    }
    function hg(n, s) {
      return n !== 0 && n < s;
    }
    function Fu(n) {
      var s = Tn(n);
      return hg(Xo, s) ? hg(qo, s) ? te(s) ? rs : Wp : qo : Xo;
    }
    function Vi(n) {
      var s = n.current.memoizedState;
      return s.isDehydrated;
    }
    var _v;
    function Jn(n) {
      _v = n;
    }
    function Th(n) {
      _v(n);
    }
    var Im;
    function z0(n) {
      Im = n;
    }
    var jp;
    function ip(n) {
      jp = n;
    }
    var Bm;
    function Sy(n) {
      Bm = n;
    }
    var ap;
    function Yp(n) {
      ap = n;
    }
    var Xp = !1, Jd = [], no = null, Gi = null, is = null, To = /* @__PURE__ */ new Map(), xl = /* @__PURE__ */ new Map(), pd = [], Uf = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function _y(n) {
      return Uf.indexOf(n) > -1;
    }
    function al(n, s, v, b, R) {
      return {
        blockedOn: n,
        domEventName: s,
        eventSystemFlags: v,
        nativeEvent: R,
        targetContainers: [b]
      };
    }
    function pg(n, s) {
      switch (n) {
        case "focusin":
        case "focusout":
          no = null;
          break;
        case "dragenter":
        case "dragleave":
          Gi = null;
          break;
        case "mouseover":
        case "mouseout":
          is = null;
          break;
        case "pointerover":
        case "pointerout": {
          var v = s.pointerId;
          To.delete(v);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var b = s.pointerId;
          xl.delete(b);
          break;
        }
      }
    }
    function ql(n, s, v, b, R, F) {
      if (n === null || n.nativeEvent !== F) {
        var Y = al(s, v, b, R, F);
        if (s !== null) {
          var K = Cn(s);
          K !== null && Im(K);
        }
        return Y;
      }
      n.eventSystemFlags |= b;
      var re = n.targetContainers;
      return R !== null && re.indexOf(R) === -1 && re.push(R), n;
    }
    function md(n, s, v, b, R) {
      switch (s) {
        case "focusin": {
          var F = R;
          return no = ql(no, n, s, v, b, F), !0;
        }
        case "dragenter": {
          var Y = R;
          return Gi = ql(Gi, n, s, v, b, Y), !0;
        }
        case "mouseover": {
          var K = R;
          return is = ql(is, n, s, v, b, K), !0;
        }
        case "pointerover": {
          var re = R, _e = re.pointerId;
          return To.set(_e, ql(To.get(_e) || null, n, s, v, b, re)), !0;
        }
        case "gotpointercapture": {
          var Re = R, nt = Re.pointerId;
          return xl.set(nt, ql(xl.get(nt) || null, n, s, v, b, Re)), !0;
        }
      }
      return !1;
    }
    function by(n) {
      var s = sn(n.target);
      if (s !== null) {
        var v = wo(s);
        if (v !== null) {
          var b = v.tag;
          if (b === X) {
            var R = Nm(v);
            if (R !== null) {
              n.blockedOn = R, ap(n.priority, function() {
                jp(v);
              });
              return;
            }
          } else if (b === _) {
            var F = v.stateNode;
            if (Vi(F)) {
              n.blockedOn = wh(v);
              return;
            }
          }
        }
      }
      n.blockedOn = null;
    }
    function bv(n) {
      for (var s = Bm(), v = {
        blockedOn: null,
        target: n,
        priority: s
      }, b = 0; b < pd.length && hg(s, pd[b].priority); b++)
        ;
      pd.splice(b, 0, v), b === 0 && by(v);
    }
    function mg(n) {
      if (n.blockedOn !== null)
        return !1;
      for (var s = n.targetContainers; s.length > 0; ) {
        var v = s[0], b = op(n.domEventName, n.eventSystemFlags, v, n.nativeEvent);
        if (b === null) {
          var R = n.nativeEvent, F = new R.constructor(R.type, R);
          ic(F), R.target.dispatchEvent(F), gf();
        } else {
          var Y = Cn(b);
          return Y !== null && Im(Y), n.blockedOn = b, !1;
        }
        s.shift();
      }
      return !0;
    }
    function wv(n, s, v) {
      mg(n) && v.delete(s);
    }
    function Ch() {
      Xp = !1, no !== null && mg(no) && (no = null), Gi !== null && mg(Gi) && (Gi = null), is !== null && mg(is) && (is = null), To.forEach(wv), xl.forEach(wv);
    }
    function aa(n, s) {
      n.blockedOn === s && (n.blockedOn = null, Xp || (Xp = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Ch)));
    }
    function Nr(n) {
      if (Jd.length > 0) {
        aa(Jd[0], n);
        for (var s = 1; s < Jd.length; s++) {
          var v = Jd[s];
          v.blockedOn === n && (v.blockedOn = null);
        }
      }
      no !== null && aa(no, n), Gi !== null && aa(Gi, n), is !== null && aa(is, n);
      var b = function(K) {
        return aa(K, n);
      };
      To.forEach(b), xl.forEach(b);
      for (var R = 0; R < pd.length; R++) {
        var F = pd[R];
        F.blockedOn === n && (F.blockedOn = null);
      }
      for (; pd.length > 0; ) {
        var Y = pd[0];
        if (Y.blockedOn !== null)
          break;
        by(Y), Y.blockedOn === null && pd.shift();
      }
    }
    var ea = t.ReactCurrentBatchConfig, Ga = !0;
    function vs(n) {
      Ga = !!n;
    }
    function Hc() {
      return Ga;
    }
    function Hm(n, s, v) {
      var b = gu(s), R;
      switch (b) {
        case Xo:
          R = sl;
          break;
        case qo:
          R = Vm;
          break;
        case rs:
        default:
          R = vd;
          break;
      }
      return R.bind(null, s, v, n);
    }
    function sl(n, s, v, b) {
      var R = pc(), F = ea.transition;
      ea.transition = null;
      try {
        to(Xo), vd(n, s, v, b);
      } finally {
        to(R), ea.transition = F;
      }
    }
    function Vm(n, s, v, b) {
      var R = pc(), F = ea.transition;
      ea.transition = null;
      try {
        to(qo), vd(n, s, v, b);
      } finally {
        to(R), ea.transition = F;
      }
    }
    function vd(n, s, v, b) {
      !Ga || Gm(n, s, v, b);
    }
    function Gm(n, s, v, b) {
      var R = op(n, s, v, b);
      if (R === null) {
        Fr(n, s, b, sp, v), pg(n, b);
        return;
      }
      if (md(R, n, s, v, b)) {
        b.stopPropagation();
        return;
      }
      if (pg(n, b), s & So && _y(n)) {
        for (; R !== null; ) {
          var F = Cn(R);
          F !== null && Th(F);
          var Y = op(n, s, v, b);
          if (Y === null && Fr(n, s, b, sp, v), Y === R)
            break;
          R = Y;
        }
        R !== null && b.stopPropagation();
        return;
      }
      Fr(n, s, b, null, v);
    }
    var sp = null;
    function op(n, s, v, b) {
      sp = null;
      var R = an(b), F = sn(R);
      if (F !== null) {
        var Y = wo(F);
        if (Y === null)
          F = null;
        else {
          var K = Y.tag;
          if (K === X) {
            var re = Nm(Y);
            if (re !== null)
              return re;
            F = null;
          } else if (K === _) {
            var _e = Y.stateNode;
            if (Vi(_e))
              return wh(Y);
            F = null;
          } else
            Y !== F && (F = null);
        }
      }
      return sp = F, null;
    }
    function gu(n) {
      switch (n) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Xo;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return qo;
        case "message": {
          var s = Uu();
          switch (s) {
            case Hp:
              return Xo;
            case du:
              return qo;
            case Bl:
            case $h:
              return rs;
            case bf:
              return Wp;
            default:
              return rs;
          }
        }
        default:
          return rs;
      }
    }
    function Wm(n, s, v) {
      return n.addEventListener(s, v, !1), v;
    }
    function lp(n, s, v) {
      return n.addEventListener(s, v, !0), v;
    }
    function gd(n, s, v, b) {
      return n.addEventListener(s, v, {
        capture: !0,
        passive: b
      }), v;
    }
    function vg(n, s, v, b) {
      return n.addEventListener(s, v, {
        passive: b
      }), v;
    }
    var qp = null, Kd = null, up = null;
    function Qo(n) {
      return qp = n, Kd = Ev(), !0;
    }
    function cp() {
      qp = null, Kd = null, up = null;
    }
    function jm() {
      if (up)
        return up;
      var n, s = Kd, v = s.length, b, R = Ev(), F = R.length;
      for (n = 0; n < v && s[n] === R[n]; n++)
        ;
      var Y = v - n;
      for (b = 1; b <= Y && s[v - b] === R[F - b]; b++)
        ;
      var K = b > 1 ? 1 - b : void 0;
      return up = R.slice(n, K), up;
    }
    function Ev() {
      return "value" in qp ? qp.value : qp.textContent;
    }
    function Vc(n) {
      var s, v = n.keyCode;
      return "charCode" in n ? (s = n.charCode, s === 0 && v === 13 && (s = 13)) : s = v, s === 10 && (s = 13), s >= 32 || s === 13 ? s : 0;
    }
    function fp() {
      return !0;
    }
    function ha() {
      return !1;
    }
    function ro(n) {
      function s(v, b, R, F, Y) {
        this._reactName = v, this._targetInst = R, this.type = b, this.nativeEvent = F, this.target = Y, this.currentTarget = null;
        for (var K in n)
          if (!!n.hasOwnProperty(K)) {
            var re = n[K];
            re ? this[K] = re(F) : this[K] = F[K];
          }
        var _e = F.defaultPrevented != null ? F.defaultPrevented : F.returnValue === !1;
        return _e ? this.isDefaultPrevented = fp : this.isDefaultPrevented = ha, this.isPropagationStopped = ha, this;
      }
      return Xn(s.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var v = this.nativeEvent;
          !v || (v.preventDefault ? v.preventDefault() : typeof v.returnValue != "unknown" && (v.returnValue = !1), this.isDefaultPrevented = fp);
        },
        stopPropagation: function() {
          var v = this.nativeEvent;
          !v || (v.stopPropagation ? v.stopPropagation() : typeof v.cancelBubble != "unknown" && (v.cancelBubble = !0), this.isPropagationStopped = fp);
        },
        persist: function() {
        },
        isPersistent: fp
      }), s;
    }
    var Sl = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Zo = ro(Sl), dp = Xn({}, Sl, {
      view: 0,
      detail: 0
    }), Mv = ro(dp), Qp, gg, yu;
    function Tv(n) {
      n !== yu && (yu && n.type === "mousemove" ? (Qp = n.screenX - yu.screenX, gg = n.screenY - yu.screenY) : (Qp = 0, gg = 0), yu = n);
    }
    var Rh = Xn({}, dp, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Sg,
      button: 0,
      buttons: 0,
      relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
      },
      movementX: function(n) {
        return "movementX" in n ? n.movementX : (Tv(n), Qp);
      },
      movementY: function(n) {
        return "movementY" in n ? n.movementY : gg;
      }
    }), Ah = ro(Rh), yg = Xn({}, Rh, {
      dataTransfer: 0
    }), zf = ro(yg), wy = Xn({}, dp, {
      relatedTarget: 0
    }), xg = ro(wy), Ey = Xn({}, Sl, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), hp = ro(Ey), pp = Xn({}, Sl, {
      clipboardData: function(n) {
        return "clipboardData" in n ? n.clipboardData : window.clipboardData;
      }
    }), Cv = ro(pp), Rv = Xn({}, Sl, {
      data: 0
    }), Ym = ro(Rv), Dh = Ym, My = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Gc = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Zp(n) {
      if (n.key) {
        var s = My[n.key] || n.key;
        if (s !== "Unidentified")
          return s;
      }
      if (n.type === "keypress") {
        var v = Vc(n);
        return v === 13 ? "Enter" : String.fromCharCode(v);
      }
      return n.type === "keydown" || n.type === "keyup" ? Gc[n.keyCode] || "Unidentified" : "";
    }
    var Is = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Ty(n) {
      var s = this, v = s.nativeEvent;
      if (v.getModifierState)
        return v.getModifierState(n);
      var b = Is[n];
      return b ? !!v[b] : !1;
    }
    function Sg(n) {
      return Ty;
    }
    var N0 = Xn({}, dp, {
      key: Zp,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Sg,
      charCode: function(n) {
        return n.type === "keypress" ? Vc(n) : 0;
      },
      keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      },
      which: function(n) {
        return n.type === "keypress" ? Vc(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      }
    }), F0 = ro(N0), Xm = Xn({}, Rh, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Wc = ro(Xm), Cy = Xn({}, dp, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Sg
    }), _l = ro(Cy), Av = Xn({}, Sl, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), _g = ro(Av), ku = Xn({}, Rh, {
      deltaX: function(n) {
        return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
      },
      deltaY: function(n) {
        return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Lh = ro(ku), Jp = [9, 13, 27, 32], mp = 229, mc = et && "CompositionEvent" in window, Aa = null;
    et && "documentMode" in document && (Aa = document.documentMode);
    var vp = et && "TextEvent" in window && !Aa, Ts = et && (!mc || Aa && Aa > 8 && Aa <= 11), bl = 32, Dv = String.fromCharCode(bl);
    function bg() {
      Ot("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Ot("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Ot("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Ot("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Lv = !1;
    function On(n) {
      return (n.ctrlKey || n.altKey || n.metaKey) && !(n.ctrlKey && n.altKey);
    }
    function Iu(n) {
      switch (n) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Pv(n, s) {
      return n === "keydown" && s.keyCode === mp;
    }
    function Kp(n, s) {
      switch (n) {
        case "keyup":
          return Jp.indexOf(s.keyCode) !== -1;
        case "keydown":
          return s.keyCode !== mp;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Ph(n) {
      var s = n.detail;
      return typeof s == "object" && "data" in s ? s.data : null;
    }
    function sa(n) {
      return n.locale === "ko";
    }
    var Cs = !1;
    function Co(n, s, v, b, R) {
      var F, Y;
      if (mc ? F = Iu(s) : Cs ? Kp(s, b) && (F = "onCompositionEnd") : Pv(s, b) && (F = "onCompositionStart"), !F)
        return null;
      Ts && !sa(b) && (!Cs && F === "onCompositionStart" ? Cs = Qo(R) : F === "onCompositionEnd" && Cs && (Y = jm()));
      var K = qr(v, F);
      if (K.length > 0) {
        var re = new Ym(F, s, null, b, R);
        if (n.push({
          event: re,
          listeners: K
        }), Y)
          re.data = Y;
        else {
          var _e = Ph(b);
          _e !== null && (re.data = _e);
        }
      }
    }
    function $p(n, s) {
      switch (n) {
        case "compositionend":
          return Ph(s);
        case "keypress":
          var v = s.which;
          return v !== bl ? null : (Lv = !0, Dv);
        case "textInput":
          var b = s.data;
          return b === Dv && Lv ? null : b;
        default:
          return null;
      }
    }
    function qm(n, s) {
      if (Cs) {
        if (n === "compositionend" || !mc && Kp(n, s)) {
          var v = jm();
          return cp(), Cs = !1, v;
        }
        return null;
      }
      switch (n) {
        case "paste":
          return null;
        case "keypress":
          if (!On(s)) {
            if (s.char && s.char.length > 1)
              return s.char;
            if (s.which)
              return String.fromCharCode(s.which);
          }
          return null;
        case "compositionend":
          return Ts && !sa(s) ? null : s.data;
        default:
          return null;
      }
    }
    function gp(n, s, v, b, R) {
      var F;
      if (vp ? F = $p(s, b) : F = qm(s, b), !F)
        return null;
      var Y = qr(v, "onBeforeInput");
      if (Y.length > 0) {
        var K = new Dh("onBeforeInput", "beforeinput", null, b, R);
        n.push({
          event: K,
          listeners: Y
        }), K.data = F;
      }
    }
    function wg(n, s, v, b, R, F, Y) {
      Co(n, s, v, b, R), gp(n, s, v, b, R);
    }
    var u1 = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Wt(n) {
      var s = n && n.nodeName && n.nodeName.toLowerCase();
      return s === "input" ? !!u1[n.type] : s === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function Nf(n) {
      if (!et)
        return !1;
      var s = "on" + n, v = s in document;
      if (!v) {
        var b = document.createElement("div");
        b.setAttribute(s, "return;"), v = typeof b[s] == "function";
      }
      return v;
    }
    function yd() {
      Ot("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function c(n, s, v, b) {
      Du(b);
      var R = qr(s, "onChange");
      if (R.length > 0) {
        var F = new Zo("onChange", "change", null, v, b);
        n.push({
          event: F,
          listeners: R
        });
      }
    }
    var p = null, E = null;
    function O(n) {
      var s = n.nodeName && n.nodeName.toLowerCase();
      return s === "select" || s === "input" && n.type === "file";
    }
    function G(n) {
      var s = [];
      c(s, E, n, an(n)), Jh(Q, s);
    }
    function Q(n) {
      q0(n, 0);
    }
    function le(n) {
      var s = Ln(n);
      if (_c(s))
        return n;
    }
    function Le(n, s) {
      if (n === "change")
        return s;
    }
    var Ve = !1;
    et && (Ve = Nf("input") && (!document.documentMode || document.documentMode > 9));
    function Ct(n, s) {
      p = n, E = s, p.attachEvent("onpropertychange", ln);
    }
    function un() {
      !p || (p.detachEvent("onpropertychange", ln), p = null, E = null);
    }
    function ln(n) {
      n.propertyName === "value" && le(E) && G(n);
    }
    function nn(n, s, v) {
      n === "focusin" ? (un(), Ct(s, v)) : n === "focusout" && un();
    }
    function kn(n, s) {
      if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return le(E);
    }
    function qn(n) {
      var s = n.nodeName;
      return s && s.toLowerCase() === "input" && (n.type === "checkbox" || n.type === "radio");
    }
    function rr(n, s) {
      if (n === "click")
        return le(s);
    }
    function Bs(n, s) {
      if (n === "input" || n === "change")
        return le(s);
    }
    function ht(n) {
      var s = n._wrapperState;
      !s || !s.controlled || n.type !== "number" || Tu(n, "number", n.value);
    }
    function Ze(n, s, v, b, R, F, Y) {
      var K = v ? Ln(v) : window, re, _e;
      if (O(K) ? re = Le : Wt(K) ? Ve ? re = Bs : (re = kn, _e = nn) : qn(K) && (re = rr), re) {
        var Re = re(s, v);
        if (Re) {
          c(n, Re, b, R);
          return;
        }
      }
      _e && _e(s, K, v), s === "focusout" && ht(K);
    }
    function gt() {
      He("onMouseEnter", ["mouseout", "mouseover"]), He("onMouseLeave", ["mouseout", "mouseover"]), He("onPointerEnter", ["pointerout", "pointerover"]), He("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function xn(n, s, v, b, R, F, Y) {
      var K = s === "mouseover" || s === "pointerover", re = s === "mouseout" || s === "pointerout";
      if (K && !nd(b)) {
        var _e = b.relatedTarget || b.fromElement;
        if (_e && (sn(_e) || Kt(_e)))
          return;
      }
      if (!(!re && !K)) {
        var Re;
        if (R.window === R)
          Re = R;
        else {
          var nt = R.ownerDocument;
          nt ? Re = nt.defaultView || nt.parentWindow : Re = window;
        }
        var $e, Dt;
        if (re) {
          var Lt = b.relatedTarget || b.toElement;
          if ($e = v, Dt = Lt ? sn(Lt) : null, Dt !== null) {
            var Yt = wo(Dt);
            (Dt !== Yt || Dt.tag !== C && Dt.tag !== D) && (Dt = null);
          }
        } else
          $e = null, Dt = v;
        if ($e !== Dt) {
          var er = Ah, Dr = "onMouseLeave", _r = "onMouseEnter", ma = "mouse";
          (s === "pointerout" || s === "pointerover") && (er = Wc, Dr = "onPointerLeave", _r = "onPointerEnter", ma = "pointer");
          var ta = $e == null ? Re : Ln($e), xt = Dt == null ? Re : Ln(Dt), Xt = new er(Dr, ma + "leave", $e, b, R);
          Xt.target = ta, Xt.relatedTarget = xt;
          var St = null, gn = sn(R);
          if (gn === v) {
            var tr = new er(_r, ma + "enter", Dt, b, R);
            tr.target = xt, tr.relatedTarget = ta, St = tr;
          }
          Z0(n, Xt, St, $e, Dt);
        }
      }
    }
    function ar(n, s) {
      return n === s && (n !== 0 || 1 / n === 1 / s) || n !== n && s !== s;
    }
    var Qn = typeof Object.is == "function" ? Object.is : ar;
    function pr(n, s) {
      if (Qn(n, s))
        return !0;
      if (typeof n != "object" || n === null || typeof s != "object" || s === null)
        return !1;
      var v = Object.keys(n), b = Object.keys(s);
      if (v.length !== b.length)
        return !1;
      for (var R = 0; R < v.length; R++) {
        var F = v[R];
        if (!mt.call(s, F) || !Qn(n[F], s[F]))
          return !1;
      }
      return !0;
    }
    function Lr(n) {
      for (; n && n.firstChild; )
        n = n.firstChild;
      return n;
    }
    function ol(n) {
      for (; n; ) {
        if (n.nextSibling)
          return n.nextSibling;
        n = n.parentNode;
      }
    }
    function Zi(n, s) {
      for (var v = Lr(n), b = 0, R = 0; v; ) {
        if (v.nodeType === ec) {
          if (R = b + v.textContent.length, b <= s && R >= s)
            return {
              node: v,
              offset: s - b
            };
          b = R;
        }
        v = Lr(ol(v));
      }
    }
    function Ff(n) {
      var s = n.ownerDocument, v = s && s.defaultView || window, b = v.getSelection && v.getSelection();
      if (!b || b.rangeCount === 0)
        return null;
      var R = b.anchorNode, F = b.anchorOffset, Y = b.focusNode, K = b.focusOffset;
      try {
        R.nodeType, Y.nodeType;
      } catch {
        return null;
      }
      return Eg(n, R, F, Y, K);
    }
    function Eg(n, s, v, b, R) {
      var F = 0, Y = -1, K = -1, re = 0, _e = 0, Re = n, nt = null;
      e:
        for (; ; ) {
          for (var $e = null; Re === s && (v === 0 || Re.nodeType === ec) && (Y = F + v), Re === b && (R === 0 || Re.nodeType === ec) && (K = F + R), Re.nodeType === ec && (F += Re.nodeValue.length), ($e = Re.firstChild) !== null; )
            nt = Re, Re = $e;
          for (; ; ) {
            if (Re === n)
              break e;
            if (nt === s && ++re === v && (Y = F), nt === b && ++_e === R && (K = F), ($e = Re.nextSibling) !== null)
              break;
            Re = nt, nt = Re.parentNode;
          }
          Re = $e;
        }
      return Y === -1 || K === -1 ? null : {
        start: Y,
        end: K
      };
    }
    function k0(n, s) {
      var v = n.ownerDocument || document, b = v && v.defaultView || window;
      if (!!b.getSelection) {
        var R = b.getSelection(), F = n.textContent.length, Y = Math.min(s.start, F), K = s.end === void 0 ? Y : Math.min(s.end, F);
        if (!R.extend && Y > K) {
          var re = K;
          K = Y, Y = re;
        }
        var _e = Zi(n, Y), Re = Zi(n, K);
        if (_e && Re) {
          if (R.rangeCount === 1 && R.anchorNode === _e.node && R.anchorOffset === _e.offset && R.focusNode === Re.node && R.focusOffset === Re.offset)
            return;
          var nt = v.createRange();
          nt.setStart(_e.node, _e.offset), R.removeAllRanges(), Y > K ? (R.addRange(nt), R.extend(Re.node, Re.offset)) : (nt.setEnd(Re.node, Re.offset), R.addRange(nt));
        }
      }
    }
    function Mg(n) {
      return n && n.nodeType === ec;
    }
    function I0(n, s) {
      return !n || !s ? !1 : n === s ? !0 : Mg(n) ? !1 : Mg(s) ? I0(n, s.parentNode) : "contains" in n ? n.contains(s) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(s) & 16) : !1;
    }
    function B0(n) {
      return n && n.ownerDocument && I0(n.ownerDocument.documentElement, n);
    }
    function Ry(n) {
      try {
        return typeof n.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function Ay() {
      for (var n = window, s = Ll(); s instanceof n.HTMLIFrameElement; ) {
        if (Ry(s))
          n = s.contentWindow;
        else
          return s;
        s = Ll(n.document);
      }
      return s;
    }
    function Ov(n) {
      var s = n && n.nodeName && n.nodeName.toLowerCase();
      return s && (s === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || s === "textarea" || n.contentEditable === "true");
    }
    function Bu() {
      var n = Ay();
      return {
        focusedElem: n,
        selectionRange: Ov(n) ? H0(n) : null
      };
    }
    function c1(n) {
      var s = Ay(), v = n.focusedElem, b = n.selectionRange;
      if (s !== v && B0(v)) {
        b !== null && Ov(v) && em(v, b);
        for (var R = [], F = v; F = F.parentNode; )
          F.nodeType === Ol && R.push({
            element: F,
            left: F.scrollLeft,
            top: F.scrollTop
          });
        typeof v.focus == "function" && v.focus();
        for (var Y = 0; Y < R.length; Y++) {
          var K = R[Y];
          K.element.scrollLeft = K.left, K.element.scrollTop = K.top;
        }
      }
    }
    function H0(n) {
      var s;
      return "selectionStart" in n ? s = {
        start: n.selectionStart,
        end: n.selectionEnd
      } : s = Ff(n), s || {
        start: 0,
        end: 0
      };
    }
    function em(n, s) {
      var v = s.start, b = s.end;
      b === void 0 && (b = v), "selectionStart" in n ? (n.selectionStart = v, n.selectionEnd = Math.min(b, n.value.length)) : k0(n, s);
    }
    var ei = et && "documentMode" in document && document.documentMode <= 11;
    function KS() {
      Ot("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var ll = null, Rs = null, Dy = null, xd = !1;
    function f1(n) {
      if ("selectionStart" in n && Ov(n))
        return {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      var s = n.ownerDocument && n.ownerDocument.defaultView || window, v = s.getSelection();
      return {
        anchorNode: v.anchorNode,
        anchorOffset: v.anchorOffset,
        focusNode: v.focusNode,
        focusOffset: v.focusOffset
      };
    }
    function V0(n) {
      return n.window === n ? n.document : n.nodeType === Za ? n : n.ownerDocument;
    }
    function G0(n, s, v) {
      var b = V0(v);
      if (!(xd || ll == null || ll !== Ll(b))) {
        var R = f1(ll);
        if (!Dy || !pr(Dy, R)) {
          Dy = R;
          var F = qr(Rs, "onSelect");
          if (F.length > 0) {
            var Y = new Zo("onSelect", "select", null, s, v);
            n.push({
              event: Y,
              listeners: F
            }), Y.target = ll;
          }
        }
      }
    }
    function W0(n, s, v, b, R, F, Y) {
      var K = v ? Ln(v) : window;
      switch (s) {
        case "focusin":
          (Wt(K) || K.contentEditable === "true") && (ll = K, Rs = v, Dy = null);
          break;
        case "focusout":
          ll = null, Rs = null, Dy = null;
          break;
        case "mousedown":
          xd = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          xd = !1, G0(n, b, R);
          break;
        case "selectionchange":
          if (ei)
            break;
        case "keydown":
        case "keyup":
          G0(n, b, R);
      }
    }
    function Tg(n, s) {
      var v = {};
      return v[n.toLowerCase()] = s.toLowerCase(), v["Webkit" + n] = "webkit" + s, v["Moz" + n] = "moz" + s, v;
    }
    var tm = {
      animationend: Tg("Animation", "AnimationEnd"),
      animationiteration: Tg("Animation", "AnimationIteration"),
      animationstart: Tg("Animation", "AnimationStart"),
      transitionend: Tg("Transition", "TransitionEnd")
    }, j0 = {}, yp = {};
    et && (yp = document.createElement("div").style, "AnimationEvent" in window || (delete tm.animationend.animation, delete tm.animationiteration.animation, delete tm.animationstart.animation), "TransitionEvent" in window || delete tm.transitionend.transition);
    function Uv(n) {
      if (j0[n])
        return j0[n];
      if (!tm[n])
        return n;
      var s = tm[n];
      for (var v in s)
        if (s.hasOwnProperty(v) && v in yp)
          return j0[n] = s[v];
      return n;
    }
    var Cg = Uv("animationend"), Hs = Uv("animationiteration"), io = Uv("animationstart"), d1 = Uv("transitionend"), Y0 = /* @__PURE__ */ new Map(), Ly = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Qm(n, s) {
      Y0.set(n, s), Ot(s, [n]);
    }
    function yw() {
      for (var n = 0; n < Ly.length; n++) {
        var s = Ly[n], v = s.toLowerCase(), b = s[0].toUpperCase() + s.slice(1);
        Qm(v, "on" + b);
      }
      Qm(Cg, "onAnimationEnd"), Qm(Hs, "onAnimationIteration"), Qm(io, "onAnimationStart"), Qm("dblclick", "onDoubleClick"), Qm("focusin", "onFocus"), Qm("focusout", "onBlur"), Qm(d1, "onTransitionEnd");
    }
    function $S(n, s, v, b, R, F, Y) {
      var K = Y0.get(s);
      if (K !== void 0) {
        var re = Zo, _e = s;
        switch (s) {
          case "keypress":
            if (Vc(b) === 0)
              return;
          case "keydown":
          case "keyup":
            re = F0;
            break;
          case "focusin":
            _e = "focus", re = xg;
            break;
          case "focusout":
            _e = "blur", re = xg;
            break;
          case "beforeblur":
          case "afterblur":
            re = xg;
            break;
          case "click":
            if (b.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            re = Ah;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            re = zf;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            re = _l;
            break;
          case Cg:
          case Hs:
          case io:
            re = hp;
            break;
          case d1:
            re = _g;
            break;
          case "scroll":
            re = Mv;
            break;
          case "wheel":
            re = Lh;
            break;
          case "copy":
          case "cut":
          case "paste":
            re = Cv;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            re = Wc;
            break;
        }
        var Re = (F & So) !== 0;
        {
          var nt = !Re && s === "scroll", $e = xp(v, K, b.type, Re, nt);
          if ($e.length > 0) {
            var Dt = new re(K, _e, null, b, R);
            n.push({
              event: Dt,
              listeners: $e
            });
          }
        }
      }
    }
    yw(), gt(), yd(), KS(), bg();
    function e_(n, s, v, b, R, F, Y) {
      $S(n, s, v, b, R, F);
      var K = (F & td) === 0;
      K && (xn(n, s, v, b, R), Ze(n, s, v, b, R), W0(n, s, v, b, R), wg(n, s, v, b, R));
    }
    var zv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], Zm = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(zv));
    function Py(n, s, v) {
      var b = n.type || "unknown-event";
      n.currentTarget = v, _o(b, s, void 0, n), n.currentTarget = null;
    }
    function X0(n, s, v) {
      var b;
      if (v)
        for (var R = s.length - 1; R >= 0; R--) {
          var F = s[R], Y = F.instance, K = F.currentTarget, re = F.listener;
          if (Y !== b && n.isPropagationStopped())
            return;
          Py(n, re, K), b = Y;
        }
      else
        for (var _e = 0; _e < s.length; _e++) {
          var Re = s[_e], nt = Re.instance, $e = Re.currentTarget, Dt = Re.listener;
          if (nt !== b && n.isPropagationStopped())
            return;
          Py(n, Dt, $e), b = nt;
        }
    }
    function q0(n, s) {
      for (var v = (s & So) !== 0, b = 0; b < n.length; b++) {
        var R = n[b], F = R.event, Y = R.listeners;
        X0(F, Y, v);
      }
      ad();
    }
    function Oy(n, s, v, b, R) {
      var F = an(v), Y = [];
      e_(Y, n, b, v, F, s), q0(Y, s);
    }
    function Ni(n, s) {
      Zm.has(n) || l('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', n);
      var v = !1, b = kr(s), R = Da(n, v);
      b.has(R) || (Uy(s, n, Fa, v), b.add(R));
    }
    function nm(n, s, v) {
      Zm.has(n) && !s && l('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', n);
      var b = 0;
      s && (b |= So), Uy(v, n, b, s);
    }
    var Sd = "_reactListening" + Math.random().toString(36).slice(2);
    function jc(n) {
      if (!n[Sd]) {
        n[Sd] = !0, rt.forEach(function(v) {
          v !== "selectionchange" && (Zm.has(v) || nm(v, !1, n), nm(v, !0, n));
        });
        var s = n.nodeType === Za ? n : n.ownerDocument;
        s !== null && (s[Sd] || (s[Sd] = !0, nm("selectionchange", !1, s)));
      }
    }
    function Uy(n, s, v, b, R) {
      var F = Hm(n, s, v), Y = void 0;
      rd && (s === "touchstart" || s === "touchmove" || s === "wheel") && (Y = !0), n = n, b ? Y !== void 0 ? gd(n, s, F, Y) : lp(n, s, F) : Y !== void 0 ? vg(n, s, F, Y) : Wm(n, s, F);
    }
    function Q0(n, s) {
      return n === s || n.nodeType === Oi && n.parentNode === s;
    }
    function Fr(n, s, v, b, R) {
      var F = b;
      if ((s & Br) === 0 && (s & Fa) === 0) {
        var Y = R;
        if (b !== null) {
          var K = b;
          e:
            for (; ; ) {
              if (K === null)
                return;
              var re = K.tag;
              if (re === _ || re === T) {
                var _e = K.stateNode.containerInfo;
                if (Q0(_e, Y))
                  break;
                if (re === T)
                  for (var Re = K.return; Re !== null; ) {
                    var nt = Re.tag;
                    if (nt === _ || nt === T) {
                      var $e = Re.stateNode.containerInfo;
                      if (Q0($e, Y))
                        return;
                    }
                    Re = Re.return;
                  }
                for (; _e !== null; ) {
                  var Dt = sn(_e);
                  if (Dt === null)
                    return;
                  var Lt = Dt.tag;
                  if (Lt === C || Lt === D) {
                    K = F = Dt;
                    continue e;
                  }
                  _e = _e.parentNode;
                }
              }
              K = K.return;
            }
        }
      }
      Jh(function() {
        return Oy(n, s, v, F);
      });
    }
    function _d(n, s, v) {
      return {
        instance: n,
        listener: s,
        currentTarget: v
      };
    }
    function xp(n, s, v, b, R, F) {
      for (var Y = s !== null ? s + "Capture" : null, K = b ? Y : s, re = [], _e = n, Re = null; _e !== null; ) {
        var nt = _e, $e = nt.stateNode, Dt = nt.tag;
        if (Dt === C && $e !== null && (Re = $e, K !== null)) {
          var Lt = Lu(_e, K);
          Lt != null && re.push(_d(_e, Lt, Re));
        }
        if (R)
          break;
        _e = _e.return;
      }
      return re;
    }
    function qr(n, s) {
      for (var v = s + "Capture", b = [], R = n; R !== null; ) {
        var F = R, Y = F.stateNode, K = F.tag;
        if (K === C && Y !== null) {
          var re = Y, _e = Lu(R, v);
          _e != null && b.unshift(_d(R, _e, re));
          var Re = Lu(R, s);
          Re != null && b.push(_d(R, Re, re));
        }
        R = R.return;
      }
      return b;
    }
    function Oh(n) {
      if (n === null)
        return null;
      do
        n = n.return;
      while (n && n.tag !== C);
      return n || null;
    }
    function Yc(n, s) {
      for (var v = n, b = s, R = 0, F = v; F; F = Oh(F))
        R++;
      for (var Y = 0, K = b; K; K = Oh(K))
        Y++;
      for (; R - Y > 0; )
        v = Oh(v), R--;
      for (; Y - R > 0; )
        b = Oh(b), Y--;
      for (var re = R; re--; ) {
        if (v === b || b !== null && v === b.alternate)
          return v;
        v = Oh(v), b = Oh(b);
      }
      return null;
    }
    function zy(n, s, v, b, R) {
      for (var F = s._reactName, Y = [], K = v; K !== null && K !== b; ) {
        var re = K, _e = re.alternate, Re = re.stateNode, nt = re.tag;
        if (_e !== null && _e === b)
          break;
        if (nt === C && Re !== null) {
          var $e = Re;
          if (R) {
            var Dt = Lu(K, F);
            Dt != null && Y.unshift(_d(K, Dt, $e));
          } else if (!R) {
            var Lt = Lu(K, F);
            Lt != null && Y.push(_d(K, Lt, $e));
          }
        }
        K = K.return;
      }
      Y.length !== 0 && n.push({
        event: s,
        listeners: Y
      });
    }
    function Z0(n, s, v, b, R) {
      var F = b && R ? Yc(b, R) : null;
      b !== null && zy(n, s, b, F, !1), R !== null && v !== null && zy(n, v, R, F, !0);
    }
    function Da(n, s) {
      return n + "__" + (s ? "capture" : "bubble");
    }
    var kf = !1, Rg = "dangerouslySetInnerHTML", Nv = "suppressContentEditableWarning", rm = "suppressHydrationWarning", h1 = "autoFocus", im = "children", Jm = "style", Fv = "__html", If, Ag, vc, J0, Dg, Ny, t_;
    If = {
      dialog: !0,
      webview: !0
    }, Ag = function(n, s) {
      xi(n, s), Au(n, s), $i(n, s, {
        registrationNameDependencies: _t,
        possibleRegistrationNames: Rt
      });
    }, Ny = et && !document.documentMode, vc = function(n, s, v) {
      if (!kf) {
        var b = Fy(v), R = Fy(s);
        R !== b && (kf = !0, l("Prop `%s` did not match. Server: %s Client: %s", n, JSON.stringify(R), JSON.stringify(b)));
      }
    }, J0 = function(n) {
      if (!kf) {
        kf = !0;
        var s = [];
        n.forEach(function(v) {
          s.push(v);
        }), l("Extra attributes from the server: %s", s);
      }
    }, Dg = function(n, s) {
      s === !1 ? l("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", n, n, n) : l("Expected `%s` listener to be a function, instead got a value of `%s` type.", n, typeof s);
    }, t_ = function(n, s) {
      var v = n.namespaceURI === Ru ? n.ownerDocument.createElement(n.tagName) : n.ownerDocument.createElementNS(n.namespaceURI, n.tagName);
      return v.innerHTML = s, v.innerHTML;
    };
    var p1 = /\r\n?/g, m1 = /\u0000|\uFFFD/g;
    function Fy(n) {
      Me(n);
      var s = typeof n == "string" ? n : "" + n;
      return s.replace(p1, `
`).replace(m1, "");
    }
    function Km(n, s, v, b) {
      var R = Fy(s), F = Fy(n);
      if (F !== R && (b && (kf || (kf = !0, l('Text content did not match. Server: "%s" Client: "%s"', F, R))), v && Be))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function v1(n) {
      return n.nodeType === Za ? n : n.ownerDocument;
    }
    function xw() {
    }
    function K0(n) {
      n.onclick = xw;
    }
    function Ql(n, s, v, b, R) {
      for (var F in b)
        if (!!b.hasOwnProperty(F)) {
          var Y = b[F];
          if (F === Jm)
            Y && Object.freeze(Y), Ye(s, Y);
          else if (F === Rg) {
            var K = Y ? Y[Fv] : void 0;
            K != null && mf(s, K);
          } else if (F === im)
            if (typeof Y == "string") {
              var re = n !== "textarea" || Y !== "";
              re && ca(s, Y);
            } else
              typeof Y == "number" && ca(s, "" + Y);
          else
            F === Nv || F === rm || F === h1 || (_t.hasOwnProperty(F) ? Y != null && (typeof Y != "function" && Dg(F, Y), F === "onScroll" && Ni("scroll", s)) : Y != null && ni(s, F, Y, R));
        }
    }
    function Xc(n, s, v, b) {
      for (var R = 0; R < s.length; R += 2) {
        var F = s[R], Y = s[R + 1];
        F === Jm ? Ye(n, Y) : F === Rg ? mf(n, Y) : F === im ? ca(n, Y) : ni(n, F, Y, b);
      }
    }
    function Sw(n, s, v, b) {
      var R, F = v1(v), Y, K = b;
      if (K === Ru && (K = el(n)), K === Ru) {
        if (R = Ui(n, s), !R && n !== n.toLowerCase() && l("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", n), n === "script") {
          var re = F.createElement("div");
          re.innerHTML = "<script><\/script>";
          var _e = re.firstChild;
          Y = re.removeChild(_e);
        } else if (typeof s.is == "string")
          Y = F.createElement(n, {
            is: s.is
          });
        else if (Y = F.createElement(n), n === "select") {
          var Re = Y;
          s.multiple ? Re.multiple = !0 : s.size && (Re.size = s.size);
        }
      } else
        Y = F.createElementNS(K, n);
      return K === Ru && !R && Object.prototype.toString.call(Y) === "[object HTMLUnknownElement]" && !mt.call(If, n) && (If[n] = !0, l("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", n)), Y;
    }
    function _w(n, s) {
      return v1(s).createTextNode(n);
    }
    function Sp(n, s, v, b) {
      var R = Ui(s, v);
      Ag(s, v);
      var F;
      switch (s) {
        case "dialog":
          Ni("cancel", n), Ni("close", n), F = v;
          break;
        case "iframe":
        case "object":
        case "embed":
          Ni("load", n), F = v;
          break;
        case "video":
        case "audio":
          for (var Y = 0; Y < zv.length; Y++)
            Ni(zv[Y], n);
          F = v;
          break;
        case "source":
          Ni("error", n), F = v;
          break;
        case "img":
        case "image":
        case "link":
          Ni("error", n), Ni("load", n), F = v;
          break;
        case "details":
          Ni("toggle", n), F = v;
          break;
        case "input":
          Oa(n, v), F = Mu(n, v), Ni("invalid", n);
          break;
        case "option":
          Jr(n, v), F = v;
          break;
        case "select":
          Up(n, v), F = Cu(n, v), Ni("invalid", n);
          break;
        case "textarea":
          Pm(n, v), F = Lm(n, v), Ni("invalid", n);
          break;
        default:
          F = v;
      }
      switch ($n(s, F), Ql(s, n, b, F, R), s) {
        case "input":
          Ps(n), Ua(n, v, !1);
          break;
        case "textarea":
          Ps(n), $u(n);
          break;
        case "option":
          xs(n, v);
          break;
        case "select":
          cg(n, v);
          break;
        default:
          typeof F.onClick == "function" && K0(n);
          break;
      }
    }
    function g1(n, s, v, b, R) {
      Ag(s, b);
      var F = null, Y, K;
      switch (s) {
        case "input":
          Y = Mu(n, v), K = Mu(n, b), F = [];
          break;
        case "select":
          Y = Cu(n, v), K = Cu(n, b), F = [];
          break;
        case "textarea":
          Y = Lm(n, v), K = Lm(n, b), F = [];
          break;
        default:
          Y = v, K = b, typeof Y.onClick != "function" && typeof K.onClick == "function" && K0(n);
          break;
      }
      $n(s, K);
      var re, _e, Re = null;
      for (re in Y)
        if (!(K.hasOwnProperty(re) || !Y.hasOwnProperty(re) || Y[re] == null))
          if (re === Jm) {
            var nt = Y[re];
            for (_e in nt)
              nt.hasOwnProperty(_e) && (Re || (Re = {}), Re[_e] = "");
          } else
            re === Rg || re === im || re === Nv || re === rm || re === h1 || (_t.hasOwnProperty(re) ? F || (F = []) : (F = F || []).push(re, null));
      for (re in K) {
        var $e = K[re], Dt = Y != null ? Y[re] : void 0;
        if (!(!K.hasOwnProperty(re) || $e === Dt || $e == null && Dt == null))
          if (re === Jm)
            if ($e && Object.freeze($e), Dt) {
              for (_e in Dt)
                Dt.hasOwnProperty(_e) && (!$e || !$e.hasOwnProperty(_e)) && (Re || (Re = {}), Re[_e] = "");
              for (_e in $e)
                $e.hasOwnProperty(_e) && Dt[_e] !== $e[_e] && (Re || (Re = {}), Re[_e] = $e[_e]);
            } else
              Re || (F || (F = []), F.push(re, Re)), Re = $e;
          else if (re === Rg) {
            var Lt = $e ? $e[Fv] : void 0, Yt = Dt ? Dt[Fv] : void 0;
            Lt != null && Yt !== Lt && (F = F || []).push(re, Lt);
          } else
            re === im ? (typeof $e == "string" || typeof $e == "number") && (F = F || []).push(re, "" + $e) : re === Nv || re === rm || (_t.hasOwnProperty(re) ? ($e != null && (typeof $e != "function" && Dg(re, $e), re === "onScroll" && Ni("scroll", n)), !F && Dt !== $e && (F = [])) : (F = F || []).push(re, $e));
      }
      return Re && (Mn(Re, K[Jm]), (F = F || []).push(Jm, Re)), F;
    }
    function n_(n, s, v, b, R) {
      v === "input" && R.type === "radio" && R.name != null && ys(n, R);
      var F = Ui(v, b), Y = Ui(v, R);
      switch (Xc(n, s, F, Y), v) {
        case "input":
          ou(n, R);
          break;
        case "textarea":
          vh(n, R);
          break;
        case "select":
          Zh(n, R);
          break;
      }
    }
    function ky(n) {
      {
        var s = n.toLowerCase();
        return ra.hasOwnProperty(s) && ra[s] || null;
      }
    }
    function Iy(n, s, v, b, R, F, Y) {
      var K, re;
      switch (K = Ui(s, v), Ag(s, v), s) {
        case "dialog":
          Ni("cancel", n), Ni("close", n);
          break;
        case "iframe":
        case "object":
        case "embed":
          Ni("load", n);
          break;
        case "video":
        case "audio":
          for (var _e = 0; _e < zv.length; _e++)
            Ni(zv[_e], n);
          break;
        case "source":
          Ni("error", n);
          break;
        case "img":
        case "image":
        case "link":
          Ni("error", n), Ni("load", n);
          break;
        case "details":
          Ni("toggle", n);
          break;
        case "input":
          Oa(n, v), Ni("invalid", n);
          break;
        case "option":
          Jr(n, v);
          break;
        case "select":
          Up(n, v), Ni("invalid", n);
          break;
        case "textarea":
          Pm(n, v), Ni("invalid", n);
          break;
      }
      $n(s, v);
      {
        re = /* @__PURE__ */ new Set();
        for (var Re = n.attributes, nt = 0; nt < Re.length; nt++) {
          var $e = Re[nt].name.toLowerCase();
          switch ($e) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              re.add(Re[nt].name);
          }
        }
      }
      var Dt = null;
      for (var Lt in v)
        if (!!v.hasOwnProperty(Lt)) {
          var Yt = v[Lt];
          if (Lt === im)
            typeof Yt == "string" ? n.textContent !== Yt && (v[rm] !== !0 && Km(n.textContent, Yt, F, Y), Dt = [im, Yt]) : typeof Yt == "number" && n.textContent !== "" + Yt && (v[rm] !== !0 && Km(n.textContent, Yt, F, Y), Dt = [im, "" + Yt]);
          else if (_t.hasOwnProperty(Lt))
            Yt != null && (typeof Yt != "function" && Dg(Lt, Yt), Lt === "onScroll" && Ni("scroll", n));
          else if (Y && !0 && typeof K == "boolean") {
            var er = void 0, Dr = K && Xe ? null : Gt(Lt);
            if (v[rm] !== !0) {
              if (!(Lt === Nv || Lt === rm || Lt === "value" || Lt === "checked" || Lt === "selected")) {
                if (Lt === Rg) {
                  var _r = n.innerHTML, ma = Yt ? Yt[Fv] : void 0;
                  if (ma != null) {
                    var ta = t_(n, ma);
                    ta !== _r && vc(Lt, _r, ta);
                  }
                } else if (Lt === Jm) {
                  if (re.delete(Lt), Ny) {
                    var xt = ko(Yt);
                    er = n.getAttribute("style"), xt !== er && vc(Lt, er, xt);
                  }
                } else if (K && !Xe)
                  re.delete(Lt.toLowerCase()), er = Wi(n, Lt, Yt), Yt !== er && vc(Lt, er, Yt);
                else if (!De(Lt, Dr, K) && !Ne(Lt, Yt, Dr, K)) {
                  var Xt = !1;
                  if (Dr !== null)
                    re.delete(Dr.attributeName), er = ki(n, Lt, Yt, Dr);
                  else {
                    var St = b;
                    if (St === Ru && (St = el(s)), St === Ru)
                      re.delete(Lt.toLowerCase());
                    else {
                      var gn = ky(Lt);
                      gn !== null && gn !== Lt && (Xt = !0, re.delete(gn)), re.delete(Lt);
                    }
                    er = Wi(n, Lt, Yt);
                  }
                  var tr = Xe;
                  !tr && Yt !== er && !Xt && vc(Lt, er, Yt);
                }
              }
            }
          }
        }
      switch (Y && re.size > 0 && v[rm] !== !0 && J0(re), s) {
        case "input":
          Ps(n), Ua(n, v, !0);
          break;
        case "textarea":
          Ps(n), $u(n);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof v.onClick == "function" && K0(n);
          break;
      }
      return Dt;
    }
    function By(n, s, v) {
      var b = n.nodeValue !== s;
      return b;
    }
    function Lg(n, s) {
      {
        if (kf)
          return;
        kf = !0, l("Did not expect server HTML to contain a <%s> in <%s>.", s.nodeName.toLowerCase(), n.nodeName.toLowerCase());
      }
    }
    function $0(n, s) {
      {
        if (kf)
          return;
        kf = !0, l('Did not expect server HTML to contain the text node "%s" in <%s>.', s.nodeValue, n.nodeName.toLowerCase());
      }
    }
    function kv(n, s, v) {
      {
        if (kf)
          return;
        kf = !0, l("Expected server HTML to contain a matching <%s> in <%s>.", s, n.nodeName.toLowerCase());
      }
    }
    function wl(n, s) {
      {
        if (s === "" || kf)
          return;
        kf = !0, l('Expected server HTML to contain a matching text node for "%s" in <%s>.', s, n.nodeName.toLowerCase());
      }
    }
    function y1(n, s, v) {
      switch (s) {
        case "input":
          bc(n, v);
          return;
        case "textarea":
          Nd(n, v);
          return;
        case "select":
          Am(n, v);
          return;
      }
    }
    var am = function() {
    }, qc = function() {
    };
    {
      var x1 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], Pg = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        "foreignObject",
        "desc",
        "title"
      ], $m = Pg.concat(["button"]), S1 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], ex = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      qc = function(n, s) {
        var v = Xn({}, n || ex), b = {
          tag: s
        };
        return Pg.indexOf(s) !== -1 && (v.aTagInScope = null, v.buttonTagInScope = null, v.nobrTagInScope = null), $m.indexOf(s) !== -1 && (v.pTagInButtonScope = null), x1.indexOf(s) !== -1 && s !== "address" && s !== "div" && s !== "p" && (v.listItemTagAutoclosing = null, v.dlItemTagAutoclosing = null), v.current = b, s === "form" && (v.formTag = b), s === "a" && (v.aTagInScope = b), s === "button" && (v.buttonTagInScope = b), s === "nobr" && (v.nobrTagInScope = b), s === "p" && (v.pTagInButtonScope = b), s === "li" && (v.listItemTagAutoclosing = b), (s === "dd" || s === "dt") && (v.dlItemTagAutoclosing = b), v;
      };
      var Iv = function(n, s) {
        switch (s) {
          case "select":
            return n === "option" || n === "optgroup" || n === "#text";
          case "optgroup":
            return n === "option" || n === "#text";
          case "option":
            return n === "#text";
          case "tr":
            return n === "th" || n === "td" || n === "style" || n === "script" || n === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return n === "tr" || n === "style" || n === "script" || n === "template";
          case "colgroup":
            return n === "col" || n === "template";
          case "table":
            return n === "caption" || n === "colgroup" || n === "tbody" || n === "tfoot" || n === "thead" || n === "style" || n === "script" || n === "template";
          case "head":
            return n === "base" || n === "basefont" || n === "bgsound" || n === "link" || n === "meta" || n === "title" || n === "noscript" || n === "noframes" || n === "style" || n === "script" || n === "template";
          case "html":
            return n === "head" || n === "body" || n === "frameset";
          case "frameset":
            return n === "frame";
          case "#document":
            return n === "html";
        }
        switch (n) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s !== "h1" && s !== "h2" && s !== "h3" && s !== "h4" && s !== "h5" && s !== "h6";
          case "rp":
          case "rt":
            return S1.indexOf(s) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return s == null;
        }
        return !0;
      }, _1 = function(n, s) {
        switch (n) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return s.pTagInButtonScope;
          case "form":
            return s.formTag || s.pTagInButtonScope;
          case "li":
            return s.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return s.dlItemTagAutoclosing;
          case "button":
            return s.buttonTagInScope;
          case "a":
            return s.aTagInScope;
          case "nobr":
            return s.nobrTagInScope;
        }
        return null;
      }, Hy = {};
      am = function(n, s, v) {
        v = v || ex;
        var b = v.current, R = b && b.tag;
        s != null && (n != null && l("validateDOMNesting: when childText is passed, childTag should be null"), n = "#text");
        var F = Iv(n, R) ? null : b, Y = F ? null : _1(n, v), K = F || Y;
        if (!!K) {
          var re = K.tag, _e = !!F + "|" + n + "|" + re;
          if (!Hy[_e]) {
            Hy[_e] = !0;
            var Re = n, nt = "";
            if (n === "#text" ? /\S/.test(s) ? Re = "Text nodes" : (Re = "Whitespace text nodes", nt = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Re = "<" + n + ">", F) {
              var $e = "";
              re === "table" && n === "tr" && ($e += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), l("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Re, re, nt, $e);
            } else
              l("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Re, re);
          }
        }
      };
    }
    var Zl = "suppressHydrationWarning", Vy = "$", Gy = "/$", Og = "$?", Ug = "$!", r_ = "style", b1 = null, w1 = null;
    function bw(n) {
      var s, v, b = n.nodeType;
      switch (b) {
        case Za:
        case Ma: {
          s = b === Za ? "#document" : "#fragment";
          var R = n.documentElement;
          v = R ? R.namespaceURI : pf(null, "");
          break;
        }
        default: {
          var F = b === Oi ? n.parentNode : n, Y = F.namespaceURI || null;
          s = F.tagName, v = pf(Y, s);
          break;
        }
      }
      {
        var K = s.toLowerCase(), re = qc(null, K);
        return {
          namespace: v,
          ancestorInfo: re
        };
      }
    }
    function i_(n, s, v) {
      {
        var b = n, R = pf(b.namespace, s), F = qc(b.ancestorInfo, s);
        return {
          namespace: R,
          ancestorInfo: F
        };
      }
    }
    function a_(n) {
      return n;
    }
    function s_(n) {
      b1 = Hc(), w1 = Bu();
      var s = null;
      return vs(!1), s;
    }
    function E1(n) {
      c1(w1), vs(b1), b1 = null, w1 = null;
    }
    function o_(n, s, v, b, R) {
      var F;
      {
        var Y = b;
        if (am(n, null, Y.ancestorInfo), typeof s.children == "string" || typeof s.children == "number") {
          var K = "" + s.children, re = qc(Y.ancestorInfo, n);
          am(null, K, re);
        }
        F = Y.namespace;
      }
      var _e = Sw(n, s, v, F);
      return We(R, _e), gi(_e, s), _e;
    }
    function ww(n, s) {
      n.appendChild(s);
    }
    function l_(n, s, v, b, R) {
      switch (Sp(n, s, v, b), s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!v.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function Ew(n, s, v, b, R, F) {
      {
        var Y = F;
        if (typeof b.children != typeof v.children && (typeof b.children == "string" || typeof b.children == "number")) {
          var K = "" + b.children, re = qc(Y.ancestorInfo, s);
          am(null, K, re);
        }
      }
      return g1(n, s, v, b);
    }
    function M1(n, s) {
      return n === "textarea" || n === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null;
    }
    function Mw(n, s, v, b) {
      {
        var R = v;
        am(null, n, R.ancestorInfo);
      }
      var F = _w(n, s);
      return We(b, F), F;
    }
    function Tw() {
      var n = window.event;
      return n === void 0 ? rs : gu(n.type);
    }
    var T1 = typeof setTimeout == "function" ? setTimeout : void 0, C1 = typeof clearTimeout == "function" ? clearTimeout : void 0, zg = -1, Wy = typeof Promise == "function" ? Promise : void 0, u_ = typeof queueMicrotask == "function" ? queueMicrotask : typeof Wy < "u" ? function(n) {
      return Wy.resolve(null).then(n).catch(Cw);
    } : T1;
    function Cw(n) {
      setTimeout(function() {
        throw n;
      });
    }
    function c_(n, s, v, b) {
      switch (s) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          v.autoFocus && n.focus();
          return;
        case "img": {
          v.src && (n.src = v.src);
          return;
        }
      }
    }
    function tx(n, s, v, b, R, F) {
      n_(n, s, v, b, R), gi(n, R);
    }
    function jy(n) {
      ca(n, "");
    }
    function f_(n, s, v) {
      n.nodeValue = v;
    }
    function R1(n, s) {
      n.appendChild(s);
    }
    function d_(n, s) {
      var v;
      n.nodeType === Oi ? (v = n.parentNode, v.insertBefore(s, n)) : (v = n, v.appendChild(s));
      var b = n._reactRootContainer;
      b == null && v.onclick === null && K0(v);
    }
    function h_(n, s, v) {
      n.insertBefore(s, v);
    }
    function nx(n, s, v) {
      n.nodeType === Oi ? n.parentNode.insertBefore(s, v) : n.insertBefore(s, v);
    }
    function rx(n, s) {
      n.removeChild(s);
    }
    function Rw(n, s) {
      n.nodeType === Oi ? n.parentNode.removeChild(s) : n.removeChild(s);
    }
    function A1(n, s) {
      var v = s, b = 0;
      do {
        var R = v.nextSibling;
        if (n.removeChild(v), R && R.nodeType === Oi) {
          var F = R.data;
          if (F === Gy)
            if (b === 0) {
              n.removeChild(R), Nr(s);
              return;
            } else
              b--;
          else
            (F === Vy || F === Og || F === Ug) && b++;
        }
        v = R;
      } while (v);
      Nr(s);
    }
    function Bf(n, s) {
      n.nodeType === Oi ? A1(n.parentNode, s) : n.nodeType === Ol && A1(n, s), Nr(n);
    }
    function ix(n) {
      n = n;
      var s = n.style;
      typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none";
    }
    function Aw(n) {
      n.nodeValue = "";
    }
    function Dw(n, s) {
      n = n;
      var v = s[r_], b = v != null && v.hasOwnProperty("display") ? v.display : null;
      n.style.display = gh("display", b);
    }
    function Lw(n, s) {
      n.nodeValue = s;
    }
    function Pw(n) {
      n.nodeType === Ol ? n.textContent = "" : n.nodeType === Za && n.documentElement && n.removeChild(n.documentElement);
    }
    function ax(n, s, v) {
      return n.nodeType !== Ol || s.toLowerCase() !== n.nodeName.toLowerCase() ? null : n;
    }
    function Ow(n, s) {
      return s === "" || n.nodeType !== ec ? null : n;
    }
    function Yy(n) {
      return n.nodeType !== Oi ? null : n;
    }
    function D1(n) {
      return n.data === Og;
    }
    function L1(n) {
      return n.data === Ug;
    }
    function p_(n) {
      var s = n.nextSibling && n.nextSibling.dataset, v, b, R;
      return s && (v = s.dgst, b = s.msg, R = s.stck), {
        message: b,
        digest: v,
        stack: R
      };
    }
    function Uw(n, s) {
      n._reactRetry = s;
    }
    function Ng(n) {
      for (; n != null; n = n.nextSibling) {
        var s = n.nodeType;
        if (s === Ol || s === ec)
          break;
        if (s === Oi) {
          var v = n.data;
          if (v === Vy || v === Ug || v === Og)
            break;
          if (v === Gy)
            return null;
        }
      }
      return n;
    }
    function Xy(n) {
      return Ng(n.nextSibling);
    }
    function sx(n) {
      return Ng(n.firstChild);
    }
    function sm(n) {
      return Ng(n.firstChild);
    }
    function P1(n) {
      return Ng(n.nextSibling);
    }
    function qy(n, s, v, b, R, F, Y) {
      We(F, n), gi(n, v);
      var K;
      {
        var re = R;
        K = re.namespace;
      }
      var _e = (F.mode & Yr) !== hr;
      return Iy(n, s, v, K, b, _e, Y);
    }
    function zw(n, s, v, b) {
      return We(v, n), v.mode & Yr, By(n, s);
    }
    function m_(n, s) {
      We(s, n);
    }
    function Nw(n) {
      for (var s = n.nextSibling, v = 0; s; ) {
        if (s.nodeType === Oi) {
          var b = s.data;
          if (b === Gy) {
            if (v === 0)
              return Xy(s);
            v--;
          } else
            (b === Vy || b === Ug || b === Og) && v++;
        }
        s = s.nextSibling;
      }
      return null;
    }
    function O1(n) {
      for (var s = n.previousSibling, v = 0; s; ) {
        if (s.nodeType === Oi) {
          var b = s.data;
          if (b === Vy || b === Ug || b === Og) {
            if (v === 0)
              return s;
            v--;
          } else
            b === Gy && v++;
        }
        s = s.previousSibling;
      }
      return null;
    }
    function v_(n) {
      Nr(n);
    }
    function g_(n) {
      Nr(n);
    }
    function U1(n) {
      return n !== "head" && n !== "body";
    }
    function Fw(n, s, v, b) {
      var R = !0;
      Km(s.nodeValue, v, b, R);
    }
    function Qy(n, s, v, b, R, F) {
      if (s[Zl] !== !0) {
        var Y = !0;
        Km(b.nodeValue, R, F, Y);
      }
    }
    function ox(n, s) {
      s.nodeType === Ol ? Lg(n, s) : s.nodeType === Oi || $0(n, s);
    }
    function kw(n, s) {
      {
        var v = n.parentNode;
        v !== null && (s.nodeType === Ol ? Lg(v, s) : s.nodeType === Oi || $0(v, s));
      }
    }
    function y_(n, s, v, b, R) {
      (R || s[Zl] !== !0) && (b.nodeType === Ol ? Lg(v, b) : b.nodeType === Oi || $0(v, b));
    }
    function Iw(n, s, v) {
      kv(n, s);
    }
    function x_(n, s) {
      wl(n, s);
    }
    function S_(n, s, v) {
      {
        var b = n.parentNode;
        b !== null && kv(b, s);
      }
    }
    function lx(n, s) {
      {
        var v = n.parentNode;
        v !== null && wl(v, s);
      }
    }
    function ev(n, s, v, b, R, F) {
      (F || s[Zl] !== !0) && kv(v, b);
    }
    function Bw(n, s, v, b, R) {
      (R || s[Zl] !== !0) && wl(v, b);
    }
    function In(n) {
      l("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", n.nodeName.toLowerCase());
    }
    function Fg(n) {
      jc(n);
    }
    var Uh = Math.random().toString(36).slice(2), g = "__reactFiber$" + Uh, w = "__reactProps$" + Uh, N = "__reactContainer$" + Uh, Z = "__reactEvents$" + Uh, ae = "__reactListeners$" + Uh, be = "__reactHandles$" + Uh;
    function ke(n) {
      delete n[g], delete n[w], delete n[Z], delete n[ae], delete n[be];
    }
    function We(n, s) {
      s[g] = n;
    }
    function ut(n, s) {
      s[N] = n;
    }
    function tn(n) {
      n[N] = null;
    }
    function Kt(n) {
      return !!n[N];
    }
    function sn(n) {
      var s = n[g];
      if (s)
        return s;
      for (var v = n.parentNode; v; ) {
        if (s = v[N] || v[g], s) {
          var b = s.alternate;
          if (s.child !== null || b !== null && b.child !== null)
            for (var R = O1(n); R !== null; ) {
              var F = R[g];
              if (F)
                return F;
              R = O1(R);
            }
          return s;
        }
        n = v, v = n.parentNode;
      }
      return null;
    }
    function Cn(n) {
      var s = n[g] || n[N];
      return s && (s.tag === C || s.tag === D || s.tag === X || s.tag === _) ? s : null;
    }
    function Ln(n) {
      if (n.tag === C || n.tag === D)
        return n.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function dr(n) {
      return n[w] || null;
    }
    function gi(n, s) {
      n[w] = s;
    }
    function kr(n) {
      var s = n[Z];
      return s === void 0 && (s = n[Z] = /* @__PURE__ */ new Set()), s;
    }
    var Fi = {}, Ji = t.ReactDebugCurrentFrame;
    function Hu(n) {
      if (n) {
        var s = n._owner, v = Dl(n.type, n._source, s ? s.type : null);
        Ji.setExtraStackFrame(v);
      } else
        Ji.setExtraStackFrame(null);
    }
    function Vs(n, s, v, b, R) {
      {
        var F = Function.call.bind(mt);
        for (var Y in n)
          if (F(n, Y)) {
            var K = void 0;
            try {
              if (typeof n[Y] != "function") {
                var re = Error((b || "React class") + ": " + v + " type `" + Y + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof n[Y] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw re.name = "Invariant Violation", re;
              }
              K = n[Y](s, Y, b, v, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (_e) {
              K = _e;
            }
            K && !(K instanceof Error) && (Hu(R), l("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", b || "React class", v, Y, typeof K), Hu(null)), K instanceof Error && !(K.message in Fi) && (Fi[K.message] = !0, Hu(R), l("Failed %s type: %s", v, K.message), Hu(null));
          }
      }
    }
    var gc = [], Gs;
    Gs = [];
    var Jl = -1;
    function Vu(n) {
      return {
        current: n
      };
    }
    function Gu(n, s) {
      if (Jl < 0) {
        l("Unexpected pop.");
        return;
      }
      s !== Gs[Jl] && l("Unexpected Fiber popped."), n.current = gc[Jl], gc[Jl] = null, Gs[Jl] = null, Jl--;
    }
    function Hf(n, s, v) {
      Jl++, gc[Jl] = n.current, Gs[Jl] = v, n.current = s;
    }
    var Hw;
    Hw = {};
    var $d = {};
    Object.freeze($d);
    var tv = Vu($d), om = Vu(!1), z1 = $d;
    function kg(n, s, v) {
      return v && lm(s) ? z1 : tv.current;
    }
    function Vw(n, s, v) {
      {
        var b = n.stateNode;
        b.__reactInternalMemoizedUnmaskedChildContext = s, b.__reactInternalMemoizedMaskedChildContext = v;
      }
    }
    function ux(n, s) {
      {
        var v = n.type, b = v.contextTypes;
        if (!b)
          return $d;
        var R = n.stateNode;
        if (R && R.__reactInternalMemoizedUnmaskedChildContext === s)
          return R.__reactInternalMemoizedMaskedChildContext;
        var F = {};
        for (var Y in b)
          F[Y] = s[Y];
        {
          var K = xr(n) || "Unknown";
          Vs(b, F, "context", K);
        }
        return R && Vw(n, s, F), F;
      }
    }
    function cx() {
      return om.current;
    }
    function lm(n) {
      {
        var s = n.childContextTypes;
        return s != null;
      }
    }
    function __(n) {
      Gu(om, n), Gu(tv, n);
    }
    function fx(n) {
      Gu(om, n), Gu(tv, n);
    }
    function oT(n, s, v) {
      {
        if (tv.current !== $d)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Hf(tv, s, n), Hf(om, v, n);
      }
    }
    function lT(n, s, v) {
      {
        var b = n.stateNode, R = s.childContextTypes;
        if (typeof b.getChildContext != "function") {
          {
            var F = xr(n) || "Unknown";
            Hw[F] || (Hw[F] = !0, l("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", F, F));
          }
          return v;
        }
        var Y = b.getChildContext();
        for (var K in Y)
          if (!(K in R))
            throw new Error((xr(n) || "Unknown") + '.getChildContext(): key "' + K + '" is not defined in childContextTypes.');
        {
          var re = xr(n) || "Unknown";
          Vs(R, Y, "child context", re);
        }
        return Xn({}, v, Y);
      }
    }
    function b_(n) {
      {
        var s = n.stateNode, v = s && s.__reactInternalMemoizedMergedChildContext || $d;
        return z1 = tv.current, Hf(tv, v, n), Hf(om, om.current, n), !0;
      }
    }
    function uT(n, s, v) {
      {
        var b = n.stateNode;
        if (!b)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (v) {
          var R = lT(n, s, z1);
          b.__reactInternalMemoizedMergedChildContext = R, Gu(om, n), Gu(tv, n), Hf(tv, R, n), Hf(om, v, n);
        } else
          Gu(om, n), Hf(om, v, n);
      }
    }
    function rR(n) {
      {
        if (!Ou(n) || n.tag !== m)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var s = n;
        do {
          switch (s.tag) {
            case _:
              return s.stateNode.context;
            case m: {
              var v = s.type;
              if (lm(v))
                return s.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          s = s.return;
        } while (s !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ig = 0, N1 = 1, um = null, Gw = !1, w_ = !1;
    function cT(n) {
      um === null ? um = [n] : um.push(n);
    }
    function fT(n) {
      Gw = !0, cT(n);
    }
    function dT() {
      Gw && Bg();
    }
    function Bg() {
      if (!w_ && um !== null) {
        w_ = !0;
        var n = 0, s = pc();
        try {
          var v = !0, b = um;
          for (to(Xo); n < b.length; n++) {
            var R = b[n];
            do
              R = R(v);
            while (R !== null);
          }
          um = null, Gw = !1;
        } catch (F) {
          throw um !== null && (um = um.slice(n + 1)), Vo(Hp, Bg), F;
        } finally {
          to(s), w_ = !1;
        }
      }
      return null;
    }
    var dx = [], hx = 0, E_ = null, M_ = 0, _p = [], bp = 0, Zy = null, Bv = 1, Hv = "";
    function hT(n) {
      return cm(), (n.flags & lc) !== vr;
    }
    function wp(n) {
      return cm(), M_;
    }
    function iR() {
      var n = Hv, s = Bv, v = s & ~T_(s);
      return v.toString(32) + n;
    }
    function Jy(n, s) {
      cm(), dx[hx++] = M_, dx[hx++] = E_, E_ = n, M_ = s;
    }
    function pT(n, s, v) {
      cm(), _p[bp++] = Bv, _p[bp++] = Hv, _p[bp++] = Zy, Zy = n;
      var b = Bv, R = Hv, F = Ky(b) - 1, Y = b & ~(1 << F), K = v + 1, re = Ky(s) + F;
      if (re > 30) {
        var _e = F - F % 5, Re = (1 << _e) - 1, nt = (Y & Re).toString(32), $e = Y >> _e, Dt = F - _e, Lt = Ky(s) + Dt, Yt = K << Dt, er = Yt | $e, Dr = nt + R;
        Bv = 1 << Lt | er, Hv = Dr;
      } else {
        var _r = K << F, ma = _r | Y, ta = R;
        Bv = 1 << re | ma, Hv = ta;
      }
    }
    function Ww(n) {
      cm();
      var s = n.return;
      if (s !== null) {
        var v = 1, b = 0;
        Jy(n, v), pT(n, v, b);
      }
    }
    function Ky(n) {
      return 32 - jl(n);
    }
    function T_(n) {
      return 1 << Ky(n) - 1;
    }
    function px(n) {
      for (; n === E_; )
        E_ = dx[--hx], dx[hx] = null, M_ = dx[--hx], dx[hx] = null;
      for (; n === Zy; )
        Zy = _p[--bp], _p[bp] = null, Hv = _p[--bp], _p[bp] = null, Bv = _p[--bp], _p[bp] = null;
    }
    function C_() {
      return cm(), Zy !== null ? {
        id: Bv,
        overflow: Hv
      } : null;
    }
    function R_(n, s) {
      cm(), _p[bp++] = Bv, _p[bp++] = Hv, _p[bp++] = Zy, Bv = s.id, Hv = s.overflow, Zy = n;
    }
    function cm() {
      Ws() || l("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Qc = null, Ep = null, fm = !1, $y = !1, Hg = null;
    function jw() {
      fm && l("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function A_() {
      $y = !0;
    }
    function Yw() {
      return $y;
    }
    function mT(n) {
      var s = n.stateNode.containerInfo;
      return Ep = sm(s), Qc = n, fm = !0, Hg = null, $y = !1, !0;
    }
    function aR(n, s, v) {
      return Ep = P1(s), Qc = n, fm = !0, Hg = null, $y = !1, v !== null && R_(n, v), !0;
    }
    function F1(n, s) {
      switch (n.tag) {
        case _: {
          ox(n.stateNode.containerInfo, s);
          break;
        }
        case C: {
          var v = (n.mode & Yr) !== hr;
          y_(
            n.type,
            n.memoizedProps,
            n.stateNode,
            s,
            v
          );
          break;
        }
        case X: {
          var b = n.memoizedState;
          b.dehydrated !== null && kw(b.dehydrated, s);
          break;
        }
      }
    }
    function vT(n, s) {
      F1(n, s);
      var v = FB();
      v.stateNode = s, v.return = n;
      var b = n.deletions;
      b === null ? (n.deletions = [v], n.flags |= bi) : b.push(v);
    }
    function Xw(n, s) {
      {
        if ($y)
          return;
        switch (n.tag) {
          case _: {
            var v = n.stateNode.containerInfo;
            switch (s.tag) {
              case C:
                var b = s.type;
                s.pendingProps, Iw(v, b);
                break;
              case D:
                var R = s.pendingProps;
                x_(v, R);
                break;
            }
            break;
          }
          case C: {
            var F = n.type, Y = n.memoizedProps, K = n.stateNode;
            switch (s.tag) {
              case C: {
                var re = s.type, _e = s.pendingProps, Re = (n.mode & Yr) !== hr;
                ev(
                  F,
                  Y,
                  K,
                  re,
                  _e,
                  Re
                );
                break;
              }
              case D: {
                var nt = s.pendingProps, $e = (n.mode & Yr) !== hr;
                Bw(
                  F,
                  Y,
                  K,
                  nt,
                  $e
                );
                break;
              }
            }
            break;
          }
          case X: {
            var Dt = n.memoizedState, Lt = Dt.dehydrated;
            if (Lt !== null)
              switch (s.tag) {
                case C:
                  var Yt = s.type;
                  s.pendingProps, S_(Lt, Yt);
                  break;
                case D:
                  var er = s.pendingProps;
                  lx(Lt, er);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function gT(n, s) {
      s.flags = s.flags & ~Fl | oi, Xw(n, s);
    }
    function k1(n, s) {
      switch (n.tag) {
        case C: {
          var v = n.type;
          n.pendingProps;
          var b = ax(s, v);
          return b !== null ? (n.stateNode = b, Qc = n, Ep = sx(b), !0) : !1;
        }
        case D: {
          var R = n.pendingProps, F = Ow(s, R);
          return F !== null ? (n.stateNode = F, Qc = n, Ep = null, !0) : !1;
        }
        case X: {
          var Y = Yy(s);
          if (Y !== null) {
            var K = {
              dehydrated: Y,
              treeContext: C_(),
              retryLane: vu
            };
            n.memoizedState = K;
            var re = kB(Y);
            return re.return = n, n.child = re, Qc = n, Ep = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function qw(n) {
      return (n.mode & Yr) !== hr && (n.flags & Rr) === vr;
    }
    function Qw(n) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Zw(n) {
      if (!!fm) {
        var s = Ep;
        if (!s) {
          qw(n) && (Xw(Qc, n), Qw()), gT(Qc, n), fm = !1, Qc = n;
          return;
        }
        var v = s;
        if (!k1(n, s)) {
          qw(n) && (Xw(Qc, n), Qw()), s = Xy(v);
          var b = Qc;
          if (!s || !k1(n, s)) {
            gT(Qc, n), fm = !1, Qc = n;
            return;
          }
          vT(b, v);
        }
      }
    }
    function sR(n, s, v) {
      var b = n.stateNode, R = !$y, F = qy(b, n.type, n.memoizedProps, s, v, n, R);
      return n.updateQueue = F, F !== null;
    }
    function yT(n) {
      var s = n.stateNode, v = n.memoizedProps, b = zw(s, v, n);
      if (b) {
        var R = Qc;
        if (R !== null)
          switch (R.tag) {
            case _: {
              var F = R.stateNode.containerInfo, Y = (R.mode & Yr) !== hr;
              Fw(
                F,
                s,
                v,
                Y
              );
              break;
            }
            case C: {
              var K = R.type, re = R.memoizedProps, _e = R.stateNode, Re = (R.mode & Yr) !== hr;
              Qy(
                K,
                re,
                _e,
                s,
                v,
                Re
              );
              break;
            }
          }
      }
      return b;
    }
    function oR(n) {
      var s = n.memoizedState, v = s !== null ? s.dehydrated : null;
      if (!v)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      m_(v, n);
    }
    function Jw(n) {
      var s = n.memoizedState, v = s !== null ? s.dehydrated : null;
      if (!v)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return Nw(v);
    }
    function D_(n) {
      for (var s = n.return; s !== null && s.tag !== C && s.tag !== _ && s.tag !== X; )
        s = s.return;
      Qc = s;
    }
    function ao(n) {
      if (n !== Qc)
        return !1;
      if (!fm)
        return D_(n), fm = !0, !1;
      if (n.tag !== _ && (n.tag !== C || U1(n.type) && !M1(n.type, n.memoizedProps))) {
        var s = Ep;
        if (s)
          if (qw(n))
            Kl(n), Qw();
          else
            for (; s; )
              vT(n, s), s = Xy(s);
      }
      return D_(n), n.tag === X ? Ep = Jw(n) : Ep = Qc ? Xy(n.stateNode) : null, !0;
    }
    function dm() {
      return fm && Ep !== null;
    }
    function Kl(n) {
      for (var s = Ep; s; )
        F1(n, s), s = Xy(s);
    }
    function Vg() {
      Qc = null, Ep = null, fm = !1, $y = !1;
    }
    function Zc() {
      Hg !== null && (UP(Hg), Hg = null);
    }
    function Ws() {
      return fm;
    }
    function hm(n) {
      Hg === null ? Hg = [n] : Hg.push(n);
    }
    var I1 = t.ReactCurrentBatchConfig, e0 = null;
    function L_() {
      return I1.transition;
    }
    var bd = {
      recordUnsafeLifecycleWarnings: function(n, s) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(n, s) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var xT = function(n) {
        for (var s = null, v = n; v !== null; )
          v.mode & fi && (s = v), v = v.return;
        return s;
      }, Vv = function(n) {
        var s = [];
        return n.forEach(function(v) {
          s.push(v);
        }), s.sort().join(", ");
      }, di = [], xu = [], js = [], ul = [], eh = [], t0 = [], Ro = /* @__PURE__ */ new Set();
      bd.recordUnsafeLifecycleWarnings = function(n, s) {
        Ro.has(n.type) || (typeof s.componentWillMount == "function" && s.componentWillMount.__suppressDeprecationWarning !== !0 && di.push(n), n.mode & fi && typeof s.UNSAFE_componentWillMount == "function" && xu.push(n), typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && js.push(n), n.mode & fi && typeof s.UNSAFE_componentWillReceiveProps == "function" && ul.push(n), typeof s.componentWillUpdate == "function" && s.componentWillUpdate.__suppressDeprecationWarning !== !0 && eh.push(n), n.mode & fi && typeof s.UNSAFE_componentWillUpdate == "function" && t0.push(n));
      }, bd.flushPendingUnsafeLifecycleWarnings = function() {
        var n = /* @__PURE__ */ new Set();
        di.length > 0 && (di.forEach(function($e) {
          n.add(xr($e) || "Component"), Ro.add($e.type);
        }), di = []);
        var s = /* @__PURE__ */ new Set();
        xu.length > 0 && (xu.forEach(function($e) {
          s.add(xr($e) || "Component"), Ro.add($e.type);
        }), xu = []);
        var v = /* @__PURE__ */ new Set();
        js.length > 0 && (js.forEach(function($e) {
          v.add(xr($e) || "Component"), Ro.add($e.type);
        }), js = []);
        var b = /* @__PURE__ */ new Set();
        ul.length > 0 && (ul.forEach(function($e) {
          b.add(xr($e) || "Component"), Ro.add($e.type);
        }), ul = []);
        var R = /* @__PURE__ */ new Set();
        eh.length > 0 && (eh.forEach(function($e) {
          R.add(xr($e) || "Component"), Ro.add($e.type);
        }), eh = []);
        var F = /* @__PURE__ */ new Set();
        if (t0.length > 0 && (t0.forEach(function($e) {
          F.add(xr($e) || "Component"), Ro.add($e.type);
        }), t0 = []), s.size > 0) {
          var Y = Vv(s);
          l(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, Y);
        }
        if (b.size > 0) {
          var K = Vv(b);
          l(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, K);
        }
        if (F.size > 0) {
          var re = Vv(F);
          l(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, re);
        }
        if (n.size > 0) {
          var _e = Vv(n);
          o(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _e);
        }
        if (v.size > 0) {
          var Re = Vv(v);
          o(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Re);
        }
        if (R.size > 0) {
          var nt = Vv(R);
          o(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, nt);
        }
      };
      var Gg = /* @__PURE__ */ new Map(), B1 = /* @__PURE__ */ new Set();
      bd.recordLegacyContextWarning = function(n, s) {
        var v = xT(n);
        if (v === null) {
          l("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!B1.has(n.type)) {
          var b = Gg.get(v);
          (n.type.contextTypes != null || n.type.childContextTypes != null || s !== null && typeof s.getChildContext == "function") && (b === void 0 && (b = [], Gg.set(v, b)), b.push(n));
        }
      }, bd.flushLegacyContextWarning = function() {
        Gg.forEach(function(n, s) {
          if (n.length !== 0) {
            var v = n[0], b = /* @__PURE__ */ new Set();
            n.forEach(function(F) {
              b.add(xr(F) || "Component"), B1.add(F.type);
            });
            var R = Vv(b);
            try {
              Xi(v), l(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, R);
            } finally {
              Ka();
            }
          }
        });
      }, bd.discardPendingWarnings = function() {
        di = [], xu = [], js = [], ul = [], eh = [], t0 = [], Gg = /* @__PURE__ */ new Map();
      };
    }
    function wd(n, s) {
      if (n && n.defaultProps) {
        var v = Xn({}, s), b = n.defaultProps;
        for (var R in b)
          v[R] === void 0 && (v[R] = b[R]);
        return v;
      }
      return s;
    }
    var mx = Vu(null), n0;
    n0 = {};
    var Jc = null, Wg = null, P_ = null, H1 = !1;
    function O_() {
      Jc = null, Wg = null, P_ = null, H1 = !1;
    }
    function r0() {
      H1 = !0;
    }
    function Kw() {
      H1 = !1;
    }
    function V1(n, s, v) {
      Hf(mx, s._currentValue, n), s._currentValue = v, s._currentRenderer !== void 0 && s._currentRenderer !== null && s._currentRenderer !== n0 && l("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), s._currentRenderer = n0;
    }
    function G1(n, s) {
      var v = mx.current;
      Gu(mx, s), n._currentValue = v;
    }
    function jg(n, s, v) {
      for (var b = n; b !== null; ) {
        var R = b.alternate;
        if (At(b.childLanes, s) ? R !== null && !At(R.childLanes, s) && (R.childLanes = qt(R.childLanes, s)) : (b.childLanes = qt(b.childLanes, s), R !== null && (R.childLanes = qt(R.childLanes, s))), b === v)
          break;
        b = b.return;
      }
      b !== v && l("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function i0(n, s, v) {
      Gv(n, s, v);
    }
    function Gv(n, s, v) {
      var b = n.child;
      for (b !== null && (b.return = n); b !== null; ) {
        var R = void 0, F = b.dependencies;
        if (F !== null) {
          R = b.child;
          for (var Y = F.firstContext; Y !== null; ) {
            if (Y.context === s) {
              if (b.tag === m) {
                var K = Li(v), re = rv(ii, K);
                re.tag = Ml;
                var _e = b.updateQueue;
                if (_e !== null) {
                  var Re = _e.shared, nt = Re.pending;
                  nt === null ? re.next = re : (re.next = nt.next, nt.next = re), Re.pending = re;
                }
              }
              b.lanes = qt(b.lanes, v);
              var $e = b.alternate;
              $e !== null && ($e.lanes = qt($e.lanes, v)), jg(b.return, v, n), F.lanes = qt(F.lanes, v);
              break;
            }
            Y = Y.next;
          }
        } else if (b.tag === k)
          R = b.type === n.type ? null : b.child;
        else if (b.tag === ie) {
          var Dt = b.return;
          if (Dt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Dt.lanes = qt(Dt.lanes, v);
          var Lt = Dt.alternate;
          Lt !== null && (Lt.lanes = qt(Lt.lanes, v)), jg(Dt, v, n), R = b.sibling;
        } else
          R = b.child;
        if (R !== null)
          R.return = b;
        else
          for (R = b; R !== null; ) {
            if (R === n) {
              R = null;
              break;
            }
            var Yt = R.sibling;
            if (Yt !== null) {
              Yt.return = R.return, R = Yt;
              break;
            }
            R = R.return;
          }
        b = R;
      }
    }
    function nv(n, s) {
      Jc = n, Wg = null, P_ = null;
      var v = n.dependencies;
      if (v !== null) {
        var b = v.firstContext;
        b !== null && (Qe(v.lanes, s) && PE(), v.firstContext = null);
      }
    }
    function El(n) {
      H1 && l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var s = n._currentValue;
      if (P_ !== n) {
        var v = {
          context: n,
          memoizedValue: s,
          next: null
        };
        if (Wg === null) {
          if (Jc === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Wg = v, Jc.dependencies = {
            lanes: Ht,
            firstContext: v
          };
        } else
          Wg = Wg.next = v;
      }
      return s;
    }
    var a0 = null;
    function s0(n) {
      a0 === null ? a0 = [n] : a0.push(n);
    }
    function $w() {
      if (a0 !== null) {
        for (var n = 0; n < a0.length; n++) {
          var s = a0[n], v = s.interleaved;
          if (v !== null) {
            s.interleaved = null;
            var b = v.next, R = s.pending;
            if (R !== null) {
              var F = R.next;
              R.next = b, v.next = F;
            }
            s.pending = v;
          }
        }
        a0 = null;
      }
    }
    function ST(n, s, v, b) {
      var R = s.interleaved;
      return R === null ? (v.next = v, s0(s)) : (v.next = R.next, R.next = v), s.interleaved = v, yc(n, b);
    }
    function U_(n, s, v, b) {
      var R = s.interleaved;
      R === null ? (v.next = v, s0(s)) : (v.next = R.next, R.next = v), s.interleaved = v;
    }
    function W1(n, s, v, b) {
      var R = s.interleaved;
      return R === null ? (v.next = v, s0(s)) : (v.next = R.next, R.next = v), s.interleaved = v, yc(n, b);
    }
    function Kc(n, s) {
      return yc(n, s);
    }
    var z_ = yc;
    function yc(n, s) {
      n.lanes = qt(n.lanes, s);
      var v = n.alternate;
      v !== null && (v.lanes = qt(v.lanes, s)), v === null && (n.flags & (oi | Fl)) !== vr && YP(n);
      for (var b = n, R = n.return; R !== null; )
        R.childLanes = qt(R.childLanes, s), v = R.alternate, v !== null ? v.childLanes = qt(v.childLanes, s) : (R.flags & (oi | Fl)) !== vr && YP(n), b = R, R = R.return;
      if (b.tag === _) {
        var F = b.stateNode;
        return F;
      } else
        return null;
    }
    var Wv = 0, _T = 1, Ml = 2, eE = 3, o0 = !1, N_, $c;
    N_ = !1, $c = null;
    function F_(n) {
      var s = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ht
        },
        effects: null
      };
      n.updateQueue = s;
    }
    function k_(n, s) {
      var v = s.updateQueue, b = n.updateQueue;
      if (v === b) {
        var R = {
          baseState: b.baseState,
          firstBaseUpdate: b.firstBaseUpdate,
          lastBaseUpdate: b.lastBaseUpdate,
          shared: b.shared,
          effects: b.effects
        };
        s.updateQueue = R;
      }
    }
    function rv(n, s) {
      var v = {
        eventTime: n,
        lane: s,
        tag: Wv,
        payload: null,
        callback: null,
        next: null
      };
      return v;
    }
    function Yg(n, s, v) {
      var b = n.updateQueue;
      if (b === null)
        return null;
      var R = b.shared;
      if ($c === R && !N_ && (l("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), N_ = !0), QI()) {
        var F = R.pending;
        return F === null ? s.next = s : (s.next = F.next, F.next = s), R.pending = s, z_(n, v);
      } else
        return W1(n, R, s, v);
    }
    function I_(n, s, v) {
      var b = s.updateQueue;
      if (b !== null) {
        var R = b.shared;
        if (wr(v)) {
          var F = R.lanes;
          F = Xr(F, n.pendingLanes);
          var Y = qt(F, v);
          R.lanes = Y, gr(n, Y);
        }
      }
    }
    function iv(n, s) {
      var v = n.updateQueue, b = n.alternate;
      if (b !== null) {
        var R = b.updateQueue;
        if (v === R) {
          var F = null, Y = null, K = v.firstBaseUpdate;
          if (K !== null) {
            var re = K;
            do {
              var _e = {
                eventTime: re.eventTime,
                lane: re.lane,
                tag: re.tag,
                payload: re.payload,
                callback: re.callback,
                next: null
              };
              Y === null ? F = Y = _e : (Y.next = _e, Y = _e), re = re.next;
            } while (re !== null);
            Y === null ? F = Y = s : (Y.next = s, Y = s);
          } else
            F = Y = s;
          v = {
            baseState: R.baseState,
            firstBaseUpdate: F,
            lastBaseUpdate: Y,
            shared: R.shared,
            effects: R.effects
          }, n.updateQueue = v;
          return;
        }
      }
      var Re = v.lastBaseUpdate;
      Re === null ? v.firstBaseUpdate = s : Re.next = s, v.lastBaseUpdate = s;
    }
    function bT(n, s, v, b, R, F) {
      switch (v.tag) {
        case _T: {
          var Y = v.payload;
          if (typeof Y == "function") {
            r0();
            var K = Y.call(F, b, R);
            {
              if (n.mode & fi) {
                xa(!0);
                try {
                  Y.call(F, b, R);
                } finally {
                  xa(!1);
                }
              }
              Kw();
            }
            return K;
          }
          return Y;
        }
        case eE:
          n.flags = n.flags & ~bo | Rr;
        case Wv: {
          var re = v.payload, _e;
          if (typeof re == "function") {
            r0(), _e = re.call(F, b, R);
            {
              if (n.mode & fi) {
                xa(!0);
                try {
                  re.call(F, b, R);
                } finally {
                  xa(!1);
                }
              }
              Kw();
            }
          } else
            _e = re;
          return _e == null ? b : Xn({}, b, _e);
        }
        case Ml:
          return o0 = !0, b;
      }
      return b;
    }
    function B_(n, s, v, b) {
      var R = n.updateQueue;
      o0 = !1, $c = R.shared;
      var F = R.firstBaseUpdate, Y = R.lastBaseUpdate, K = R.shared.pending;
      if (K !== null) {
        R.shared.pending = null;
        var re = K, _e = re.next;
        re.next = null, Y === null ? F = _e : Y.next = _e, Y = re;
        var Re = n.alternate;
        if (Re !== null) {
          var nt = Re.updateQueue, $e = nt.lastBaseUpdate;
          $e !== Y && ($e === null ? nt.firstBaseUpdate = _e : $e.next = _e, nt.lastBaseUpdate = re);
        }
      }
      if (F !== null) {
        var Dt = R.baseState, Lt = Ht, Yt = null, er = null, Dr = null, _r = F;
        do {
          var ma = _r.lane, ta = _r.eventTime;
          if (At(b, ma)) {
            if (Dr !== null) {
              var Xt = {
                eventTime: ta,
                lane: vi,
                tag: _r.tag,
                payload: _r.payload,
                callback: _r.callback,
                next: null
              };
              Dr = Dr.next = Xt;
            }
            Dt = bT(n, R, _r, Dt, s, v);
            var St = _r.callback;
            if (St !== null && _r.lane !== vi) {
              n.flags |= Pc;
              var gn = R.effects;
              gn === null ? R.effects = [_r] : gn.push(_r);
            }
          } else {
            var xt = {
              eventTime: ta,
              lane: ma,
              tag: _r.tag,
              payload: _r.payload,
              callback: _r.callback,
              next: null
            };
            Dr === null ? (er = Dr = xt, Yt = Dt) : Dr = Dr.next = xt, Lt = qt(Lt, ma);
          }
          if (_r = _r.next, _r === null) {
            if (K = R.shared.pending, K === null)
              break;
            var tr = K, Yn = tr.next;
            tr.next = null, _r = Yn, R.lastBaseUpdate = tr, R.shared.pending = null;
          }
        } while (!0);
        Dr === null && (Yt = Dt), R.baseState = Yt, R.firstBaseUpdate = er, R.lastBaseUpdate = Dr;
        var Qr = R.shared.interleaved;
        if (Qr !== null) {
          var hi = Qr;
          do
            Lt = qt(Lt, hi.lane), hi = hi.next;
          while (hi !== Qr);
        } else
          F === null && (R.shared.lanes = Ht);
        WE(Lt), n.lanes = Lt, n.memoizedState = Dt;
      }
      $c = null;
    }
    function lR(n, s) {
      if (typeof n != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + n));
      n.call(s);
    }
    function wT() {
      o0 = !1;
    }
    function H_() {
      return o0;
    }
    function j1(n, s, v) {
      var b = s.effects;
      if (s.effects = null, b !== null)
        for (var R = 0; R < b.length; R++) {
          var F = b[R], Y = F.callback;
          Y !== null && (F.callback = null, lR(Y, v));
        }
    }
    var tE = {}, ET = new a.Component().refs, vx, Y1, jv, V_, G_, nE, W_, gx, rE, X1;
    {
      vx = /* @__PURE__ */ new Set(), Y1 = /* @__PURE__ */ new Set(), jv = /* @__PURE__ */ new Set(), V_ = /* @__PURE__ */ new Set(), gx = /* @__PURE__ */ new Set(), G_ = /* @__PURE__ */ new Set(), rE = /* @__PURE__ */ new Set(), X1 = /* @__PURE__ */ new Set();
      var MT = /* @__PURE__ */ new Set();
      W_ = function(n, s) {
        if (!(n === null || typeof n == "function")) {
          var v = s + "_" + n;
          MT.has(v) || (MT.add(v), l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, n));
        }
      }, nE = function(n, s) {
        if (s === void 0) {
          var v = Ci(n) || "Component";
          G_.has(v) || (G_.add(v), l("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", v));
        }
      }, Object.defineProperty(tE, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(tE);
    }
    function iE(n, s, v, b) {
      var R = n.memoizedState, F = v(b, R);
      {
        if (n.mode & fi) {
          xa(!0);
          try {
            F = v(b, R);
          } finally {
            xa(!1);
          }
        }
        nE(s, F);
      }
      var Y = F == null ? R : Xn({}, R, F);
      if (n.memoizedState = Y, n.lanes === Ht) {
        var K = n.updateQueue;
        K.baseState = Y;
      }
    }
    var yx = {
      isMounted: bs,
      enqueueSetState: function(n, s, v) {
        var b = Zs(n), R = Ih(), F = zx(b), Y = rv(R, F);
        Y.payload = s, v != null && (W_(v, "setState"), Y.callback = v);
        var K = Yg(b, Y, F);
        K !== null && (of(K, b, F, R), I_(K, b, F)), fc(b, F);
      },
      enqueueReplaceState: function(n, s, v) {
        var b = Zs(n), R = Ih(), F = zx(b), Y = rv(R, F);
        Y.tag = _T, Y.payload = s, v != null && (W_(v, "replaceState"), Y.callback = v);
        var K = Yg(b, Y, F);
        K !== null && (of(K, b, F, R), I_(K, b, F)), fc(b, F);
      },
      enqueueForceUpdate: function(n, s) {
        var v = Zs(n), b = Ih(), R = zx(v), F = rv(b, R);
        F.tag = Ml, s != null && (W_(s, "forceUpdate"), F.callback = s);
        var Y = Yg(v, F, R);
        Y !== null && (of(Y, v, R, b), I_(Y, v, R)), Eh(v, R);
      }
    };
    function TT(n, s, v, b, R, F, Y) {
      var K = n.stateNode;
      if (typeof K.shouldComponentUpdate == "function") {
        var re = K.shouldComponentUpdate(b, F, Y);
        {
          if (n.mode & fi) {
            xa(!0);
            try {
              re = K.shouldComponentUpdate(b, F, Y);
            } finally {
              xa(!1);
            }
          }
          re === void 0 && l("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Ci(s) || "Component");
        }
        return re;
      }
      return s.prototype && s.prototype.isPureReactComponent ? !pr(v, b) || !pr(R, F) : !0;
    }
    function uR(n, s, v) {
      var b = n.stateNode;
      {
        var R = Ci(s) || "Component", F = b.render;
        F || (s.prototype && typeof s.prototype.render == "function" ? l("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", R) : l("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", R)), b.getInitialState && !b.getInitialState.isReactClassApproved && !b.state && l("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", R), b.getDefaultProps && !b.getDefaultProps.isReactClassApproved && l("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", R), b.propTypes && l("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", R), b.contextType && l("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", R), b.contextTypes && l("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", R), s.contextType && s.contextTypes && !rE.has(s) && (rE.add(s), l("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", R)), typeof b.componentShouldUpdate == "function" && l("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", R), s.prototype && s.prototype.isPureReactComponent && typeof b.shouldComponentUpdate < "u" && l("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Ci(s) || "A pure component"), typeof b.componentDidUnmount == "function" && l("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", R), typeof b.componentDidReceiveProps == "function" && l("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", R), typeof b.componentWillRecieveProps == "function" && l("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", R), typeof b.UNSAFE_componentWillRecieveProps == "function" && l("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", R);
        var Y = b.props !== v;
        b.props !== void 0 && Y && l("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", R, R), b.defaultProps && l("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", R, R), typeof b.getSnapshotBeforeUpdate == "function" && typeof b.componentDidUpdate != "function" && !jv.has(s) && (jv.add(s), l("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Ci(s))), typeof b.getDerivedStateFromProps == "function" && l("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof b.getDerivedStateFromError == "function" && l("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", R), typeof s.getSnapshotBeforeUpdate == "function" && l("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", R);
        var K = b.state;
        K && (typeof K != "object" || qs(K)) && l("%s.state: must be set to an object or null", R), typeof b.getChildContext == "function" && typeof s.childContextTypes != "object" && l("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", R);
      }
    }
    function CT(n, s) {
      s.updater = yx, n.stateNode = s, Hn(s, n), s._reactInternalInstance = tE;
    }
    function aE(n, s, v) {
      var b = !1, R = $d, F = $d, Y = s.contextType;
      if ("contextType" in s) {
        var K = Y === null || Y !== void 0 && Y.$$typeof === qe && Y._context === void 0;
        if (!K && !X1.has(s)) {
          X1.add(s);
          var re = "";
          Y === void 0 ? re = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof Y != "object" ? re = " However, it is set to a " + typeof Y + "." : Y.$$typeof === Oe ? re = " Did you accidentally pass the Context.Provider instead?" : Y._context !== void 0 ? re = " Did you accidentally pass the Context.Consumer instead?" : re = " However, it is set to an object with keys {" + Object.keys(Y).join(", ") + "}.", l("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Ci(s) || "Component", re);
        }
      }
      if (typeof Y == "object" && Y !== null)
        F = El(Y);
      else {
        R = kg(n, s, !0);
        var _e = s.contextTypes;
        b = _e != null, F = b ? ux(n, R) : $d;
      }
      var Re = new s(v, F);
      if (n.mode & fi) {
        xa(!0);
        try {
          Re = new s(v, F);
        } finally {
          xa(!1);
        }
      }
      var nt = n.memoizedState = Re.state !== null && Re.state !== void 0 ? Re.state : null;
      CT(n, Re);
      {
        if (typeof s.getDerivedStateFromProps == "function" && nt === null) {
          var $e = Ci(s) || "Component";
          Y1.has($e) || (Y1.add($e), l("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $e, Re.state === null ? "null" : "undefined", $e));
        }
        if (typeof s.getDerivedStateFromProps == "function" || typeof Re.getSnapshotBeforeUpdate == "function") {
          var Dt = null, Lt = null, Yt = null;
          if (typeof Re.componentWillMount == "function" && Re.componentWillMount.__suppressDeprecationWarning !== !0 ? Dt = "componentWillMount" : typeof Re.UNSAFE_componentWillMount == "function" && (Dt = "UNSAFE_componentWillMount"), typeof Re.componentWillReceiveProps == "function" && Re.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Lt = "componentWillReceiveProps" : typeof Re.UNSAFE_componentWillReceiveProps == "function" && (Lt = "UNSAFE_componentWillReceiveProps"), typeof Re.componentWillUpdate == "function" && Re.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Yt = "componentWillUpdate" : typeof Re.UNSAFE_componentWillUpdate == "function" && (Yt = "UNSAFE_componentWillUpdate"), Dt !== null || Lt !== null || Yt !== null) {
            var er = Ci(s) || "Component", Dr = typeof s.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            V_.has(er) || (V_.add(er), l(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, er, Dr, Dt !== null ? `
  ` + Dt : "", Lt !== null ? `
  ` + Lt : "", Yt !== null ? `
  ` + Yt : ""));
          }
        }
      }
      return b && Vw(n, R, F), Re;
    }
    function RT(n, s) {
      var v = s.state;
      typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(), v !== s.state && (l("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xr(n) || "Component"), yx.enqueueReplaceState(s, s.state, null));
    }
    function Xg(n, s, v, b) {
      var R = s.state;
      if (typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(v, b), typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(v, b), s.state !== R) {
        {
          var F = xr(n) || "Component";
          vx.has(F) || (vx.add(F), l("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", F));
        }
        yx.enqueueReplaceState(s, s.state, null);
      }
    }
    function sE(n, s, v, b) {
      uR(n, s, v);
      var R = n.stateNode;
      R.props = v, R.state = n.memoizedState, R.refs = ET, F_(n);
      var F = s.contextType;
      if (typeof F == "object" && F !== null)
        R.context = El(F);
      else {
        var Y = kg(n, s, !0);
        R.context = ux(n, Y);
      }
      {
        if (R.state === v) {
          var K = Ci(s) || "Component";
          gx.has(K) || (gx.add(K), l("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", K));
        }
        n.mode & fi && bd.recordLegacyContextWarning(n, R), bd.recordUnsafeLifecycleWarnings(n, R);
      }
      R.state = n.memoizedState;
      var re = s.getDerivedStateFromProps;
      if (typeof re == "function" && (iE(n, s, re, v), R.state = n.memoizedState), typeof s.getDerivedStateFromProps != "function" && typeof R.getSnapshotBeforeUpdate != "function" && (typeof R.UNSAFE_componentWillMount == "function" || typeof R.componentWillMount == "function") && (RT(n, R), B_(n, v, R, b), R.state = n.memoizedState), typeof R.componentDidMount == "function") {
        var _e = Gn;
        _e |= _s, (n.mode & Ns) !== hr && (_e |= Vr), n.flags |= _e;
      }
    }
    function av(n, s, v, b) {
      var R = n.stateNode, F = n.memoizedProps;
      R.props = F;
      var Y = R.context, K = s.contextType, re = $d;
      if (typeof K == "object" && K !== null)
        re = El(K);
      else {
        var _e = kg(n, s, !0);
        re = ux(n, _e);
      }
      var Re = s.getDerivedStateFromProps, nt = typeof Re == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !nt && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (F !== v || Y !== re) && Xg(n, R, v, re), wT();
      var $e = n.memoizedState, Dt = R.state = $e;
      if (B_(n, v, R, b), Dt = n.memoizedState, F === v && $e === Dt && !cx() && !H_()) {
        if (typeof R.componentDidMount == "function") {
          var Lt = Gn;
          Lt |= _s, (n.mode & Ns) !== hr && (Lt |= Vr), n.flags |= Lt;
        }
        return !1;
      }
      typeof Re == "function" && (iE(n, s, Re, v), Dt = n.memoizedState);
      var Yt = H_() || TT(n, s, F, v, $e, Dt, re);
      if (Yt) {
        if (!nt && (typeof R.UNSAFE_componentWillMount == "function" || typeof R.componentWillMount == "function") && (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function") {
          var er = Gn;
          er |= _s, (n.mode & Ns) !== hr && (er |= Vr), n.flags |= er;
        }
      } else {
        if (typeof R.componentDidMount == "function") {
          var Dr = Gn;
          Dr |= _s, (n.mode & Ns) !== hr && (Dr |= Vr), n.flags |= Dr;
        }
        n.memoizedProps = v, n.memoizedState = Dt;
      }
      return R.props = v, R.state = Dt, R.context = re, Yt;
    }
    function cR(n, s, v, b, R) {
      var F = s.stateNode;
      k_(n, s);
      var Y = s.memoizedProps, K = s.type === s.elementType ? Y : wd(s.type, Y);
      F.props = K;
      var re = s.pendingProps, _e = F.context, Re = v.contextType, nt = $d;
      if (typeof Re == "object" && Re !== null)
        nt = El(Re);
      else {
        var $e = kg(s, v, !0);
        nt = ux(s, $e);
      }
      var Dt = v.getDerivedStateFromProps, Lt = typeof Dt == "function" || typeof F.getSnapshotBeforeUpdate == "function";
      !Lt && (typeof F.UNSAFE_componentWillReceiveProps == "function" || typeof F.componentWillReceiveProps == "function") && (Y !== re || _e !== nt) && Xg(s, F, b, nt), wT();
      var Yt = s.memoizedState, er = F.state = Yt;
      if (B_(s, b, F, R), er = s.memoizedState, Y === re && Yt === er && !cx() && !H_() && !fe)
        return typeof F.componentDidUpdate == "function" && (Y !== n.memoizedProps || Yt !== n.memoizedState) && (s.flags |= Gn), typeof F.getSnapshotBeforeUpdate == "function" && (Y !== n.memoizedProps || Yt !== n.memoizedState) && (s.flags |= Nl), !1;
      typeof Dt == "function" && (iE(s, v, Dt, b), er = s.memoizedState);
      var Dr = H_() || TT(s, v, K, b, Yt, er, nt) || fe;
      return Dr ? (!Lt && (typeof F.UNSAFE_componentWillUpdate == "function" || typeof F.componentWillUpdate == "function") && (typeof F.componentWillUpdate == "function" && F.componentWillUpdate(b, er, nt), typeof F.UNSAFE_componentWillUpdate == "function" && F.UNSAFE_componentWillUpdate(b, er, nt)), typeof F.componentDidUpdate == "function" && (s.flags |= Gn), typeof F.getSnapshotBeforeUpdate == "function" && (s.flags |= Nl)) : (typeof F.componentDidUpdate == "function" && (Y !== n.memoizedProps || Yt !== n.memoizedState) && (s.flags |= Gn), typeof F.getSnapshotBeforeUpdate == "function" && (Y !== n.memoizedProps || Yt !== n.memoizedState) && (s.flags |= Nl), s.memoizedProps = b, s.memoizedState = er), F.props = b, F.state = er, F.context = nt, Dr;
    }
    var oE, j_, lE, uE, cE, fE = function(n, s) {
    };
    oE = !1, j_ = !1, lE = {}, uE = {}, cE = {}, fE = function(n, s) {
      if (!(n === null || typeof n != "object") && !(!n._store || n._store.validated || n.key != null)) {
        if (typeof n._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        n._store.validated = !0;
        var v = xr(s) || "Component";
        uE[v] || (uE[v] = !0, l('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function $l(n, s, v) {
      var b = v.ref;
      if (b !== null && typeof b != "function" && typeof b != "object") {
        if ((n.mode & fi || Je) && !(v._owner && v._self && v._owner.stateNode !== v._self)) {
          var R = xr(n) || "Component";
          lE[R] || (l('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', b), lE[R] = !0);
        }
        if (v._owner) {
          var F = v._owner, Y;
          if (F) {
            var K = F;
            if (K.tag !== m)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            Y = K.stateNode;
          }
          if (!Y)
            throw new Error("Missing owner for string ref " + b + ". This error is likely caused by a bug in React. Please file an issue.");
          var re = Y;
          Jt(b, "ref");
          var _e = "" + b;
          if (s !== null && s.ref !== null && typeof s.ref == "function" && s.ref._stringRef === _e)
            return s.ref;
          var Re = function(nt) {
            var $e = re.refs;
            $e === ET && ($e = re.refs = {}), nt === null ? delete $e[_e] : $e[_e] = nt;
          };
          return Re._stringRef = _e, Re;
        } else {
          if (typeof b != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!v._owner)
            throw new Error("Element ref was specified as a string (" + b + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return b;
    }
    function Y_(n, s) {
      var v = Object.prototype.toString.call(s);
      throw new Error("Objects are not valid as a React child (found: " + (v === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : v) + "). If you meant to render a collection of children, use an array instead.");
    }
    function q1(n) {
      {
        var s = xr(n) || "Component";
        if (cE[s])
          return;
        cE[s] = !0, l("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function AT(n) {
      var s = n._payload, v = n._init;
      return v(s);
    }
    function DT(n) {
      function s(xt, Xt) {
        if (!!n) {
          var St = xt.deletions;
          St === null ? (xt.deletions = [Xt], xt.flags |= bi) : St.push(Xt);
        }
      }
      function v(xt, Xt) {
        if (!n)
          return null;
        for (var St = Xt; St !== null; )
          s(xt, St), St = St.sibling;
        return null;
      }
      function b(xt, Xt) {
        for (var St = /* @__PURE__ */ new Map(), gn = Xt; gn !== null; )
          gn.key !== null ? St.set(gn.key, gn) : St.set(gn.index, gn), gn = gn.sibling;
        return St;
      }
      function R(xt, Xt) {
        var St = hS(xt, Xt);
        return St.index = 0, St.sibling = null, St;
      }
      function F(xt, Xt, St) {
        if (xt.index = St, !n)
          return xt.flags |= lc, Xt;
        var gn = xt.alternate;
        if (gn !== null) {
          var tr = gn.index;
          return tr < Xt ? (xt.flags |= oi, Xt) : tr;
        } else
          return xt.flags |= oi, Xt;
      }
      function Y(xt) {
        return n && xt.alternate === null && (xt.flags |= oi), xt;
      }
      function K(xt, Xt, St, gn) {
        if (Xt === null || Xt.tag !== D) {
          var tr = hA(St, xt.mode, gn);
          return tr.return = xt, tr;
        } else {
          var Yn = R(Xt, St);
          return Yn.return = xt, Yn;
        }
      }
      function re(xt, Xt, St, gn) {
        var tr = St.type;
        if (tr === Te)
          return Re(xt, Xt, St.props.children, gn, St.key);
        if (Xt !== null && (Xt.elementType === tr || ZP(Xt, St) || typeof tr == "object" && tr !== null && tr.$$typeof === vn && AT(tr) === Xt.type)) {
          var Yn = R(Xt, St.props);
          return Yn.ref = $l(xt, Xt, St), Yn.return = xt, Yn._debugSource = St._source, Yn._debugOwner = St._owner, Yn;
        }
        var Qr = dA(St, xt.mode, gn);
        return Qr.ref = $l(xt, Xt, St), Qr.return = xt, Qr;
      }
      function _e(xt, Xt, St, gn) {
        if (Xt === null || Xt.tag !== T || Xt.stateNode.containerInfo !== St.containerInfo || Xt.stateNode.implementation !== St.implementation) {
          var tr = pA(St, xt.mode, gn);
          return tr.return = xt, tr;
        } else {
          var Yn = R(Xt, St.children || []);
          return Yn.return = xt, Yn;
        }
      }
      function Re(xt, Xt, St, gn, tr) {
        if (Xt === null || Xt.tag !== P) {
          var Yn = Fx(St, xt.mode, gn, tr);
          return Yn.return = xt, Yn;
        } else {
          var Qr = R(Xt, St);
          return Qr.return = xt, Qr;
        }
      }
      function nt(xt, Xt, St) {
        if (typeof Xt == "string" && Xt !== "" || typeof Xt == "number") {
          var gn = hA("" + Xt, xt.mode, St);
          return gn.return = xt, gn;
        }
        if (typeof Xt == "object" && Xt !== null) {
          switch (Xt.$$typeof) {
            case ji: {
              var tr = dA(Xt, xt.mode, St);
              return tr.ref = $l(xt, null, Xt), tr.return = xt, tr;
            }
            case Si: {
              var Yn = pA(Xt, xt.mode, St);
              return Yn.return = xt, Yn;
            }
            case vn: {
              var Qr = Xt._payload, hi = Xt._init;
              return nt(xt, hi(Qr), St);
            }
          }
          if (qs(Xt) || ls(Xt)) {
            var As = Fx(Xt, xt.mode, St, null);
            return As.return = xt, As;
          }
          Y_(xt, Xt);
        }
        return typeof Xt == "function" && q1(xt), null;
      }
      function $e(xt, Xt, St, gn) {
        var tr = Xt !== null ? Xt.key : null;
        if (typeof St == "string" && St !== "" || typeof St == "number")
          return tr !== null ? null : K(xt, Xt, "" + St, gn);
        if (typeof St == "object" && St !== null) {
          switch (St.$$typeof) {
            case ji:
              return St.key === tr ? re(xt, Xt, St, gn) : null;
            case Si:
              return St.key === tr ? _e(xt, Xt, St, gn) : null;
            case vn: {
              var Yn = St._payload, Qr = St._init;
              return $e(xt, Xt, Qr(Yn), gn);
            }
          }
          if (qs(St) || ls(St))
            return tr !== null ? null : Re(xt, Xt, St, gn, null);
          Y_(xt, St);
        }
        return typeof St == "function" && q1(xt), null;
      }
      function Dt(xt, Xt, St, gn, tr) {
        if (typeof gn == "string" && gn !== "" || typeof gn == "number") {
          var Yn = xt.get(St) || null;
          return K(Xt, Yn, "" + gn, tr);
        }
        if (typeof gn == "object" && gn !== null) {
          switch (gn.$$typeof) {
            case ji: {
              var Qr = xt.get(gn.key === null ? St : gn.key) || null;
              return re(Xt, Qr, gn, tr);
            }
            case Si: {
              var hi = xt.get(gn.key === null ? St : gn.key) || null;
              return _e(Xt, hi, gn, tr);
            }
            case vn:
              var As = gn._payload, ja = gn._init;
              return Dt(xt, Xt, St, ja(As), tr);
          }
          if (qs(gn) || ls(gn)) {
            var Yu = xt.get(St) || null;
            return Re(Xt, Yu, gn, tr, null);
          }
          Y_(Xt, gn);
        }
        return typeof gn == "function" && q1(Xt), null;
      }
      function Lt(xt, Xt, St) {
        {
          if (typeof xt != "object" || xt === null)
            return Xt;
          switch (xt.$$typeof) {
            case ji:
            case Si:
              fE(xt, St);
              var gn = xt.key;
              if (typeof gn != "string")
                break;
              if (Xt === null) {
                Xt = /* @__PURE__ */ new Set(), Xt.add(gn);
                break;
              }
              if (!Xt.has(gn)) {
                Xt.add(gn);
                break;
              }
              l("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", gn);
              break;
            case vn:
              var tr = xt._payload, Yn = xt._init;
              Lt(Yn(tr), Xt, St);
              break;
          }
        }
        return Xt;
      }
      function Yt(xt, Xt, St, gn) {
        for (var tr = null, Yn = 0; Yn < St.length; Yn++) {
          var Qr = St[Yn];
          tr = Lt(Qr, tr, xt);
        }
        for (var hi = null, As = null, ja = Xt, Yu = 0, Ya = 0, _u = null; ja !== null && Ya < St.length; Ya++) {
          ja.index > Ya ? (_u = ja, ja = null) : _u = ja.sibling;
          var ah = $e(xt, ja, St[Ya], gn);
          if (ah === null) {
            ja === null && (ja = _u);
            break;
          }
          n && ja && ah.alternate === null && s(xt, ja), Yu = F(ah, Yu, Ya), As === null ? hi = ah : As.sibling = ah, As = ah, ja = _u;
        }
        if (Ya === St.length) {
          if (v(xt, ja), Ws()) {
            var Ad = Ya;
            Jy(xt, Ad);
          }
          return hi;
        }
        if (ja === null) {
          for (; Ya < St.length; Ya++) {
            var vm = nt(xt, St[Ya], gn);
            vm !== null && (Yu = F(vm, Yu, Ya), As === null ? hi = vm : As.sibling = vm, As = vm);
          }
          if (Ws()) {
            var Bh = Ya;
            Jy(xt, Bh);
          }
          return hi;
        }
        for (var Hh = b(xt, ja); Ya < St.length; Ya++) {
          var sh = Dt(Hh, xt, Ya, St[Ya], gn);
          sh !== null && (n && sh.alternate !== null && Hh.delete(sh.key === null ? Ya : sh.key), Yu = F(sh, Yu, Ya), As === null ? hi = sh : As.sibling = sh, As = sh);
        }
        if (n && Hh.forEach(function(mb) {
          return s(xt, mb);
        }), Ws()) {
          var x0 = Ya;
          Jy(xt, x0);
        }
        return hi;
      }
      function er(xt, Xt, St, gn) {
        var tr = ls(St);
        if (typeof tr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && St[Symbol.toStringTag] === "Generator" && (j_ || l("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), j_ = !0), St.entries === tr && (oE || l("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), oE = !0);
          var Yn = tr.call(St);
          if (Yn)
            for (var Qr = null, hi = Yn.next(); !hi.done; hi = Yn.next()) {
              var As = hi.value;
              Qr = Lt(As, Qr, xt);
            }
        }
        var ja = tr.call(St);
        if (ja == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Yu = null, Ya = null, _u = Xt, ah = 0, Ad = 0, vm = null, Bh = ja.next(); _u !== null && !Bh.done; Ad++, Bh = ja.next()) {
          _u.index > Ad ? (vm = _u, _u = null) : vm = _u.sibling;
          var Hh = $e(xt, _u, Bh.value, gn);
          if (Hh === null) {
            _u === null && (_u = vm);
            break;
          }
          n && _u && Hh.alternate === null && s(xt, _u), ah = F(Hh, ah, Ad), Ya === null ? Yu = Hh : Ya.sibling = Hh, Ya = Hh, _u = vm;
        }
        if (Bh.done) {
          if (v(xt, _u), Ws()) {
            var sh = Ad;
            Jy(xt, sh);
          }
          return Yu;
        }
        if (_u === null) {
          for (; !Bh.done; Ad++, Bh = ja.next()) {
            var x0 = nt(xt, Bh.value, gn);
            x0 !== null && (ah = F(x0, ah, Ad), Ya === null ? Yu = x0 : Ya.sibling = x0, Ya = x0);
          }
          if (Ws()) {
            var mb = Ad;
            Jy(xt, mb);
          }
          return Yu;
        }
        for (var QE = b(xt, _u); !Bh.done; Ad++, Bh = ja.next()) {
          var ty = Dt(QE, xt, Ad, Bh.value, gn);
          ty !== null && (n && ty.alternate !== null && QE.delete(ty.key === null ? Ad : ty.key), ah = F(ty, ah, Ad), Ya === null ? Yu = ty : Ya.sibling = ty, Ya = ty);
        }
        if (n && QE.forEach(function(m5) {
          return s(xt, m5);
        }), Ws()) {
          var p5 = Ad;
          Jy(xt, p5);
        }
        return Yu;
      }
      function Dr(xt, Xt, St, gn) {
        if (Xt !== null && Xt.tag === D) {
          v(xt, Xt.sibling);
          var tr = R(Xt, St);
          return tr.return = xt, tr;
        }
        v(xt, Xt);
        var Yn = hA(St, xt.mode, gn);
        return Yn.return = xt, Yn;
      }
      function _r(xt, Xt, St, gn) {
        for (var tr = St.key, Yn = Xt; Yn !== null; ) {
          if (Yn.key === tr) {
            var Qr = St.type;
            if (Qr === Te) {
              if (Yn.tag === P) {
                v(xt, Yn.sibling);
                var hi = R(Yn, St.props.children);
                return hi.return = xt, hi._debugSource = St._source, hi._debugOwner = St._owner, hi;
              }
            } else if (Yn.elementType === Qr || ZP(Yn, St) || typeof Qr == "object" && Qr !== null && Qr.$$typeof === vn && AT(Qr) === Yn.type) {
              v(xt, Yn.sibling);
              var As = R(Yn, St.props);
              return As.ref = $l(xt, Yn, St), As.return = xt, As._debugSource = St._source, As._debugOwner = St._owner, As;
            }
            v(xt, Yn);
            break;
          } else
            s(xt, Yn);
          Yn = Yn.sibling;
        }
        if (St.type === Te) {
          var ja = Fx(St.props.children, xt.mode, gn, St.key);
          return ja.return = xt, ja;
        } else {
          var Yu = dA(St, xt.mode, gn);
          return Yu.ref = $l(xt, Xt, St), Yu.return = xt, Yu;
        }
      }
      function ma(xt, Xt, St, gn) {
        for (var tr = St.key, Yn = Xt; Yn !== null; ) {
          if (Yn.key === tr)
            if (Yn.tag === T && Yn.stateNode.containerInfo === St.containerInfo && Yn.stateNode.implementation === St.implementation) {
              v(xt, Yn.sibling);
              var Qr = R(Yn, St.children || []);
              return Qr.return = xt, Qr;
            } else {
              v(xt, Yn);
              break;
            }
          else
            s(xt, Yn);
          Yn = Yn.sibling;
        }
        var hi = pA(St, xt.mode, gn);
        return hi.return = xt, hi;
      }
      function ta(xt, Xt, St, gn) {
        var tr = typeof St == "object" && St !== null && St.type === Te && St.key === null;
        if (tr && (St = St.props.children), typeof St == "object" && St !== null) {
          switch (St.$$typeof) {
            case ji:
              return Y(_r(xt, Xt, St, gn));
            case Si:
              return Y(ma(xt, Xt, St, gn));
            case vn:
              var Yn = St._payload, Qr = St._init;
              return ta(xt, Xt, Qr(Yn), gn);
          }
          if (qs(St))
            return Yt(xt, Xt, St, gn);
          if (ls(St))
            return er(xt, Xt, St, gn);
          Y_(xt, St);
        }
        return typeof St == "string" && St !== "" || typeof St == "number" ? Y(Dr(xt, Xt, "" + St, gn)) : (typeof St == "function" && q1(xt), v(xt, Xt));
      }
      return ta;
    }
    var xx = DT(!0), LT = DT(!1);
    function fR(n, s) {
      if (n !== null && s.child !== n.child)
        throw new Error("Resuming work not yet implemented.");
      if (s.child !== null) {
        var v = s.child, b = hS(v, v.pendingProps);
        for (s.child = b, b.return = s; v.sibling !== null; )
          v = v.sibling, b = b.sibling = hS(v, v.pendingProps), b.return = s;
        b.sibling = null;
      }
    }
    function PT(n, s) {
      for (var v = n.child; v !== null; )
        PB(v, s), v = v.sibling;
    }
    var qg = {}, pm = Vu(qg), Sx = Vu(qg), _x = Vu(qg);
    function X_(n) {
      if (n === qg)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return n;
    }
    function dE() {
      var n = X_(_x.current);
      return n;
    }
    function Q1(n, s) {
      Hf(_x, s, n), Hf(Sx, n, n), Hf(pm, qg, n);
      var v = bw(s);
      Gu(pm, n), Hf(pm, v, n);
    }
    function bx(n) {
      Gu(pm, n), Gu(Sx, n), Gu(_x, n);
    }
    function l0() {
      var n = X_(pm.current);
      return n;
    }
    function q_(n) {
      X_(_x.current);
      var s = X_(pm.current), v = i_(s, n.type);
      s !== v && (Hf(Sx, n, n), Hf(pm, v, n));
    }
    function wx(n) {
      Sx.current === n && (Gu(pm, n), Gu(Sx, n));
    }
    var OT = 0, hE = 1, UT = 1, Z1 = 2, Tl = Vu(OT);
    function Qg(n, s) {
      return (n & s) !== 0;
    }
    function Ex(n) {
      return n & hE;
    }
    function Zg(n, s) {
      return n & hE | s;
    }
    function pE(n, s) {
      return n | s;
    }
    function sv(n, s) {
      Hf(Tl, s, n);
    }
    function u0(n) {
      Gu(Tl, n);
    }
    function zT(n, s) {
      var v = n.memoizedState;
      return v !== null ? v.dehydrated !== null : (n.memoizedProps, !0);
    }
    function Q_(n) {
      for (var s = n; s !== null; ) {
        if (s.tag === X) {
          var v = s.memoizedState;
          if (v !== null) {
            var b = v.dehydrated;
            if (b === null || D1(b) || L1(b))
              return s;
          }
        } else if (s.tag === pe && s.memoizedProps.revealOrder !== void 0) {
          var R = (s.flags & Rr) !== vr;
          if (R)
            return s;
        } else if (s.child !== null) {
          s.child.return = s, s = s.child;
          continue;
        }
        if (s === n)
          return null;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === n)
            return null;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return null;
    }
    var th = 0, eu = 1, ov = 2, tu = 4, ef = 8, mE = [];
    function J1() {
      for (var n = 0; n < mE.length; n++) {
        var s = mE[n];
        s._workInProgressVersionPrimary = null;
      }
      mE.length = 0;
    }
    function NT(n, s) {
      var v = s._getVersion, b = v(s._source);
      n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [s, b] : n.mutableSourceEagerHydrationData.push(s, b);
    }
    var jn = t.ReactCurrentDispatcher, tf = t.ReactCurrentBatchConfig, K1, Mx;
    K1 = /* @__PURE__ */ new Set();
    var c0 = Ht, oa = null, Wu = null, ju = null, Tx = !1, f0 = !1, Mp = 0, dR = 0, hR = 25, en = null, zh = null, lv = -1, vE = !1;
    function Wa() {
      {
        var n = en;
        zh === null ? zh = [n] : zh.push(n);
      }
    }
    function Dn() {
      {
        var n = en;
        zh !== null && (lv++, zh[lv] !== n && pR(n));
      }
    }
    function d0(n) {
      n != null && !qs(n) && l("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", en, typeof n);
    }
    function pR(n) {
      {
        var s = xr(oa);
        if (!K1.has(s) && (K1.add(s), zh !== null)) {
          for (var v = "", b = 30, R = 0; R <= lv; R++) {
            for (var F = zh[R], Y = R === lv ? n : F, K = R + 1 + ". " + F; K.length < b; )
              K += " ";
            K += Y + `
`, v += K;
          }
          l(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, s, v);
        }
      }
    }
    function nf() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function gE(n, s) {
      if (vE)
        return !1;
      if (s === null)
        return l("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", en), !1;
      n.length !== s.length && l(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, en, "[" + s.join(", ") + "]", "[" + n.join(", ") + "]");
      for (var v = 0; v < s.length && v < n.length; v++)
        if (!Qn(n[v], s[v]))
          return !1;
      return !0;
    }
    function Cx(n, s, v, b, R, F) {
      c0 = F, oa = s, zh = n !== null ? n._debugHookTypes : null, lv = -1, vE = n !== null && n.type !== s.type, s.memoizedState = null, s.updateQueue = null, s.lanes = Ht, n !== null && n.memoizedState !== null ? jn.current = En : zh !== null ? jn.current = wt : jn.current = Zt;
      var Y = v(b, R);
      if (f0) {
        var K = 0;
        do {
          if (f0 = !1, Mp = 0, K >= hR)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          K += 1, vE = !1, Wu = null, ju = null, s.updateQueue = null, lv = -1, jn.current = yr, Y = v(b, R);
        } while (f0);
      }
      jn.current = Et, s._debugHookTypes = zh;
      var re = Wu !== null && Wu.next !== null;
      if (c0 = Ht, oa = null, Wu = null, ju = null, en = null, zh = null, lv = -1, n !== null && (n.flags & pn) !== (s.flags & pn) && (n.mode & Yr) !== hr && l("Internal React error: Expected static flag was missing. Please notify the React team."), Tx = !1, re)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return Y;
    }
    function Jg() {
      var n = Mp !== 0;
      return Mp = 0, n;
    }
    function Z_(n, s, v) {
      s.updateQueue = n.updateQueue, (s.mode & Ns) !== hr ? s.flags &= ~(uc | Vr | Ia | Gn) : s.flags &= ~(Ia | Gn), n.lanes = Wn(n.lanes, v);
    }
    function yE() {
      if (jn.current = Et, Tx) {
        for (var n = oa.memoizedState; n !== null; ) {
          var s = n.queue;
          s !== null && (s.pending = null), n = n.next;
        }
        Tx = !1;
      }
      c0 = Ht, oa = null, Wu = null, ju = null, zh = null, lv = -1, en = null, yt = !1, f0 = !1, Mp = 0;
    }
    function uv() {
      var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return ju === null ? oa.memoizedState = ju = n : ju = ju.next = n, ju;
    }
    function Tp() {
      var n;
      if (Wu === null) {
        var s = oa.alternate;
        s !== null ? n = s.memoizedState : n = null;
      } else
        n = Wu.next;
      var v;
      if (ju === null ? v = oa.memoizedState : v = ju.next, v !== null)
        ju = v, v = ju.next, Wu = n;
      else {
        if (n === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Wu = n;
        var b = {
          memoizedState: Wu.memoizedState,
          baseState: Wu.baseState,
          baseQueue: Wu.baseQueue,
          queue: Wu.queue,
          next: null
        };
        ju === null ? oa.memoizedState = ju = b : ju = ju.next = b;
      }
      return ju;
    }
    function FT() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function xE(n, s) {
      return typeof s == "function" ? s(n) : s;
    }
    function J_(n, s, v) {
      var b = uv(), R;
      v !== void 0 ? R = v(s) : R = s, b.memoizedState = b.baseState = R;
      var F = {
        pending: null,
        interleaved: null,
        lanes: Ht,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: R
      };
      b.queue = F;
      var Y = F.dispatch = Sn.bind(null, oa, F);
      return [b.memoizedState, Y];
    }
    function SE(n, s, v) {
      var b = Tp(), R = b.queue;
      if (R === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      R.lastRenderedReducer = n;
      var F = Wu, Y = F.baseQueue, K = R.pending;
      if (K !== null) {
        if (Y !== null) {
          var re = Y.next, _e = K.next;
          Y.next = _e, K.next = re;
        }
        F.baseQueue !== Y && l("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), F.baseQueue = Y = K, R.pending = null;
      }
      if (Y !== null) {
        var Re = Y.next, nt = F.baseState, $e = null, Dt = null, Lt = null, Yt = Re;
        do {
          var er = Yt.lane;
          if (At(c0, er)) {
            if (Lt !== null) {
              var _r = {
                lane: vi,
                action: Yt.action,
                hasEagerState: Yt.hasEagerState,
                eagerState: Yt.eagerState,
                next: null
              };
              Lt = Lt.next = _r;
            }
            if (Yt.hasEagerState)
              nt = Yt.eagerState;
            else {
              var ma = Yt.action;
              nt = n(nt, ma);
            }
          } else {
            var Dr = {
              lane: er,
              action: Yt.action,
              hasEagerState: Yt.hasEagerState,
              eagerState: Yt.eagerState,
              next: null
            };
            Lt === null ? (Dt = Lt = Dr, $e = nt) : Lt = Lt.next = Dr, oa.lanes = qt(oa.lanes, er), WE(er);
          }
          Yt = Yt.next;
        } while (Yt !== null && Yt !== Re);
        Lt === null ? $e = nt : Lt.next = Dt, Qn(nt, b.memoizedState) || PE(), b.memoizedState = nt, b.baseState = $e, b.baseQueue = Lt, R.lastRenderedState = nt;
      }
      var ta = R.interleaved;
      if (ta !== null) {
        var xt = ta;
        do {
          var Xt = xt.lane;
          oa.lanes = qt(oa.lanes, Xt), WE(Xt), xt = xt.next;
        } while (xt !== ta);
      } else
        Y === null && (R.lanes = Ht);
      var St = R.dispatch;
      return [b.memoizedState, St];
    }
    function _E(n, s, v) {
      var b = Tp(), R = b.queue;
      if (R === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      R.lastRenderedReducer = n;
      var F = R.dispatch, Y = R.pending, K = b.memoizedState;
      if (Y !== null) {
        R.pending = null;
        var re = Y.next, _e = re;
        do {
          var Re = _e.action;
          K = n(K, Re), _e = _e.next;
        } while (_e !== re);
        Qn(K, b.memoizedState) || PE(), b.memoizedState = K, b.baseQueue === null && (b.baseState = K), R.lastRenderedState = K;
      }
      return [K, F];
    }
    function mR(n, s, v) {
    }
    function kT(n, s, v) {
    }
    function bE(n, s, v) {
      var b = oa, R = uv(), F, Y = Ws();
      if (Y) {
        if (v === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        F = v(), Mx || F !== v() && (l("The result of getServerSnapshot should be cached to avoid an infinite loop"), Mx = !0);
      } else {
        if (F = s(), !Mx) {
          var K = s();
          Qn(F, K) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), Mx = !0);
        }
        var re = KT();
        if (re === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        cn(re, c0) || IT(b, s, F);
      }
      R.memoizedState = F;
      var _e = {
        value: F,
        getSnapshot: s
      };
      return R.queue = _e, nS(EE.bind(null, b, _e, n), [n]), b.flags |= Ia, Rx(eu | ef, wE.bind(null, b, _e, F, s), void 0, null), F;
    }
    function K_(n, s, v) {
      var b = oa, R = Tp(), F = s();
      if (!Mx) {
        var Y = s();
        Qn(F, Y) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), Mx = !0);
      }
      var K = R.memoizedState, re = !Qn(K, F);
      re && (R.memoizedState = F, PE());
      var _e = R.queue;
      if (Dx(EE.bind(null, b, _e, n), [n]), _e.getSnapshot !== s || re || ju !== null && ju.memoizedState.tag & eu) {
        b.flags |= Ia, Rx(eu | ef, wE.bind(null, b, _e, F, s), void 0, null);
        var Re = KT();
        if (Re === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        cn(Re, c0) || IT(b, s, F);
      }
      return F;
    }
    function IT(n, s, v) {
      n.flags |= Wd;
      var b = {
        getSnapshot: s,
        value: v
      }, R = oa.updateQueue;
      if (R === null)
        R = FT(), oa.updateQueue = R, R.stores = [b];
      else {
        var F = R.stores;
        F === null ? R.stores = [b] : F.push(b);
      }
    }
    function wE(n, s, v, b) {
      s.value = v, s.getSnapshot = b, ME(s) && TE(n);
    }
    function EE(n, s, v) {
      var b = function() {
        ME(s) && TE(n);
      };
      return v(b);
    }
    function ME(n) {
      var s = n.getSnapshot, v = n.value;
      try {
        var b = s();
        return !Qn(v, b);
      } catch {
        return !0;
      }
    }
    function TE(n) {
      var s = Kc(n, lr);
      s !== null && of(s, n, lr, ii);
    }
    function $1(n) {
      var s = uv();
      typeof n == "function" && (n = n()), s.memoizedState = s.baseState = n;
      var v = {
        pending: null,
        interleaved: null,
        lanes: Ht,
        dispatch: null,
        lastRenderedReducer: xE,
        lastRenderedState: n
      };
      s.queue = v;
      var b = v.dispatch = Tr.bind(null, oa, v);
      return [s.memoizedState, b];
    }
    function $_(n) {
      return SE(xE);
    }
    function eb(n) {
      return _E(xE);
    }
    function Rx(n, s, v, b) {
      var R = {
        tag: n,
        create: s,
        destroy: v,
        deps: b,
        next: null
      }, F = oa.updateQueue;
      if (F === null)
        F = FT(), oa.updateQueue = F, F.lastEffect = R.next = R;
      else {
        var Y = F.lastEffect;
        if (Y === null)
          F.lastEffect = R.next = R;
        else {
          var K = Y.next;
          Y.next = R, R.next = K, F.lastEffect = R;
        }
      }
      return R;
    }
    function tb(n) {
      var s = uv();
      {
        var v = {
          current: n
        };
        return s.memoizedState = v, v;
      }
    }
    function eS(n) {
      var s = Tp();
      return s.memoizedState;
    }
    function Ax(n, s, v, b) {
      var R = uv(), F = b === void 0 ? null : b;
      oa.flags |= n, R.memoizedState = Rx(eu | s, v, void 0, F);
    }
    function tS(n, s, v, b) {
      var R = Tp(), F = b === void 0 ? null : b, Y = void 0;
      if (Wu !== null) {
        var K = Wu.memoizedState;
        if (Y = K.destroy, F !== null) {
          var re = K.deps;
          if (gE(F, re)) {
            R.memoizedState = Rx(s, v, Y, F);
            return;
          }
        }
      }
      oa.flags |= n, R.memoizedState = Rx(eu | s, v, Y, F);
    }
    function nS(n, s) {
      return (oa.mode & Ns) !== hr ? Ax(uc | Ia | Oc, ef, n, s) : Ax(Ia | Oc, ef, n, s);
    }
    function Dx(n, s) {
      return tS(Ia, ef, n, s);
    }
    function nb(n, s) {
      return Ax(Gn, ov, n, s);
    }
    function rS(n, s) {
      return tS(Gn, ov, n, s);
    }
    function rb(n, s) {
      var v = Gn;
      return v |= _s, (oa.mode & Ns) !== hr && (v |= Vr), Ax(v, tu, n, s);
    }
    function iS(n, s) {
      return tS(Gn, tu, n, s);
    }
    function CE(n, s) {
      if (typeof s == "function") {
        var v = s, b = n();
        return v(b), function() {
          v(null);
        };
      } else if (s != null) {
        var R = s;
        R.hasOwnProperty("current") || l("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(R).join(", ") + "}");
        var F = n();
        return R.current = F, function() {
          R.current = null;
        };
      }
    }
    function aS(n, s, v) {
      typeof s != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var b = v != null ? v.concat([n]) : null, R = Gn;
      return R |= _s, (oa.mode & Ns) !== hr && (R |= Vr), Ax(R, tu, CE.bind(null, s, n), b);
    }
    function ib(n, s, v) {
      typeof s != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", s !== null ? typeof s : "null");
      var b = v != null ? v.concat([n]) : null;
      return tS(Gn, tu, CE.bind(null, s, n), b);
    }
    function vR(n, s) {
    }
    var ab = vR;
    function RE(n, s) {
      var v = uv(), b = s === void 0 ? null : s;
      return v.memoizedState = [n, b], n;
    }
    function u(n, s) {
      var v = Tp(), b = s === void 0 ? null : s, R = v.memoizedState;
      if (R !== null && b !== null) {
        var F = R[1];
        if (gE(b, F))
          return R[0];
      }
      return v.memoizedState = [n, b], n;
    }
    function f(n, s) {
      var v = uv(), b = s === void 0 ? null : s, R = n();
      return v.memoizedState = [R, b], R;
    }
    function M(n, s) {
      var v = Tp(), b = s === void 0 ? null : s, R = v.memoizedState;
      if (R !== null && b !== null) {
        var F = R[1];
        if (gE(b, F))
          return R[0];
      }
      var Y = n();
      return v.memoizedState = [Y, b], Y;
    }
    function A(n) {
      var s = uv();
      return s.memoizedState = n, n;
    }
    function z(n) {
      var s = Tp(), v = Wu, b = v.memoizedState;
      return ne(s, b, n);
    }
    function j(n) {
      var s = Tp();
      if (Wu === null)
        return s.memoizedState = n, n;
      var v = Wu.memoizedState;
      return ne(s, v, n);
    }
    function ne(n, s, v) {
      var b = !Ke(c0);
      if (b) {
        if (!Qn(v, s)) {
          var R = ur();
          oa.lanes = qt(oa.lanes, R), WE(R), n.baseState = !0;
        }
        return s;
      } else
        return n.baseState && (n.baseState = !1, PE()), n.memoizedState = v, v;
    }
    function se(n, s, v) {
      var b = pc();
      to(yl(b, qo)), n(!0);
      var R = tf.transition;
      tf.transition = {};
      var F = tf.transition;
      tf.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        n(!1), s();
      } finally {
        if (to(b), tf.transition = R, R === null && F._updatedFibers) {
          var Y = F._updatedFibers.size;
          Y > 10 && o("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), F._updatedFibers.clear();
        }
      }
    }
    function Se() {
      var n = $1(!1), s = n[0], v = n[1], b = se.bind(null, v), R = uv();
      return R.memoizedState = b, [s, b];
    }
    function Pe() {
      var n = $_(), s = n[0], v = Tp(), b = v.memoizedState;
      return [s, b];
    }
    function Ge() {
      var n = eb(), s = n[0], v = Tp(), b = v.memoizedState;
      return [s, b];
    }
    var yt = !1;
    function It() {
      return yt;
    }
    function jt() {
      var n = uv(), s = KT(), v = s.identifierPrefix, b;
      if (Ws()) {
        var R = iR();
        b = ":" + v + "R" + R;
        var F = Mp++;
        F > 0 && (b += "H" + F.toString(32)), b += ":";
      } else {
        var Y = dR++;
        b = ":" + v + "r" + Y.toString(32) + ":";
      }
      return n.memoizedState = b, b;
    }
    function dn() {
      var n = Tp(), s = n.memoizedState;
      return s;
    }
    function Sn(n, s, v) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var b = zx(n), R = {
        lane: b,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (yi(n))
        Pr(s, R);
      else {
        var F = ST(n, s, R, b);
        if (F !== null) {
          var Y = Ih();
          of(F, n, b, Y), so(F, s, b);
        }
      }
      oo(n, b);
    }
    function Tr(n, s, v) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var b = zx(n), R = {
        lane: b,
        action: v,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (yi(n))
        Pr(s, R);
      else {
        var F = n.alternate;
        if (n.lanes === Ht && (F === null || F.lanes === Ht)) {
          var Y = s.lastRenderedReducer;
          if (Y !== null) {
            var K;
            K = jn.current, jn.current = ai;
            try {
              var re = s.lastRenderedState, _e = Y(re, v);
              if (R.hasEagerState = !0, R.eagerState = _e, Qn(_e, re)) {
                U_(n, s, R, b);
                return;
              }
            } catch {
            } finally {
              jn.current = K;
            }
          }
        }
        var Re = ST(n, s, R, b);
        if (Re !== null) {
          var nt = Ih();
          of(Re, n, b, nt), so(Re, s, b);
        }
      }
      oo(n, b);
    }
    function yi(n) {
      var s = n.alternate;
      return n === oa || s !== null && s === oa;
    }
    function Pr(n, s) {
      f0 = Tx = !0;
      var v = n.pending;
      v === null ? s.next = s : (s.next = v.next, v.next = s), n.pending = s;
    }
    function so(n, s, v) {
      if (wr(v)) {
        var b = s.lanes;
        b = Xr(b, n.pendingLanes);
        var R = qt(b, v);
        s.lanes = R, gr(n, R);
      }
    }
    function oo(n, s, v) {
      fc(n, s);
    }
    var Et = {
      readContext: El,
      useCallback: nf,
      useContext: nf,
      useEffect: nf,
      useImperativeHandle: nf,
      useInsertionEffect: nf,
      useLayoutEffect: nf,
      useMemo: nf,
      useReducer: nf,
      useRef: nf,
      useState: nf,
      useDebugValue: nf,
      useDeferredValue: nf,
      useTransition: nf,
      useMutableSource: nf,
      useSyncExternalStore: nf,
      useId: nf,
      unstable_isNewReconciler: he
    }, Zt = null, wt = null, En = null, yr = null, Un = null, ai = null, ba = null;
    {
      var gs = function() {
        l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Nn = function() {
        l("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Zt = {
        readContext: function(n) {
          return El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Wa(), d0(s), RE(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Wa(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Wa(), d0(s), nS(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Wa(), d0(v), aS(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Wa(), d0(s), nb(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Wa(), d0(s), rb(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Wa(), d0(s);
          var v = jn.current;
          jn.current = Un;
          try {
            return f(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Wa();
          var b = jn.current;
          jn.current = Un;
          try {
            return J_(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Wa(), tb(n);
        },
        useState: function(n) {
          en = "useState", Wa();
          var s = jn.current;
          jn.current = Un;
          try {
            return $1(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Wa(), void 0;
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Wa(), A(n);
        },
        useTransition: function() {
          return en = "useTransition", Wa(), Se();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Wa(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Wa(), bE(n, s, v);
        },
        useId: function() {
          return en = "useId", Wa(), jt();
        },
        unstable_isNewReconciler: he
      }, wt = {
        readContext: function(n) {
          return El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Dn(), RE(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Dn(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Dn(), nS(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Dn(), aS(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Dn(), nb(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Dn(), rb(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Dn();
          var v = jn.current;
          jn.current = Un;
          try {
            return f(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Dn();
          var b = jn.current;
          jn.current = Un;
          try {
            return J_(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Dn(), tb(n);
        },
        useState: function(n) {
          en = "useState", Dn();
          var s = jn.current;
          jn.current = Un;
          try {
            return $1(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Dn(), void 0;
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Dn(), A(n);
        },
        useTransition: function() {
          return en = "useTransition", Dn(), Se();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Dn(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Dn(), bE(n, s, v);
        },
        useId: function() {
          return en = "useId", Dn(), jt();
        },
        unstable_isNewReconciler: he
      }, En = {
        readContext: function(n) {
          return El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Dn(), u(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Dn(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Dn(), Dx(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Dn(), ib(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Dn(), rS(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Dn(), iS(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Dn();
          var v = jn.current;
          jn.current = ai;
          try {
            return M(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Dn();
          var b = jn.current;
          jn.current = ai;
          try {
            return SE(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Dn(), eS();
        },
        useState: function(n) {
          en = "useState", Dn();
          var s = jn.current;
          jn.current = ai;
          try {
            return $_(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Dn(), ab();
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Dn(), z(n);
        },
        useTransition: function() {
          return en = "useTransition", Dn(), Pe();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Dn(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Dn(), K_(n, s);
        },
        useId: function() {
          return en = "useId", Dn(), dn();
        },
        unstable_isNewReconciler: he
      }, yr = {
        readContext: function(n) {
          return El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Dn(), u(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Dn(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Dn(), Dx(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Dn(), ib(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Dn(), rS(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Dn(), iS(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Dn();
          var v = jn.current;
          jn.current = ba;
          try {
            return M(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Dn();
          var b = jn.current;
          jn.current = ba;
          try {
            return _E(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Dn(), eS();
        },
        useState: function(n) {
          en = "useState", Dn();
          var s = jn.current;
          jn.current = ba;
          try {
            return eb(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Dn(), ab();
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Dn(), j(n);
        },
        useTransition: function() {
          return en = "useTransition", Dn(), Ge();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Dn(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Dn(), K_(n, s);
        },
        useId: function() {
          return en = "useId", Dn(), dn();
        },
        unstable_isNewReconciler: he
      }, Un = {
        readContext: function(n) {
          return gs(), El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Nn(), Wa(), RE(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Nn(), Wa(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Nn(), Wa(), nS(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Nn(), Wa(), aS(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Nn(), Wa(), nb(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Nn(), Wa(), rb(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Nn(), Wa();
          var v = jn.current;
          jn.current = Un;
          try {
            return f(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Nn(), Wa();
          var b = jn.current;
          jn.current = Un;
          try {
            return J_(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Nn(), Wa(), tb(n);
        },
        useState: function(n) {
          en = "useState", Nn(), Wa();
          var s = jn.current;
          jn.current = Un;
          try {
            return $1(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Nn(), Wa(), void 0;
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Nn(), Wa(), A(n);
        },
        useTransition: function() {
          return en = "useTransition", Nn(), Wa(), Se();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Nn(), Wa(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Nn(), Wa(), bE(n, s, v);
        },
        useId: function() {
          return en = "useId", Nn(), Wa(), jt();
        },
        unstable_isNewReconciler: he
      }, ai = {
        readContext: function(n) {
          return gs(), El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Nn(), Dn(), u(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Nn(), Dn(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Nn(), Dn(), Dx(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Nn(), Dn(), ib(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Nn(), Dn(), rS(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Nn(), Dn(), iS(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Nn(), Dn();
          var v = jn.current;
          jn.current = ai;
          try {
            return M(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Nn(), Dn();
          var b = jn.current;
          jn.current = ai;
          try {
            return SE(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Nn(), Dn(), eS();
        },
        useState: function(n) {
          en = "useState", Nn(), Dn();
          var s = jn.current;
          jn.current = ai;
          try {
            return $_(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Nn(), Dn(), ab();
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Nn(), Dn(), z(n);
        },
        useTransition: function() {
          return en = "useTransition", Nn(), Dn(), Pe();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Nn(), Dn(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Nn(), Dn(), K_(n, s);
        },
        useId: function() {
          return en = "useId", Nn(), Dn(), dn();
        },
        unstable_isNewReconciler: he
      }, ba = {
        readContext: function(n) {
          return gs(), El(n);
        },
        useCallback: function(n, s) {
          return en = "useCallback", Nn(), Dn(), u(n, s);
        },
        useContext: function(n) {
          return en = "useContext", Nn(), Dn(), El(n);
        },
        useEffect: function(n, s) {
          return en = "useEffect", Nn(), Dn(), Dx(n, s);
        },
        useImperativeHandle: function(n, s, v) {
          return en = "useImperativeHandle", Nn(), Dn(), ib(n, s, v);
        },
        useInsertionEffect: function(n, s) {
          return en = "useInsertionEffect", Nn(), Dn(), rS(n, s);
        },
        useLayoutEffect: function(n, s) {
          return en = "useLayoutEffect", Nn(), Dn(), iS(n, s);
        },
        useMemo: function(n, s) {
          en = "useMemo", Nn(), Dn();
          var v = jn.current;
          jn.current = ai;
          try {
            return M(n, s);
          } finally {
            jn.current = v;
          }
        },
        useReducer: function(n, s, v) {
          en = "useReducer", Nn(), Dn();
          var b = jn.current;
          jn.current = ai;
          try {
            return _E(n, s, v);
          } finally {
            jn.current = b;
          }
        },
        useRef: function(n) {
          return en = "useRef", Nn(), Dn(), eS();
        },
        useState: function(n) {
          en = "useState", Nn(), Dn();
          var s = jn.current;
          jn.current = ai;
          try {
            return eb(n);
          } finally {
            jn.current = s;
          }
        },
        useDebugValue: function(n, s) {
          return en = "useDebugValue", Nn(), Dn(), ab();
        },
        useDeferredValue: function(n) {
          return en = "useDeferredValue", Nn(), Dn(), j(n);
        },
        useTransition: function() {
          return en = "useTransition", Nn(), Dn(), Ge();
        },
        useMutableSource: function(n, s, v) {
          return en = "useMutableSource", Nn(), Dn(), void 0;
        },
        useSyncExternalStore: function(n, s, v) {
          return en = "useSyncExternalStore", Nn(), Dn(), K_(n, s);
        },
        useId: function() {
          return en = "useId", Nn(), Dn(), dn();
        },
        unstable_isNewReconciler: he
      };
    }
    var as = e.unstable_now, wa = 0, Ei = -1, Ao = -1, lo = -1, nh = !1, Su = !1;
    function rh() {
      return nh;
    }
    function Nh() {
      Su = !0;
    }
    function cv() {
      nh = !1, Su = !1;
    }
    function Lx() {
      nh = Su, Su = !1;
    }
    function h0() {
      return wa;
    }
    function ih() {
      wa = as();
    }
    function Yv(n) {
      Ao = as(), n.actualStartTime < 0 && (n.actualStartTime = as());
    }
    function sb(n) {
      Ao = -1;
    }
    function sS(n, s) {
      if (Ao >= 0) {
        var v = as() - Ao;
        n.actualDuration += v, s && (n.selfBaseDuration = v), Ao = -1;
      }
    }
    function fv(n) {
      if (Ei >= 0) {
        var s = as() - Ei;
        Ei = -1;
        for (var v = n.return; v !== null; ) {
          switch (v.tag) {
            case _:
              var b = v.stateNode;
              b.effectDuration += s;
              return;
            case I:
              var R = v.stateNode;
              R.effectDuration += s;
              return;
          }
          v = v.return;
        }
      }
    }
    function AE(n) {
      if (lo >= 0) {
        var s = as() - lo;
        lo = -1;
        for (var v = n.return; v !== null; ) {
          switch (v.tag) {
            case _:
              var b = v.stateNode;
              b !== null && (b.passiveEffectDuration += s);
              return;
            case I:
              var R = v.stateNode;
              R !== null && (R.passiveEffectDuration += s);
              return;
          }
          v = v.return;
        }
      }
    }
    function Kg() {
      Ei = as();
    }
    function gR() {
      lo = as();
    }
    function yR(n) {
      for (var s = n.child; s; )
        n.actualDuration += s.actualDuration, s = s.sibling;
    }
    function oS(n, s) {
      return {
        value: n,
        source: s,
        stack: go(s),
        digest: null
      };
    }
    function xR(n, s, v) {
      return {
        value: n,
        source: null,
        stack: v != null ? v : null,
        digest: s != null ? s : null
      };
    }
    function xk(n, s) {
      return !0;
    }
    function SR(n, s) {
      try {
        var v = xk(n, s);
        if (v === !1)
          return;
        var b = s.value, R = s.source, F = s.stack, Y = F !== null ? F : "";
        if (b != null && b._suppressLogging) {
          if (n.tag === m)
            return;
          console.error(b);
        }
        var K = R ? xr(R) : null, re = K ? "The above error occurred in the <" + K + "> component:" : "The above error occurred in one of your React components:", _e;
        if (n.tag === _)
          _e = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Re = xr(n) || "Anonymous";
          _e = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Re + ".");
        }
        var nt = re + `
` + Y + `

` + ("" + _e);
        console.error(nt);
      } catch ($e) {
        setTimeout(function() {
          throw $e;
        });
      }
    }
    var Sk = typeof WeakMap == "function" ? WeakMap : Map;
    function BL(n, s, v) {
      var b = rv(ii, v);
      b.tag = eE, b.payload = {
        element: null
      };
      var R = s.value;
      return b.callback = function() {
        dB(R), SR(n, s);
      }, b;
    }
    function _R(n, s, v) {
      var b = rv(ii, v);
      b.tag = eE;
      var R = n.type.getDerivedStateFromError;
      if (typeof R == "function") {
        var F = s.value;
        b.payload = function() {
          return R(F);
        }, b.callback = function() {
          JP(n), SR(n, s);
        };
      }
      var Y = n.stateNode;
      return Y !== null && typeof Y.componentDidCatch == "function" && (b.callback = function() {
        JP(n), SR(n, s), typeof R != "function" && cB(this);
        var re = s.value, _e = s.stack;
        this.componentDidCatch(re, {
          componentStack: _e !== null ? _e : ""
        }), typeof R != "function" && (Qe(n.lanes, lr) || l("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", xr(n) || "Unknown"));
      }), b;
    }
    function HL(n, s, v) {
      var b = n.pingCache, R;
      if (b === null ? (b = n.pingCache = new Sk(), R = /* @__PURE__ */ new Set(), b.set(s, R)) : (R = b.get(s), R === void 0 && (R = /* @__PURE__ */ new Set(), b.set(s, R))), !R.has(v)) {
        R.add(v);
        var F = hB.bind(null, n, s, v);
        ya && jE(n, v), s.then(F, F);
      }
    }
    function _k(n, s, v, b) {
      var R = n.updateQueue;
      if (R === null) {
        var F = /* @__PURE__ */ new Set();
        F.add(v), n.updateQueue = F;
      } else
        R.add(v);
    }
    function bk(n, s) {
      var v = n.tag;
      if ((n.mode & Yr) === hr && (v === h || v === V || v === $)) {
        var b = n.alternate;
        b ? (n.updateQueue = b.updateQueue, n.memoizedState = b.memoizedState, n.lanes = b.lanes) : (n.updateQueue = null, n.memoizedState = null);
      }
    }
    function VL(n) {
      var s = n;
      do {
        if (s.tag === X && zT(s))
          return s;
        s = s.return;
      } while (s !== null);
      return null;
    }
    function GL(n, s, v, b, R) {
      if ((n.mode & Yr) === hr) {
        if (n === s)
          n.flags |= bo;
        else {
          if (n.flags |= Rr, v.flags |= Kh, v.flags &= ~(Ho | vl), v.tag === m) {
            var F = v.alternate;
            if (F === null)
              v.tag = ee;
            else {
              var Y = rv(ii, lr);
              Y.tag = Ml, Yg(v, Y, lr);
            }
          }
          v.lanes = qt(v.lanes, lr);
        }
        return n;
      }
      return n.flags |= bo, n.lanes = R, n;
    }
    function wk(n, s, v, b, R) {
      if (v.flags |= vl, ya && jE(n, R), b !== null && typeof b == "object" && typeof b.then == "function") {
        var F = b;
        bk(v), Ws() && v.mode & Yr && A_();
        var Y = VL(s);
        if (Y !== null) {
          Y.flags &= ~hs, GL(Y, s, v, n, R), Y.mode & Yr && HL(n, F, R), _k(Y, n, F);
          return;
        } else {
          if (!q(R)) {
            HL(n, F, R), eA();
            return;
          }
          var K = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          b = K;
        }
      } else if (Ws() && v.mode & Yr) {
        A_();
        var re = VL(s);
        if (re !== null) {
          (re.flags & bo) === vr && (re.flags |= hs), GL(re, s, v, n, R), hm(oS(b, v));
          return;
        }
      }
      b = oS(b, v), nB(b);
      var _e = s;
      do {
        switch (_e.tag) {
          case _: {
            var Re = b;
            _e.flags |= bo;
            var nt = Li(R);
            _e.lanes = qt(_e.lanes, nt);
            var $e = BL(_e, Re, nt);
            iv(_e, $e);
            return;
          }
          case m:
            var Dt = b, Lt = _e.type, Yt = _e.stateNode;
            if ((_e.flags & Rr) === vr && (typeof Lt.getDerivedStateFromError == "function" || Yt !== null && typeof Yt.componentDidCatch == "function" && !VP(Yt))) {
              _e.flags |= bo;
              var er = Li(R);
              _e.lanes = qt(_e.lanes, er);
              var Dr = _R(_e, Dt, er);
              iv(_e, Dr);
              return;
            }
            break;
        }
        _e = _e.return;
      } while (_e !== null);
    }
    function Ek() {
      return null;
    }
    var DE = t.ReactCurrentOwner, Xv = !1, bR, LE, wR, ER, MR, lS, TR, BT;
    bR = {}, LE = {}, wR = {}, ER = {}, MR = {}, lS = !1, TR = {}, BT = {};
    function Fh(n, s, v, b) {
      n === null ? s.child = LT(s, null, v, b) : s.child = xx(s, n.child, v, b);
    }
    function Mk(n, s, v, b) {
      s.child = xx(s, n.child, null, b), s.child = xx(s, null, v, b);
    }
    function WL(n, s, v, b, R) {
      if (s.type !== s.elementType) {
        var F = v.propTypes;
        F && Vs(
          F,
          b,
          "prop",
          Ci(v)
        );
      }
      var Y = v.render, K = s.ref, re, _e;
      nv(s, R), Ra(s);
      {
        if (DE.current = s, mi(!0), re = Cx(n, s, Y, b, K, R), _e = Jg(), s.mode & fi) {
          xa(!0);
          try {
            re = Cx(n, s, Y, b, K, R), _e = Jg();
          } finally {
            xa(!1);
          }
        }
        mi(!1);
      }
      return Ba(), n !== null && !Xv ? (Z_(n, s, R), p0(n, s, R)) : (Ws() && _e && Ww(s), s.flags |= Bi, Fh(n, s, re, R), s.child);
    }
    function jL(n, s, v, b, R) {
      if (n === null) {
        var F = v.type;
        if (DB(F) && v.compare === null && v.defaultProps === void 0) {
          var Y = F;
          return Y = pb(F), s.tag = $, s.type = Y, AR(s, F), YL(n, s, Y, b, R);
        }
        {
          var K = F.propTypes;
          K && Vs(
            K,
            b,
            "prop",
            Ci(F)
          );
        }
        var re = fA(v.type, null, b, s, s.mode, R);
        return re.ref = s.ref, re.return = s, s.child = re, re;
      }
      {
        var _e = v.type, Re = _e.propTypes;
        Re && Vs(
          Re,
          b,
          "prop",
          Ci(_e)
        );
      }
      var nt = n.child, $e = zR(n, R);
      if (!$e) {
        var Dt = nt.memoizedProps, Lt = v.compare;
        if (Lt = Lt !== null ? Lt : pr, Lt(Dt, b) && n.ref === s.ref)
          return p0(n, s, R);
      }
      s.flags |= Bi;
      var Yt = hS(nt, b);
      return Yt.ref = s.ref, Yt.return = s, s.child = Yt, Yt;
    }
    function YL(n, s, v, b, R) {
      if (s.type !== s.elementType) {
        var F = s.elementType;
        if (F.$$typeof === vn) {
          var Y = F, K = Y._payload, re = Y._init;
          try {
            F = re(K);
          } catch {
            F = null;
          }
          var _e = F && F.propTypes;
          _e && Vs(
            _e,
            b,
            "prop",
            Ci(F)
          );
        }
      }
      if (n !== null) {
        var Re = n.memoizedProps;
        if (pr(Re, b) && n.ref === s.ref && s.type === n.type)
          if (Xv = !1, s.pendingProps = b = Re, zR(n, R))
            (n.flags & Kh) !== vr && (Xv = !0);
          else
            return s.lanes = n.lanes, p0(n, s, R);
      }
      return CR(n, s, v, b, R);
    }
    function XL(n, s, v) {
      var b = s.pendingProps, R = b.children, F = n !== null ? n.memoizedState : null;
      if (b.mode === "hidden" || ue)
        if ((s.mode & Yr) === hr) {
          var Y = {
            baseLanes: Ht,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = Y, $T(s, v);
        } else if (Qe(v, vu)) {
          var nt = {
            baseLanes: Ht,
            cachePool: null,
            transitions: null
          };
          s.memoizedState = nt;
          var $e = F !== null ? F.baseLanes : v;
          $T(s, $e);
        } else {
          var K = null, re;
          if (F !== null) {
            var _e = F.baseLanes;
            re = qt(_e, v);
          } else
            re = v;
          s.lanes = s.childLanes = vu;
          var Re = {
            baseLanes: re,
            cachePool: K,
            transitions: null
          };
          return s.memoizedState = Re, s.updateQueue = null, $T(s, re), null;
        }
      else {
        var Dt;
        F !== null ? (Dt = qt(F.baseLanes, v), s.memoizedState = null) : Dt = v, $T(s, Dt);
      }
      return Fh(n, s, R, v), s.child;
    }
    function Tk(n, s, v) {
      var b = s.pendingProps;
      return Fh(n, s, b, v), s.child;
    }
    function Ck(n, s, v) {
      var b = s.pendingProps.children;
      return Fh(n, s, b, v), s.child;
    }
    function Rk(n, s, v) {
      {
        s.flags |= Gn;
        {
          var b = s.stateNode;
          b.effectDuration = 0, b.passiveEffectDuration = 0;
        }
      }
      var R = s.pendingProps, F = R.children;
      return Fh(n, s, F, v), s.child;
    }
    function qL(n, s) {
      var v = s.ref;
      (n === null && v !== null || n !== null && n.ref !== v) && (s.flags |= es, s.flags |= cu);
    }
    function CR(n, s, v, b, R) {
      if (s.type !== s.elementType) {
        var F = v.propTypes;
        F && Vs(
          F,
          b,
          "prop",
          Ci(v)
        );
      }
      var Y;
      {
        var K = kg(s, v, !0);
        Y = ux(s, K);
      }
      var re, _e;
      nv(s, R), Ra(s);
      {
        if (DE.current = s, mi(!0), re = Cx(n, s, v, b, Y, R), _e = Jg(), s.mode & fi) {
          xa(!0);
          try {
            re = Cx(n, s, v, b, Y, R), _e = Jg();
          } finally {
            xa(!1);
          }
        }
        mi(!1);
      }
      return Ba(), n !== null && !Xv ? (Z_(n, s, R), p0(n, s, R)) : (Ws() && _e && Ww(s), s.flags |= Bi, Fh(n, s, re, R), s.child);
    }
    function QL(n, s, v, b, R) {
      {
        switch (jB(s)) {
          case !1: {
            var F = s.stateNode, Y = s.type, K = new Y(s.memoizedProps, F.context), re = K.state;
            F.updater.enqueueSetState(F, re, null);
            break;
          }
          case !0: {
            s.flags |= Rr, s.flags |= bo;
            var _e = new Error("Simulated error coming from DevTools"), Re = Li(R);
            s.lanes = qt(s.lanes, Re);
            var nt = _R(s, oS(_e, s), Re);
            iv(s, nt);
            break;
          }
        }
        if (s.type !== s.elementType) {
          var $e = v.propTypes;
          $e && Vs(
            $e,
            b,
            "prop",
            Ci(v)
          );
        }
      }
      var Dt;
      lm(v) ? (Dt = !0, b_(s)) : Dt = !1, nv(s, R);
      var Lt = s.stateNode, Yt;
      Lt === null ? (VT(n, s), aE(s, v, b), sE(s, v, b, R), Yt = !0) : n === null ? Yt = av(s, v, b, R) : Yt = cR(n, s, v, b, R);
      var er = RR(n, s, v, Yt, Dt, R);
      {
        var Dr = s.stateNode;
        Yt && Dr.props !== b && (lS || l("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xr(s) || "a component"), lS = !0);
      }
      return er;
    }
    function RR(n, s, v, b, R, F) {
      qL(n, s);
      var Y = (s.flags & Rr) !== vr;
      if (!b && !Y)
        return R && uT(s, v, !1), p0(n, s, F);
      var K = s.stateNode;
      DE.current = s;
      var re;
      if (Y && typeof v.getDerivedStateFromError != "function")
        re = null, sb();
      else {
        Ra(s);
        {
          if (mi(!0), re = K.render(), s.mode & fi) {
            xa(!0);
            try {
              K.render();
            } finally {
              xa(!1);
            }
          }
          mi(!1);
        }
        Ba();
      }
      return s.flags |= Bi, n !== null && Y ? Mk(n, s, re, F) : Fh(n, s, re, F), s.memoizedState = K.state, R && uT(s, v, !0), s.child;
    }
    function ZL(n) {
      var s = n.stateNode;
      s.pendingContext ? oT(n, s.pendingContext, s.pendingContext !== s.context) : s.context && oT(n, s.context, !1), Q1(n, s.containerInfo);
    }
    function Ak(n, s, v) {
      if (ZL(s), n === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var b = s.pendingProps, R = s.memoizedState, F = R.element;
      k_(n, s), B_(s, b, null, v);
      var Y = s.memoizedState;
      s.stateNode;
      var K = Y.element;
      if (R.isDehydrated) {
        var re = {
          element: K,
          isDehydrated: !1,
          cache: Y.cache,
          pendingSuspenseBoundaries: Y.pendingSuspenseBoundaries,
          transitions: Y.transitions
        }, _e = s.updateQueue;
        if (_e.baseState = re, s.memoizedState = re, s.flags & hs) {
          var Re = oS(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), s);
          return JL(n, s, K, v, Re);
        } else if (K !== F) {
          var nt = oS(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), s);
          return JL(n, s, K, v, nt);
        } else {
          mT(s);
          var $e = LT(s, null, K, v);
          s.child = $e;
          for (var Dt = $e; Dt; )
            Dt.flags = Dt.flags & ~oi | Fl, Dt = Dt.sibling;
        }
      } else {
        if (Vg(), K === F)
          return p0(n, s, v);
        Fh(n, s, K, v);
      }
      return s.child;
    }
    function JL(n, s, v, b, R) {
      return Vg(), hm(R), s.flags |= hs, Fh(n, s, v, b), s.child;
    }
    function Dk(n, s, v) {
      q_(s), n === null && Zw(s);
      var b = s.type, R = s.pendingProps, F = n !== null ? n.memoizedProps : null, Y = R.children, K = M1(b, R);
      return K ? Y = null : F !== null && M1(b, F) && (s.flags |= zi), qL(n, s), Fh(n, s, Y, v), s.child;
    }
    function Lk(n, s) {
      return n === null && Zw(s), null;
    }
    function Pk(n, s, v, b) {
      VT(n, s);
      var R = s.pendingProps, F = v, Y = F._payload, K = F._init, re = K(Y);
      s.type = re;
      var _e = s.tag = LB(re), Re = wd(re, R), nt;
      switch (_e) {
        case h:
          return AR(s, re), s.type = re = pb(re), nt = CR(null, s, re, Re, b), nt;
        case m:
          return s.type = re = aA(re), nt = QL(null, s, re, Re, b), nt;
        case V:
          return s.type = re = sA(re), nt = WL(null, s, re, Re, b), nt;
        case J: {
          if (s.type !== s.elementType) {
            var $e = re.propTypes;
            $e && Vs(
              $e,
              Re,
              "prop",
              Ci(re)
            );
          }
          return nt = jL(
            null,
            s,
            re,
            wd(re.type, Re),
            b
          ), nt;
        }
      }
      var Dt = "";
      throw re !== null && typeof re == "object" && re.$$typeof === vn && (Dt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + re + ". " + ("Lazy element type must resolve to a class or function." + Dt));
    }
    function Ok(n, s, v, b, R) {
      VT(n, s), s.tag = m;
      var F;
      return lm(v) ? (F = !0, b_(s)) : F = !1, nv(s, R), aE(s, v, b), sE(s, v, b, R), RR(null, s, v, !0, F, R);
    }
    function Uk(n, s, v, b) {
      VT(n, s);
      var R = s.pendingProps, F;
      {
        var Y = kg(s, v, !1);
        F = ux(s, Y);
      }
      nv(s, b);
      var K, re;
      Ra(s);
      {
        if (v.prototype && typeof v.prototype.render == "function") {
          var _e = Ci(v) || "Unknown";
          bR[_e] || (l("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _e, _e), bR[_e] = !0);
        }
        s.mode & fi && bd.recordLegacyContextWarning(s, null), mi(!0), DE.current = s, K = Cx(null, s, v, R, F, b), re = Jg(), mi(!1);
      }
      if (Ba(), s.flags |= Bi, typeof K == "object" && K !== null && typeof K.render == "function" && K.$$typeof === void 0) {
        var Re = Ci(v) || "Unknown";
        LE[Re] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Re, Re, Re), LE[Re] = !0);
      }
      if (typeof K == "object" && K !== null && typeof K.render == "function" && K.$$typeof === void 0) {
        {
          var nt = Ci(v) || "Unknown";
          LE[nt] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", nt, nt, nt), LE[nt] = !0);
        }
        s.tag = m, s.memoizedState = null, s.updateQueue = null;
        var $e = !1;
        return lm(v) ? ($e = !0, b_(s)) : $e = !1, s.memoizedState = K.state !== null && K.state !== void 0 ? K.state : null, F_(s), CT(s, K), sE(s, v, R, b), RR(null, s, v, !0, $e, b);
      } else {
        if (s.tag = h, s.mode & fi) {
          xa(!0);
          try {
            K = Cx(null, s, v, R, F, b), re = Jg();
          } finally {
            xa(!1);
          }
        }
        return Ws() && re && Ww(s), Fh(null, s, K, b), AR(s, v), s.child;
      }
    }
    function AR(n, s) {
      {
        if (s && s.childContextTypes && l("%s(...): childContextTypes cannot be defined on a function component.", s.displayName || s.name || "Component"), n.ref !== null) {
          var v = "", b = fl();
          b && (v += `

Check the render method of \`` + b + "`.");
          var R = b || "", F = n._debugSource;
          F && (R = F.fileName + ":" + F.lineNumber), MR[R] || (MR[R] = !0, l("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", v));
        }
        if (typeof s.getDerivedStateFromProps == "function") {
          var Y = Ci(s) || "Unknown";
          ER[Y] || (l("%s: Function components do not support getDerivedStateFromProps.", Y), ER[Y] = !0);
        }
        if (typeof s.contextType == "object" && s.contextType !== null) {
          var K = Ci(s) || "Unknown";
          wR[K] || (l("%s: Function components do not support contextType.", K), wR[K] = !0);
        }
      }
    }
    var DR = {
      dehydrated: null,
      treeContext: null,
      retryLane: vi
    };
    function LR(n) {
      return {
        baseLanes: n,
        cachePool: Ek(),
        transitions: null
      };
    }
    function zk(n, s) {
      var v = null;
      return {
        baseLanes: qt(n.baseLanes, s),
        cachePool: v,
        transitions: n.transitions
      };
    }
    function Nk(n, s, v, b) {
      if (s !== null) {
        var R = s.memoizedState;
        if (R === null)
          return !1;
      }
      return Qg(n, Z1);
    }
    function Fk(n, s) {
      return Wn(n.childLanes, s);
    }
    function KL(n, s, v) {
      var b = s.pendingProps;
      YB(s) && (s.flags |= Rr);
      var R = Tl.current, F = !1, Y = (s.flags & Rr) !== vr;
      if (Y || Nk(R, n) ? (F = !0, s.flags &= ~Rr) : (n === null || n.memoizedState !== null) && (R = pE(R, UT)), R = Ex(R), sv(s, R), n === null) {
        Zw(s);
        var K = s.memoizedState;
        if (K !== null) {
          var re = K.dehydrated;
          if (re !== null)
            return Vk(s, re);
        }
        var _e = b.children, Re = b.fallback;
        if (F) {
          var nt = kk(s, _e, Re, v), $e = s.child;
          return $e.memoizedState = LR(v), s.memoizedState = DR, nt;
        } else
          return PR(s, _e);
      } else {
        var Dt = n.memoizedState;
        if (Dt !== null) {
          var Lt = Dt.dehydrated;
          if (Lt !== null)
            return Gk(n, s, Y, b, Lt, Dt, v);
        }
        if (F) {
          var Yt = b.fallback, er = b.children, Dr = Bk(n, s, er, Yt, v), _r = s.child, ma = n.child.memoizedState;
          return _r.memoizedState = ma === null ? LR(v) : zk(ma, v), _r.childLanes = Fk(n, v), s.memoizedState = DR, Dr;
        } else {
          var ta = b.children, xt = Ik(n, s, ta, v);
          return s.memoizedState = null, xt;
        }
      }
    }
    function PR(n, s, v) {
      var b = n.mode, R = {
        mode: "visible",
        children: s
      }, F = OR(R, b);
      return F.return = n, n.child = F, F;
    }
    function kk(n, s, v, b) {
      var R = n.mode, F = n.child, Y = {
        mode: "hidden",
        children: s
      }, K, re;
      return (R & Yr) === hr && F !== null ? (K = F, K.childLanes = Ht, K.pendingProps = Y, n.mode & fr && (K.actualDuration = 0, K.actualStartTime = -1, K.selfBaseDuration = 0, K.treeBaseDuration = 0), re = Fx(v, R, b, null)) : (K = OR(Y, R), re = Fx(v, R, b, null)), K.return = n, re.return = n, K.sibling = re, n.child = K, re;
    }
    function OR(n, s, v) {
      return $P(n, s, Ht, null);
    }
    function $L(n, s) {
      return hS(n, s);
    }
    function Ik(n, s, v, b) {
      var R = n.child, F = R.sibling, Y = $L(R, {
        mode: "visible",
        children: v
      });
      if ((s.mode & Yr) === hr && (Y.lanes = b), Y.return = s, Y.sibling = null, F !== null) {
        var K = s.deletions;
        K === null ? (s.deletions = [F], s.flags |= bi) : K.push(F);
      }
      return s.child = Y, Y;
    }
    function Bk(n, s, v, b, R) {
      var F = s.mode, Y = n.child, K = Y.sibling, re = {
        mode: "hidden",
        children: v
      }, _e;
      if ((F & Yr) === hr && s.child !== Y) {
        var Re = s.child;
        _e = Re, _e.childLanes = Ht, _e.pendingProps = re, s.mode & fr && (_e.actualDuration = 0, _e.actualStartTime = -1, _e.selfBaseDuration = Y.selfBaseDuration, _e.treeBaseDuration = Y.treeBaseDuration), s.deletions = null;
      } else
        _e = $L(Y, re), _e.subtreeFlags = Y.subtreeFlags & pn;
      var nt;
      return K !== null ? nt = hS(K, b) : (nt = Fx(b, F, R, null), nt.flags |= oi), nt.return = s, _e.return = s, _e.sibling = nt, s.child = _e, nt;
    }
    function HT(n, s, v, b) {
      b !== null && hm(b), xx(s, n.child, null, v);
      var R = s.pendingProps, F = R.children, Y = PR(s, F);
      return Y.flags |= oi, s.memoizedState = null, Y;
    }
    function Hk(n, s, v, b, R) {
      var F = s.mode, Y = {
        mode: "visible",
        children: v
      }, K = OR(Y, F), re = Fx(b, F, R, null);
      return re.flags |= oi, K.return = s, re.return = s, K.sibling = re, s.child = K, (s.mode & Yr) !== hr && xx(s, n.child, null, R), re;
    }
    function Vk(n, s, v) {
      return (n.mode & Yr) === hr ? (l("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), n.lanes = lr) : L1(s) ? n.lanes = jo : n.lanes = vu, null;
    }
    function Gk(n, s, v, b, R, F, Y) {
      if (v)
        if (s.flags & hs) {
          s.flags &= ~hs;
          var xt = xR(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return HT(n, s, Y, xt);
        } else {
          if (s.memoizedState !== null)
            return s.child = n.child, s.flags |= Rr, null;
          var Xt = b.children, St = b.fallback, gn = Hk(n, s, Xt, St, Y), tr = s.child;
          return tr.memoizedState = LR(Y), s.memoizedState = DR, gn;
        }
      else {
        if (jw(), (s.mode & Yr) === hr)
          return HT(
            n,
            s,
            Y,
            null
          );
        if (L1(R)) {
          var K, re, _e;
          {
            var Re = p_(R);
            K = Re.digest, re = Re.message, _e = Re.stack;
          }
          var nt;
          re ? nt = new Error(re) : nt = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var $e = xR(nt, K, _e);
          return HT(n, s, Y, $e);
        }
        var Dt = Qe(Y, n.childLanes);
        if (Xv || Dt) {
          var Lt = KT();
          if (Lt !== null) {
            var Yt = Gp(Lt, Y);
            if (Yt !== vi && Yt !== F.retryLane) {
              F.retryLane = Yt;
              var er = ii;
              Kc(n, Yt), of(Lt, n, Yt, er);
            }
          }
          eA();
          var Dr = xR(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return HT(n, s, Y, Dr);
        } else if (D1(R)) {
          s.flags |= Rr, s.child = n.child;
          var _r = pB.bind(null, n);
          return Uw(R, _r), null;
        } else {
          aR(s, R, F.treeContext);
          var ma = b.children, ta = PR(s, ma);
          return ta.flags |= Fl, ta;
        }
      }
    }
    function eP(n, s, v) {
      n.lanes = qt(n.lanes, s);
      var b = n.alternate;
      b !== null && (b.lanes = qt(b.lanes, s)), jg(n.return, s, v);
    }
    function Wk(n, s, v) {
      for (var b = s; b !== null; ) {
        if (b.tag === X) {
          var R = b.memoizedState;
          R !== null && eP(b, v, n);
        } else if (b.tag === pe)
          eP(b, v, n);
        else if (b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === n)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === n)
            return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }
    function jk(n) {
      for (var s = n, v = null; s !== null; ) {
        var b = s.alternate;
        b !== null && Q_(b) === null && (v = s), s = s.sibling;
      }
      return v;
    }
    function Yk(n) {
      if (n !== void 0 && n !== "forwards" && n !== "backwards" && n !== "together" && !TR[n])
        if (TR[n] = !0, typeof n == "string")
          switch (n.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', n, n.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', n, n.toLowerCase());
              break;
            }
            default:
              l('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
              break;
          }
        else
          l('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
    }
    function Xk(n, s) {
      n !== void 0 && !BT[n] && (n !== "collapsed" && n !== "hidden" ? (BT[n] = !0, l('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', n)) : s !== "forwards" && s !== "backwards" && (BT[n] = !0, l('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', n)));
    }
    function tP(n, s) {
      {
        var v = qs(n), b = !v && typeof ls(n) == "function";
        if (v || b) {
          var R = v ? "array" : "iterable";
          return l("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", R, s, R), !1;
        }
      }
      return !0;
    }
    function qk(n, s) {
      if ((s === "forwards" || s === "backwards") && n !== void 0 && n !== null && n !== !1)
        if (qs(n)) {
          for (var v = 0; v < n.length; v++)
            if (!tP(n[v], v))
              return;
        } else {
          var b = ls(n);
          if (typeof b == "function") {
            var R = b.call(n);
            if (R)
              for (var F = R.next(), Y = 0; !F.done; F = R.next()) {
                if (!tP(F.value, Y))
                  return;
                Y++;
              }
          } else
            l('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', s);
        }
    }
    function UR(n, s, v, b, R) {
      var F = n.memoizedState;
      F === null ? n.memoizedState = {
        isBackwards: s,
        rendering: null,
        renderingStartTime: 0,
        last: b,
        tail: v,
        tailMode: R
      } : (F.isBackwards = s, F.rendering = null, F.renderingStartTime = 0, F.last = b, F.tail = v, F.tailMode = R);
    }
    function nP(n, s, v) {
      var b = s.pendingProps, R = b.revealOrder, F = b.tail, Y = b.children;
      Yk(R), Xk(F, R), qk(Y, R), Fh(n, s, Y, v);
      var K = Tl.current, re = Qg(K, Z1);
      if (re)
        K = Zg(K, Z1), s.flags |= Rr;
      else {
        var _e = n !== null && (n.flags & Rr) !== vr;
        _e && Wk(s, s.child, v), K = Ex(K);
      }
      if (sv(s, K), (s.mode & Yr) === hr)
        s.memoizedState = null;
      else
        switch (R) {
          case "forwards": {
            var Re = jk(s.child), nt;
            Re === null ? (nt = s.child, s.child = null) : (nt = Re.sibling, Re.sibling = null), UR(
              s,
              !1,
              nt,
              Re,
              F
            );
            break;
          }
          case "backwards": {
            var $e = null, Dt = s.child;
            for (s.child = null; Dt !== null; ) {
              var Lt = Dt.alternate;
              if (Lt !== null && Q_(Lt) === null) {
                s.child = Dt;
                break;
              }
              var Yt = Dt.sibling;
              Dt.sibling = $e, $e = Dt, Dt = Yt;
            }
            UR(
              s,
              !0,
              $e,
              null,
              F
            );
            break;
          }
          case "together": {
            UR(
              s,
              !1,
              null,
              null,
              void 0
            );
            break;
          }
          default:
            s.memoizedState = null;
        }
      return s.child;
    }
    function Qk(n, s, v) {
      Q1(s, s.stateNode.containerInfo);
      var b = s.pendingProps;
      return n === null ? s.child = xx(s, null, b, v) : Fh(n, s, b, v), s.child;
    }
    var rP = !1;
    function Zk(n, s, v) {
      var b = s.type, R = b._context, F = s.pendingProps, Y = s.memoizedProps, K = F.value;
      {
        "value" in F || rP || (rP = !0, l("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var re = s.type.propTypes;
        re && Vs(re, F, "prop", "Context.Provider");
      }
      if (V1(s, R, K), Y !== null) {
        var _e = Y.value;
        if (Qn(_e, K)) {
          if (Y.children === F.children && !cx())
            return p0(n, s, v);
        } else
          i0(s, R, v);
      }
      var Re = F.children;
      return Fh(n, s, Re, v), s.child;
    }
    var iP = !1;
    function Jk(n, s, v) {
      var b = s.type;
      b._context === void 0 ? b !== b.Consumer && (iP || (iP = !0, l("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : b = b._context;
      var R = s.pendingProps, F = R.children;
      typeof F != "function" && l("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), nv(s, v);
      var Y = El(b);
      Ra(s);
      var K;
      return DE.current = s, mi(!0), K = F(Y), mi(!1), Ba(), s.flags |= Bi, Fh(n, s, K, v), s.child;
    }
    function PE() {
      Xv = !0;
    }
    function VT(n, s) {
      (s.mode & Yr) === hr && n !== null && (n.alternate = null, s.alternate = null, s.flags |= oi);
    }
    function p0(n, s, v) {
      return n !== null && (s.dependencies = n.dependencies), sb(), WE(s.lanes), Qe(v, s.childLanes) ? (fR(n, s), s.child) : null;
    }
    function Kk(n, s, v) {
      {
        var b = s.return;
        if (b === null)
          throw new Error("Cannot swap the root fiber.");
        if (n.alternate = null, s.alternate = null, v.index = s.index, v.sibling = s.sibling, v.return = s.return, v.ref = s.ref, s === b.child)
          b.child = v;
        else {
          var R = b.child;
          if (R === null)
            throw new Error("Expected parent to have a child.");
          for (; R.sibling !== s; )
            if (R = R.sibling, R === null)
              throw new Error("Expected to find the previous sibling.");
          R.sibling = v;
        }
        var F = b.deletions;
        return F === null ? (b.deletions = [n], b.flags |= bi) : F.push(n), v.flags |= oi, v;
      }
    }
    function zR(n, s) {
      var v = n.lanes;
      return !!Qe(v, s);
    }
    function $k(n, s, v) {
      switch (s.tag) {
        case _:
          ZL(s), s.stateNode, Vg();
          break;
        case C:
          q_(s);
          break;
        case m: {
          var b = s.type;
          lm(b) && b_(s);
          break;
        }
        case T:
          Q1(s, s.stateNode.containerInfo);
          break;
        case k: {
          var R = s.memoizedProps.value, F = s.type._context;
          V1(s, F, R);
          break;
        }
        case I:
          {
            var Y = Qe(v, s.childLanes);
            Y && (s.flags |= Gn);
            {
              var K = s.stateNode;
              K.effectDuration = 0, K.passiveEffectDuration = 0;
            }
          }
          break;
        case X: {
          var re = s.memoizedState;
          if (re !== null) {
            if (re.dehydrated !== null)
              return sv(s, Ex(Tl.current)), s.flags |= Rr, null;
            var _e = s.child, Re = _e.childLanes;
            if (Qe(v, Re))
              return KL(n, s, v);
            sv(s, Ex(Tl.current));
            var nt = p0(n, s, v);
            return nt !== null ? nt.sibling : null;
          } else
            sv(s, Ex(Tl.current));
          break;
        }
        case pe: {
          var $e = (n.flags & Rr) !== vr, Dt = Qe(v, s.childLanes);
          if ($e) {
            if (Dt)
              return nP(n, s, v);
            s.flags |= Rr;
          }
          var Lt = s.memoizedState;
          if (Lt !== null && (Lt.rendering = null, Lt.tail = null, Lt.lastEffect = null), sv(s, Tl.current), Dt)
            break;
          return null;
        }
        case Ee:
        case de:
          return s.lanes = Ht, XL(n, s, v);
      }
      return p0(n, s, v);
    }
    function aP(n, s, v) {
      if (s._debugNeedsRemount && n !== null)
        return Kk(n, s, fA(s.type, s.key, s.pendingProps, s._debugOwner || null, s.mode, s.lanes));
      if (n !== null) {
        var b = n.memoizedProps, R = s.pendingProps;
        if (b !== R || cx() || s.type !== n.type)
          Xv = !0;
        else {
          var F = zR(n, v);
          if (!F && (s.flags & Rr) === vr)
            return Xv = !1, $k(n, s, v);
          (n.flags & Kh) !== vr ? Xv = !0 : Xv = !1;
        }
      } else if (Xv = !1, Ws() && hT(s)) {
        var Y = s.index, K = wp();
        pT(s, K, Y);
      }
      switch (s.lanes = Ht, s.tag) {
        case S:
          return Uk(n, s, s.type, v);
        case W: {
          var re = s.elementType;
          return Pk(n, s, re, v);
        }
        case h: {
          var _e = s.type, Re = s.pendingProps, nt = s.elementType === _e ? Re : wd(_e, Re);
          return CR(n, s, _e, nt, v);
        }
        case m: {
          var $e = s.type, Dt = s.pendingProps, Lt = s.elementType === $e ? Dt : wd($e, Dt);
          return QL(n, s, $e, Lt, v);
        }
        case _:
          return Ak(n, s, v);
        case C:
          return Dk(n, s, v);
        case D:
          return Lk(n, s);
        case X:
          return KL(n, s, v);
        case T:
          return Qk(n, s, v);
        case V: {
          var Yt = s.type, er = s.pendingProps, Dr = s.elementType === Yt ? er : wd(Yt, er);
          return WL(n, s, Yt, Dr, v);
        }
        case P:
          return Tk(n, s, v);
        case U:
          return Ck(n, s, v);
        case I:
          return Rk(n, s, v);
        case k:
          return Zk(n, s, v);
        case B:
          return Jk(n, s, v);
        case J: {
          var _r = s.type, ma = s.pendingProps, ta = wd(_r, ma);
          if (s.type !== s.elementType) {
            var xt = _r.propTypes;
            xt && Vs(
              xt,
              ta,
              "prop",
              Ci(_r)
            );
          }
          return ta = wd(_r.type, ta), jL(n, s, _r, ta, v);
        }
        case $:
          return YL(n, s, s.type, s.pendingProps, v);
        case ee: {
          var Xt = s.type, St = s.pendingProps, gn = s.elementType === Xt ? St : wd(Xt, St);
          return Ok(n, s, Xt, gn, v);
        }
        case pe:
          return nP(n, s, v);
        case ce:
          break;
        case Ee:
          return XL(n, s, v);
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function ob(n) {
      n.flags |= Gn;
    }
    function sP(n) {
      n.flags |= es, n.flags |= cu;
    }
    var oP, NR, lP, uP;
    oP = function(n, s, v, b) {
      for (var R = s.child; R !== null; ) {
        if (R.tag === C || R.tag === D)
          ww(n, R.stateNode);
        else if (R.tag !== T) {
          if (R.child !== null) {
            R.child.return = R, R = R.child;
            continue;
          }
        }
        if (R === s)
          return;
        for (; R.sibling === null; ) {
          if (R.return === null || R.return === s)
            return;
          R = R.return;
        }
        R.sibling.return = R.return, R = R.sibling;
      }
    }, NR = function(n, s) {
    }, lP = function(n, s, v, b, R) {
      var F = n.memoizedProps;
      if (F !== b) {
        var Y = s.stateNode, K = l0(), re = Ew(Y, v, F, b, R, K);
        s.updateQueue = re, re && ob(s);
      }
    }, uP = function(n, s, v, b) {
      v !== b && ob(s);
    };
    function OE(n, s) {
      if (!Ws())
        switch (n.tailMode) {
          case "hidden": {
            for (var v = n.tail, b = null; v !== null; )
              v.alternate !== null && (b = v), v = v.sibling;
            b === null ? n.tail = null : b.sibling = null;
            break;
          }
          case "collapsed": {
            for (var R = n.tail, F = null; R !== null; )
              R.alternate !== null && (F = R), R = R.sibling;
            F === null ? !s && n.tail !== null ? n.tail.sibling = null : n.tail = null : F.sibling = null;
            break;
          }
        }
    }
    function Ed(n) {
      var s = n.alternate !== null && n.alternate.child === n.child, v = Ht, b = vr;
      if (s) {
        if ((n.mode & fr) !== hr) {
          for (var re = n.selfBaseDuration, _e = n.child; _e !== null; )
            v = qt(v, qt(_e.lanes, _e.childLanes)), b |= _e.subtreeFlags & pn, b |= _e.flags & pn, re += _e.treeBaseDuration, _e = _e.sibling;
          n.treeBaseDuration = re;
        } else
          for (var Re = n.child; Re !== null; )
            v = qt(v, qt(Re.lanes, Re.childLanes)), b |= Re.subtreeFlags & pn, b |= Re.flags & pn, Re.return = n, Re = Re.sibling;
        n.subtreeFlags |= b;
      } else {
        if ((n.mode & fr) !== hr) {
          for (var R = n.actualDuration, F = n.selfBaseDuration, Y = n.child; Y !== null; )
            v = qt(v, qt(Y.lanes, Y.childLanes)), b |= Y.subtreeFlags, b |= Y.flags, R += Y.actualDuration, F += Y.treeBaseDuration, Y = Y.sibling;
          n.actualDuration = R, n.treeBaseDuration = F;
        } else
          for (var K = n.child; K !== null; )
            v = qt(v, qt(K.lanes, K.childLanes)), b |= K.subtreeFlags, b |= K.flags, K.return = n, K = K.sibling;
        n.subtreeFlags |= b;
      }
      return n.childLanes = v, s;
    }
    function eI(n, s, v) {
      if (dm() && (s.mode & Yr) !== hr && (s.flags & Rr) === vr)
        return Kl(s), Vg(), s.flags |= hs | vl | bo, !1;
      var b = ao(s);
      if (v !== null && v.dehydrated !== null)
        if (n === null) {
          if (!b)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (oR(s), Ed(s), (s.mode & fr) !== hr) {
            var R = v !== null;
            if (R) {
              var F = s.child;
              F !== null && (s.treeBaseDuration -= F.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Vg(), (s.flags & Rr) === vr && (s.memoizedState = null), s.flags |= Gn, Ed(s), (s.mode & fr) !== hr) {
            var Y = v !== null;
            if (Y) {
              var K = s.child;
              K !== null && (s.treeBaseDuration -= K.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return Zc(), !0;
    }
    function cP(n, s, v) {
      var b = s.pendingProps;
      switch (px(s), s.tag) {
        case S:
        case W:
        case $:
        case h:
        case V:
        case P:
        case U:
        case I:
        case B:
        case J:
          return Ed(s), null;
        case m: {
          var R = s.type;
          return lm(R) && __(s), Ed(s), null;
        }
        case _: {
          var F = s.stateNode;
          if (bx(s), fx(s), J1(), F.pendingContext && (F.context = F.pendingContext, F.pendingContext = null), n === null || n.child === null) {
            var Y = ao(s);
            if (Y)
              ob(s);
            else if (n !== null) {
              var K = n.memoizedState;
              (!K.isDehydrated || (s.flags & hs) !== vr) && (s.flags |= Nl, Zc());
            }
          }
          return NR(n, s), Ed(s), null;
        }
        case C: {
          wx(s);
          var re = dE(), _e = s.type;
          if (n !== null && s.stateNode != null)
            lP(n, s, _e, b, re), n.ref !== s.ref && sP(s);
          else {
            if (!b) {
              if (s.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Ed(s), null;
            }
            var Re = l0(), nt = ao(s);
            if (nt)
              sR(s, re, Re) && ob(s);
            else {
              var $e = o_(_e, b, re, Re, s);
              oP($e, s, !1, !1), s.stateNode = $e, l_($e, _e, b, re) && ob(s);
            }
            s.ref !== null && sP(s);
          }
          return Ed(s), null;
        }
        case D: {
          var Dt = b;
          if (n && s.stateNode != null) {
            var Lt = n.memoizedProps;
            uP(n, s, Lt, Dt);
          } else {
            if (typeof Dt != "string" && s.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Yt = dE(), er = l0(), Dr = ao(s);
            Dr ? yT(s) && ob(s) : s.stateNode = Mw(Dt, Yt, er, s);
          }
          return Ed(s), null;
        }
        case X: {
          u0(s);
          var _r = s.memoizedState;
          if (n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            var ma = eI(n, s, _r);
            if (!ma)
              return s.flags & bo ? s : null;
          }
          if ((s.flags & Rr) !== vr)
            return s.lanes = v, (s.mode & fr) !== hr && yR(s), s;
          var ta = _r !== null, xt = n !== null && n.memoizedState !== null;
          if (ta !== xt && ta) {
            var Xt = s.child;
            if (Xt.flags |= _f, (s.mode & Yr) !== hr) {
              var St = n === null && (s.memoizedProps.unstable_avoidThisFallback !== !0 || !ye);
              St || Qg(Tl.current, UT) ? tB() : eA();
            }
          }
          var gn = s.updateQueue;
          if (gn !== null && (s.flags |= Gn), Ed(s), (s.mode & fr) !== hr && ta) {
            var tr = s.child;
            tr !== null && (s.treeBaseDuration -= tr.treeBaseDuration);
          }
          return null;
        }
        case T:
          return bx(s), NR(n, s), n === null && Fg(s.stateNode.containerInfo), Ed(s), null;
        case k:
          var Yn = s.type._context;
          return G1(Yn, s), Ed(s), null;
        case ee: {
          var Qr = s.type;
          return lm(Qr) && __(s), Ed(s), null;
        }
        case pe: {
          u0(s);
          var hi = s.memoizedState;
          if (hi === null)
            return Ed(s), null;
          var As = (s.flags & Rr) !== vr, ja = hi.rendering;
          if (ja === null)
            if (As)
              OE(hi, !1);
            else {
              var Yu = rB() && (n === null || (n.flags & Rr) === vr);
              if (!Yu)
                for (var Ya = s.child; Ya !== null; ) {
                  var _u = Q_(Ya);
                  if (_u !== null) {
                    As = !0, s.flags |= Rr, OE(hi, !1);
                    var ah = _u.updateQueue;
                    return ah !== null && (s.updateQueue = ah, s.flags |= Gn), s.subtreeFlags = vr, PT(s, v), sv(s, Zg(Tl.current, Z1)), s.child;
                  }
                  Ya = Ya.sibling;
                }
              hi.tail !== null && fa() > LP() && (s.flags |= Rr, As = !0, OE(hi, !1), s.lanes = fd);
            }
          else {
            if (!As) {
              var Ad = Q_(ja);
              if (Ad !== null) {
                s.flags |= Rr, As = !0;
                var vm = Ad.updateQueue;
                if (vm !== null && (s.updateQueue = vm, s.flags |= Gn), OE(hi, !0), hi.tail === null && hi.tailMode === "hidden" && !ja.alternate && !Ws())
                  return Ed(s), null;
              } else
                fa() * 2 - hi.renderingStartTime > LP() && v !== vu && (s.flags |= Rr, As = !0, OE(hi, !1), s.lanes = fd);
            }
            if (hi.isBackwards)
              ja.sibling = s.child, s.child = ja;
            else {
              var Bh = hi.last;
              Bh !== null ? Bh.sibling = ja : s.child = ja, hi.last = ja;
            }
          }
          if (hi.tail !== null) {
            var Hh = hi.tail;
            hi.rendering = Hh, hi.tail = Hh.sibling, hi.renderingStartTime = fa(), Hh.sibling = null;
            var sh = Tl.current;
            return As ? sh = Zg(sh, Z1) : sh = Ex(sh), sv(s, sh), Hh;
          }
          return Ed(s), null;
        }
        case ce:
          break;
        case Ee:
        case de: {
          $R(s);
          var x0 = s.memoizedState, mb = x0 !== null;
          if (n !== null) {
            var QE = n.memoizedState, ty = QE !== null;
            ty !== mb && !ue && (s.flags |= _f);
          }
          return !mb || (s.mode & Yr) === hr ? Ed(s) : Qe(ey, vu) && (Ed(s), s.subtreeFlags & (oi | Gn) && (s.flags |= _f)), null;
        }
        case Fe:
          return null;
        case Ce:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + s.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function tI(n, s, v) {
      switch (px(s), s.tag) {
        case m: {
          var b = s.type;
          lm(b) && __(s);
          var R = s.flags;
          return R & bo ? (s.flags = R & ~bo | Rr, (s.mode & fr) !== hr && yR(s), s) : null;
        }
        case _: {
          s.stateNode, bx(s), fx(s), J1();
          var F = s.flags;
          return (F & bo) !== vr && (F & Rr) === vr ? (s.flags = F & ~bo | Rr, s) : null;
        }
        case C:
          return wx(s), null;
        case X: {
          u0(s);
          var Y = s.memoizedState;
          if (Y !== null && Y.dehydrated !== null) {
            if (s.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Vg();
          }
          var K = s.flags;
          return K & bo ? (s.flags = K & ~bo | Rr, (s.mode & fr) !== hr && yR(s), s) : null;
        }
        case pe:
          return u0(s), null;
        case T:
          return bx(s), null;
        case k:
          var re = s.type._context;
          return G1(re, s), null;
        case Ee:
        case de:
          return $R(s), null;
        case Fe:
          return null;
        default:
          return null;
      }
    }
    function fP(n, s, v) {
      switch (px(s), s.tag) {
        case m: {
          var b = s.type.childContextTypes;
          b != null && __(s);
          break;
        }
        case _: {
          s.stateNode, bx(s), fx(s), J1();
          break;
        }
        case C: {
          wx(s);
          break;
        }
        case T:
          bx(s);
          break;
        case X:
          u0(s);
          break;
        case pe:
          u0(s);
          break;
        case k:
          var R = s.type._context;
          G1(R, s);
          break;
        case Ee:
        case de:
          $R(s);
          break;
      }
    }
    var dP = null;
    dP = /* @__PURE__ */ new Set();
    var GT = !1, Md = !1, nI = typeof WeakSet == "function" ? WeakSet : Set, cr = null, lb = null, ub = null;
    function rI(n) {
      Pu(null, function() {
        throw n;
      }), oc();
    }
    var iI = function(n, s) {
      if (s.props = n.memoizedProps, s.state = n.memoizedState, n.mode & fr)
        try {
          Kg(), s.componentWillUnmount();
        } finally {
          fv(n);
        }
      else
        s.componentWillUnmount();
    };
    function hP(n, s) {
      try {
        Px(tu, n);
      } catch (v) {
        Do(n, s, v);
      }
    }
    function FR(n, s, v) {
      try {
        iI(n, v);
      } catch (b) {
        Do(n, s, b);
      }
    }
    function aI(n, s, v) {
      try {
        v.componentDidMount();
      } catch (b) {
        Do(n, s, b);
      }
    }
    function pP(n, s) {
      try {
        vP(n);
      } catch (v) {
        Do(n, s, v);
      }
    }
    function cb(n, s) {
      var v = n.ref;
      if (v !== null)
        if (typeof v == "function") {
          var b;
          try {
            if (Ue && ot && n.mode & fr)
              try {
                Kg(), b = v(null);
              } finally {
                fv(n);
              }
            else
              b = v(null);
          } catch (R) {
            Do(n, s, R);
          }
          typeof b == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xr(n));
        } else
          v.current = null;
    }
    function WT(n, s, v) {
      try {
        v();
      } catch (b) {
        Do(n, s, b);
      }
    }
    var mP = !1;
    function sI(n, s) {
      s_(n.containerInfo), cr = s, oI();
      var v = mP;
      return mP = !1, v;
    }
    function oI() {
      for (; cr !== null; ) {
        var n = cr, s = n.child;
        (n.subtreeFlags & zr) !== vr && s !== null ? (s.return = n, cr = s) : lI();
      }
    }
    function lI() {
      for (; cr !== null; ) {
        var n = cr;
        Xi(n);
        try {
          uI(n);
        } catch (v) {
          Do(n, n.return, v);
        }
        Ka();
        var s = n.sibling;
        if (s !== null) {
          s.return = n.return, cr = s;
          return;
        }
        cr = n.return;
      }
    }
    function uI(n) {
      var s = n.alternate, v = n.flags;
      if ((v & Nl) !== vr) {
        switch (Xi(n), n.tag) {
          case h:
          case V:
          case $:
            break;
          case m: {
            if (s !== null) {
              var b = s.memoizedProps, R = s.memoizedState, F = n.stateNode;
              n.type === n.elementType && !lS && (F.props !== n.memoizedProps && l("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(n) || "instance"), F.state !== n.memoizedState && l("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(n) || "instance"));
              var Y = F.getSnapshotBeforeUpdate(n.elementType === n.type ? b : wd(n.type, b), R);
              {
                var K = dP;
                Y === void 0 && !K.has(n.type) && (K.add(n.type), l("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", xr(n)));
              }
              F.__reactInternalSnapshotBeforeUpdate = Y;
            }
            break;
          }
          case _: {
            {
              var re = n.stateNode;
              Pw(re.containerInfo);
            }
            break;
          }
          case C:
          case D:
          case T:
          case ee:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ka();
      }
    }
    function qv(n, s, v) {
      var b = s.updateQueue, R = b !== null ? b.lastEffect : null;
      if (R !== null) {
        var F = R.next, Y = F;
        do {
          if ((Y.tag & n) === n) {
            var K = Y.destroy;
            Y.destroy = void 0, K !== void 0 && ((n & ef) !== th ? od(s) : (n & tu) !== th && cc(s), (n & ov) !== th && YE(!0), WT(s, v, K), (n & ov) !== th && YE(!1), (n & ef) !== th ? ws() : (n & tu) !== th && qd());
          }
          Y = Y.next;
        } while (Y !== F);
      }
    }
    function Px(n, s) {
      var v = s.updateQueue, b = v !== null ? v.lastEffect : null;
      if (b !== null) {
        var R = b.next, F = R;
        do {
          if ((F.tag & n) === n) {
            (n & ef) !== th ? ci(s) : (n & tu) !== th && Xd(s);
            var Y = F.create;
            (n & ov) !== th && YE(!0), F.destroy = Y(), (n & ov) !== th && YE(!1), (n & ef) !== th ? Hl() : (n & tu) !== th && zc();
            {
              var K = F.destroy;
              if (K !== void 0 && typeof K != "function") {
                var re = void 0;
                (F.tag & tu) !== vr ? re = "useLayoutEffect" : (F.tag & ov) !== vr ? re = "useInsertionEffect" : re = "useEffect";
                var _e = void 0;
                K === null ? _e = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof K.then == "function" ? _e = `

It looks like you wrote ` + re + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + re + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : _e = " You returned: " + K, l("%s must not return anything besides a function, which is used for clean-up.%s", re, _e);
              }
            }
          }
          F = F.next;
        } while (F !== R);
      }
    }
    function cI(n, s) {
      if ((s.flags & Gn) !== vr)
        switch (s.tag) {
          case I: {
            var v = s.stateNode.passiveEffectDuration, b = s.memoizedProps, R = b.id, F = b.onPostCommit, Y = h0(), K = s.alternate === null ? "mount" : "update";
            rh() && (K = "nested-update"), typeof F == "function" && F(R, K, v, Y);
            var re = s.return;
            e:
              for (; re !== null; ) {
                switch (re.tag) {
                  case _:
                    var _e = re.stateNode;
                    _e.passiveEffectDuration += v;
                    break e;
                  case I:
                    var Re = re.stateNode;
                    Re.passiveEffectDuration += v;
                    break e;
                }
                re = re.return;
              }
            break;
          }
        }
    }
    function fI(n, s, v, b) {
      if ((v.flags & ps) !== vr)
        switch (v.tag) {
          case h:
          case V:
          case $: {
            if (!Md)
              if (v.mode & fr)
                try {
                  Kg(), Px(tu | eu, v);
                } finally {
                  fv(v);
                }
              else
                Px(tu | eu, v);
            break;
          }
          case m: {
            var R = v.stateNode;
            if (v.flags & Gn && !Md)
              if (s === null)
                if (v.type === v.elementType && !lS && (R.props !== v.memoizedProps && l("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(v) || "instance"), R.state !== v.memoizedState && l("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(v) || "instance")), v.mode & fr)
                  try {
                    Kg(), R.componentDidMount();
                  } finally {
                    fv(v);
                  }
                else
                  R.componentDidMount();
              else {
                var F = v.elementType === v.type ? s.memoizedProps : wd(v.type, s.memoizedProps), Y = s.memoizedState;
                if (v.type === v.elementType && !lS && (R.props !== v.memoizedProps && l("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(v) || "instance"), R.state !== v.memoizedState && l("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(v) || "instance")), v.mode & fr)
                  try {
                    Kg(), R.componentDidUpdate(F, Y, R.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    fv(v);
                  }
                else
                  R.componentDidUpdate(F, Y, R.__reactInternalSnapshotBeforeUpdate);
              }
            var K = v.updateQueue;
            K !== null && (v.type === v.elementType && !lS && (R.props !== v.memoizedProps && l("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(v) || "instance"), R.state !== v.memoizedState && l("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(v) || "instance")), j1(v, K, R));
            break;
          }
          case _: {
            var re = v.updateQueue;
            if (re !== null) {
              var _e = null;
              if (v.child !== null)
                switch (v.child.tag) {
                  case C:
                    _e = v.child.stateNode;
                    break;
                  case m:
                    _e = v.child.stateNode;
                    break;
                }
              j1(v, re, _e);
            }
            break;
          }
          case C: {
            var Re = v.stateNode;
            if (s === null && v.flags & Gn) {
              var nt = v.type, $e = v.memoizedProps;
              c_(Re, nt, $e);
            }
            break;
          }
          case D:
            break;
          case T:
            break;
          case I: {
            {
              var Dt = v.memoizedProps, Lt = Dt.onCommit, Yt = Dt.onRender, er = v.stateNode.effectDuration, Dr = h0(), _r = s === null ? "mount" : "update";
              rh() && (_r = "nested-update"), typeof Yt == "function" && Yt(v.memoizedProps.id, _r, v.actualDuration, v.treeBaseDuration, v.actualStartTime, Dr);
              {
                typeof Lt == "function" && Lt(v.memoizedProps.id, _r, er, Dr), lB(v);
                var ma = v.return;
                e:
                  for (; ma !== null; ) {
                    switch (ma.tag) {
                      case _:
                        var ta = ma.stateNode;
                        ta.effectDuration += er;
                        break e;
                      case I:
                        var xt = ma.stateNode;
                        xt.effectDuration += er;
                        break e;
                    }
                    ma = ma.return;
                  }
              }
            }
            break;
          }
          case X: {
            xI(n, v);
            break;
          }
          case pe:
          case ee:
          case ce:
          case Ee:
          case de:
          case Ce:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Md || v.flags & es && vP(v);
    }
    function dI(n) {
      switch (n.tag) {
        case h:
        case V:
        case $: {
          if (n.mode & fr)
            try {
              Kg(), hP(n, n.return);
            } finally {
              fv(n);
            }
          else
            hP(n, n.return);
          break;
        }
        case m: {
          var s = n.stateNode;
          typeof s.componentDidMount == "function" && aI(n, n.return, s), pP(n, n.return);
          break;
        }
        case C: {
          pP(n, n.return);
          break;
        }
      }
    }
    function hI(n, s) {
      for (var v = null, b = n; ; ) {
        if (b.tag === C) {
          if (v === null) {
            v = b;
            try {
              var R = b.stateNode;
              s ? ix(R) : Dw(b.stateNode, b.memoizedProps);
            } catch (Y) {
              Do(n, n.return, Y);
            }
          }
        } else if (b.tag === D) {
          if (v === null)
            try {
              var F = b.stateNode;
              s ? Aw(F) : Lw(F, b.memoizedProps);
            } catch (Y) {
              Do(n, n.return, Y);
            }
        } else if (!((b.tag === Ee || b.tag === de) && b.memoizedState !== null && b !== n)) {
          if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === n)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === n)
            return;
          v === b && (v = null), b = b.return;
        }
        v === b && (v = null), b.sibling.return = b.return, b = b.sibling;
      }
    }
    function vP(n) {
      var s = n.ref;
      if (s !== null) {
        var v = n.stateNode, b;
        switch (n.tag) {
          case C:
            b = v;
            break;
          default:
            b = v;
        }
        if (typeof s == "function") {
          var R;
          if (n.mode & fr)
            try {
              Kg(), R = s(b);
            } finally {
              fv(n);
            }
          else
            R = s(b);
          typeof R == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xr(n));
        } else
          s.hasOwnProperty("current") || l("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", xr(n)), s.current = b;
      }
    }
    function pI(n) {
      var s = n.alternate;
      s !== null && (s.return = null), n.return = null;
    }
    function gP(n) {
      var s = n.alternate;
      s !== null && (n.alternate = null, gP(s));
      {
        if (n.child = null, n.deletions = null, n.sibling = null, n.tag === C) {
          var v = n.stateNode;
          v !== null && ke(v);
        }
        n.stateNode = null, n._debugOwner = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
      }
    }
    function mI(n) {
      for (var s = n.return; s !== null; ) {
        if (yP(s))
          return s;
        s = s.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function yP(n) {
      return n.tag === C || n.tag === _ || n.tag === T;
    }
    function xP(n) {
      var s = n;
      e:
        for (; ; ) {
          for (; s.sibling === null; ) {
            if (s.return === null || yP(s.return))
              return null;
            s = s.return;
          }
          for (s.sibling.return = s.return, s = s.sibling; s.tag !== C && s.tag !== D && s.tag !== ie; ) {
            if (s.flags & oi || s.child === null || s.tag === T)
              continue e;
            s.child.return = s, s = s.child;
          }
          if (!(s.flags & oi))
            return s.stateNode;
        }
    }
    function vI(n) {
      var s = mI(n);
      switch (s.tag) {
        case C: {
          var v = s.stateNode;
          s.flags & zi && (jy(v), s.flags &= ~zi);
          var b = xP(n);
          IR(n, b, v);
          break;
        }
        case _:
        case T: {
          var R = s.stateNode.containerInfo, F = xP(n);
          kR(n, F, R);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function kR(n, s, v) {
      var b = n.tag, R = b === C || b === D;
      if (R) {
        var F = n.stateNode;
        s ? nx(v, F, s) : d_(v, F);
      } else if (b !== T) {
        var Y = n.child;
        if (Y !== null) {
          kR(Y, s, v);
          for (var K = Y.sibling; K !== null; )
            kR(K, s, v), K = K.sibling;
        }
      }
    }
    function IR(n, s, v) {
      var b = n.tag, R = b === C || b === D;
      if (R) {
        var F = n.stateNode;
        s ? h_(v, F, s) : R1(v, F);
      } else if (b !== T) {
        var Y = n.child;
        if (Y !== null) {
          IR(Y, s, v);
          for (var K = Y.sibling; K !== null; )
            IR(K, s, v), K = K.sibling;
        }
      }
    }
    var Td = null, Qv = !1;
    function gI(n, s, v) {
      {
        var b = s;
        e:
          for (; b !== null; ) {
            switch (b.tag) {
              case C: {
                Td = b.stateNode, Qv = !1;
                break e;
              }
              case _: {
                Td = b.stateNode.containerInfo, Qv = !0;
                break e;
              }
              case T: {
                Td = b.stateNode.containerInfo, Qv = !0;
                break e;
              }
            }
            b = b.return;
          }
        if (Td === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        SP(n, s, v), Td = null, Qv = !1;
      }
      pI(v);
    }
    function Ox(n, s, v) {
      for (var b = v.child; b !== null; )
        SP(n, s, b), b = b.sibling;
    }
    function SP(n, s, v) {
      switch (An(v), v.tag) {
        case C:
          Md || cb(v, s);
        case D: {
          {
            var b = Td, R = Qv;
            Td = null, Ox(n, s, v), Td = b, Qv = R, Td !== null && (Qv ? Rw(Td, v.stateNode) : rx(Td, v.stateNode));
          }
          return;
        }
        case ie: {
          Td !== null && (Qv ? Bf(Td, v.stateNode) : A1(Td, v.stateNode));
          return;
        }
        case T: {
          {
            var F = Td, Y = Qv;
            Td = v.stateNode.containerInfo, Qv = !0, Ox(n, s, v), Td = F, Qv = Y;
          }
          return;
        }
        case h:
        case V:
        case J:
        case $: {
          if (!Md) {
            var K = v.updateQueue;
            if (K !== null) {
              var re = K.lastEffect;
              if (re !== null) {
                var _e = re.next, Re = _e;
                do {
                  var nt = Re, $e = nt.destroy, Dt = nt.tag;
                  $e !== void 0 && ((Dt & ov) !== th ? WT(v, s, $e) : (Dt & tu) !== th && (cc(v), v.mode & fr ? (Kg(), WT(v, s, $e), fv(v)) : WT(v, s, $e), qd())), Re = Re.next;
                } while (Re !== _e);
              }
            }
          }
          Ox(n, s, v);
          return;
        }
        case m: {
          if (!Md) {
            cb(v, s);
            var Lt = v.stateNode;
            typeof Lt.componentWillUnmount == "function" && FR(v, s, Lt);
          }
          Ox(n, s, v);
          return;
        }
        case ce: {
          Ox(n, s, v);
          return;
        }
        case Ee: {
          if (v.mode & Yr) {
            var Yt = Md;
            Md = Yt || v.memoizedState !== null, Ox(n, s, v), Md = Yt;
          } else
            Ox(n, s, v);
          break;
        }
        default: {
          Ox(n, s, v);
          return;
        }
      }
    }
    function yI(n) {
      n.memoizedState;
    }
    function xI(n, s) {
      var v = s.memoizedState;
      if (v === null) {
        var b = s.alternate;
        if (b !== null) {
          var R = b.memoizedState;
          if (R !== null) {
            var F = R.dehydrated;
            F !== null && g_(F);
          }
        }
      }
    }
    function _P(n) {
      var s = n.updateQueue;
      if (s !== null) {
        n.updateQueue = null;
        var v = n.stateNode;
        v === null && (v = n.stateNode = new nI()), s.forEach(function(b) {
          var R = mB.bind(null, n, b);
          if (!v.has(b)) {
            if (v.add(b), ya)
              if (lb !== null && ub !== null)
                jE(ub, lb);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            b.then(R, R);
          }
        });
      }
    }
    function SI(n, s, v) {
      lb = v, ub = n, Xi(s), bP(s, n), Xi(s), lb = null, ub = null;
    }
    function Zv(n, s, v) {
      var b = s.deletions;
      if (b !== null)
        for (var R = 0; R < b.length; R++) {
          var F = b[R];
          try {
            gI(n, s, F);
          } catch (re) {
            Do(F, s, re);
          }
        }
      var Y = Rm();
      if (s.subtreeFlags & Js)
        for (var K = s.child; K !== null; )
          Xi(K), bP(K, n), K = K.sibling;
      Xi(Y);
    }
    function bP(n, s, v) {
      var b = n.alternate, R = n.flags;
      switch (n.tag) {
        case h:
        case V:
        case J:
        case $: {
          if (Zv(s, n), $g(n), R & Gn) {
            try {
              qv(ov | eu, n, n.return), Px(ov | eu, n);
            } catch (Qr) {
              Do(n, n.return, Qr);
            }
            if (n.mode & fr) {
              try {
                Kg(), qv(tu | eu, n, n.return);
              } catch (Qr) {
                Do(n, n.return, Qr);
              }
              fv(n);
            } else
              try {
                qv(tu | eu, n, n.return);
              } catch (Qr) {
                Do(n, n.return, Qr);
              }
          }
          return;
        }
        case m: {
          Zv(s, n), $g(n), R & es && b !== null && cb(b, b.return);
          return;
        }
        case C: {
          Zv(s, n), $g(n), R & es && b !== null && cb(b, b.return);
          {
            if (n.flags & zi) {
              var F = n.stateNode;
              try {
                jy(F);
              } catch (Qr) {
                Do(n, n.return, Qr);
              }
            }
            if (R & Gn) {
              var Y = n.stateNode;
              if (Y != null) {
                var K = n.memoizedProps, re = b !== null ? b.memoizedProps : K, _e = n.type, Re = n.updateQueue;
                if (n.updateQueue = null, Re !== null)
                  try {
                    tx(Y, Re, _e, re, K, n);
                  } catch (Qr) {
                    Do(n, n.return, Qr);
                  }
              }
            }
          }
          return;
        }
        case D: {
          if (Zv(s, n), $g(n), R & Gn) {
            if (n.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var nt = n.stateNode, $e = n.memoizedProps, Dt = b !== null ? b.memoizedProps : $e;
            try {
              f_(nt, Dt, $e);
            } catch (Qr) {
              Do(n, n.return, Qr);
            }
          }
          return;
        }
        case _: {
          if (Zv(s, n), $g(n), R & Gn && b !== null) {
            var Lt = b.memoizedState;
            if (Lt.isDehydrated)
              try {
                v_(s.containerInfo);
              } catch (Qr) {
                Do(n, n.return, Qr);
              }
          }
          return;
        }
        case T: {
          Zv(s, n), $g(n);
          return;
        }
        case X: {
          Zv(s, n), $g(n);
          var Yt = n.child;
          if (Yt.flags & _f) {
            var er = Yt.stateNode, Dr = Yt.memoizedState, _r = Dr !== null;
            if (er.isHidden = _r, _r) {
              var ma = Yt.alternate !== null && Yt.alternate.memoizedState !== null;
              ma || eB();
            }
          }
          if (R & Gn) {
            try {
              yI(n);
            } catch (Qr) {
              Do(n, n.return, Qr);
            }
            _P(n);
          }
          return;
        }
        case Ee: {
          var ta = b !== null && b.memoizedState !== null;
          if (n.mode & Yr) {
            var xt = Md;
            Md = xt || ta, Zv(s, n), Md = xt;
          } else
            Zv(s, n);
          if ($g(n), R & _f) {
            var Xt = n.stateNode, St = n.memoizedState, gn = St !== null, tr = n;
            if (Xt.isHidden = gn, gn && !ta && (tr.mode & Yr) !== hr) {
              cr = tr;
              for (var Yn = tr.child; Yn !== null; )
                cr = Yn, bI(Yn), Yn = Yn.sibling;
            }
            hI(tr, gn);
          }
          return;
        }
        case pe: {
          Zv(s, n), $g(n), R & Gn && _P(n);
          return;
        }
        case ce:
          return;
        default: {
          Zv(s, n), $g(n);
          return;
        }
      }
    }
    function $g(n) {
      var s = n.flags;
      if (s & oi) {
        try {
          vI(n);
        } catch (v) {
          Do(n, n.return, v);
        }
        n.flags &= ~oi;
      }
      s & Fl && (n.flags &= ~Fl);
    }
    function _I(n, s, v) {
      lb = v, ub = s, cr = n, wP(n, s, v), lb = null, ub = null;
    }
    function wP(n, s, v) {
      for (var b = (n.mode & Yr) !== hr; cr !== null; ) {
        var R = cr, F = R.child;
        if (R.tag === Ee && b) {
          var Y = R.memoizedState !== null, K = Y || GT;
          if (K) {
            BR(n, s, v);
            continue;
          } else {
            var re = R.alternate, _e = re !== null && re.memoizedState !== null, Re = _e || Md, nt = GT, $e = Md;
            GT = K, Md = Re, Md && !$e && (cr = R, wI(R));
            for (var Dt = F; Dt !== null; )
              cr = Dt, wP(
                Dt,
                s,
                v
              ), Dt = Dt.sibling;
            cr = R, GT = nt, Md = $e, BR(n, s, v);
            continue;
          }
        }
        (R.subtreeFlags & ps) !== vr && F !== null ? (F.return = R, cr = F) : BR(n, s, v);
      }
    }
    function BR(n, s, v) {
      for (; cr !== null; ) {
        var b = cr;
        if ((b.flags & ps) !== vr) {
          var R = b.alternate;
          Xi(b);
          try {
            fI(s, R, b, v);
          } catch (Y) {
            Do(b, b.return, Y);
          }
          Ka();
        }
        if (b === n) {
          cr = null;
          return;
        }
        var F = b.sibling;
        if (F !== null) {
          F.return = b.return, cr = F;
          return;
        }
        cr = b.return;
      }
    }
    function bI(n) {
      for (; cr !== null; ) {
        var s = cr, v = s.child;
        switch (s.tag) {
          case h:
          case V:
          case J:
          case $: {
            if (s.mode & fr)
              try {
                Kg(), qv(tu, s, s.return);
              } finally {
                fv(s);
              }
            else
              qv(tu, s, s.return);
            break;
          }
          case m: {
            cb(s, s.return);
            var b = s.stateNode;
            typeof b.componentWillUnmount == "function" && FR(s, s.return, b);
            break;
          }
          case C: {
            cb(s, s.return);
            break;
          }
          case Ee: {
            var R = s.memoizedState !== null;
            if (R) {
              EP(n);
              continue;
            }
            break;
          }
        }
        v !== null ? (v.return = s, cr = v) : EP(n);
      }
    }
    function EP(n) {
      for (; cr !== null; ) {
        var s = cr;
        if (s === n) {
          cr = null;
          return;
        }
        var v = s.sibling;
        if (v !== null) {
          v.return = s.return, cr = v;
          return;
        }
        cr = s.return;
      }
    }
    function wI(n) {
      for (; cr !== null; ) {
        var s = cr, v = s.child;
        if (s.tag === Ee) {
          var b = s.memoizedState !== null;
          if (b) {
            MP(n);
            continue;
          }
        }
        v !== null ? (v.return = s, cr = v) : MP(n);
      }
    }
    function MP(n) {
      for (; cr !== null; ) {
        var s = cr;
        Xi(s);
        try {
          dI(s);
        } catch (b) {
          Do(s, s.return, b);
        }
        if (Ka(), s === n) {
          cr = null;
          return;
        }
        var v = s.sibling;
        if (v !== null) {
          v.return = s.return, cr = v;
          return;
        }
        cr = s.return;
      }
    }
    function EI(n, s, v, b) {
      cr = s, MI(s, n, v, b);
    }
    function MI(n, s, v, b) {
      for (; cr !== null; ) {
        var R = cr, F = R.child;
        (R.subtreeFlags & Uc) !== vr && F !== null ? (F.return = R, cr = F) : TI(n, s, v, b);
      }
    }
    function TI(n, s, v, b) {
      for (; cr !== null; ) {
        var R = cr;
        if ((R.flags & Ia) !== vr) {
          Xi(R);
          try {
            CI(s, R, v, b);
          } catch (Y) {
            Do(R, R.return, Y);
          }
          Ka();
        }
        if (R === n) {
          cr = null;
          return;
        }
        var F = R.sibling;
        if (F !== null) {
          F.return = R.return, cr = F;
          return;
        }
        cr = R.return;
      }
    }
    function CI(n, s, v, b) {
      switch (s.tag) {
        case h:
        case V:
        case $: {
          if (s.mode & fr) {
            gR();
            try {
              Px(ef | eu, s);
            } finally {
              AE(s);
            }
          } else
            Px(ef | eu, s);
          break;
        }
      }
    }
    function RI(n) {
      cr = n, AI();
    }
    function AI() {
      for (; cr !== null; ) {
        var n = cr, s = n.child;
        if ((cr.flags & bi) !== vr) {
          var v = n.deletions;
          if (v !== null) {
            for (var b = 0; b < v.length; b++) {
              var R = v[b];
              cr = R, PI(R, n);
            }
            {
              var F = n.alternate;
              if (F !== null) {
                var Y = F.child;
                if (Y !== null) {
                  F.child = null;
                  do {
                    var K = Y.sibling;
                    Y.sibling = null, Y = K;
                  } while (Y !== null);
                }
              }
            }
            cr = n;
          }
        }
        (n.subtreeFlags & Uc) !== vr && s !== null ? (s.return = n, cr = s) : DI();
      }
    }
    function DI() {
      for (; cr !== null; ) {
        var n = cr;
        (n.flags & Ia) !== vr && (Xi(n), LI(n), Ka());
        var s = n.sibling;
        if (s !== null) {
          s.return = n.return, cr = s;
          return;
        }
        cr = n.return;
      }
    }
    function LI(n) {
      switch (n.tag) {
        case h:
        case V:
        case $: {
          n.mode & fr ? (gR(), qv(ef | eu, n, n.return), AE(n)) : qv(ef | eu, n, n.return);
          break;
        }
      }
    }
    function PI(n, s) {
      for (; cr !== null; ) {
        var v = cr;
        Xi(v), UI(v, s), Ka();
        var b = v.child;
        b !== null ? (b.return = v, cr = b) : OI(n);
      }
    }
    function OI(n) {
      for (; cr !== null; ) {
        var s = cr, v = s.sibling, b = s.return;
        if (gP(s), s === n) {
          cr = null;
          return;
        }
        if (v !== null) {
          v.return = b, cr = v;
          return;
        }
        cr = b;
      }
    }
    function UI(n, s) {
      switch (n.tag) {
        case h:
        case V:
        case $: {
          n.mode & fr ? (gR(), qv(ef, n, s), AE(n)) : qv(ef, n, s);
          break;
        }
      }
    }
    function zI(n) {
      switch (n.tag) {
        case h:
        case V:
        case $: {
          try {
            Px(tu | eu, n);
          } catch (v) {
            Do(n, n.return, v);
          }
          break;
        }
        case m: {
          var s = n.stateNode;
          try {
            s.componentDidMount();
          } catch (v) {
            Do(n, n.return, v);
          }
          break;
        }
      }
    }
    function NI(n) {
      switch (n.tag) {
        case h:
        case V:
        case $: {
          try {
            Px(ef | eu, n);
          } catch (s) {
            Do(n, n.return, s);
          }
          break;
        }
      }
    }
    function FI(n) {
      switch (n.tag) {
        case h:
        case V:
        case $: {
          try {
            qv(tu | eu, n, n.return);
          } catch (v) {
            Do(n, n.return, v);
          }
          break;
        }
        case m: {
          var s = n.stateNode;
          typeof s.componentWillUnmount == "function" && FR(n, n.return, s);
          break;
        }
      }
    }
    function kI(n) {
      switch (n.tag) {
        case h:
        case V:
        case $:
          try {
            qv(ef | eu, n, n.return);
          } catch (s) {
            Do(n, n.return, s);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var UE = Symbol.for;
      UE("selector.component"), UE("selector.has_pseudo_class"), UE("selector.role"), UE("selector.test_id"), UE("selector.text");
    }
    var II = [];
    function BI() {
      II.forEach(function(n) {
        return n();
      });
    }
    var HI = t.ReactCurrentActQueue;
    function VI(n) {
      {
        var s = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, v = typeof jest < "u";
        return v && s !== !1;
      }
    }
    function TP() {
      {
        var n = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !n && HI.current !== null && l("The current testing environment is not configured to support act(...)"), n;
      }
    }
    var GI = Math.ceil, HR = t.ReactCurrentDispatcher, VR = t.ReactCurrentOwner, Cd = t.ReactCurrentBatchConfig, Jv = t.ReactCurrentActQueue, rf = 0, CP = 1, Rd = 2, dv = 4, m0 = 0, zE = 1, uS = 2, jT = 3, NE = 4, RP = 5, GR = 6, pa = rf, kh = null, nu = null, af = Ht, ey = Ht, WR = Vu(Ht), sf = m0, FE = null, YT = Ht, kE = Ht, XT = Ht, IE = null, Cp = null, jR = 0, AP = 500, DP = 1 / 0, WI = 500, v0 = null;
    function BE() {
      DP = fa() + WI;
    }
    function LP() {
      return DP;
    }
    var qT = !1, YR = null, fb = null, cS = !1, Ux = null, HE = Ht, XR = [], qR = null, jI = 50, VE = 0, QR = null, ZR = !1, QT = !1, YI = 50, db = 0, ZT = null, GE = ii, JT = Ht, PP = !1;
    function KT() {
      return kh;
    }
    function Ih() {
      return (pa & (Rd | dv)) !== rf ? fa() : (GE !== ii || (GE = fa()), GE);
    }
    function zx(n) {
      var s = n.mode;
      if ((s & Yr) === hr)
        return lr;
      if ((pa & Rd) !== rf && af !== Ht)
        return Li(af);
      var v = L_() !== e0;
      if (v) {
        if (Cd.transition !== null) {
          var b = Cd.transition;
          b._updatedFibers || (b._updatedFibers = /* @__PURE__ */ new Set()), b._updatedFibers.add(n);
        }
        return JT === vi && (JT = ur()), JT;
      }
      var R = pc();
      if (R !== vi)
        return R;
      var F = Tw();
      return F;
    }
    function XI(n) {
      var s = n.mode;
      return (s & Yr) === hr ? lr : _a();
    }
    function of(n, s, v, b) {
      gB(), PP && l("useInsertionEffect must not schedule updates."), ZR && (QT = !0), $r(n, v, b), (pa & Rd) !== Ht && n === kh ? SB(s) : (ya && km(n, s, v), _B(s), n === kh && ((pa & Rd) === rf && (kE = qt(kE, v)), sf === NE && Nx(n, af)), Rp(n, b), v === lr && pa === rf && (s.mode & Yr) === hr && !Jv.isBatchingLegacy && (BE(), dT()));
    }
    function qI(n, s, v) {
      var b = n.current;
      b.lanes = s, $r(n, s, v), Rp(n, v);
    }
    function QI(n) {
      return (pa & Rd) !== rf;
    }
    function Rp(n, s) {
      var v = n.callbackNode;
      x(n, s);
      var b = Pf(n, n === kh ? af : Ht);
      if (b === Ht) {
        v !== null && qP(v), n.callbackNode = null, n.callbackPriority = vi;
        return;
      }
      var R = Tn(b), F = n.callbackPriority;
      if (F === R && !(Jv.current !== null && v !== rA)) {
        v == null && F !== lr && l("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      v != null && qP(v);
      var Y;
      if (R === lr)
        n.tag === Ig ? (Jv.isBatchingLegacy !== null && (Jv.didScheduleLegacyUpdate = !0), fT(zP.bind(null, n))) : cT(zP.bind(null, n)), Jv.current !== null ? Jv.current.push(Bg) : u_(function() {
          (pa & (Rd | dv)) === rf && Bg();
        }), Y = null;
      else {
        var K;
        switch (Fu(b)) {
          case Xo:
            K = Hp;
            break;
          case qo:
            K = du;
            break;
          case rs:
            K = Bl;
            break;
          case Wp:
            K = bf;
            break;
          default:
            K = Bl;
            break;
        }
        Y = iA(K, OP.bind(null, n));
      }
      n.callbackPriority = R, n.callbackNode = Y;
    }
    function OP(n, s) {
      if (cv(), GE = ii, JT = Ht, (pa & (Rd | dv)) !== rf)
        throw new Error("Should not already be working.");
      var v = n.callbackNode, b = y0();
      if (b && n.callbackNode !== v)
        return null;
      var R = Pf(n, n === kh ? af : Ht);
      if (R === Ht)
        return null;
      var F = !cn(n, R) && !bn(n, R) && !s, Y = F ? aB(n, R) : e2(n, R);
      if (Y !== m0) {
        if (Y === uS) {
          var K = H(n);
          K !== Ht && (R = K, Y = JR(n, K));
        }
        if (Y === zE) {
          var re = FE;
          throw fS(n, Ht), Nx(n, R), Rp(n, fa()), re;
        }
        if (Y === GR)
          Nx(n, R);
        else {
          var _e = !cn(n, R), Re = n.current.alternate;
          if (_e && !JI(Re)) {
            if (Y = e2(n, R), Y === uS) {
              var nt = H(n);
              nt !== Ht && (R = nt, Y = JR(n, nt));
            }
            if (Y === zE) {
              var $e = FE;
              throw fS(n, Ht), Nx(n, R), Rp(n, fa()), $e;
            }
          }
          n.finishedWork = Re, n.finishedLanes = R, ZI(n, Y, R);
        }
      }
      return Rp(n, fa()), n.callbackNode === v ? OP.bind(null, n) : null;
    }
    function JR(n, s) {
      var v = IE;
      if (Vi(n)) {
        var b = fS(n, s);
        b.flags |= hs, In(n.containerInfo);
      }
      var R = e2(n, s);
      if (R !== uS) {
        var F = Cp;
        Cp = v, F !== null && UP(F);
      }
      return R;
    }
    function UP(n) {
      Cp === null ? Cp = n : Cp.push.apply(Cp, n);
    }
    function ZI(n, s, v) {
      switch (s) {
        case m0:
        case zE:
          throw new Error("Root did not complete. This is a bug in React.");
        case uS: {
          dS(n, Cp, v0);
          break;
        }
        case jT: {
          if (Nx(n, v), Ae(v) && !QP()) {
            var b = jR + AP - fa();
            if (b > 10) {
              var R = Pf(n, Ht);
              if (R !== Ht)
                break;
              var F = n.suspendedLanes;
              if (!At(F, v)) {
                Ih(), hd(n, F);
                break;
              }
              n.timeoutHandle = T1(dS.bind(null, n, Cp, v0), b);
              break;
            }
          }
          dS(n, Cp, v0);
          break;
        }
        case NE: {
          if (Nx(n, v), kt(v))
            break;
          if (!QP()) {
            var Y = Vp(n, v), K = Y, re = fa() - K, _e = vB(re) - re;
            if (_e > 10) {
              n.timeoutHandle = T1(dS.bind(null, n, Cp, v0), _e);
              break;
            }
          }
          dS(n, Cp, v0);
          break;
        }
        case RP: {
          dS(n, Cp, v0);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function JI(n) {
      for (var s = n; ; ) {
        if (s.flags & Wd) {
          var v = s.updateQueue;
          if (v !== null) {
            var b = v.stores;
            if (b !== null)
              for (var R = 0; R < b.length; R++) {
                var F = b[R], Y = F.getSnapshot, K = F.value;
                try {
                  if (!Qn(Y(), K))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var re = s.child;
        if (s.subtreeFlags & Wd && re !== null) {
          re.return = s, s = re;
          continue;
        }
        if (s === n)
          return !0;
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === n)
            return !0;
          s = s.return;
        }
        s.sibling.return = s.return, s = s.sibling;
      }
      return !0;
    }
    function Nx(n, s) {
      s = Wn(s, XT), s = Wn(s, kE), hc(n, s);
    }
    function zP(n) {
      if (Lx(), (pa & (Rd | dv)) !== rf)
        throw new Error("Should not already be working.");
      y0();
      var s = Pf(n, Ht);
      if (!Qe(s, lr))
        return Rp(n, fa()), null;
      var v = e2(n, s);
      if (n.tag !== Ig && v === uS) {
        var b = H(n);
        b !== Ht && (s = b, v = JR(n, b));
      }
      if (v === zE) {
        var R = FE;
        throw fS(n, Ht), Nx(n, s), Rp(n, fa()), R;
      }
      if (v === GR)
        throw new Error("Root did not complete. This is a bug in React.");
      var F = n.current.alternate;
      return n.finishedWork = F, n.finishedLanes = s, dS(n, Cp, v0), Rp(n, fa()), null;
    }
    function KI(n, s) {
      s !== Ht && (gr(n, qt(s, lr)), Rp(n, fa()), (pa & (Rd | dv)) === rf && (BE(), Bg()));
    }
    function KR(n, s) {
      var v = pa;
      pa |= CP;
      try {
        return n(s);
      } finally {
        pa = v, pa === rf && !Jv.isBatchingLegacy && (BE(), dT());
      }
    }
    function $I(n, s, v, b, R) {
      var F = pc(), Y = Cd.transition;
      try {
        return Cd.transition = null, to(Xo), n(s, v, b, R);
      } finally {
        to(F), Cd.transition = Y, pa === rf && BE();
      }
    }
    function g0(n) {
      Ux !== null && Ux.tag === Ig && (pa & (Rd | dv)) === rf && y0();
      var s = pa;
      pa |= CP;
      var v = Cd.transition, b = pc();
      try {
        return Cd.transition = null, to(Xo), n ? n() : void 0;
      } finally {
        to(b), Cd.transition = v, pa = s, (pa & (Rd | dv)) === rf && Bg();
      }
    }
    function NP() {
      return (pa & (Rd | dv)) !== rf;
    }
    function $T(n, s) {
      Hf(WR, ey, n), ey = qt(ey, s);
    }
    function $R(n) {
      ey = WR.current, Gu(WR, n);
    }
    function fS(n, s) {
      n.finishedWork = null, n.finishedLanes = Ht;
      var v = n.timeoutHandle;
      if (v !== zg && (n.timeoutHandle = zg, C1(v)), nu !== null)
        for (var b = nu.return; b !== null; ) {
          var R = b.alternate;
          fP(R, b), b = b.return;
        }
      kh = n;
      var F = hS(n.current, null);
      return nu = F, af = ey = s, sf = m0, FE = null, YT = Ht, kE = Ht, XT = Ht, IE = null, Cp = null, $w(), bd.discardPendingWarnings(), F;
    }
    function FP(n, s) {
      do {
        var v = nu;
        try {
          if (O_(), yE(), Ka(), VR.current = null, v === null || v.return === null) {
            sf = zE, FE = s, nu = null;
            return;
          }
          if (Ue && v.mode & fr && sS(v, !0), st)
            if (Ba(), s !== null && typeof s == "object" && typeof s.then == "function") {
              var b = s;
              il(v, b, af);
            } else
              ld(v, s, af);
          wk(n, v.return, v, s, af), HP(v);
        } catch (R) {
          s = R, nu === v && v !== null ? (v = v.return, nu = v) : v = nu;
          continue;
        }
        return;
      } while (!0);
    }
    function kP() {
      var n = HR.current;
      return HR.current = Et, n === null ? Et : n;
    }
    function IP(n) {
      HR.current = n;
    }
    function eB() {
      jR = fa();
    }
    function WE(n) {
      YT = qt(n, YT);
    }
    function tB() {
      sf === m0 && (sf = jT);
    }
    function eA() {
      (sf === m0 || sf === jT || sf === uS) && (sf = NE), kh !== null && (te(YT) || te(kE)) && Nx(kh, af);
    }
    function nB(n) {
      sf !== NE && (sf = uS), IE === null ? IE = [n] : IE.push(n);
    }
    function rB() {
      return sf === m0;
    }
    function e2(n, s) {
      var v = pa;
      pa |= Rd;
      var b = kP();
      if (kh !== n || af !== s) {
        if (ya) {
          var R = n.memoizedUpdaters;
          R.size > 0 && (jE(n, af), R.clear()), Of(n, s);
        }
        v0 = dg(), fS(n, s);
      }
      Vl(s);
      do
        try {
          iB();
          break;
        } catch (F) {
          FP(n, F);
        }
      while (!0);
      if (O_(), pa = v, IP(b), nu !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ud(), kh = null, af = Ht, sf;
    }
    function iB() {
      for (; nu !== null; )
        BP(nu);
    }
    function aB(n, s) {
      var v = pa;
      pa |= Rd;
      var b = kP();
      if (kh !== n || af !== s) {
        if (ya) {
          var R = n.memoizedUpdaters;
          R.size > 0 && (jE(n, af), R.clear()), Of(n, s);
        }
        v0 = dg(), BE(), fS(n, s);
      }
      Vl(s);
      do
        try {
          sB();
          break;
        } catch (F) {
          FP(n, F);
        }
      while (!0);
      return O_(), IP(b), pa = v, nu !== null ? (Gl(), m0) : (ud(), kh = null, af = Ht, sf);
    }
    function sB() {
      for (; nu !== null && !rl(); )
        BP(nu);
    }
    function BP(n) {
      var s = n.alternate;
      Xi(n);
      var v;
      (n.mode & fr) !== hr ? (Yv(n), v = tA(s, n, ey), sS(n, !0)) : v = tA(s, n, ey), Ka(), n.memoizedProps = n.pendingProps, v === null ? HP(n) : nu = v, VR.current = null;
    }
    function HP(n) {
      var s = n;
      do {
        var v = s.alternate, b = s.return;
        if ((s.flags & vl) === vr) {
          Xi(s);
          var R = void 0;
          if ((s.mode & fr) === hr ? R = cP(v, s, ey) : (Yv(s), R = cP(v, s, ey), sS(s, !1)), Ka(), R !== null) {
            nu = R;
            return;
          }
        } else {
          var F = tI(v, s);
          if (F !== null) {
            F.flags &= Sv, nu = F;
            return;
          }
          if ((s.mode & fr) !== hr) {
            sS(s, !1);
            for (var Y = s.actualDuration, K = s.child; K !== null; )
              Y += K.actualDuration, K = K.sibling;
            s.actualDuration = Y;
          }
          if (b !== null)
            b.flags |= vl, b.subtreeFlags = vr, b.deletions = null;
          else {
            sf = GR, nu = null;
            return;
          }
        }
        var re = s.sibling;
        if (re !== null) {
          nu = re;
          return;
        }
        s = b, nu = s;
      } while (s !== null);
      sf === m0 && (sf = RP);
    }
    function dS(n, s, v) {
      var b = pc(), R = Cd.transition;
      try {
        Cd.transition = null, to(Xo), oB(n, s, v, b);
      } finally {
        Cd.transition = R, to(b);
      }
      return null;
    }
    function oB(n, s, v, b) {
      do
        y0();
      while (Ux !== null);
      if (yB(), (pa & (Rd | dv)) !== rf)
        throw new Error("Should not already be working.");
      var R = n.finishedWork, F = n.finishedLanes;
      if (Sa(F), R === null)
        return Kr(), null;
      if (F === Ht && l("root.finishedLanes should not be empty during a commit. This is a bug in React."), n.finishedWork = null, n.finishedLanes = Ht, R === n.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      n.callbackNode = null, n.callbackPriority = vi;
      var Y = qt(R.lanes, R.childLanes);
      np(n, Y), n === kh && (kh = null, nu = null, af = Ht), ((R.subtreeFlags & Uc) !== vr || (R.flags & Uc) !== vr) && (cS || (cS = !0, qR = v, iA(Bl, function() {
        return y0(), null;
      })));
      var K = (R.subtreeFlags & (zr | Js | ps | Uc)) !== vr, re = (R.flags & (zr | Js | ps | Uc)) !== vr;
      if (K || re) {
        var _e = Cd.transition;
        Cd.transition = null;
        var Re = pc();
        to(Xo);
        var nt = pa;
        pa |= dv, VR.current = null, sI(n, R), ih(), SI(n, R, F), E1(n.containerInfo), n.current = R, Fm(F), _I(R, n, F), Ef(), zs(), pa = nt, to(Re), Cd.transition = _e;
      } else
        n.current = R, ih();
      var $e = cS;
      if (cS ? (cS = !1, Ux = n, HE = F) : (db = 0, ZT = null), Y = n.pendingLanes, Y === Ht && (fb = null), $e || jP(n.current, !1), Wo(R.stateNode, b), ya && n.memoizedUpdaters.clear(), BI(), Rp(n, fa()), s !== null)
        for (var Dt = n.onRecoverableError, Lt = 0; Lt < s.length; Lt++) {
          var Yt = s[Lt], er = Yt.stack, Dr = Yt.digest;
          Dt(Yt.value, {
            componentStack: er,
            digest: Dr
          });
        }
      if (qT) {
        qT = !1;
        var _r = YR;
        throw YR = null, _r;
      }
      return Qe(HE, lr) && n.tag !== Ig && y0(), Y = n.pendingLanes, Qe(Y, lr) ? (Nh(), n === QR ? VE++ : (VE = 0, QR = n)) : VE = 0, Bg(), Kr(), null;
    }
    function y0() {
      if (Ux !== null) {
        var n = Fu(HE), s = xy(rs, n), v = Cd.transition, b = pc();
        try {
          return Cd.transition = null, to(s), uB();
        } finally {
          to(b), Cd.transition = v;
        }
      }
      return !1;
    }
    function lB(n) {
      XR.push(n), cS || (cS = !0, iA(Bl, function() {
        return y0(), null;
      }));
    }
    function uB() {
      if (Ux === null)
        return !1;
      var n = qR;
      qR = null;
      var s = Ux, v = HE;
      if (Ux = null, HE = Ht, (pa & (Rd | dv)) !== rf)
        throw new Error("Cannot flush passive effects while already rendering.");
      ZR = !0, QT = !1, Qd(v);
      var b = pa;
      pa |= dv, RI(s.current), EI(s, s.current, v, n);
      {
        var R = XR;
        XR = [];
        for (var F = 0; F < R.length; F++) {
          var Y = R[F];
          cI(s, Y);
        }
      }
      Mf(), jP(s.current, !0), pa = b, Bg(), QT ? s === ZT ? db++ : (db = 0, ZT = s) : db = 0, ZR = !1, QT = !1, ts(s);
      {
        var K = s.current.stateNode;
        K.effectDuration = 0, K.passiveEffectDuration = 0;
      }
      return !0;
    }
    function VP(n) {
      return fb !== null && fb.has(n);
    }
    function cB(n) {
      fb === null ? fb = /* @__PURE__ */ new Set([n]) : fb.add(n);
    }
    function fB(n) {
      qT || (qT = !0, YR = n);
    }
    var dB = fB;
    function GP(n, s, v) {
      var b = oS(v, s), R = BL(n, b, lr), F = Yg(n, R, lr), Y = Ih();
      F !== null && ($r(F, lr, Y), Rp(F, Y));
    }
    function Do(n, s, v) {
      if (rI(v), YE(!1), n.tag === _) {
        GP(n, n, v);
        return;
      }
      var b = null;
      for (b = s; b !== null; ) {
        if (b.tag === _) {
          GP(b, n, v);
          return;
        } else if (b.tag === m) {
          var R = b.type, F = b.stateNode;
          if (typeof R.getDerivedStateFromError == "function" || typeof F.componentDidCatch == "function" && !VP(F)) {
            var Y = oS(v, n), K = _R(b, Y, lr), re = Yg(b, K, lr), _e = Ih();
            re !== null && ($r(re, lr, _e), Rp(re, _e));
            return;
          }
        }
        b = b.return;
      }
      l(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, v);
    }
    function hB(n, s, v) {
      var b = n.pingCache;
      b !== null && b.delete(s);
      var R = Ih();
      hd(n, v), bB(n), kh === n && At(af, v) && (sf === NE || sf === jT && Ae(af) && fa() - jR < AP ? fS(n, Ht) : XT = qt(XT, v)), Rp(n, R);
    }
    function WP(n, s) {
      s === vi && (s = XI(n));
      var v = Ih(), b = Kc(n, s);
      b !== null && ($r(b, s, v), Rp(b, v));
    }
    function pB(n) {
      var s = n.memoizedState, v = vi;
      s !== null && (v = s.retryLane), WP(n, v);
    }
    function mB(n, s) {
      var v = vi, b;
      switch (n.tag) {
        case X:
          b = n.stateNode;
          var R = n.memoizedState;
          R !== null && (v = R.retryLane);
          break;
        case pe:
          b = n.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      b !== null && b.delete(s), WP(n, v);
    }
    function vB(n) {
      return n < 120 ? 120 : n < 480 ? 480 : n < 1080 ? 1080 : n < 1920 ? 1920 : n < 3e3 ? 3e3 : n < 4320 ? 4320 : GI(n / 1960) * 1960;
    }
    function gB() {
      if (VE > jI)
        throw VE = 0, QR = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      db > YI && (db = 0, ZT = null, l("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function yB() {
      bd.flushLegacyContextWarning(), bd.flushPendingUnsafeLifecycleWarnings();
    }
    function jP(n, s) {
      Xi(n), t2(n, Vr, FI), s && t2(n, uc, kI), t2(n, Vr, zI), s && t2(n, uc, NI), Ka();
    }
    function t2(n, s, v) {
      for (var b = n, R = null; b !== null; ) {
        var F = b.subtreeFlags & s;
        b !== R && b.child !== null && F !== vr ? b = b.child : ((b.flags & s) !== vr && v(b), b.sibling !== null ? b = b.sibling : b = R = b.return);
      }
    }
    var n2 = null;
    function YP(n) {
      {
        if ((pa & Rd) !== rf || !(n.mode & Yr))
          return;
        var s = n.tag;
        if (s !== S && s !== _ && s !== m && s !== h && s !== V && s !== J && s !== $)
          return;
        var v = xr(n) || "ReactComponent";
        if (n2 !== null) {
          if (n2.has(v))
            return;
          n2.add(v);
        } else
          n2 = /* @__PURE__ */ new Set([v]);
        var b = ua;
        try {
          Xi(n), l("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          b ? Xi(n) : Ka();
        }
      }
    }
    var tA;
    {
      var xB = null;
      tA = function(n, s, v) {
        var b = eO(xB, s);
        try {
          return aP(n, s, v);
        } catch (F) {
          if (Yw() || F !== null && typeof F == "object" && typeof F.then == "function")
            throw F;
          if (O_(), yE(), fP(n, s), eO(s, b), s.mode & fr && Yv(s), Pu(null, aP, null, n, s, v), ve()) {
            var R = oc();
            typeof R == "object" && R !== null && R._suppressLogging && typeof F == "object" && F !== null && !F._suppressLogging && (F._suppressLogging = !0);
          }
          throw F;
        }
      };
    }
    var XP = !1, nA;
    nA = /* @__PURE__ */ new Set();
    function SB(n) {
      if (Cr && !It())
        switch (n.tag) {
          case h:
          case V:
          case $: {
            var s = nu && xr(nu) || "Unknown", v = s;
            if (!nA.has(v)) {
              nA.add(v);
              var b = xr(n) || "Unknown";
              l("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", b, s, s);
            }
            break;
          }
          case m: {
            XP || (l("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), XP = !0);
            break;
          }
        }
    }
    function jE(n, s) {
      if (ya) {
        var v = n.memoizedUpdaters;
        v.forEach(function(b) {
          km(n, b, s);
        });
      }
    }
    var rA = {};
    function iA(n, s) {
      {
        var v = Jv.current;
        return v !== null ? (v.push(s), rA) : Vo(n, s);
      }
    }
    function qP(n) {
      if (n !== rA)
        return jd(n);
    }
    function QP() {
      return Jv.current !== null;
    }
    function _B(n) {
      {
        if (n.mode & Yr) {
          if (!TP())
            return;
        } else if (!VI() || pa !== rf || n.tag !== h && n.tag !== V && n.tag !== $)
          return;
        if (Jv.current === null) {
          var s = ua;
          try {
            Xi(n), l(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, xr(n));
          } finally {
            s ? Xi(n) : Ka();
          }
        }
      }
    }
    function bB(n) {
      n.tag !== Ig && TP() && Jv.current === null && l(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function YE(n) {
      PP = n;
    }
    var hv = null, hb = null, wB = function(n) {
      hv = n;
    };
    function pb(n) {
      {
        if (hv === null)
          return n;
        var s = hv(n);
        return s === void 0 ? n : s.current;
      }
    }
    function aA(n) {
      return pb(n);
    }
    function sA(n) {
      {
        if (hv === null)
          return n;
        var s = hv(n);
        if (s === void 0) {
          if (n != null && typeof n.render == "function") {
            var v = pb(n.render);
            if (n.render !== v) {
              var b = {
                $$typeof: on,
                render: v
              };
              return n.displayName !== void 0 && (b.displayName = n.displayName), b;
            }
          }
          return n;
        }
        return s.current;
      }
    }
    function ZP(n, s) {
      {
        if (hv === null)
          return !1;
        var v = n.elementType, b = s.type, R = !1, F = typeof b == "object" && b !== null ? b.$$typeof : null;
        switch (n.tag) {
          case m: {
            typeof b == "function" && (R = !0);
            break;
          }
          case h: {
            (typeof b == "function" || F === vn) && (R = !0);
            break;
          }
          case V: {
            (F === on || F === vn) && (R = !0);
            break;
          }
          case J:
          case $: {
            (F === mn || F === vn) && (R = !0);
            break;
          }
          default:
            return !1;
        }
        if (R) {
          var Y = hv(v);
          if (Y !== void 0 && Y === hv(b))
            return !0;
        }
        return !1;
      }
    }
    function JP(n) {
      {
        if (hv === null || typeof WeakSet != "function")
          return;
        hb === null && (hb = /* @__PURE__ */ new WeakSet()), hb.add(n);
      }
    }
    var EB = function(n, s) {
      {
        if (hv === null)
          return;
        var v = s.staleFamilies, b = s.updatedFamilies;
        y0(), g0(function() {
          oA(n.current, b, v);
        });
      }
    }, MB = function(n, s) {
      {
        if (n.context !== $d)
          return;
        y0(), g0(function() {
          XE(s, n, null, null);
        });
      }
    };
    function oA(n, s, v) {
      {
        var b = n.alternate, R = n.child, F = n.sibling, Y = n.tag, K = n.type, re = null;
        switch (Y) {
          case h:
          case $:
          case m:
            re = K;
            break;
          case V:
            re = K.render;
            break;
        }
        if (hv === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var _e = !1, Re = !1;
        if (re !== null) {
          var nt = hv(re);
          nt !== void 0 && (v.has(nt) ? Re = !0 : s.has(nt) && (Y === m ? Re = !0 : _e = !0));
        }
        if (hb !== null && (hb.has(n) || b !== null && hb.has(b)) && (Re = !0), Re && (n._debugNeedsRemount = !0), Re || _e) {
          var $e = Kc(n, lr);
          $e !== null && of($e, n, lr, ii);
        }
        R !== null && !Re && oA(R, s, v), F !== null && oA(F, s, v);
      }
    }
    var TB = function(n, s) {
      {
        var v = /* @__PURE__ */ new Set(), b = new Set(s.map(function(R) {
          return R.current;
        }));
        return lA(n.current, b, v), v;
      }
    };
    function lA(n, s, v) {
      {
        var b = n.child, R = n.sibling, F = n.tag, Y = n.type, K = null;
        switch (F) {
          case h:
          case $:
          case m:
            K = Y;
            break;
          case V:
            K = Y.render;
            break;
        }
        var re = !1;
        K !== null && s.has(K) && (re = !0), re ? CB(n, v) : b !== null && lA(b, s, v), R !== null && lA(R, s, v);
      }
    }
    function CB(n, s) {
      {
        var v = RB(n, s);
        if (v)
          return;
        for (var b = n; ; ) {
          switch (b.tag) {
            case C:
              s.add(b.stateNode);
              return;
            case T:
              s.add(b.stateNode.containerInfo);
              return;
            case _:
              s.add(b.stateNode.containerInfo);
              return;
          }
          if (b.return === null)
            throw new Error("Expected to reach root first.");
          b = b.return;
        }
      }
    }
    function RB(n, s) {
      for (var v = n, b = !1; ; ) {
        if (v.tag === C)
          b = !0, s.add(v.stateNode);
        else if (v.child !== null) {
          v.child.return = v, v = v.child;
          continue;
        }
        if (v === n)
          return b;
        for (; v.sibling === null; ) {
          if (v.return === null || v.return === n)
            return b;
          v = v.return;
        }
        v.sibling.return = v.return, v = v.sibling;
      }
      return !1;
    }
    var uA;
    {
      uA = !1;
      try {
        var KP = Object.preventExtensions({});
      } catch {
        uA = !0;
      }
    }
    function AB(n, s, v, b) {
      this.tag = n, this.key = v, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = s, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = b, this.flags = vr, this.subtreeFlags = vr, this.deletions = null, this.lanes = Ht, this.childLanes = Ht, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !uA && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var mm = function(n, s, v, b) {
      return new AB(n, s, v, b);
    };
    function cA(n) {
      var s = n.prototype;
      return !!(s && s.isReactComponent);
    }
    function DB(n) {
      return typeof n == "function" && !cA(n) && n.defaultProps === void 0;
    }
    function LB(n) {
      if (typeof n == "function")
        return cA(n) ? m : h;
      if (n != null) {
        var s = n.$$typeof;
        if (s === on)
          return V;
        if (s === mn)
          return J;
      }
      return S;
    }
    function hS(n, s) {
      var v = n.alternate;
      v === null ? (v = mm(n.tag, s, n.key, n.mode), v.elementType = n.elementType, v.type = n.type, v.stateNode = n.stateNode, v._debugSource = n._debugSource, v._debugOwner = n._debugOwner, v._debugHookTypes = n._debugHookTypes, v.alternate = n, n.alternate = v) : (v.pendingProps = s, v.type = n.type, v.flags = vr, v.subtreeFlags = vr, v.deletions = null, v.actualDuration = 0, v.actualStartTime = -1), v.flags = n.flags & pn, v.childLanes = n.childLanes, v.lanes = n.lanes, v.child = n.child, v.memoizedProps = n.memoizedProps, v.memoizedState = n.memoizedState, v.updateQueue = n.updateQueue;
      var b = n.dependencies;
      switch (v.dependencies = b === null ? null : {
        lanes: b.lanes,
        firstContext: b.firstContext
      }, v.sibling = n.sibling, v.index = n.index, v.ref = n.ref, v.selfBaseDuration = n.selfBaseDuration, v.treeBaseDuration = n.treeBaseDuration, v._debugNeedsRemount = n._debugNeedsRemount, v.tag) {
        case S:
        case h:
        case $:
          v.type = pb(n.type);
          break;
        case m:
          v.type = aA(n.type);
          break;
        case V:
          v.type = sA(n.type);
          break;
      }
      return v;
    }
    function PB(n, s) {
      n.flags &= pn | oi;
      var v = n.alternate;
      if (v === null)
        n.childLanes = Ht, n.lanes = s, n.child = null, n.subtreeFlags = vr, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null, n.selfBaseDuration = 0, n.treeBaseDuration = 0;
      else {
        n.childLanes = v.childLanes, n.lanes = v.lanes, n.child = v.child, n.subtreeFlags = vr, n.deletions = null, n.memoizedProps = v.memoizedProps, n.memoizedState = v.memoizedState, n.updateQueue = v.updateQueue, n.type = v.type;
        var b = v.dependencies;
        n.dependencies = b === null ? null : {
          lanes: b.lanes,
          firstContext: b.firstContext
        }, n.selfBaseDuration = v.selfBaseDuration, n.treeBaseDuration = v.treeBaseDuration;
      }
      return n;
    }
    function OB(n, s, v) {
      var b;
      return n === N1 ? (b = Yr, s === !0 && (b |= fi, b |= Ns)) : b = hr, ya && (b |= fr), mm(_, null, null, b);
    }
    function fA(n, s, v, b, R, F) {
      var Y = S, K = n;
      if (typeof n == "function")
        cA(n) ? (Y = m, K = aA(K)) : K = pb(K);
      else if (typeof n == "string")
        Y = C;
      else {
        e:
          switch (n) {
            case Te:
              return Fx(v.children, R, F, s);
            case ct:
              Y = U, R |= fi, (R & Yr) !== hr && (R |= Ns);
              break;
            case me:
              return UB(v, R, F, s);
            case yn:
              return zB(v, R, F, s);
            case Rn:
              return NB(v, R, F, s);
            case br:
              return $P(v, R, F, s);
            case Yi:
            case Zn:
            case La:
            case Ys:
            case nr:
            default: {
              if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                  case Oe:
                    Y = k;
                    break e;
                  case qe:
                    Y = B;
                    break e;
                  case on:
                    Y = V, K = sA(K);
                    break e;
                  case mn:
                    Y = J;
                    break e;
                  case vn:
                    Y = W, K = null;
                    break e;
                }
              var re = "";
              {
                (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (re += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var _e = b ? xr(b) : null;
                _e && (re += `

Check the render method of \`` + _e + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (n == null ? n : typeof n) + "." + re));
            }
          }
      }
      var Re = mm(Y, v, s, R);
      return Re.elementType = n, Re.type = K, Re.lanes = F, Re._debugOwner = b, Re;
    }
    function dA(n, s, v) {
      var b = null;
      b = n._owner;
      var R = n.type, F = n.key, Y = n.props, K = fA(R, F, Y, b, s, v);
      return K._debugSource = n._source, K._debugOwner = n._owner, K;
    }
    function Fx(n, s, v, b) {
      var R = mm(P, n, b, s);
      return R.lanes = v, R;
    }
    function UB(n, s, v, b) {
      typeof n.id != "string" && l('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof n.id);
      var R = mm(I, n, b, s | fr);
      return R.elementType = me, R.lanes = v, R.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, R;
    }
    function zB(n, s, v, b) {
      var R = mm(X, n, b, s);
      return R.elementType = yn, R.lanes = v, R;
    }
    function NB(n, s, v, b) {
      var R = mm(pe, n, b, s);
      return R.elementType = Rn, R.lanes = v, R;
    }
    function $P(n, s, v, b) {
      var R = mm(Ee, n, b, s);
      R.elementType = br, R.lanes = v;
      var F = {
        isHidden: !1
      };
      return R.stateNode = F, R;
    }
    function hA(n, s, v) {
      var b = mm(D, n, null, s);
      return b.lanes = v, b;
    }
    function FB() {
      var n = mm(C, null, null, hr);
      return n.elementType = "DELETED", n;
    }
    function kB(n) {
      var s = mm(ie, null, null, hr);
      return s.stateNode = n, s;
    }
    function pA(n, s, v) {
      var b = n.children !== null ? n.children : [], R = mm(T, b, n.key, s);
      return R.lanes = v, R.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
      }, R;
    }
    function eO(n, s) {
      return n === null && (n = mm(S, null, null, hr)), n.tag = s.tag, n.key = s.key, n.elementType = s.elementType, n.type = s.type, n.stateNode = s.stateNode, n.return = s.return, n.child = s.child, n.sibling = s.sibling, n.index = s.index, n.ref = s.ref, n.pendingProps = s.pendingProps, n.memoizedProps = s.memoizedProps, n.updateQueue = s.updateQueue, n.memoizedState = s.memoizedState, n.dependencies = s.dependencies, n.mode = s.mode, n.flags = s.flags, n.subtreeFlags = s.subtreeFlags, n.deletions = s.deletions, n.lanes = s.lanes, n.childLanes = s.childLanes, n.alternate = s.alternate, n.actualDuration = s.actualDuration, n.actualStartTime = s.actualStartTime, n.selfBaseDuration = s.selfBaseDuration, n.treeBaseDuration = s.treeBaseDuration, n._debugSource = s._debugSource, n._debugOwner = s._debugOwner, n._debugNeedsRemount = s._debugNeedsRemount, n._debugHookTypes = s._debugHookTypes, n;
    }
    function IB(n, s, v, b, R) {
      this.tag = s, this.containerInfo = n, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = zg, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = vi, this.eventTimes = Va(Ht), this.expirationTimes = Va(ii), this.pendingLanes = Ht, this.suspendedLanes = Ht, this.pingedLanes = Ht, this.expiredLanes = Ht, this.mutableReadLanes = Ht, this.finishedLanes = Ht, this.entangledLanes = Ht, this.entanglements = Va(Ht), this.identifierPrefix = b, this.onRecoverableError = R, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var F = this.pendingUpdatersLaneMap = [], Y = 0; Y < Ai; Y++)
          F.push(/* @__PURE__ */ new Set());
      }
      switch (s) {
        case N1:
          this._debugRootType = v ? "hydrateRoot()" : "createRoot()";
          break;
        case Ig:
          this._debugRootType = v ? "hydrate()" : "render()";
          break;
      }
    }
    function tO(n, s, v, b, R, F, Y, K, re, _e) {
      var Re = new IB(n, s, v, K, re), nt = OB(s, F);
      Re.current = nt, nt.stateNode = Re;
      {
        var $e = {
          element: b,
          isDehydrated: v,
          cache: null,
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        nt.memoizedState = $e;
      }
      return F_(nt), Re;
    }
    var mA = "18.2.0";
    function BB(n, s, v) {
      var b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Vt(b), {
        $$typeof: Si,
        key: b == null ? null : "" + b,
        children: n,
        containerInfo: s,
        implementation: v
      };
    }
    var vA, gA;
    vA = !1, gA = {};
    function nO(n) {
      if (!n)
        return $d;
      var s = Zs(n), v = rR(s);
      if (s.tag === m) {
        var b = s.type;
        if (lm(b))
          return lT(s, b, v);
      }
      return v;
    }
    function HB(n, s) {
      {
        var v = Zs(n);
        if (v === void 0) {
          if (typeof n.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var b = Object.keys(n).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + b);
        }
        var R = fu(v);
        if (R === null)
          return null;
        if (R.mode & fi) {
          var F = xr(v) || "Component";
          if (!gA[F]) {
            gA[F] = !0;
            var Y = ua;
            try {
              Xi(R), v.mode & fi ? l("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, F) : l("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", s, s, F);
            } finally {
              Y ? Xi(Y) : Ka();
            }
          }
        }
        return R.stateNode;
      }
    }
    function rO(n, s, v, b, R, F, Y, K) {
      var re = !1, _e = null;
      return tO(n, s, re, _e, v, b, R, F, Y);
    }
    function iO(n, s, v, b, R, F, Y, K, re, _e) {
      var Re = !0, nt = tO(v, b, Re, n, R, F, Y, K, re);
      nt.context = nO(null);
      var $e = nt.current, Dt = Ih(), Lt = zx($e), Yt = rv(Dt, Lt);
      return Yt.callback = s != null ? s : null, Yg($e, Yt, Lt), qI(nt, Lt, Dt), nt;
    }
    function XE(n, s, v, b) {
      Go(s, n);
      var R = s.current, F = Ih(), Y = zx(R);
      Wl(Y);
      var K = nO(v);
      s.context === null ? s.context = K : s.pendingContext = K, Cr && ua !== null && !vA && (vA = !0, l(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, xr(ua) || "Unknown"));
      var re = rv(F, Y);
      re.payload = {
        element: n
      }, b = b === void 0 ? null : b, b !== null && (typeof b != "function" && l("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", b), re.callback = b);
      var _e = Yg(R, re, Y);
      return _e !== null && (of(_e, R, Y, F), I_(_e, R, Y)), Y;
    }
    function r2(n) {
      var s = n.current;
      if (!s.child)
        return null;
      switch (s.child.tag) {
        case C:
          return s.child.stateNode;
        default:
          return s.child.stateNode;
      }
    }
    function VB(n) {
      switch (n.tag) {
        case _: {
          var s = n.stateNode;
          if (Vi(s)) {
            var v = L(s);
            KI(s, v);
          }
          break;
        }
        case X: {
          g0(function() {
            var R = Kc(n, lr);
            if (R !== null) {
              var F = Ih();
              of(R, n, lr, F);
            }
          });
          var b = lr;
          yA(n, b);
          break;
        }
      }
    }
    function aO(n, s) {
      var v = n.memoizedState;
      v !== null && v.dehydrated !== null && (v.retryLane = Ar(v.retryLane, s));
    }
    function yA(n, s) {
      aO(n, s);
      var v = n.alternate;
      v && aO(v, s);
    }
    function GB(n) {
      if (n.tag === X) {
        var s = mu, v = Kc(n, s);
        if (v !== null) {
          var b = Ih();
          of(v, n, s, b);
        }
        yA(n, s);
      }
    }
    function WB(n) {
      if (n.tag === X) {
        var s = zx(n), v = Kc(n, s);
        if (v !== null) {
          var b = Ih();
          of(v, n, s, b);
        }
        yA(n, s);
      }
    }
    function sO(n) {
      var s = sd(n);
      return s === null ? null : s.stateNode;
    }
    var oO = function(n) {
      return null;
    };
    function jB(n) {
      return oO(n);
    }
    var lO = function(n) {
      return !1;
    };
    function YB(n) {
      return lO(n);
    }
    var uO = null, cO = null, fO = null, dO = null, hO = null, pO = null, mO = null, vO = null, gO = null;
    {
      var yO = function(n, s, v) {
        var b = s[v], R = qs(n) ? n.slice() : Xn({}, n);
        return v + 1 === s.length ? (qs(R) ? R.splice(b, 1) : delete R[b], R) : (R[b] = yO(n[b], s, v + 1), R);
      }, xO = function(n, s) {
        return yO(n, s, 0);
      }, SO = function(n, s, v, b) {
        var R = s[b], F = qs(n) ? n.slice() : Xn({}, n);
        if (b + 1 === s.length) {
          var Y = v[b];
          F[Y] = F[R], qs(F) ? F.splice(R, 1) : delete F[R];
        } else
          F[R] = SO(
            n[R],
            s,
            v,
            b + 1
          );
        return F;
      }, _O = function(n, s, v) {
        if (s.length !== v.length) {
          o("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var b = 0; b < v.length - 1; b++)
            if (s[b] !== v[b]) {
              o("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return SO(n, s, v, 0);
      }, bO = function(n, s, v, b) {
        if (v >= s.length)
          return b;
        var R = s[v], F = qs(n) ? n.slice() : Xn({}, n);
        return F[R] = bO(n[R], s, v + 1, b), F;
      }, wO = function(n, s, v) {
        return bO(n, s, 0, v);
      }, xA = function(n, s) {
        for (var v = n.memoizedState; v !== null && s > 0; )
          v = v.next, s--;
        return v;
      };
      uO = function(n, s, v, b) {
        var R = xA(n, s);
        if (R !== null) {
          var F = wO(R.memoizedState, v, b);
          R.memoizedState = F, R.baseState = F, n.memoizedProps = Xn({}, n.memoizedProps);
          var Y = Kc(n, lr);
          Y !== null && of(Y, n, lr, ii);
        }
      }, cO = function(n, s, v) {
        var b = xA(n, s);
        if (b !== null) {
          var R = xO(b.memoizedState, v);
          b.memoizedState = R, b.baseState = R, n.memoizedProps = Xn({}, n.memoizedProps);
          var F = Kc(n, lr);
          F !== null && of(F, n, lr, ii);
        }
      }, fO = function(n, s, v, b) {
        var R = xA(n, s);
        if (R !== null) {
          var F = _O(R.memoizedState, v, b);
          R.memoizedState = F, R.baseState = F, n.memoizedProps = Xn({}, n.memoizedProps);
          var Y = Kc(n, lr);
          Y !== null && of(Y, n, lr, ii);
        }
      }, dO = function(n, s, v) {
        n.pendingProps = wO(n.memoizedProps, s, v), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var b = Kc(n, lr);
        b !== null && of(b, n, lr, ii);
      }, hO = function(n, s) {
        n.pendingProps = xO(n.memoizedProps, s), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var v = Kc(n, lr);
        v !== null && of(v, n, lr, ii);
      }, pO = function(n, s, v) {
        n.pendingProps = _O(n.memoizedProps, s, v), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var b = Kc(n, lr);
        b !== null && of(b, n, lr, ii);
      }, mO = function(n) {
        var s = Kc(n, lr);
        s !== null && of(s, n, lr, ii);
      }, vO = function(n) {
        oO = n;
      }, gO = function(n) {
        lO = n;
      };
    }
    function XB(n) {
      var s = fu(n);
      return s === null ? null : s.stateNode;
    }
    function qB(n) {
      return null;
    }
    function QB() {
      return ua;
    }
    function ZB(n) {
      var s = n.findFiberByHostInstance, v = t.ReactCurrentDispatcher;
      return ep({
        bundleType: n.bundleType,
        version: n.version,
        rendererPackageName: n.rendererPackageName,
        rendererConfig: n.rendererConfig,
        overrideHookState: uO,
        overrideHookStateDeletePath: cO,
        overrideHookStateRenamePath: fO,
        overrideProps: dO,
        overridePropsDeletePath: hO,
        overridePropsRenamePath: pO,
        setErrorHandler: vO,
        setSuspenseHandler: gO,
        scheduleUpdate: mO,
        currentDispatcherRef: v,
        findHostInstanceByFiber: XB,
        findFiberByHostInstance: s || qB,
        findHostInstancesForRefresh: TB,
        scheduleRefresh: EB,
        scheduleRoot: MB,
        setRefreshHandler: wB,
        getCurrentFiber: QB,
        reconcilerVersion: mA
      });
    }
    var EO = typeof reportError == "function" ? reportError : function(n) {
      console.error(n);
    };
    function SA(n) {
      this._internalRoot = n;
    }
    i2.prototype.render = SA.prototype.render = function(n) {
      var s = this._internalRoot;
      if (s === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? l("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : a2(arguments[1]) ? l("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && l("You passed a second argument to root.render(...) but it only accepts one argument.");
        var v = s.containerInfo;
        if (v.nodeType !== Oi) {
          var b = sO(s.current);
          b && b.parentNode !== v && l("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      XE(n, s, null, null);
    }, i2.prototype.unmount = SA.prototype.unmount = function() {
      typeof arguments[0] == "function" && l("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var n = this._internalRoot;
      if (n !== null) {
        this._internalRoot = null;
        var s = n.containerInfo;
        NP() && l("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), g0(function() {
          XE(null, n, null, null);
        }), tn(s);
      }
    };
    function JB(n, s) {
      if (!a2(n))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      MO(n);
      var v = !1, b = !1, R = "", F = EO;
      s != null && (s.hydrate ? o("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof s == "object" && s !== null && s.$$typeof === ji && l(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), s.unstable_strictMode === !0 && (v = !0), s.identifierPrefix !== void 0 && (R = s.identifierPrefix), s.onRecoverableError !== void 0 && (F = s.onRecoverableError), s.transitionCallbacks !== void 0 && s.transitionCallbacks);
      var Y = rO(n, N1, null, v, b, R, F);
      ut(Y.current, n);
      var K = n.nodeType === Oi ? n.parentNode : n;
      return jc(K), new SA(Y);
    }
    function i2(n) {
      this._internalRoot = n;
    }
    function KB(n) {
      n && bv(n);
    }
    i2.prototype.unstable_scheduleHydration = KB;
    function $B(n, s, v) {
      if (!a2(n))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      MO(n), s === void 0 && l("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var b = v != null ? v : null, R = v != null && v.hydratedSources || null, F = !1, Y = !1, K = "", re = EO;
      v != null && (v.unstable_strictMode === !0 && (F = !0), v.identifierPrefix !== void 0 && (K = v.identifierPrefix), v.onRecoverableError !== void 0 && (re = v.onRecoverableError));
      var _e = iO(s, null, n, N1, b, F, Y, K, re);
      if (ut(_e.current, n), jc(n), R)
        for (var Re = 0; Re < R.length; Re++) {
          var nt = R[Re];
          NT(_e, nt);
        }
      return new i2(_e);
    }
    function a2(n) {
      return !!(n && (n.nodeType === Ol || n.nodeType === Za || n.nodeType === Ma || !we));
    }
    function qE(n) {
      return !!(n && (n.nodeType === Ol || n.nodeType === Za || n.nodeType === Ma || n.nodeType === Oi && n.nodeValue === " react-mount-point-unstable "));
    }
    function MO(n) {
      n.nodeType === Ol && n.tagName && n.tagName.toUpperCase() === "BODY" && l("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Kt(n) && (n._reactRootContainer ? l("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : l("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var e5 = t.ReactCurrentOwner, TO;
    TO = function(n) {
      if (n._reactRootContainer && n.nodeType !== Oi) {
        var s = sO(n._reactRootContainer.current);
        s && s.parentNode !== n && l("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var v = !!n._reactRootContainer, b = _A(n), R = !!(b && Cn(b));
      R && !v && l("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), n.nodeType === Ol && n.tagName && n.tagName.toUpperCase() === "BODY" && l("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function _A(n) {
      return n ? n.nodeType === Za ? n.documentElement : n.firstChild : null;
    }
    function CO() {
    }
    function t5(n, s, v, b, R) {
      if (R) {
        if (typeof b == "function") {
          var F = b;
          b = function() {
            var $e = r2(Y);
            F.call($e);
          };
        }
        var Y = iO(
          s,
          b,
          n,
          Ig,
          null,
          !1,
          !1,
          "",
          CO
        );
        n._reactRootContainer = Y, ut(Y.current, n);
        var K = n.nodeType === Oi ? n.parentNode : n;
        return jc(K), g0(), Y;
      } else {
        for (var re; re = n.lastChild; )
          n.removeChild(re);
        if (typeof b == "function") {
          var _e = b;
          b = function() {
            var $e = r2(Re);
            _e.call($e);
          };
        }
        var Re = rO(
          n,
          Ig,
          null,
          !1,
          !1,
          "",
          CO
        );
        n._reactRootContainer = Re, ut(Re.current, n);
        var nt = n.nodeType === Oi ? n.parentNode : n;
        return jc(nt), g0(function() {
          XE(s, Re, v, b);
        }), Re;
      }
    }
    function n5(n, s) {
      n !== null && typeof n != "function" && l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", s, n);
    }
    function s2(n, s, v, b, R) {
      TO(v), n5(R === void 0 ? null : R, "render");
      var F = v._reactRootContainer, Y;
      if (!F)
        Y = t5(v, s, n, R, b);
      else {
        if (Y = F, typeof R == "function") {
          var K = R;
          R = function() {
            var re = r2(Y);
            K.call(re);
          };
        }
        XE(s, Y, n, R);
      }
      return r2(Y);
    }
    function r5(n) {
      {
        var s = e5.current;
        if (s !== null && s.stateNode !== null) {
          var v = s.stateNode._warnedAboutRefsInRender;
          v || l("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ci(s.type) || "A component"), s.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return n == null ? null : n.nodeType === Ol ? n : HB(n, "findDOMNode");
    }
    function i5(n, s, v) {
      if (l("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !qE(s))
        throw new Error("Target container is not a DOM element.");
      {
        var b = Kt(s) && s._reactRootContainer === void 0;
        b && l("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return s2(null, n, s, !0, v);
    }
    function a5(n, s, v) {
      if (l("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !qE(s))
        throw new Error("Target container is not a DOM element.");
      {
        var b = Kt(s) && s._reactRootContainer === void 0;
        b && l("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return s2(null, n, s, !1, v);
    }
    function s5(n, s, v, b) {
      if (l("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !qE(v))
        throw new Error("Target container is not a DOM element.");
      if (n == null || !ka(n))
        throw new Error("parentComponent must be a valid React Component");
      return s2(n, s, v, !1, b);
    }
    function o5(n) {
      if (!qE(n))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var s = Kt(n) && n._reactRootContainer === void 0;
        s && l("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (n._reactRootContainer) {
        {
          var v = _A(n), b = v && !Cn(v);
          b && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return g0(function() {
          s2(null, null, n, !1, function() {
            n._reactRootContainer = null, tn(n);
          });
        }), !0;
      } else {
        {
          var R = _A(n), F = !!(R && Cn(R)), Y = n.nodeType === Ol && qE(n.parentNode) && !!n.parentNode._reactRootContainer;
          F && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", Y ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Jn(VB), z0(GB), ip(WB), Sy(pc), Yp(rp), (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && l("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), ac(y1), Vd(KR, $I, g0);
    function l5(n, s) {
      var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!a2(s))
        throw new Error("Target container is not a DOM element.");
      return BB(n, s, null, v);
    }
    function u5(n, s, v, b) {
      return s5(n, s, v, b);
    }
    var bA = {
      usingClientEntryPoint: !1,
      Events: [Cn, Ln, dr, Du, yf, KR]
    };
    function c5(n, s) {
      return bA.usingClientEntryPoint || l('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), JB(n, s);
    }
    function f5(n, s, v) {
      return bA.usingClientEntryPoint || l('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), $B(n, s, v);
    }
    function d5(n) {
      return NP() && l("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), g0(n);
    }
    var h5 = ZB({
      findFiberByHostInstance: sn,
      bundleType: 1,
      version: mA,
      rendererPackageName: "react-dom"
    });
    if (!h5 && et && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var RO = window.location.protocol;
      /^(https?|file):$/.test(RO) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (RO === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Dp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bA, Dp.createPortal = l5, Dp.createRoot = c5, Dp.findDOMNode = r5, Dp.flushSync = d5, Dp.hydrate = i5, Dp.hydrateRoot = f5, Dp.render = a5, Dp.unmountComponentAtNode = o5, Dp.unstable_batchedUpdates = KR, Dp.unstable_renderSubtreeIntoContainer = u5, Dp.version = mA, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Dp;
}
(function(a) {
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
    }
  }
  process.env.NODE_ENV === "production" ? (e(), a.exports = vj()) : a.exports = gj();
})(B4);
var R3, eC = B4.exports;
if (process.env.NODE_ENV === "production")
  R3 = eC.createRoot, eC.hydrateRoot;
else {
  var Cz = eC.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  R3 = function(a, e) {
    Cz.usingClientEntryPoint = !0;
    try {
      return eC.createRoot(a, e);
    } finally {
      Cz.usingClientEntryPoint = !1;
    }
  };
}
const aT = new ge(), EL = new ge(), yj = new ge();
function xj(a, e, t) {
  const r = aT.setFromMatrixPosition(a.matrixWorld);
  r.project(e);
  const i = t.width / 2, o = t.height / 2;
  return [r.x * i + i, -(r.y * o) + o];
}
function Sj(a, e) {
  const t = aT.setFromMatrixPosition(a.matrixWorld), r = EL.setFromMatrixPosition(e.matrixWorld), i = t.sub(r), o = e.getWorldDirection(yj);
  return i.angleTo(o) > Math.PI / 2;
}
function _j(a, e, t, r) {
  const i = aT.setFromMatrixPosition(a.matrixWorld), o = i.clone();
  o.project(e), t.setFromCamera(o, e);
  const l = t.intersectObjects(r, !0);
  if (l.length) {
    const d = l[0].distance;
    return i.distanceTo(t.ray.origin) < d;
  }
  return !0;
}
function bj(a, e) {
  if (e instanceof cy)
    return e.zoom;
  if (e instanceof fo) {
    const t = aT.setFromMatrixPosition(a.matrixWorld), r = EL.setFromMatrixPosition(e.matrixWorld), i = e.fov * Math.PI / 180, o = t.distanceTo(r), l = 2 * Math.tan(i / 2) * o;
    return 1 / l;
  } else
    return 1;
}
function wj(a, e, t) {
  if (e instanceof fo || e instanceof cy) {
    const r = aT.setFromMatrixPosition(a.matrixWorld), i = EL.setFromMatrixPosition(e.matrixWorld), o = r.distanceTo(i), l = (t[1] - t[0]) / (e.far - e.near), d = t[1] - l * e.far;
    return Math.round(l * o + d);
  }
}
const A3 = (a) => Math.abs(a) < 1e-10 ? 0 : a;
function V4(a, e, t = "") {
  let r = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    r += A3(e[i] * a.elements[i]) + (i !== 15 ? "," : ")");
  return t + r;
}
const Ej = ((a) => (e) => V4(e, a))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), Mj = ((a) => (e, t) => V4(e, a(t), "translate(-50%,-50%)"))((a) => [1 / a, 1 / a, 1 / a, 1, -1 / a, -1 / a, -1 / a, -1, 1 / a, 1 / a, 1 / a, 1, 1, 1, 1, 1]), G4 = /* @__PURE__ */ Or.forwardRef(({
  children: a,
  eps: e = 1e-3,
  style: t,
  className: r,
  prepend: i,
  center: o,
  fullscreen: l,
  portal: d,
  distanceFactor: h,
  sprite: m = !1,
  transform: S = !1,
  occlude: _,
  onOcclude: T,
  zIndexRange: C = [16777271, 0],
  calculatePosition: D = xj,
  as: P = "div",
  wrapperClass: U,
  pointerEvents: B = "auto",
  ...k
}, V) => {
  const {
    gl: I,
    camera: X,
    scene: J,
    size: $,
    raycaster: W,
    events: ee
  } = Od(), [ie] = Or.useState(() => document.createElement(P)), pe = Or.useRef(), ce = Or.useRef(null), Ee = Or.useRef(0), de = Or.useRef([0, 0]), Fe = Or.useRef(null), Ce = Or.useRef(null), Be = (d == null ? void 0 : d.current) || ee.connected || I.domElement.parentNode;
  Or.useLayoutEffect(() => {
    if (ce.current) {
      const ye = pe.current = R3(ie);
      if (J.updateMatrixWorld(), S)
        ie.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
      else {
        const we = D(ce.current, X, $);
        ie.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${we[0]}px,${we[1]}px,0);transform-origin:0 0;`;
      }
      return Be && (i ? Be.prepend(ie) : Be.appendChild(ie)), () => {
        Be && Be.removeChild(ie), ye.unmount();
      };
    }
  }, [Be, S]), Or.useLayoutEffect(() => {
    U && (ie.className = U);
  }, [U]);
  const he = Or.useMemo(() => S ? {
    position: "absolute",
    top: 0,
    left: 0,
    width: $.width,
    height: $.height,
    transformStyle: "preserve-3d",
    pointerEvents: "none"
  } : {
    position: "absolute",
    transform: o ? "translate3d(-50%,-50%,0)" : "none",
    ...l && {
      top: -$.height / 2,
      left: -$.width / 2,
      width: $.width,
      height: $.height
    },
    ...t
  }, [t, o, l, $, S]), fe = Or.useMemo(() => ({
    position: "absolute",
    pointerEvents: B
  }), [B]);
  Or.useLayoutEffect(() => {
    if (S) {
      var ye;
      (ye = pe.current) == null || ye.render(
        /* @__PURE__ */ _n("div", {
          ref: Fe,
          style: he,
          children: /* @__PURE__ */ _n("div", {
            ref: Ce,
            style: fe,
            children: /* @__PURE__ */ _n("div", {
              ref: V,
              className: r,
              style: t,
              children: a
            })
          })
        })
      );
    } else {
      var we;
      (we = pe.current) == null || we.render(
        /* @__PURE__ */ _n("div", {
          ref: V,
          style: he,
          className: r,
          children: a
        })
      );
    }
  });
  const ue = Or.useRef(!0);
  return yy(() => {
    if (ce.current) {
      X.updateMatrixWorld(), ce.current.updateWorldMatrix(!0, !1);
      const ye = S ? de.current : D(ce.current, X, $);
      if (S || Math.abs(Ee.current - X.zoom) > e || Math.abs(de.current[0] - ye[0]) > e || Math.abs(de.current[1] - ye[1]) > e) {
        const we = Sj(ce.current, X);
        let Xe = !1;
        typeof _ == "boolean" ? _ === !0 && (Xe = [J]) : Array.isArray(_) && (Xe = _.map((st) => st.current));
        const Je = ue.current;
        if (Xe) {
          const st = _j(ce.current, X, W, Xe);
          ue.current = st && !we;
        } else
          ue.current = !we;
        if (Je !== ue.current && (T ? T(!ue.current) : ie.style.display = ue.current ? "block" : "none"), ie.style.zIndex = `${wj(ce.current, X, C)}`, S) {
          const [st, Ue] = [$.width / 2, $.height / 2], ot = X.projectionMatrix.elements[5] * Ue, {
            isOrthographicCamera: rt,
            top: _t,
            left: Rt,
            bottom: Ot,
            right: He
          } = X, et = Ej(X.matrixWorldInverse), mt = rt ? `scale(${ot})translate(${A3(-(He + Rt) / 2)}px,${A3((_t + Ot) / 2)}px)` : `translateZ(${ot}px)`;
          let vt = ce.current.matrixWorld;
          m && (vt = X.matrixWorldInverse.clone().transpose().copyPosition(vt).scale(ce.current.scale), vt.elements[3] = vt.elements[7] = vt.elements[11] = 0, vt.elements[15] = 1), ie.style.width = $.width + "px", ie.style.height = $.height + "px", ie.style.perspective = rt ? "" : `${ot}px`, Fe.current && Ce.current && (Fe.current.style.transform = `${mt}${et}translate(${st}px,${Ue}px)`, Ce.current.style.transform = Mj(vt, 1 / ((h || 10) / 400)));
        } else {
          const st = h === void 0 ? 1 : bj(ce.current, X) * h;
          ie.style.transform = `translate3d(${ye[0]}px,${ye[1]}px,0) scale(${st})`;
        }
        de.current = ye, Ee.current = X.zoom;
      }
    }
  }), /* @__PURE__ */ _n("group", {
    ...k,
    ref: ce
  });
});
function Tj(a) {
  return function(e) {
    a.forEach(function(t) {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
var Rz = function() {
  var a = 0, e = 1, t = new ge();
  function r() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new d(), this.unassigned = new d(), this.vertices = [];
  }
  Object.assign(r.prototype, {
    setFromPoints: function(h) {
      Array.isArray(h) !== !0 && console.error("THREE.ConvexHull: Points parameter is not an array."), h.length < 4 && console.error("THREE.ConvexHull: The algorithm needs at least four points."), this.makeEmpty();
      for (let m = 0, S = h.length; m < S; m++)
        this.vertices.push(new l(h[m]));
      return this.compute(), this;
    },
    setFromObject: function(h) {
      var m = [];
      return h.updateMatrixWorld(!0), h.traverse(function(S) {
        var _, T, C, D = S.geometry;
        if (D !== void 0) {
          if (D.isGeometry) {
            console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
            return;
          } else if (D.isBufferGeometry) {
            var P = D.attributes.position;
            if (P !== void 0)
              for (_ = 0, T = P.count; _ < T; _++)
                C = new ge(), C.fromBufferAttribute(P, _).applyMatrix4(S.matrixWorld), m.push(C);
          }
        }
      }), this.setFromPoints(m);
    },
    containsPoint: function(h) {
      var m = this.faces;
      for (let _ = 0, T = m.length; _ < T; _++) {
        var S = m[_];
        if (S.distanceToPoint(h) > this.tolerance)
          return !1;
      }
      return !0;
    },
    intersectRay: function(h, m) {
      var S = this.faces, _ = -1 / 0, T = 1 / 0;
      for (let B = 0, k = S.length; B < k; B++) {
        var C = S[B], D = C.distanceToPoint(h.origin), P = C.normal.dot(h.direction);
        if (D > 0 && P >= 0)
          return null;
        var U = P !== 0 ? -D / P : 0;
        if (!(U <= 0) && (P > 0 ? T = Math.min(U, T) : _ = Math.max(U, _), _ > T))
          return null;
      }
      return _ !== -1 / 0 ? h.at(_, m) : h.at(T, m), m;
    },
    intersectsRay: function(h) {
      return this.intersectRay(h, t) !== null;
    },
    makeEmpty: function() {
      return this.faces = [], this.vertices = [], this;
    },
    addVertexToFace: function(h, m) {
      return h.face = m, m.outside === null ? this.assigned.append(h) : this.assigned.insertBefore(m.outside, h), m.outside = h, this;
    },
    removeVertexFromFace: function(h, m) {
      return h === m.outside && (h.next !== null && h.next.face === m ? m.outside = h.next : m.outside = null), this.assigned.remove(h), this;
    },
    removeAllVerticesFromFace: function(h) {
      if (h.outside !== null) {
        for (var m = h.outside, S = h.outside; S.next !== null && S.next.face === h; )
          S = S.next;
        return this.assigned.removeSubList(m, S), m.prev = S.next = null, h.outside = null, m;
      }
    },
    deleteFaceVertices: function(h, m) {
      var S = this.removeAllVerticesFromFace(h);
      if (S !== void 0)
        if (m === void 0)
          this.unassigned.appendChain(S);
        else {
          var _ = S;
          do {
            var T = _.next, C = m.distanceToPoint(_.point);
            C > this.tolerance ? this.addVertexToFace(_, m) : this.unassigned.append(_), _ = T;
          } while (_ !== null);
        }
      return this;
    },
    resolveUnassignedPoints: function(h) {
      if (this.unassigned.isEmpty() === !1) {
        var m = this.unassigned.first();
        do {
          var S = m.next, _ = this.tolerance, T = null;
          for (let P = 0; P < h.length; P++) {
            var C = h[P];
            if (C.mark === a) {
              var D = C.distanceToPoint(m.point);
              if (D > _ && (_ = D, T = C), _ > 1e3 * this.tolerance)
                break;
            }
          }
          T !== null && this.addVertexToFace(m, T), m = S;
        } while (m !== null);
      }
      return this;
    },
    computeExtremes: function() {
      var h = new ge(), m = new ge(), S = [], _ = [], T, C, D;
      for (T = 0; T < 3; T++)
        S[T] = _[T] = this.vertices[0];
      for (h.copy(this.vertices[0].point), m.copy(this.vertices[0].point), T = 0, C = this.vertices.length; T < C; T++) {
        var P = this.vertices[T], U = P.point;
        for (D = 0; D < 3; D++)
          U.getComponent(D) < h.getComponent(D) && (h.setComponent(D, U.getComponent(D)), S[D] = P);
        for (D = 0; D < 3; D++)
          U.getComponent(D) > m.getComponent(D) && (m.setComponent(D, U.getComponent(D)), _[D] = P);
      }
      return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(h.x), Math.abs(m.x)) + Math.max(Math.abs(h.y), Math.abs(m.y)) + Math.max(Math.abs(h.z), Math.abs(m.z))), {
        min: S,
        max: _
      };
    },
    computeInitialHull: function() {
      var h, m, S;
      return function() {
        h === void 0 && (h = new bL(), m = new C0(), S = new ge());
        var T, C = this.vertices, D = this.computeExtremes(), P = D.min, U = D.max, B, k, V, I, X, J, $, W, ee = 0, ie = 0;
        for (X = 0; X < 3; X++)
          W = U[X].point.getComponent(X) - P[X].point.getComponent(X), W > ee && (ee = W, ie = X);
        for (B = P[ie], k = U[ie], ee = 0, h.set(B.point, k.point), X = 0, J = this.vertices.length; X < J; X++)
          T = C[X], T !== B && T !== k && (h.closestPointToPoint(T.point, !0, S), W = S.distanceToSquared(T.point), W > ee && (ee = W, V = T));
        for (ee = -1, m.setFromCoplanarPoints(B.point, k.point, V.point), X = 0, J = this.vertices.length; X < J; X++)
          T = C[X], T !== B && T !== k && T !== V && (W = Math.abs(m.distanceToPoint(T.point)), W > ee && (ee = W, I = T));
        var pe = [];
        if (m.distanceToPoint(I.point) < 0)
          for (pe.push(i.create(B, k, V), i.create(I, k, B), i.create(I, V, k), i.create(I, B, V)), X = 0; X < 3; X++)
            $ = (X + 1) % 3, pe[X + 1].getEdge(2).setTwin(pe[0].getEdge($)), pe[X + 1].getEdge(1).setTwin(pe[$ + 1].getEdge(0));
        else
          for (pe.push(i.create(B, V, k), i.create(I, B, k), i.create(I, k, V), i.create(I, V, B)), X = 0; X < 3; X++)
            $ = (X + 1) % 3, pe[X + 1].getEdge(2).setTwin(pe[0].getEdge((3 - X) % 3)), pe[X + 1].getEdge(0).setTwin(pe[$ + 1].getEdge(1));
        for (X = 0; X < 4; X++)
          this.faces.push(pe[X]);
        for (X = 0, J = C.length; X < J; X++)
          if (T = C[X], T !== B && T !== k && T !== V && T !== I) {
            ee = this.tolerance;
            var ce = null;
            for ($ = 0; $ < 4; $++)
              W = this.faces[$].distanceToPoint(T.point), W > ee && (ee = W, ce = this.faces[$]);
            ce !== null && this.addVertexToFace(T, ce);
          }
        return this;
      };
    }(),
    reindexFaces: function() {
      var h = [];
      for (let S = 0; S < this.faces.length; S++) {
        var m = this.faces[S];
        m.mark === a && h.push(m);
      }
      return this.faces = h, this;
    },
    nextVertexToAdd: function() {
      if (this.assigned.isEmpty() === !1) {
        var h, m = 0, S = this.assigned.first().face, _ = S.outside;
        do {
          var T = S.distanceToPoint(_.point);
          T > m && (m = T, h = _), _ = _.next;
        } while (_ !== null && _.face === S);
        return h;
      }
    },
    computeHorizon: function(h, m, S, _) {
      this.deleteFaceVertices(S), S.mark = e;
      var T;
      m === null ? T = m = S.getEdge(0) : T = m.next;
      do {
        var C = T.twin, D = C.face;
        D.mark === a && (D.distanceToPoint(h) > this.tolerance ? this.computeHorizon(h, C, D, _) : _.push(T)), T = T.next;
      } while (T !== m);
      return this;
    },
    addAdjoiningFace: function(h, m) {
      var S = i.create(h, m.tail(), m.head());
      return this.faces.push(S), S.getEdge(-1).setTwin(m.twin), S.getEdge(0);
    },
    addNewFaces: function(h, m) {
      this.newFaces = [];
      var S = null, _ = null;
      for (let D = 0; D < m.length; D++) {
        var T = m[D], C = this.addAdjoiningFace(h, T);
        S === null ? S = C : C.next.setTwin(_), this.newFaces.push(C.face), _ = C;
      }
      return S.next.setTwin(_), this;
    },
    addVertexToHull: function(h) {
      var m = [];
      return this.unassigned.clear(), this.removeVertexFromFace(h, h.face), this.computeHorizon(h.point, null, h.face, m), this.addNewFaces(h, m), this.resolveUnassignedPoints(this.newFaces), this;
    },
    cleanup: function() {
      return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
    },
    compute: function() {
      var h;
      for (this.computeInitialHull(); (h = this.nextVertexToAdd()) !== void 0; )
        this.addVertexToHull(h);
      return this.reindexFaces(), this.cleanup(), this;
    }
  });
  function i() {
    this.normal = new ge(), this.midpoint = new ge(), this.area = 0, this.constant = 0, this.outside = null, this.mark = a, this.edge = null;
  }
  Object.assign(i, {
    create: function(h, m, S) {
      var _ = new i(), T = new o(h, _), C = new o(m, _), D = new o(S, _);
      return T.next = D.prev = C, C.next = T.prev = D, D.next = C.prev = T, _.edge = T, _.compute();
    }
  }), Object.assign(i.prototype, {
    getEdge: function(h) {
      for (var m = this.edge; h > 0; )
        m = m.next, h--;
      for (; h < 0; )
        m = m.prev, h++;
      return m;
    },
    compute: function() {
      var h;
      return function() {
        h === void 0 && (h = new xm());
        var S = this.edge.tail(), _ = this.edge.head(), T = this.edge.next.head();
        return h.set(S.point, _.point, T.point), h.getNormal(this.normal), h.getMidpoint(this.midpoint), this.area = h.getArea(), this.constant = this.normal.dot(this.midpoint), this;
      };
    }(),
    distanceToPoint: function(h) {
      return this.normal.dot(h) - this.constant;
    }
  });
  function o(h, m) {
    this.vertex = h, this.prev = null, this.next = null, this.twin = null, this.face = m;
  }
  Object.assign(o.prototype, {
    head: function() {
      return this.vertex;
    },
    tail: function() {
      return this.prev ? this.prev.vertex : null;
    },
    length: function() {
      var h = this.head(), m = this.tail();
      return m !== null ? m.point.distanceTo(h.point) : -1;
    },
    lengthSquared: function() {
      var h = this.head(), m = this.tail();
      return m !== null ? m.point.distanceToSquared(h.point) : -1;
    },
    setTwin: function(h) {
      return this.twin = h, h.twin = this, this;
    }
  });
  function l(h) {
    this.point = h, this.prev = null, this.next = null, this.face = null;
  }
  function d() {
    this.head = null, this.tail = null;
  }
  return Object.assign(d.prototype, {
    first: function() {
      return this.head;
    },
    last: function() {
      return this.tail;
    },
    clear: function() {
      return this.head = this.tail = null, this;
    },
    insertBefore: function(h, m) {
      return m.prev = h.prev, m.next = h, m.prev === null ? this.head = m : m.prev.next = m, h.prev = m, this;
    },
    insertAfter: function(h, m) {
      return m.prev = h, m.next = h.next, m.next === null ? this.tail = m : m.next.prev = m, h.next = m, this;
    },
    append: function(h) {
      return this.head === null ? this.head = h : this.tail.next = h, h.prev = this.tail, h.next = null, this.tail = h, this;
    },
    appendChain: function(h) {
      for (this.head === null ? this.head = h : this.tail.next = h, h.prev = this.tail; h.next !== null; )
        h = h.next;
      return this.tail = h, this;
    },
    remove: function(h) {
      return h.prev === null ? this.head = h.next : h.prev.next = h.next, h.next === null ? this.tail = h.prev : h.next.prev = h.prev, this;
    },
    removeSubList: function(h, m) {
      return h.prev === null ? this.head = m.next : h.prev.next = m.next, m.next === null ? this.tail = h.prev : m.next.prev = h.prev, this;
    },
    isEmpty: function() {
      return this.head === null;
    }
  }), r;
}();
class Az extends ui {
  constructor(e) {
    super();
    const t = [], r = [];
    Rz === void 0 && console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");
    const o = new Rz().setFromPoints(e).faces;
    for (let l = 0; l < o.length; l++) {
      const d = o[l];
      let h = d.edge;
      do {
        const m = h.head().point;
        t.push(m.x, m.y, m.z), r.push(d.normal.x, d.normal.y, d.normal.z), h = h.next;
      } while (h !== d.edge);
    }
    this.setAttribute("position", new sr(t, 3)), this.setAttribute("normal", new sr(r, 3));
  }
}
function Pi(a, e, t) {
  return e in a ? Object.defineProperty(a, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : a[e] = t, a;
}
const W4 = (a, e) => {
  const t = a[0].index !== null, r = new Set(Object.keys(a[0].attributes)), i = new Set(Object.keys(a[0].morphAttributes)), o = {}, l = {}, d = a[0].morphTargetsRelative, h = new ui();
  let m = 0;
  if (a.forEach((S, _) => {
    let T = 0;
    if (t !== (S.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + _ + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (let C in S.attributes) {
      if (!r.has(C))
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + _ + '. All geometries must have compatible attributes; make sure "' + C + '" attribute exists among all geometries, or in none of them.'), null;
      o[C] === void 0 && (o[C] = []), o[C].push(S.attributes[C]), T++;
    }
    if (T !== r.size)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + _ + ". Make sure all geometries have the same number of attributes."), null;
    if (d !== S.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + _ + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (let C in S.morphAttributes) {
      if (!i.has(C))
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + _ + ".  .morphAttributes must be consistent throughout all geometries."), null;
      l[C] === void 0 && (l[C] = []), l[C].push(S.morphAttributes[C]);
    }
    if (h.userData.mergedUserData = h.userData.mergedUserData || [], h.userData.mergedUserData.push(S.userData), e) {
      let C;
      if (S.index)
        C = S.index.count;
      else if (S.attributes.position !== void 0)
        C = S.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + _ + ". The geometry must have either an index or a position attribute"), null;
      h.addGroup(m, C, _), m += C;
    }
  }), t) {
    let S = 0;
    const _ = [];
    a.forEach((T) => {
      const C = T.index;
      for (let D = 0; D < C.count; ++D)
        _.push(C.getX(D) + S);
      S += T.attributes.position.count;
    }), h.setIndex(_);
  }
  for (let S in o) {
    const _ = Dz(o[S]);
    if (!_)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + S + " attribute."), null;
    h.setAttribute(S, _);
  }
  for (let S in l) {
    const _ = l[S][0].length;
    if (_ === 0)
      break;
    h.morphAttributes = h.morphAttributes || {}, h.morphAttributes[S] = [];
    for (let T = 0; T < _; ++T) {
      const C = [];
      for (let P = 0; P < l[S].length; ++P)
        C.push(l[S][P][T]);
      const D = Dz(C);
      if (!D)
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + S + " morphAttribute."), null;
      h.morphAttributes[S].push(D);
    }
  }
  return h;
}, Dz = (a) => {
  let e, t, r, i = 0;
  if (a.forEach((o) => {
    if (e === void 0 && (e = o.array.constructor), e !== o.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = o.itemSize), t !== o.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (r === void 0 && (r = o.normalized), r !== o.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    i += o.array.length;
  }), e && t) {
    const o = new e(i);
    let l = 0;
    return a.forEach((d) => {
      o.set(d.array, l), l += d.array.length;
    }), new os(o, t, r);
  }
}, Lz = (a, e) => (a % e + e) % e;
class Cj extends Mm {
  constructor(e, t) {
    super(), Pi(this, "object", void 0), Pi(this, "domElement", void 0), Pi(this, "enabled", !0), Pi(this, "target", new ge()), Pi(this, "minDistance", 0), Pi(this, "maxDistance", 1 / 0), Pi(this, "minZoom", 0), Pi(this, "maxZoom", 1 / 0), Pi(this, "minPolarAngle", 0), Pi(this, "maxPolarAngle", Math.PI), Pi(this, "minAzimuthAngle", -1 / 0), Pi(this, "maxAzimuthAngle", 1 / 0), Pi(this, "enableDamping", !1), Pi(this, "dampingFactor", 0.05), Pi(this, "enableZoom", !0), Pi(this, "zoomSpeed", 1), Pi(this, "enableRotate", !0), Pi(this, "rotateSpeed", 1), Pi(this, "enablePan", !0), Pi(this, "panSpeed", 1), Pi(this, "screenSpacePanning", !0), Pi(this, "keyPanSpeed", 7), Pi(this, "autoRotate", !1), Pi(this, "autoRotateSpeed", 2), Pi(this, "reverseOrbit", !1), Pi(this, "keys", {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown"
    }), Pi(this, "mouseButtons", {
      LEFT: ES.ROTATE,
      MIDDLE: ES.DOLLY,
      RIGHT: ES.PAN
    }), Pi(this, "touches", {
      ONE: MS.ROTATE,
      TWO: MS.DOLLY_PAN
    }), Pi(this, "target0", void 0), Pi(this, "position0", void 0), Pi(this, "zoom0", void 0), Pi(this, "_domElementKeyEvents", null), Pi(this, "getPolarAngle", void 0), Pi(this, "getAzimuthalAngle", void 0), Pi(this, "setPolarAngle", void 0), Pi(this, "setAzimuthalAngle", void 0), Pi(this, "getDistance", void 0), Pi(this, "listenToKeyEvents", void 0), Pi(this, "saveState", void 0), Pi(this, "reset", void 0), Pi(this, "update", void 0), Pi(this, "connect", void 0), Pi(this, "dispose", void 0), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object instanceof fo ? this.object.zoom : 1, this.getPolarAngle = () => S.phi, this.getAzimuthalAngle = () => S.theta, this.setPolarAngle = (xe) => {
      let Ie = Lz(xe, 2 * Math.PI), it = S.phi;
      it < 0 && (it += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI);
      let at = Math.abs(Ie - it);
      2 * Math.PI - at < at && (Ie < it ? Ie += 2 * Math.PI : it += 2 * Math.PI), _.phi = Ie - it, r.update();
    }, this.setAzimuthalAngle = (xe) => {
      let Ie = Lz(xe, 2 * Math.PI), it = S.theta;
      it < 0 && (it += 2 * Math.PI), Ie < 0 && (Ie += 2 * Math.PI);
      let at = Math.abs(Ie - it);
      2 * Math.PI - at < at && (Ie < it ? Ie += 2 * Math.PI : it += 2 * Math.PI), _.theta = Ie - it, r.update();
    }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = (xe) => {
      xe.addEventListener("keydown", je), this._domElementKeyEvents = xe;
    }, this.saveState = () => {
      r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object instanceof fo ? r.object.zoom : 1;
    }, this.reset = () => {
      r.target.copy(r.target0), r.object.position.copy(r.position0), r.object instanceof fo && (r.object.zoom = r.zoom0, r.object.updateProjectionMatrix()), r.dispatchEvent(i), r.update(), h = d.NONE;
    }, this.update = (() => {
      const xe = new ge(), Ie = new Ko().setFromUnitVectors(e.up, new ge(0, 1, 0)), it = Ie.clone().invert(), at = new ge(), hn = new Ko(), De = 2 * Math.PI;
      return function() {
        const Ne = r.object.position;
        xe.copy(Ne).sub(r.target), xe.applyQuaternion(Ie), S.setFromVector3(xe), r.autoRotate && h === d.NONE && ce(ie()), r.enableDamping ? (S.theta += _.theta * r.dampingFactor, S.phi += _.phi * r.dampingFactor) : (S.theta += _.theta, S.phi += _.phi);
        let Gt = r.minAzimuthAngle, Pt = r.maxAzimuthAngle;
        return isFinite(Gt) && isFinite(Pt) && (Gt < -Math.PI ? Gt += De : Gt > Math.PI && (Gt -= De), Pt < -Math.PI ? Pt += De : Pt > Math.PI && (Pt -= De), Gt <= Pt ? S.theta = Math.max(Gt, Math.min(Pt, S.theta)) : S.theta = S.theta > (Gt + Pt) / 2 ? Math.max(Gt, S.theta) : Math.min(Pt, S.theta)), S.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, S.phi)), S.makeSafe(), S.radius *= T, S.radius = Math.max(r.minDistance, Math.min(r.maxDistance, S.radius)), r.enableDamping === !0 ? r.target.addScaledVector(C, r.dampingFactor) : r.target.add(C), xe.setFromSpherical(S), xe.applyQuaternion(it), Ne.copy(r.target).add(xe), r.object.lookAt(r.target), r.enableDamping === !0 ? (_.theta *= 1 - r.dampingFactor, _.phi *= 1 - r.dampingFactor, C.multiplyScalar(1 - r.dampingFactor)) : (_.set(0, 0, 0), C.set(0, 0, 0)), T = 1, D || at.distanceToSquared(r.object.position) > m || 8 * (1 - hn.dot(r.object.quaternion)) > m ? (r.dispatchEvent(i), at.copy(r.object.position), hn.copy(r.object.quaternion), D = !1, !0) : !1;
      };
    })(), this.connect = (xe) => {
      xe === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), r.domElement = xe, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", Nt), r.domElement.addEventListener("pointerdown", Qt), r.domElement.addEventListener("pointercancel", Jt), r.domElement.addEventListener("wheel", oe);
    }, this.dispose = () => {
      var xe, Ie, it, at, hn, De;
      (xe = r.domElement) === null || xe === void 0 || xe.removeEventListener("contextmenu", Nt), (Ie = r.domElement) === null || Ie === void 0 || Ie.removeEventListener("pointerdown", Qt), (it = r.domElement) === null || it === void 0 || it.removeEventListener("pointercancel", Jt), (at = r.domElement) === null || at === void 0 || at.removeEventListener("wheel", oe), (hn = r.domElement) === null || hn === void 0 || hn.ownerDocument.removeEventListener("pointermove", ft), (De = r.domElement) === null || De === void 0 || De.ownerDocument.removeEventListener("pointerup", Vt), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", je);
    };
    const r = this, i = {
      type: "change"
    }, o = {
      type: "start"
    }, l = {
      type: "end"
    }, d = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let h = d.NONE;
    const m = 1e-6, S = new b3(), _ = new b3();
    let T = 1;
    const C = new ge();
    let D = !1;
    const P = new Ft(), U = new Ft(), B = new Ft(), k = new Ft(), V = new Ft(), I = new Ft(), X = new Ft(), J = new Ft(), $ = new Ft(), W = [], ee = {};
    function ie() {
      return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed;
    }
    function pe() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function ce(xe) {
      r.reverseOrbit ? _.theta += xe : _.theta -= xe;
    }
    function Ee(xe) {
      r.reverseOrbit ? _.phi += xe : _.phi -= xe;
    }
    const de = (() => {
      const xe = new ge();
      return function(it, at) {
        xe.setFromMatrixColumn(at, 0), xe.multiplyScalar(-it), C.add(xe);
      };
    })(), Fe = (() => {
      const xe = new ge();
      return function(it, at) {
        r.screenSpacePanning === !0 ? xe.setFromMatrixColumn(at, 1) : (xe.setFromMatrixColumn(at, 0), xe.crossVectors(r.object.up, xe)), xe.multiplyScalar(it), C.add(xe);
      };
    })(), Ce = (() => {
      const xe = new ge();
      return function(it, at) {
        const hn = r.domElement;
        if (hn && r.object instanceof fo && r.object.isPerspectiveCamera) {
          const De = r.object.position;
          xe.copy(De).sub(r.target);
          let Tt = xe.length();
          Tt *= Math.tan(r.object.fov / 2 * Math.PI / 180), de(2 * it * Tt / hn.clientHeight, r.object.matrix), Fe(2 * at * Tt / hn.clientHeight, r.object.matrix);
        } else
          hn && r.object instanceof cy && r.object.isOrthographicCamera ? (de(it * (r.object.right - r.object.left) / r.object.zoom / hn.clientWidth, r.object.matrix), Fe(at * (r.object.top - r.object.bottom) / r.object.zoom / hn.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1);
      };
    })();
    function Be(xe) {
      r.object instanceof fo && r.object.isPerspectiveCamera ? T /= xe : r.object instanceof cy && r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * xe)), r.object.updateProjectionMatrix(), D = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function he(xe) {
      r.object instanceof fo && r.object.isPerspectiveCamera ? T *= xe : r.object instanceof cy && r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / xe)), r.object.updateProjectionMatrix(), D = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function fe(xe) {
      P.set(xe.clientX, xe.clientY);
    }
    function ue(xe) {
      X.set(xe.clientX, xe.clientY);
    }
    function ye(xe) {
      k.set(xe.clientX, xe.clientY);
    }
    function we(xe) {
      U.set(xe.clientX, xe.clientY), B.subVectors(U, P).multiplyScalar(r.rotateSpeed);
      const Ie = r.domElement;
      Ie && (ce(2 * Math.PI * B.x / Ie.clientHeight), Ee(2 * Math.PI * B.y / Ie.clientHeight)), P.copy(U), r.update();
    }
    function Xe(xe) {
      J.set(xe.clientX, xe.clientY), $.subVectors(J, X), $.y > 0 ? Be(pe()) : $.y < 0 && he(pe()), X.copy(J), r.update();
    }
    function Je(xe) {
      V.set(xe.clientX, xe.clientY), I.subVectors(V, k).multiplyScalar(r.panSpeed), Ce(I.x, I.y), k.copy(V), r.update();
    }
    function st(xe) {
      xe.deltaY < 0 ? he(pe()) : xe.deltaY > 0 && Be(pe()), r.update();
    }
    function Ue(xe) {
      let Ie = !1;
      switch (xe.code) {
        case r.keys.UP:
          Ce(0, r.keyPanSpeed), Ie = !0;
          break;
        case r.keys.BOTTOM:
          Ce(0, -r.keyPanSpeed), Ie = !0;
          break;
        case r.keys.LEFT:
          Ce(r.keyPanSpeed, 0), Ie = !0;
          break;
        case r.keys.RIGHT:
          Ce(-r.keyPanSpeed, 0), Ie = !0;
          break;
      }
      Ie && (xe.preventDefault(), r.update());
    }
    function ot() {
      if (W.length == 1)
        P.set(W[0].pageX, W[0].pageY);
      else {
        const xe = 0.5 * (W[0].pageX + W[1].pageX), Ie = 0.5 * (W[0].pageY + W[1].pageY);
        P.set(xe, Ie);
      }
    }
    function rt() {
      if (W.length == 1)
        k.set(W[0].pageX, W[0].pageY);
      else {
        const xe = 0.5 * (W[0].pageX + W[1].pageX), Ie = 0.5 * (W[0].pageY + W[1].pageY);
        k.set(xe, Ie);
      }
    }
    function _t() {
      const xe = W[0].pageX - W[1].pageX, Ie = W[0].pageY - W[1].pageY, it = Math.sqrt(xe * xe + Ie * Ie);
      X.set(0, it);
    }
    function Rt() {
      r.enableZoom && _t(), r.enablePan && rt();
    }
    function Ot() {
      r.enableZoom && _t(), r.enableRotate && ot();
    }
    function He(xe) {
      if (W.length == 1)
        U.set(xe.pageX, xe.pageY);
      else {
        const it = ze(xe), at = 0.5 * (xe.pageX + it.x), hn = 0.5 * (xe.pageY + it.y);
        U.set(at, hn);
      }
      B.subVectors(U, P).multiplyScalar(r.rotateSpeed);
      const Ie = r.domElement;
      Ie && (ce(2 * Math.PI * B.x / Ie.clientHeight), Ee(2 * Math.PI * B.y / Ie.clientHeight)), P.copy(U);
    }
    function et(xe) {
      if (W.length == 1)
        V.set(xe.pageX, xe.pageY);
      else {
        const Ie = ze(xe), it = 0.5 * (xe.pageX + Ie.x), at = 0.5 * (xe.pageY + Ie.y);
        V.set(it, at);
      }
      I.subVectors(V, k).multiplyScalar(r.panSpeed), Ce(I.x, I.y), k.copy(V);
    }
    function mt(xe) {
      const Ie = ze(xe), it = xe.pageX - Ie.x, at = xe.pageY - Ie.y, hn = Math.sqrt(it * it + at * at);
      J.set(0, hn), $.set(0, Math.pow(J.y / X.y, r.zoomSpeed)), Be($.y), X.copy(J);
    }
    function vt(xe) {
      r.enableZoom && mt(xe), r.enablePan && et(xe);
    }
    function bt(xe) {
      r.enableZoom && mt(xe), r.enableRotate && He(xe);
    }
    function Qt(xe) {
      if (r.enabled !== !1) {
        if (W.length === 0) {
          var Ie, it;
          (Ie = r.domElement) === null || Ie === void 0 || Ie.ownerDocument.addEventListener("pointermove", ft), (it = r.domElement) === null || it === void 0 || it.ownerDocument.addEventListener("pointerup", Vt);
        }
        Ut(xe), xe.pointerType === "touch" ? lt(xe) : Mt(xe);
      }
    }
    function ft(xe) {
      r.enabled !== !1 && (xe.pointerType === "touch" ? zt(xe) : Me(xe));
    }
    function Vt(xe) {
      if (tt(xe), W.length === 0) {
        var Ie, it, at;
        (Ie = r.domElement) === null || Ie === void 0 || Ie.releasePointerCapture(xe.pointerId), (it = r.domElement) === null || it === void 0 || it.ownerDocument.removeEventListener("pointermove", ft), (at = r.domElement) === null || at === void 0 || at.ownerDocument.removeEventListener("pointerup", Vt);
      }
      r.dispatchEvent(l), h = d.NONE;
    }
    function Jt(xe) {
      tt(xe);
    }
    function Mt(xe) {
      let Ie;
      switch (xe.button) {
        case 0:
          Ie = r.mouseButtons.LEFT;
          break;
        case 1:
          Ie = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Ie = r.mouseButtons.RIGHT;
          break;
        default:
          Ie = -1;
      }
      switch (Ie) {
        case ES.DOLLY:
          if (r.enableZoom === !1)
            return;
          ue(xe), h = d.DOLLY;
          break;
        case ES.ROTATE:
          if (xe.ctrlKey || xe.metaKey || xe.shiftKey) {
            if (r.enablePan === !1)
              return;
            ye(xe), h = d.PAN;
          } else {
            if (r.enableRotate === !1)
              return;
            fe(xe), h = d.ROTATE;
          }
          break;
        case ES.PAN:
          if (xe.ctrlKey || xe.metaKey || xe.shiftKey) {
            if (r.enableRotate === !1)
              return;
            fe(xe), h = d.ROTATE;
          } else {
            if (r.enablePan === !1)
              return;
            ye(xe), h = d.PAN;
          }
          break;
        default:
          h = d.NONE;
      }
      h !== d.NONE && r.dispatchEvent(o);
    }
    function Me(xe) {
      if (r.enabled !== !1)
        switch (h) {
          case d.ROTATE:
            if (r.enableRotate === !1)
              return;
            we(xe);
            break;
          case d.DOLLY:
            if (r.enableZoom === !1)
              return;
            Xe(xe);
            break;
          case d.PAN:
            if (r.enablePan === !1)
              return;
            Je(xe);
            break;
        }
    }
    function oe(xe) {
      r.enabled === !1 || r.enableZoom === !1 || h !== d.NONE && h !== d.ROTATE || (xe.preventDefault(), r.dispatchEvent(o), st(xe), r.dispatchEvent(l));
    }
    function je(xe) {
      r.enabled === !1 || r.enablePan === !1 || Ue(xe);
    }
    function lt(xe) {
      switch (rn(xe), W.length) {
        case 1:
          switch (r.touches.ONE) {
            case MS.ROTATE:
              if (r.enableRotate === !1)
                return;
              ot(), h = d.TOUCH_ROTATE;
              break;
            case MS.PAN:
              if (r.enablePan === !1)
                return;
              rt(), h = d.TOUCH_PAN;
              break;
            default:
              h = d.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case MS.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1)
                return;
              Rt(), h = d.TOUCH_DOLLY_PAN;
              break;
            case MS.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1)
                return;
              Ot(), h = d.TOUCH_DOLLY_ROTATE;
              break;
            default:
              h = d.NONE;
          }
          break;
        default:
          h = d.NONE;
      }
      h !== d.NONE && r.dispatchEvent(o);
    }
    function zt(xe) {
      switch (rn(xe), h) {
        case d.TOUCH_ROTATE:
          if (r.enableRotate === !1)
            return;
          He(xe), r.update();
          break;
        case d.TOUCH_PAN:
          if (r.enablePan === !1)
            return;
          et(xe), r.update();
          break;
        case d.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1)
            return;
          vt(xe), r.update();
          break;
        case d.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1)
            return;
          bt(xe), r.update();
          break;
        default:
          h = d.NONE;
      }
    }
    function Nt(xe) {
      r.enabled !== !1 && xe.preventDefault();
    }
    function Ut(xe) {
      W.push(xe);
    }
    function tt(xe) {
      delete ee[xe.pointerId];
      for (let Ie = 0; Ie < W.length; Ie++)
        if (W[Ie].pointerId == xe.pointerId) {
          W.splice(Ie, 1);
          return;
        }
    }
    function rn(xe) {
      let Ie = ee[xe.pointerId];
      Ie === void 0 && (Ie = new Ft(), ee[xe.pointerId] = Ie), Ie.set(xe.pageX, xe.pageY);
    }
    function ze(xe) {
      const Ie = xe.pointerId === W[0].pointerId ? W[1] : W[0];
      return ee[Ie.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
}
const lM = new ge();
function mv(a, e, t, r, i, o) {
  const l = 2 * Math.PI * i / 4, d = Math.max(o - 2 * i, 0), h = Math.PI / 4;
  lM.copy(e), lM[r] = 0, lM.normalize();
  const m = 0.5 * l / (l + d), S = 1 - lM.angleTo(a) / h;
  return Math.sign(lM[t]) === 1 ? S * m : d / (l + d) + m + m * (1 - S);
}
class Rj extends cl {
  constructor(e = 1, t = 1, r = 1, i = 2, o = 0.1) {
    if (i = i * 2 + 1, o = Math.min(e / 2, t / 2, r / 2, o), super(1, 1, 1, i, i, i), i === 1)
      return;
    const l = this.toNonIndexed();
    this.index = null, this.attributes.position = l.attributes.position, this.attributes.normal = l.attributes.normal, this.attributes.uv = l.attributes.uv;
    const d = new ge(), h = new ge(), m = new ge(e, t, r).divideScalar(2).subScalar(o), S = this.attributes.position.array, _ = this.attributes.normal.array, T = this.attributes.uv.array, C = S.length / 6, D = new ge(), P = 0.5 / i;
    for (let U = 0, B = 0; U < S.length; U += 3, B += 2)
      switch (d.fromArray(S, U), h.copy(d), h.x -= Math.sign(h.x) * P, h.y -= Math.sign(h.y) * P, h.z -= Math.sign(h.z) * P, h.normalize(), S[U + 0] = m.x * Math.sign(d.x) + h.x * o, S[U + 1] = m.y * Math.sign(d.y) + h.y * o, S[U + 2] = m.z * Math.sign(d.z) + h.z * o, _[U + 0] = h.x, _[U + 1] = h.y, _[U + 2] = h.z, Math.floor(U / C)) {
        case 0:
          D.set(1, 0, 0), T[B + 0] = mv(D, h, "z", "y", o, r), T[B + 1] = 1 - mv(D, h, "y", "z", o, t);
          break;
        case 1:
          D.set(-1, 0, 0), T[B + 0] = 1 - mv(D, h, "z", "y", o, r), T[B + 1] = 1 - mv(D, h, "y", "z", o, t);
          break;
        case 2:
          D.set(0, 1, 0), T[B + 0] = 1 - mv(D, h, "x", "z", o, e), T[B + 1] = mv(D, h, "z", "x", o, r);
          break;
        case 3:
          D.set(0, -1, 0), T[B + 0] = 1 - mv(D, h, "x", "z", o, e), T[B + 1] = 1 - mv(D, h, "z", "x", o, r);
          break;
        case 4:
          D.set(0, 0, 1), T[B + 0] = 1 - mv(D, h, "x", "y", o, e), T[B + 1] = 1 - mv(D, h, "y", "x", o, t);
          break;
        case 5:
          D.set(0, 0, -1), T[B + 0] = mv(D, h, "x", "y", o, e), T[B + 1] = 1 - mv(D, h, "y", "x", o, t);
          break;
      }
  }
}
const Pz = new sg(), tC = new ge();
class j4 extends JC {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new sr(e, 3)), this.setAttribute("uv", new sr(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new CC(t, 6, 1);
    return this.setAttribute("instanceStart", new _m(r, 3, 0)), this.setAttribute("instanceEnd", new _m(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new CC(t, 6, 1);
    return this.setAttribute("instanceColorStart", new _m(r, 3, 0)), this.setAttribute("instanceColorEnd", new _m(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new uL(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new sg());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Pz.setFromBufferAttribute(t), this.boundingBox.union(Pz));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new vy()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        tC.fromBufferAttribute(e, o), i = Math.max(i, r.distanceToSquared(tC)), tC.fromBufferAttribute(t, o), i = Math.max(i, r.distanceToSquared(tC));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
class Y4 extends j4 {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
Fn.line = {
  worldUnits: {
    value: 1
  },
  linewidth: {
    value: 1
  },
  resolution: {
    value: new Ft(1, 1)
  },
  dashOffset: {
    value: 0
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  }
};
Gh.line = {
  uniforms: $M.merge([Fn.common, Fn.fog, Fn.line]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class ML extends wu {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: $M.clone(Gh.line.uniforms),
      vertexShader: Gh.line.vertexShader,
      fragmentShader: Gh.line.fragmentShader,
      clipping: !0
    }), this.isLineMaterial = !0, Object.defineProperties(this, {
      color: {
        enumerable: !0,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(t) {
          this.uniforms.diffuse.value = t;
        }
      },
      worldUnits: {
        enumerable: !0,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(t) {
          t === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
        }
      },
      linewidth: {
        enumerable: !0,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(t) {
          this.uniforms.linewidth.value = t;
        }
      },
      dashed: {
        enumerable: !0,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(t) {
          Boolean(t) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
        }
      },
      dashScale: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(t) {
          this.uniforms.dashScale.value = t;
        }
      },
      dashSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(t) {
          this.uniforms.dashSize.value = t;
        }
      },
      dashOffset: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(t) {
          this.uniforms.dashOffset.value = t;
        }
      },
      gapSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(t) {
          this.uniforms.gapSize.value = t;
        }
      },
      opacity: {
        enumerable: !0,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(t) {
          this.uniforms.opacity.value = t;
        }
      },
      resolution: {
        enumerable: !0,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(t) {
          this.uniforms.resolution.value.copy(t);
        }
      },
      alphaToCoverage: {
        enumerable: !0,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(t) {
          Boolean(t) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), t === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
        }
      }
    }), this.setValues(e);
  }
}
const Oz = new ge(), Uz = new ge(), Dd = new la(), Ld = new la(), ry = new la(), _D = new ge(), bD = new si(), uh = new bL(), zz = new ge(), nC = new sg(), rC = new vy(), iy = new la();
let oy, D3, X4, VS;
function Nz(a, e, t) {
  return iy.set(0, 0, -e, 1).applyMatrix4(a.projectionMatrix), iy.multiplyScalar(1 / iy.w), iy.x = VS / t.width, iy.y = VS / t.height, iy.applyMatrix4(a.projectionMatrixInverse), iy.multiplyScalar(1 / iy.w), Math.abs(Math.max(iy.x, iy.y));
}
function Aj(a, e) {
  for (let t = 0, r = D3.count; t < r; t++) {
    uh.start.fromBufferAttribute(D3, t), uh.end.fromBufferAttribute(X4, t);
    const i = new ge(), o = new ge();
    oy.distanceSqToSegment(uh.start, uh.end, o, i), o.distanceTo(i) < VS * 0.5 && e.push({
      point: o,
      pointOnLine: i,
      distance: oy.origin.distanceTo(o),
      object: a,
      face: null,
      faceIndex: t,
      uv: null,
      uv2: null
    });
  }
}
function Dj(a, e, t) {
  const r = e.projectionMatrix, o = a.material.resolution, l = a.matrixWorld, d = a.geometry, h = d.attributes.instanceStart, m = d.attributes.instanceEnd, S = -e.near;
  oy.at(1, ry), ry.w = 1, ry.applyMatrix4(e.matrixWorldInverse), ry.applyMatrix4(r), ry.multiplyScalar(1 / ry.w), ry.x *= o.x / 2, ry.y *= o.y / 2, ry.z = 0, _D.copy(ry), bD.multiplyMatrices(e.matrixWorldInverse, l);
  for (let _ = 0, T = h.count; _ < T; _++) {
    if (Dd.fromBufferAttribute(h, _), Ld.fromBufferAttribute(m, _), Dd.w = 1, Ld.w = 1, Dd.applyMatrix4(bD), Ld.applyMatrix4(bD), Dd.z > S && Ld.z > S)
      continue;
    if (Dd.z > S) {
      const k = Dd.z - Ld.z, V = (Dd.z - S) / k;
      Dd.lerp(Ld, V);
    } else if (Ld.z > S) {
      const k = Ld.z - Dd.z, V = (Ld.z - S) / k;
      Ld.lerp(Dd, V);
    }
    Dd.applyMatrix4(r), Ld.applyMatrix4(r), Dd.multiplyScalar(1 / Dd.w), Ld.multiplyScalar(1 / Ld.w), Dd.x *= o.x / 2, Dd.y *= o.y / 2, Ld.x *= o.x / 2, Ld.y *= o.y / 2, uh.start.copy(Dd), uh.start.z = 0, uh.end.copy(Ld), uh.end.z = 0;
    const D = uh.closestPointToPointParameter(_D, !0);
    uh.at(D, zz);
    const P = vF.lerp(Dd.z, Ld.z, D), U = P >= -1 && P <= 1, B = _D.distanceTo(zz) < VS * 0.5;
    if (U && B) {
      uh.start.fromBufferAttribute(h, _), uh.end.fromBufferAttribute(m, _), uh.start.applyMatrix4(l), uh.end.applyMatrix4(l);
      const k = new ge(), V = new ge();
      oy.distanceSqToSegment(uh.start, uh.end, V, k), t.push({
        point: V,
        pointOnLine: k,
        distance: oy.origin.distanceTo(V),
        object: a,
        face: null,
        faceIndex: _,
        uv: null,
        uv2: null
      });
    }
  }
}
class Lj extends zn {
  constructor(e = new j4(), t = new ML({
    color: Math.random() * 16777215
  })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, i = new Float32Array(2 * t.count);
    for (let l = 0, d = 0, h = t.count; l < h; l++, d += 2)
      Oz.fromBufferAttribute(t, l), Uz.fromBufferAttribute(r, l), i[d] = d === 0 ? 0 : i[d - 1], i[d + 1] = i[d] + Oz.distanceTo(Uz);
    const o = new CC(i, 2, 1);
    return e.setAttribute("instanceDistanceStart", new _m(o, 1, 0)), e.setAttribute("instanceDistanceEnd", new _m(o, 1, 1)), this;
  }
  raycast(e, t) {
    const r = this.material.worldUnits, i = e.camera;
    i === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const o = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    oy = e.ray;
    const l = this.matrixWorld, d = this.geometry, h = this.material;
    VS = h.linewidth + o, D3 = d.attributes.instanceStart, X4 = d.attributes.instanceEnd, d.boundingSphere === null && d.computeBoundingSphere(), rC.copy(d.boundingSphere).applyMatrix4(l);
    let m;
    if (r)
      m = VS * 0.5;
    else {
      const _ = Math.max(i.near, rC.distanceToPoint(oy.origin));
      m = Nz(i, _, h.resolution);
    }
    if (rC.radius += m, oy.intersectsSphere(rC) === !1)
      return;
    d.boundingBox === null && d.computeBoundingBox(), nC.copy(d.boundingBox).applyMatrix4(l);
    let S;
    if (r)
      S = VS * 0.5;
    else {
      const _ = Math.max(i.near, nC.distanceToPoint(oy.origin));
      S = Nz(i, _, h.resolution);
    }
    nC.expandByScalar(S), oy.intersectsBox(nC) !== !1 && (r ? Aj(this, t) : Dj(this, i, t));
  }
}
class Pj extends Lj {
  constructor(e = new Y4(), t = new ML({
    color: Math.random() * 16777215
  })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
const Oj = /* @__PURE__ */ Or.forwardRef(function({
  follow: e = !0,
  lockX: t = !1,
  lockY: r = !1,
  lockZ: i = !1,
  ...o
}, l) {
  const d = Or.useRef();
  return yy(({
    camera: h
  }) => {
    if (!e || !d.current)
      return;
    const m = d.current.rotation.clone();
    d.current.quaternion.copy(h.quaternion), t && (d.current.rotation.x = m.x), r && (d.current.rotation.y = m.y), i && (d.current.rotation.z = m.z);
  }), /* @__PURE__ */ _n("group", {
    ref: Tj([d, l]),
    ...o
  });
}), Uj = /* @__PURE__ */ Or.forwardRef(function({
  points: e,
  color: t = "black",
  vertexColors: r,
  linewidth: i,
  lineWidth: o,
  dashed: l,
  ...d
}, h) {
  const m = Od((C) => C.size), [S] = Or.useState(() => new Pj()), [_] = Or.useState(() => new ML()), T = Or.useMemo(() => {
    const C = new Y4(), D = e.map((P) => P instanceof ge ? P.toArray() : P);
    if (C.setPositions(D.flat()), r) {
      const P = r.map((U) => U instanceof Pn ? U.toArray() : U);
      C.setColors(P.flat());
    }
    return C;
  }, [e, r]);
  return Or.useLayoutEffect(() => {
    S.computeLineDistances();
  }, [e, S]), Or.useLayoutEffect(() => {
    l ? _.defines.USE_DASH = "" : delete _.defines.USE_DASH, _.needsUpdate = !0;
  }, [l, _]), Or.useEffect(() => () => T.dispose(), [T]), /* @__PURE__ */ dh("primitive", {
    object: S,
    ref: h,
    ...d,
    children: [/* @__PURE__ */ _n("primitive", {
      object: T,
      attach: "geometry"
    }), /* @__PURE__ */ _n("primitive", {
      object: _,
      attach: "material",
      color: t,
      vertexColors: Boolean(r),
      resolution: [m.width, m.height],
      linewidth: i != null ? i : o,
      dashed: l,
      ...d
    })]
  });
});
function TL() {
  var a = 0, e = [], t, r = 0, i = 0;
  function o(B, k) {
    var V = TL();
    function I() {
      var X = a > 0 ? B : k;
      if (P(X))
        try {
          var J = X(t);
          J === V && D();
          var $ = T(J);
          $ ? $.call(J, V.resolve, V.reject) : V.resolve(J);
        } catch (W) {
          V.reject(W);
        }
      else
        V[a > 0 ? "resolve" : "reject"](t);
    }
    return e.push(I), a && m(), V;
  }
  var l = C(function(B) {
    i || h(1, B);
  }), d = C(function(B) {
    i || h(-1, B);
  });
  function h(B, k) {
    i++;
    var V = 0;
    try {
      k === U && D();
      var I = B > 0 && T(k);
      I ? I.call(k, C(function(X) {
        V++, h(1, X);
      }), C(function(X) {
        V++, h(-1, X);
      })) : (a = B, t = k, m());
    } catch (X) {
      !a && !V && h(-1, X);
    }
  }
  function m() {
    r || (setTimeout(S, 0), r = 1);
  }
  function S() {
    var B = e;
    r = 0, e = [], B.forEach(_);
  }
  function _(B) {
    B();
  }
  function T(B) {
    var k = B && (P(B) || typeof B == "object") && B.then;
    return P(k) && k;
  }
  function C(B) {
    var k = 0;
    return function() {
      for (var V = [], I = arguments.length; I--; )
        V[I] = arguments[I];
      k++ || B.apply(this, V);
    };
  }
  function D() {
    throw new TypeError("Chaining cycle detected");
  }
  var P = function(B) {
    return typeof B == "function";
  }, U = {
    then: o,
    resolve: l,
    reject: d
  };
  return U;
}
function q4() {
  var a, e, t = new Promise(function(r, i) {
    a = r, e = i;
  });
  return {
    then: t.then.bind(t),
    resolve: a,
    reject: e
  };
}
TL.all = q4.all = function(a) {
  var e = 0, t = [], r = O0();
  return a.length === 0 ? r.resolve([]) : a.forEach(function(i, o) {
    var l = O0();
    l.resolve(i), l.then(function(d) {
      e++, t[o] = d, e === a.length && r.resolve(t);
    }, r.reject);
  }), r;
};
var O0 = typeof Promise == "function" ? q4 : TL;
function zj() {
  var a = /* @__PURE__ */ Object.create(null);
  function e(i, o) {
    var l = i.id, d = i.name, h = i.dependencies;
    h === void 0 && (h = []);
    var m = i.init;
    m === void 0 && (m = function() {
    });
    var S = i.getTransferables;
    if (S === void 0 && (S = null), !a[l])
      try {
        h = h.map(function(T) {
          return T && T.isWorkerModule && (e(T, function(C) {
            if (C instanceof Error)
              throw C;
          }), T = a[T.id].value), T;
        }), m = r("<" + d + ">.init", m), S && (S = r("<" + d + ">.getTransferables", S));
        var _ = null;
        typeof m == "function" ? _ = m.apply(void 0, h) : console.error("worker module init function failed to rehydrate"), a[l] = {
          id: l,
          value: _,
          getTransferables: S
        }, o(_);
      } catch (T) {
        T && T.noLog || console.error(T), o(T);
      }
  }
  function t(i, o) {
    var l, d = i.id, h = i.args;
    (!a[d] || typeof a[d].value != "function") && o(new Error("Worker module " + d + ": not found or its 'init' did not return a function"));
    try {
      var m = (l = a[d]).value.apply(l, h);
      m && typeof m.then == "function" ? m.then(S, function(_) {
        return o(_ instanceof Error ? _ : new Error("" + _));
      }) : S(m);
    } catch (_) {
      o(_);
    }
    function S(_) {
      try {
        var T = a[d].getTransferables && a[d].getTransferables(_);
        (!T || !Array.isArray(T) || !T.length) && (T = void 0), o(_, T);
      } catch (C) {
        console.error(C), o(C);
      }
    }
  }
  function r(i, o) {
    var l = void 0;
    self.troikaDefine = function(h) {
      return l = h;
    };
    var d = URL.createObjectURL(
      new Blob(
        ["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + o + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(d);
    } catch (h) {
      console.error(h);
    }
    return URL.revokeObjectURL(d), delete self.troikaDefine, l;
  }
  self.addEventListener("message", function(i) {
    var o = i.data, l = o.messageId, d = o.action, h = o.data;
    try {
      d === "registerModule" && e(h, function(m) {
        m instanceof Error ? postMessage({
          messageId: l,
          success: !1,
          error: m.message
        }) : postMessage({
          messageId: l,
          success: !0,
          result: { isCallable: typeof m == "function" }
        });
      }), d === "callModule" && t(h, function(m, S) {
        m instanceof Error ? postMessage({
          messageId: l,
          success: !1,
          error: m.message
        }) : postMessage({
          messageId: l,
          success: !0,
          result: m
        }, S || void 0);
      });
    } catch (m) {
      postMessage({
        messageId: l,
        success: !1,
        error: m.stack
      });
    }
  });
}
function Nj(a) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(i) {
      if (typeof i == "function")
        return i.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = a.dependencies, r = a.init;
    t = Array.isArray(t) ? t.map(
      function(o) {
        return o && o._getInitResult ? o._getInitResult() : o;
      }
    ) : [];
    var i = O0.all(t).then(function(o) {
      return r.apply(null, o);
    });
    return e._getInitResult = function() {
      return i;
    }, i;
  }, e;
}
var Q4 = function() {
  var a = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), a = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return Q4 = function() {
    return a;
  }, a;
}, Fj = 0, kj = 0, wD = !1, bM = /* @__PURE__ */ Object.create(null), wM = /* @__PURE__ */ Object.create(null), L3 = /* @__PURE__ */ Object.create(null);
function vw(a) {
  if ((!a || typeof a.init != "function") && !wD)
    throw new Error("requires `options.init` function");
  var e = a.dependencies, t = a.init, r = a.getTransferables, i = a.workerId;
  if (!Q4())
    return Nj(a);
  i == null && (i = "#default");
  var o = "workerModule" + ++Fj, l = a.name || o, d = null;
  e = e && e.map(function(m) {
    return typeof m == "function" && !m.workerModuleData && (wD = !0, m = vw({
      workerId: i,
      name: "<" + l + "> function dependency: " + m.name,
      init: `function(){return (
` + yC(m) + `
)}`
    }), wD = !1), m && m.workerModuleData && (m = m.workerModuleData), m;
  });
  function h() {
    for (var m = [], S = arguments.length; S--; )
      m[S] = arguments[S];
    if (!d) {
      d = Fz(i, "registerModule", h.workerModuleData);
      var _ = function() {
        d = null, wM[i].delete(_);
      };
      (wM[i] || (wM[i] = /* @__PURE__ */ new Set())).add(_);
    }
    return d.then(function(T) {
      var C = T.isCallable;
      if (C)
        return Fz(i, "callModule", { id: o, args: m });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return h.workerModuleData = {
    isWorkerModule: !0,
    id: o,
    name: l,
    dependencies: e,
    init: yC(t),
    getTransferables: r && yC(r)
  }, h;
}
function Ij(a) {
  wM[a] && wM[a].forEach(function(e) {
    e();
  }), bM[a] && (bM[a].terminate(), delete bM[a]);
}
function yC(a) {
  var e = a.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function Bj(a) {
  var e = bM[a];
  if (!e) {
    var t = yC(zj);
    e = bM[a] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + a.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var i = r.data, o = i.messageId, l = L3[o];
      if (!l)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete L3[o], l(i);
    };
  }
  return e;
}
function Fz(a, e, t) {
  var r = O0(), i = ++kj;
  return L3[i] = function(o) {
    o.success ? r.resolve(o.result) : r.reject(new Error("Error in worker " + e + " call: " + o.error));
  }, Bj(a).postMessage({
    messageId: i,
    action: e,
    data: t
  }), r;
}
var Hj = /* @__PURE__ */ vw({
  name: "Thenable",
  dependencies: [O0],
  init: function(a) {
    return a;
  }
});
function Z4() {
  var a = function(e) {
    function t(fe, ue, ye, we, Xe, Je, st, Ue) {
      var ot = 1 - st;
      Ue.x = ot * ot * fe + 2 * ot * st * ye + st * st * Xe, Ue.y = ot * ot * ue + 2 * ot * st * we + st * st * Je;
    }
    function r(fe, ue, ye, we, Xe, Je, st, Ue, ot, rt) {
      var _t = 1 - ot;
      rt.x = _t * _t * _t * fe + 3 * _t * _t * ot * ye + 3 * _t * ot * ot * Xe + ot * ot * ot * st, rt.y = _t * _t * _t * ue + 3 * _t * _t * ot * we + 3 * _t * ot * ot * Je + ot * ot * ot * Ue;
    }
    function i(fe, ue) {
      for (var ye = /([MLQCZ])([^MLQCZ]*)/g, we, Xe, Je, st, Ue; we = ye.exec(fe); ) {
        var ot = we[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(rt) {
          return parseFloat(rt);
        });
        switch (we[1]) {
          case "M":
            st = Xe = ot[0], Ue = Je = ot[1];
            break;
          case "L":
            (ot[0] !== st || ot[1] !== Ue) && ue("L", st, Ue, st = ot[0], Ue = ot[1]);
            break;
          case "Q": {
            ue("Q", st, Ue, st = ot[2], Ue = ot[3], ot[0], ot[1]);
            break;
          }
          case "C": {
            ue("C", st, Ue, st = ot[4], Ue = ot[5], ot[0], ot[1], ot[2], ot[3]);
            break;
          }
          case "Z":
            (st !== Xe || Ue !== Je) && ue("L", st, Ue, Xe, Je);
            break;
        }
      }
    }
    function o(fe, ue, ye) {
      ye === void 0 && (ye = 16);
      var we = { x: 0, y: 0 };
      i(fe, function(Xe, Je, st, Ue, ot, rt, _t, Rt, Ot) {
        switch (Xe) {
          case "L":
            ue(Je, st, Ue, ot);
            break;
          case "Q": {
            for (var He = Je, et = st, mt = 1; mt < ye; mt++)
              t(
                Je,
                st,
                rt,
                _t,
                Ue,
                ot,
                mt / (ye - 1),
                we
              ), ue(He, et, we.x, we.y), He = we.x, et = we.y;
            break;
          }
          case "C": {
            for (var vt = Je, bt = st, Qt = 1; Qt < ye; Qt++)
              r(
                Je,
                st,
                rt,
                _t,
                Rt,
                Ot,
                Ue,
                ot,
                Qt / (ye - 1),
                we
              ), ue(vt, bt, we.x, we.y), vt = we.x, bt = we.y;
            break;
          }
        }
      });
    }
    var l = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", d = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", h = /* @__PURE__ */ new WeakMap(), m = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function S(fe, ue) {
      var ye = fe.getContext ? fe.getContext("webgl", m) : fe, we = h.get(ye);
      if (!we) {
        let _t = function(vt) {
          var bt = Je[vt];
          if (!bt && (bt = Je[vt] = ye.getExtension(vt), !bt))
            throw new Error(vt + " not supported");
          return bt;
        }, Rt = function(vt, bt) {
          var Qt = ye.createShader(bt);
          return ye.shaderSource(Qt, vt), ye.compileShader(Qt), Qt;
        }, Ot = function(vt, bt, Qt, ft) {
          if (!st[vt]) {
            var Vt = {}, Jt = {}, Mt = ye.createProgram();
            ye.attachShader(Mt, Rt(bt, ye.VERTEX_SHADER)), ye.attachShader(Mt, Rt(Qt, ye.FRAGMENT_SHADER)), ye.linkProgram(Mt), st[vt] = {
              program: Mt,
              transaction: function(oe) {
                ye.useProgram(Mt), oe({
                  setUniform: function(lt, zt) {
                    for (var Nt = [], Ut = arguments.length - 2; Ut-- > 0; )
                      Nt[Ut] = arguments[Ut + 2];
                    var tt = Jt[zt] || (Jt[zt] = ye.getUniformLocation(Mt, zt));
                    ye["uniform" + lt].apply(ye, [tt].concat(Nt));
                  },
                  setAttribute: function(lt, zt, Nt, Ut, tt) {
                    var rn = Vt[lt];
                    rn || (rn = Vt[lt] = {
                      buf: ye.createBuffer(),
                      loc: ye.getAttribLocation(Mt, lt),
                      data: null
                    }), ye.bindBuffer(ye.ARRAY_BUFFER, rn.buf), ye.vertexAttribPointer(rn.loc, zt, ye.FLOAT, !1, 0, 0), ye.enableVertexAttribArray(rn.loc), Xe ? ye.vertexAttribDivisor(rn.loc, Ut) : _t("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(rn.loc, Ut), tt !== rn.data && (ye.bufferData(ye.ARRAY_BUFFER, tt, Nt), rn.data = tt);
                  }
                });
              }
            };
          }
          st[vt].transaction(ft);
        }, He = function(vt, bt) {
          ot++;
          try {
            ye.activeTexture(ye.TEXTURE0 + ot);
            var Qt = Ue[vt];
            Qt || (Qt = Ue[vt] = ye.createTexture(), ye.bindTexture(ye.TEXTURE_2D, Qt), ye.texParameteri(ye.TEXTURE_2D, ye.TEXTURE_MIN_FILTER, ye.NEAREST), ye.texParameteri(ye.TEXTURE_2D, ye.TEXTURE_MAG_FILTER, ye.NEAREST)), ye.bindTexture(ye.TEXTURE_2D, Qt), bt(Qt, ot);
          } finally {
            ot--;
          }
        }, et = function(vt, bt, Qt) {
          var ft = ye.createFramebuffer();
          rt.push(ft), ye.bindFramebuffer(ye.FRAMEBUFFER, ft), ye.activeTexture(ye.TEXTURE0 + bt), ye.bindTexture(ye.TEXTURE_2D, vt), ye.framebufferTexture2D(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_2D, vt, 0);
          try {
            Qt(ft);
          } finally {
            ye.deleteFramebuffer(ft), ye.bindFramebuffer(ye.FRAMEBUFFER, rt[--rt.length - 1] || null);
          }
        }, mt = function() {
          Je = {}, st = {}, Ue = {}, ot = -1, rt.length = 0;
        };
        var Xe = typeof WebGL2RenderingContext < "u" && ye instanceof WebGL2RenderingContext, Je = {}, st = {}, Ue = {}, ot = -1, rt = [];
        ye.canvas.addEventListener("webglcontextlost", function(vt) {
          mt(), vt.preventDefault();
        }, !1), h.set(ye, we = {
          gl: ye,
          isWebGL2: Xe,
          getExtension: _t,
          withProgram: Ot,
          withTexture: He,
          withTextureFramebuffer: et,
          handleContextLoss: mt
        });
      }
      ue(we);
    }
    function _(fe, ue, ye, we, Xe, Je, st, Ue) {
      st === void 0 && (st = 15), Ue === void 0 && (Ue = null), S(fe, function(ot) {
        var rt = ot.gl, _t = ot.withProgram, Rt = ot.withTexture;
        Rt("copy", function(Ot, He) {
          rt.texImage2D(rt.TEXTURE_2D, 0, rt.RGBA, Xe, Je, 0, rt.RGBA, rt.UNSIGNED_BYTE, ue), _t("copy", l, d, function(et) {
            var mt = et.setUniform, vt = et.setAttribute;
            vt("aUV", 2, rt.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), mt("1i", "image", He), rt.bindFramebuffer(rt.FRAMEBUFFER, Ue || null), rt.disable(rt.BLEND), rt.colorMask(st & 8, st & 4, st & 2, st & 1), rt.viewport(ye, we, Xe, Je), rt.scissor(ye, we, Xe, Je), rt.drawArrays(rt.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function T(fe, ue, ye) {
      var we = fe.width, Xe = fe.height;
      S(fe, function(Je) {
        var st = Je.gl, Ue = new Uint8Array(we * Xe * 4);
        st.readPixels(0, 0, we, Xe, st.RGBA, st.UNSIGNED_BYTE, Ue), fe.width = ue, fe.height = ye, _(st, Ue, 0, 0, we, Xe);
      });
    }
    var C = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: S,
      renderImageData: _,
      resizeWebGLCanvasWithoutClearing: T
    });
    function D(fe, ue, ye, we, Xe, Je) {
      Je === void 0 && (Je = 1);
      var st = new Uint8Array(fe * ue), Ue = we[2] - we[0], ot = we[3] - we[1], rt = [];
      o(ye, function(vt, bt, Qt, ft) {
        rt.push({
          x1: vt,
          y1: bt,
          x2: Qt,
          y2: ft,
          minX: Math.min(vt, Qt),
          minY: Math.min(bt, ft),
          maxX: Math.max(vt, Qt),
          maxY: Math.max(bt, ft)
        });
      }), rt.sort(function(vt, bt) {
        return vt.maxX - bt.maxX;
      });
      for (var _t = 0; _t < fe; _t++)
        for (var Rt = 0; Rt < ue; Rt++) {
          var Ot = et(
            we[0] + Ue * (_t + 0.5) / fe,
            we[1] + ot * (Rt + 0.5) / ue
          ), He = Math.pow(1 - Math.abs(Ot) / Xe, Je) / 2;
          Ot < 0 && (He = 1 - He), He = Math.max(0, Math.min(255, Math.round(He * 255))), st[Rt * fe + _t] = He;
        }
      return st;
      function et(vt, bt) {
        for (var Qt = 1 / 0, ft = 1 / 0, Vt = rt.length; Vt--; ) {
          var Jt = rt[Vt];
          if (Jt.maxX + ft <= vt)
            break;
          if (vt + ft > Jt.minX && bt - ft < Jt.maxY && bt + ft > Jt.minY) {
            var Mt = B(vt, bt, Jt.x1, Jt.y1, Jt.x2, Jt.y2);
            Mt < Qt && (Qt = Mt, ft = Math.sqrt(Qt));
          }
        }
        return mt(vt, bt) && (ft = -ft), ft;
      }
      function mt(vt, bt) {
        for (var Qt = 0, ft = rt.length; ft--; ) {
          var Vt = rt[ft];
          if (Vt.maxX <= vt)
            break;
          var Jt = Vt.y1 > bt != Vt.y2 > bt && vt < (Vt.x2 - Vt.x1) * (bt - Vt.y1) / (Vt.y2 - Vt.y1) + Vt.x1;
          Jt && (Qt += Vt.y1 < Vt.y2 ? 1 : -1);
        }
        return Qt !== 0;
      }
    }
    function P(fe, ue, ye, we, Xe, Je, st, Ue, ot, rt) {
      Je === void 0 && (Je = 1), Ue === void 0 && (Ue = 0), ot === void 0 && (ot = 0), rt === void 0 && (rt = 0), U(fe, ue, ye, we, Xe, Je, st, null, Ue, ot, rt);
    }
    function U(fe, ue, ye, we, Xe, Je, st, Ue, ot, rt, _t) {
      Je === void 0 && (Je = 1), ot === void 0 && (ot = 0), rt === void 0 && (rt = 0), _t === void 0 && (_t = 0);
      for (var Rt = D(fe, ue, ye, we, Xe, Je), Ot = new Uint8Array(Rt.length * 4), He = 0; He < Rt.length; He++)
        Ot[He * 4 + _t] = Rt[He];
      _(st, Ot, ot, rt, fe, ue, 1 << 3 - _t, Ue);
    }
    function B(fe, ue, ye, we, Xe, Je) {
      var st = Xe - ye, Ue = Je - we, ot = st * st + Ue * Ue, rt = ot ? Math.max(0, Math.min(1, ((fe - ye) * st + (ue - we) * Ue) / ot)) : 0, _t = fe - (ye + rt * st), Rt = ue - (we + rt * Ue);
      return _t * _t + Rt * Rt;
    }
    var k = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: D,
      generateIntoCanvas: P,
      generateIntoFramebuffer: U
    }), V = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", I = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", X = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", J = new Float32Array([0, 0, 2, 0, 0, 2]), $ = null, W = !1, ee = {}, ie = /* @__PURE__ */ new WeakMap();
    function pe(fe) {
      if (!W && !Fe(fe))
        throw new Error("WebGL generation not supported");
    }
    function ce(fe, ue, ye, we, Xe, Je, st) {
      if (Je === void 0 && (Je = 1), st === void 0 && (st = null), !st && (st = $, !st)) {
        var Ue = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Ue)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        st = $ = Ue.getContext("webgl", { depth: !1 });
      }
      pe(st);
      var ot = new Uint8Array(fe * ue * 4);
      S(st, function(Ot) {
        var He = Ot.gl, et = Ot.withTexture, mt = Ot.withTextureFramebuffer;
        et("readable", function(vt, bt) {
          He.texImage2D(He.TEXTURE_2D, 0, He.RGBA, fe, ue, 0, He.RGBA, He.UNSIGNED_BYTE, null), mt(vt, bt, function(Qt) {
            de(
              fe,
              ue,
              ye,
              we,
              Xe,
              Je,
              He,
              Qt,
              0,
              0,
              0
            ), He.readPixels(0, 0, fe, ue, He.RGBA, He.UNSIGNED_BYTE, ot);
          });
        });
      });
      for (var rt = new Uint8Array(fe * ue), _t = 0, Rt = 0; _t < ot.length; _t += 4)
        rt[Rt++] = ot[_t];
      return rt;
    }
    function Ee(fe, ue, ye, we, Xe, Je, st, Ue, ot, rt) {
      Je === void 0 && (Je = 1), Ue === void 0 && (Ue = 0), ot === void 0 && (ot = 0), rt === void 0 && (rt = 0), de(fe, ue, ye, we, Xe, Je, st, null, Ue, ot, rt);
    }
    function de(fe, ue, ye, we, Xe, Je, st, Ue, ot, rt, _t) {
      Je === void 0 && (Je = 1), ot === void 0 && (ot = 0), rt === void 0 && (rt = 0), _t === void 0 && (_t = 0), pe(st);
      var Rt = [];
      o(ye, function(Ot, He, et, mt) {
        Rt.push(Ot, He, et, mt);
      }), Rt = new Float32Array(Rt), S(st, function(Ot) {
        var He = Ot.gl, et = Ot.isWebGL2, mt = Ot.getExtension, vt = Ot.withProgram, bt = Ot.withTexture, Qt = Ot.withTextureFramebuffer, ft = Ot.handleContextLoss;
        if (bt("rawDistances", function(Vt, Jt) {
          (fe !== Vt._lastWidth || ue !== Vt._lastHeight) && He.texImage2D(
            He.TEXTURE_2D,
            0,
            He.RGBA,
            Vt._lastWidth = fe,
            Vt._lastHeight = ue,
            0,
            He.RGBA,
            He.UNSIGNED_BYTE,
            null
          ), vt("main", V, I, function(Mt) {
            var Me = Mt.setAttribute, oe = Mt.setUniform, je = !et && mt("ANGLE_instanced_arrays"), lt = !et && mt("EXT_blend_minmax");
            Me("aUV", 2, He.STATIC_DRAW, 0, J), Me("aLineSegment", 4, He.DYNAMIC_DRAW, 1, Rt), oe.apply(void 0, ["4f", "uGlyphBounds"].concat(we)), oe("1f", "uMaxDistance", Xe), oe("1f", "uExponent", Je), Qt(Vt, Jt, function(zt) {
              He.enable(He.BLEND), He.colorMask(!0, !0, !0, !0), He.viewport(0, 0, fe, ue), He.scissor(0, 0, fe, ue), He.blendFunc(He.ONE, He.ONE), He.blendEquationSeparate(He.FUNC_ADD, et ? He.MAX : lt.MAX_EXT), He.clear(He.COLOR_BUFFER_BIT), et ? He.drawArraysInstanced(He.TRIANGLES, 0, 3, Rt.length / 4) : je.drawArraysInstancedANGLE(He.TRIANGLES, 0, 3, Rt.length / 4);
            });
          }), vt("post", l, X, function(Mt) {
            Mt.setAttribute("aUV", 2, He.STATIC_DRAW, 0, J), Mt.setUniform("1i", "tex", Jt), He.bindFramebuffer(He.FRAMEBUFFER, Ue), He.disable(He.BLEND), He.colorMask(_t === 0, _t === 1, _t === 2, _t === 3), He.viewport(ot, rt, fe, ue), He.scissor(ot, rt, fe, ue), He.drawArrays(He.TRIANGLES, 0, 3);
          });
        }), He.isContextLost())
          throw ft(), new Error("webgl context lost");
      });
    }
    function Fe(fe) {
      var ue = !fe || fe === $ ? ee : fe.canvas || fe, ye = ie.get(ue);
      if (ye === void 0) {
        W = !0;
        var we = null;
        try {
          var Xe = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], Je = ce(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            fe
          );
          ye = Je && Xe.length === Je.length && Je.every(function(st, Ue) {
            return st === Xe[Ue];
          }), ye || (we = "bad trial run results", console.info(Xe, Je));
        } catch (st) {
          ye = !1, we = st.message;
        }
        we && console.warn("WebGL SDF generation not supported:", we), W = !1, ie.set(ue, ye);
      }
      return ye;
    }
    var Ce = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: ce,
      generateIntoCanvas: Ee,
      generateIntoFramebuffer: de,
      isSupported: Fe
    });
    function Be(fe, ue, ye, we, Xe, Je) {
      Xe === void 0 && (Xe = Math.max(we[2] - we[0], we[3] - we[1]) / 2), Je === void 0 && (Je = 1);
      try {
        return ce.apply(Ce, arguments);
      } catch (st) {
        return console.info("WebGL SDF generation failed, falling back to JS", st), D.apply(k, arguments);
      }
    }
    function he(fe, ue, ye, we, Xe, Je, st, Ue, ot, rt) {
      Xe === void 0 && (Xe = Math.max(we[2] - we[0], we[3] - we[1]) / 2), Je === void 0 && (Je = 1), Ue === void 0 && (Ue = 0), ot === void 0 && (ot = 0), rt === void 0 && (rt = 0);
      try {
        return Ee.apply(Ce, arguments);
      } catch (_t) {
        return console.info("WebGL SDF generation failed, falling back to JS", _t), P.apply(k, arguments);
      }
    }
    return e.forEachPathCommand = i, e.generate = Be, e.generateIntoCanvas = he, e.javascript = k, e.pathToLineSegments = o, e.webgl = Ce, e.webglUtils = C, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return a;
}
function Vj() {
  var a = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, i = {};
    r.L = 1, i[1] = "L", Object.keys(t).forEach(function(ft, Vt) {
      r[ft] = 1 << Vt + 1, i[r[ft]] = ft;
    }), Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI, l = r.L | r.R | r.AL, d = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, h = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, m = r.S | r.WS | r.B | o | r.PDI | h, S = null;
    function _() {
      if (!S) {
        S = /* @__PURE__ */ new Map();
        var ft = function(Jt) {
          if (t.hasOwnProperty(Jt)) {
            var Mt = 0;
            t[Jt].split(",").forEach(function(Me) {
              var oe = Me.split("+"), je = oe[0], lt = oe[1];
              je = parseInt(je, 36), lt = lt ? parseInt(lt, 36) : 0, S.set(Mt += je, r[Jt]);
              for (var zt = 0; zt < lt; zt++)
                S.set(++Mt, r[Jt]);
            });
          }
        };
        for (var Vt in t)
          ft(Vt);
      }
    }
    function T(ft) {
      return _(), S.get(ft.codePointAt(0)) || r.L;
    }
    function C(ft) {
      return i[T(ft)];
    }
    var D = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function P(ft, Vt) {
      var Jt = 36, Mt = 0, Me = /* @__PURE__ */ new Map(), oe = Vt && /* @__PURE__ */ new Map(), je;
      return ft.split(",").forEach(function lt(zt) {
        if (zt.indexOf("+") !== -1)
          for (var Nt = +zt; Nt--; )
            lt(je);
        else {
          je = zt;
          var Ut = zt.split(">"), tt = Ut[0], rn = Ut[1];
          tt = String.fromCodePoint(Mt += parseInt(tt, Jt)), rn = String.fromCodePoint(Mt += parseInt(rn, Jt)), Me.set(tt, rn), Vt && oe.set(rn, tt);
        }
      }), { map: Me, reverseMap: oe };
    }
    var U, B, k;
    function V() {
      if (!U) {
        var ft = P(D.pairs, !0), Vt = ft.map, Jt = ft.reverseMap;
        U = Vt, B = Jt, k = P(D.canonical, !1).map;
      }
    }
    function I(ft) {
      return V(), U.get(ft) || null;
    }
    function X(ft) {
      return V(), B.get(ft) || null;
    }
    function J(ft) {
      return V(), k.get(ft) || null;
    }
    var $ = r.L, W = r.R, ee = r.EN, ie = r.ES, pe = r.ET, ce = r.AN, Ee = r.CS, de = r.B, Fe = r.S, Ce = r.ON, Be = r.BN, he = r.NSM, fe = r.AL, ue = r.LRO, ye = r.RLO, we = r.LRE, Xe = r.RLE, Je = r.PDF, st = r.LRI, Ue = r.RLI, ot = r.FSI, rt = r.PDI;
    function _t(ft, Vt) {
      for (var Jt = 125, Mt = new Uint32Array(ft.length), Me = 0; Me < ft.length; Me++)
        Mt[Me] = T(ft[Me]);
      var oe = /* @__PURE__ */ new Map();
      function je(za, Xs) {
        var Jr = Mt[za];
        Mt[za] = Xs, oe.set(Jr, oe.get(Jr) - 1), Jr & d && oe.set(d, oe.get(d) - 1), oe.set(Xs, (oe.get(Xs) || 0) + 1), Xs & d && oe.set(d, (oe.get(d) || 0) + 1);
      }
      for (var lt = new Uint8Array(ft.length), zt = /* @__PURE__ */ new Map(), Nt = [], Ut = null, tt = 0; tt < ft.length; tt++)
        Ut || Nt.push(Ut = {
          start: tt,
          end: ft.length - 1,
          level: Vt === "rtl" ? 1 : Vt === "ltr" ? 0 : xo(tt, !1)
        }), Mt[tt] & de && (Ut.end = tt, Ut = null);
      for (var rn = Xe | we | ye | ue | o | rt | Je | de, ze = function(za) {
        return za + (za & 1 ? 1 : 2);
      }, xe = function(za) {
        return za + (za & 1 ? 2 : 1);
      }, Ie = 0; Ie < Nt.length; Ie++) {
        Ut = Nt[Ie];
        var it = [{
          _level: Ut.level,
          _override: 0,
          _isolate: 0
        }], at = void 0, hn = 0, De = 0, Tt = 0;
        oe.clear();
        for (var Ne = Ut.start; Ne <= Ut.end; Ne++) {
          var Gt = Mt[Ne];
          if (at = it[it.length - 1], oe.set(Gt, (oe.get(Gt) || 0) + 1), Gt & d && oe.set(d, (oe.get(d) || 0) + 1), Gt & rn)
            if (Gt & (Xe | we)) {
              lt[Ne] = at._level;
              var Pt = (Gt === Xe ? xe : ze)(at._level);
              Pt <= Jt && !hn && !De ? it.push({
                _level: Pt,
                _override: 0,
                _isolate: 0
              }) : hn || De++;
            } else if (Gt & (ye | ue)) {
              lt[Ne] = at._level;
              var fn = (Gt === ye ? xe : ze)(at._level);
              fn <= Jt && !hn && !De ? it.push({
                _level: fn,
                _override: Gt & ye ? W : $,
                _isolate: 0
              }) : hn || De++;
            } else if (Gt & o) {
              Gt & ot && (Gt = xo(Ne + 1, !0) === 1 ? Ue : st), lt[Ne] = at._level, at._override && je(Ne, at._override);
              var Gr = (Gt === Ue ? xe : ze)(at._level);
              Gr <= Jt && hn === 0 && De === 0 ? (Tt++, it.push({
                _level: Gr,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Ne
              })) : hn++;
            } else if (Gt & rt) {
              if (hn > 0)
                hn--;
              else if (Tt > 0) {
                for (De = 0; !it[it.length - 1]._isolate; )
                  it.pop();
                var Wr = it[it.length - 1]._isolInitIndex;
                Wr != null && (zt.set(Wr, Ne), zt.set(Ne, Wr)), it.pop(), Tt--;
              }
              at = it[it.length - 1], lt[Ne] = at._level, at._override && je(Ne, at._override);
            } else
              Gt & Je ? (hn === 0 && (De > 0 ? De-- : !at._isolate && it.length > 1 && (it.pop(), at = it[it.length - 1])), lt[Ne] = at._level) : Gt & de && (lt[Ne] = Ut.level);
          else
            lt[Ne] = at._level, at._override && Gt !== Be && je(Ne, at._override);
        }
        for (var Ur = [], ir = null, Vn = Ut.start; Vn <= Ut.end; Vn++) {
          var jr = Mt[Vn];
          if (!(jr & h)) {
            var ti = lt[Vn], ki = jr & o, Wi = jr === rt;
            ir && ti === ir._level ? (ir._end = Vn, ir._endsWithIsolInit = ki) : Ur.push(ir = {
              _start: Vn,
              _end: Vn,
              _level: ti,
              _startsWithPDI: Wi,
              _endsWithIsolInit: ki
            });
          }
        }
        for (var ni = [], ji = 0; ji < Ur.length; ji++) {
          var Si = Ur[ji];
          if (!Si._startsWithPDI || Si._startsWithPDI && !zt.has(Si._start)) {
            for (var Te = [ir = Si], ct = void 0; ir && ir._endsWithIsolInit && (ct = zt.get(ir._end)) != null; )
              for (var me = ji + 1; me < Ur.length; me++)
                if (Ur[me]._start === ct) {
                  Te.push(ir = Ur[me]);
                  break;
                }
            for (var Oe = [], qe = 0; qe < Te.length; qe++)
              for (var on = Te[qe], yn = on._start; yn <= on._end; yn++)
                Oe.push(yn);
            for (var Rn = lt[Oe[0]], mn = Ut.level, vn = Oe[0] - 1; vn >= 0; vn--)
              if (!(Mt[vn] & h)) {
                mn = lt[vn];
                break;
              }
            var Zn = Oe[Oe.length - 1], nr = lt[Zn], br = Ut.level;
            if (!(Mt[Zn] & o)) {
              for (var Yi = Zn + 1; Yi <= Ut.end; Yi++)
                if (!(Mt[Yi] & h)) {
                  br = lt[Yi];
                  break;
                }
            }
            ni.push({
              _seqIndices: Oe,
              _sosType: Math.max(mn, Rn) % 2 ? W : $,
              _eosType: Math.max(br, nr) % 2 ? W : $
            });
          }
        }
        for (var La = 0; La < ni.length; La++) {
          var Ys = ni[La], $t = Ys._seqIndices, Zr = Ys._sosType, ls = Ys._eosType;
          if (oe.get(he))
            for (var Xn = 0; Xn < $t.length; Xn++) {
              var qa = $t[Xn];
              if (Mt[qa] & he) {
                for (var mo = Zr, Ds = Xn - 1; Ds >= 0; Ds--)
                  if (!(Mt[$t[Ds]] & h)) {
                    mo = Mt[$t[Ds]];
                    break;
                  }
                je(qa, mo & (o | rt) ? Ce : mo);
              }
            }
          if (oe.get(ee))
            for (var us = 0; us < $t.length; us++) {
              var mr = $t[us];
              if (Mt[mr] & ee)
                for (var pi = us - 1; pi >= -1; pi--) {
                  var Ea = pi === -1 ? Zr : Mt[$t[pi]];
                  if (Ea & l) {
                    Ea === fe && je(mr, ce);
                    break;
                  }
                }
            }
          if (oe.get(fe))
            for (var _i = 0; _i < $t.length; _i++) {
              var Ti = $t[_i];
              Mt[Ti] & fe && je(Ti, W);
            }
          if (oe.get(ie) || oe.get(Ee))
            for (var Oo = 1; Oo < $t.length - 1; Oo++) {
              var Uo = $t[Oo];
              if (Mt[Uo] & (ie | Ee)) {
                for (var Pa = 0, Rl = 0, vo = Oo - 1; vo >= 0 && (Pa = Mt[$t[vo]], !!(Pa & h)); vo--)
                  ;
                for (var Wf = Oo + 1; Wf < $t.length && (Rl = Mt[$t[Wf]], !!(Rl & h)); Wf++)
                  ;
                Pa === Rl && (Mt[Uo] === ie ? Pa === ee : Pa & (ee | ce)) && je(Uo, Pa);
              }
            }
          if (oe.get(ee))
            for (var Al = 0; Al < $t.length; Al++) {
              var zd = $t[Al];
              if (Mt[zd] & ee) {
                for (var Ls = Al - 1; Ls >= 0 && Mt[$t[Ls]] & (pe | h); Ls--)
                  je($t[Ls], ee);
                for (var Ju = Al + 1; Ju < $t.length && Mt[$t[Ju]] & (pe | h); Ju++)
                  je($t[Ju], ee);
              }
            }
          if (oe.get(pe) || oe.get(ie) || oe.get(Ee))
            for (var au = 0; au < $t.length; au++) {
              var qh = $t[au];
              if (Mt[qh] & (pe | ie | Ee)) {
                je(qh, Ce);
                for (var Dl = au - 1; Dl >= 0 && Mt[$t[Dl]] & h; Dl--)
                  je($t[Dl], Ce);
                for (var ri = au + 1; ri < $t.length && Mt[$t[ri]] & h; ri++)
                  je($t[ri], Ce);
              }
            }
          if (oe.get(ee))
            for (var go = 0, jf = Zr; go < $t.length; go++) {
              var zo = $t[go], Ci = Mt[zo];
              Ci & ee ? jf === $ && je(zo, $) : Ci & l && (jf = Ci);
            }
          if (oe.get(d)) {
            var cs = W | ee | ce, Yf = cs | $, xr = [];
            {
              for (var Eu = [], ua = 0; ua < $t.length; ua++)
                if (Mt[$t[ua]] & d) {
                  var Cr = ft[$t[ua]], fl = void 0;
                  if (I(Cr) !== null)
                    if (Eu.length < 63)
                      Eu.push({ char: Cr, seqIndex: ua });
                    else
                      break;
                  else if ((fl = X(Cr)) !== null)
                    for (var yo = Eu.length - 1; yo >= 0; yo--) {
                      var Ka = Eu[yo].char;
                      if (Ka === fl || Ka === X(J(Cr)) || I(J(Ka)) === Cr) {
                        xr.push([Eu[yo].seqIndex, ua]), Eu.length = yo;
                        break;
                      }
                    }
                }
              xr.sort(function(za, Xs) {
                return za[0] - Xs[0];
              });
            }
            for (var Xi = 0; Xi < xr.length; Xi++) {
              for (var Rm = xr[Xi], mi = Rm[0], Qa = Rm[1], Sc = !1, dl = 0, df = mi + 1; df < Qa; df++) {
                var hf = $t[df];
                if (Mt[hf] & Yf) {
                  Sc = !0;
                  var su = Mt[hf] & cs ? W : $;
                  if (su === Pl(hf)) {
                    dl = su;
                    break;
                  }
                }
              }
              if (Sc && !dl) {
                dl = Zr;
                for (var Ii = mi - 1; Ii >= 0; Ii--) {
                  var Ri = $t[Ii];
                  if (Mt[Ri] & Yf) {
                    var No = Mt[Ri] & cs ? W : $;
                    No !== Pl(Ri) ? dl = No : dl = Pl(Ri);
                    break;
                  }
                }
              }
              if (dl) {
                if (Mt[$t[mi]] = Mt[$t[Qa]] = dl, dl !== Pl($t[mi])) {
                  for (var Ps = mi + 1; Ps < $t.length; Ps++)
                    if (!(Mt[$t[Ps]] & h)) {
                      T(ft[$t[Ps]]) & he && (Mt[$t[Ps]] = dl);
                      break;
                    }
                }
                if (dl !== Pl($t[Qa])) {
                  for (var _c = Qa + 1; _c < $t.length; _c++)
                    if (!(Mt[$t[_c]] & h)) {
                      T(ft[$t[_c]]) & he && (Mt[$t[_c]] = dl);
                      break;
                    }
                }
              }
            }
            for (var Ll = 0; Ll < $t.length; Ll++)
              if (Mt[$t[Ll]] & d) {
                for (var Xf = Ll, qf = Ll, Fo = Zr, Qf = Ll - 1; Qf >= 0; Qf--)
                  if (Mt[$t[Qf]] & h)
                    Xf = Qf;
                  else {
                    Fo = Mt[$t[Qf]] & cs ? W : $;
                    break;
                  }
                for (var Ki = ls, Mu = Ll + 1; Mu < $t.length; Mu++)
                  if (Mt[$t[Mu]] & (d | h))
                    qf = Mu;
                  else {
                    Ki = Mt[$t[Mu]] & cs ? W : $;
                    break;
                  }
                for (var Oa = Xf; Oa <= qf; Oa++)
                  Mt[$t[Oa]] = Fo === Ki ? Fo : Pl($t[Oa]);
                Ll = qf;
              }
          }
        }
        for (var ys = Ut.start; ys <= Ut.end; ys++) {
          var ou = lt[ys], Ua = Mt[ys];
          if (ou & 1 ? Ua & ($ | ee | ce) && lt[ys]++ : Ua & W ? lt[ys]++ : Ua & (ce | ee) && (lt[ys] += 2), Ua & h && (lt[ys] = ys === 0 ? Ut.level : lt[ys - 1]), ys === Ut.end || T(ft[ys]) & (Fe | de))
            for (var bc = ys; bc >= 0 && T(ft[bc]) & m; bc--)
              lt[bc] = Ut.level;
        }
      }
      return {
        levels: lt,
        paragraphs: Nt
      };
      function xo(za, Xs) {
        for (var Jr = za; Jr < ft.length; Jr++) {
          var xs = Mt[Jr];
          if (xs & (W | fe))
            return 1;
          if (xs & (de | $) || Xs && xs === rt)
            return 0;
          if (xs & o) {
            var va = Tu(Jr);
            Jr = va === -1 ? ft.length : va;
          }
        }
        return 0;
      }
      function Tu(za) {
        for (var Xs = 1, Jr = za + 1; Jr < ft.length; Jr++) {
          var xs = Mt[Jr];
          if (xs & de)
            break;
          if (xs & rt) {
            if (--Xs === 0)
              return Jr;
          } else
            xs & o && Xs++;
        }
        return -1;
      }
      function Pl(za) {
        return lt[za] & 1 ? W : $;
      }
    }
    var Rt = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", Ot;
    function He() {
      if (!Ot) {
        var ft = P(Rt, !0), Vt = ft.map, Jt = ft.reverseMap;
        Jt.forEach(function(Mt, Me) {
          Vt.set(Me, Mt);
        }), Ot = Vt;
      }
    }
    function et(ft) {
      return He(), Ot.get(ft) || null;
    }
    function mt(ft, Vt, Jt, Mt) {
      var Me = ft.length;
      Jt = Math.max(0, Jt == null ? 0 : +Jt), Mt = Math.min(Me - 1, Mt == null ? Me - 1 : +Mt);
      for (var oe = /* @__PURE__ */ new Map(), je = Jt; je <= Mt; je++)
        if (Vt[je] & 1) {
          var lt = et(ft[je]);
          lt !== null && oe.set(je, lt);
        }
      return oe;
    }
    function vt(ft, Vt, Jt, Mt) {
      var Me = ft.length;
      Jt = Math.max(0, Jt == null ? 0 : +Jt), Mt = Math.min(Me - 1, Mt == null ? Me - 1 : +Mt);
      var oe = [];
      return Vt.paragraphs.forEach(function(je) {
        var lt = Math.max(Jt, je.start), zt = Math.min(Mt, je.end);
        if (lt < zt) {
          for (var Nt = Vt.levels.slice(lt, zt + 1), Ut = zt; Ut >= lt && T(ft[Ut]) & m; Ut--)
            Nt[Ut] = je.level;
          for (var tt = je.level, rn = 1 / 0, ze = 0; ze < Nt.length; ze++) {
            var xe = Nt[ze];
            xe > tt && (tt = xe), xe < rn && (rn = xe | 1);
          }
          for (var Ie = tt; Ie >= rn; Ie--)
            for (var it = 0; it < Nt.length; it++)
              if (Nt[it] >= Ie) {
                for (var at = it; it + 1 < Nt.length && Nt[it + 1] >= Ie; )
                  it++;
                it > at && oe.push([at + Jt, it + Jt]);
              }
        }
      }), oe;
    }
    function bt(ft, Vt, Jt, Mt) {
      var Me = Qt(ft, Vt, Jt, Mt), oe = [].concat(ft);
      return Me.forEach(function(je, lt) {
        oe[lt] = (Vt.levels[je] & 1 ? et(ft[je]) : null) || ft[je];
      }), oe.join("");
    }
    function Qt(ft, Vt, Jt, Mt) {
      for (var Me = vt(ft, Vt, Jt, Mt), oe = [], je = 0; je < ft.length; je++)
        oe[je] = je;
      return Me.forEach(function(lt) {
        for (var zt = lt[0], Nt = lt[1], Ut = oe.slice(zt, Nt + 1), tt = Ut.length; tt--; )
          oe[Nt - tt] = Ut[tt];
      }), oe;
    }
    return e.closingToOpeningBracket = X, e.getBidiCharType = T, e.getBidiCharTypeName = C, e.getCanonicalBracket = J, e.getEmbeddingLevels = _t, e.getMirroredCharacter = et, e.getMirroredCharactersMap = mt, e.getReorderSegments = vt, e.getReorderedIndices = Qt, e.getReorderedString = bt, e.openingToClosingBracket = I, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return a;
}
const J4 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function P3(a) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let o = na[i];
    return o ? P3(o) : r;
  }
  return a.replace(e, t);
}
const Pd = [];
for (let a = 0; a < 256; a++)
  Pd[a] = (a < 16 ? "0" : "") + a.toString(16);
function Gj() {
  const a = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Pd[a & 255] + Pd[a >> 8 & 255] + Pd[a >> 16 & 255] + Pd[a >> 24 & 255] + "-" + Pd[e & 255] + Pd[e >> 8 & 255] + "-" + Pd[e >> 16 & 15 | 64] + Pd[e >> 24 & 255] + "-" + Pd[t & 63 | 128] + Pd[t >> 8 & 255] + "-" + Pd[t >> 16 & 255] + Pd[t >> 24 & 255] + Pd[r & 255] + Pd[r >> 8 & 255] + Pd[r >> 16 & 255] + Pd[r >> 24 & 255]).toUpperCase();
}
const bS = Object.assign || function() {
  let a = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let i in r)
        r.hasOwnProperty(i) && (a[i] = r[i]);
  }
  return a;
}, Wj = Date.now(), kz = /* @__PURE__ */ new WeakMap(), Iz = /* @__PURE__ */ new Map();
let jj = 1e10;
function O3(a, e) {
  const t = Qj(e);
  let r = kz.get(a);
  if (r || kz.set(a, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const i = `_onBeforeCompile${t}`, o = function(m) {
    a.onBeforeCompile.call(this, m);
    const S = this.customProgramCacheKey() + "|" + m.vertexShader + "|" + m.fragmentShader;
    let _ = Iz[S];
    if (!_) {
      const T = Yj(m, e, t);
      _ = Iz[S] = T;
    }
    m.vertexShader = _.vertexShader, m.fragmentShader = _.fragmentShader, bS(m.uniforms, this.uniforms), e.timeUniform && (m.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - Wj;
      }
    }), this[i] && this[i](m);
  }, l = function() {
    return d(e.chained ? a : a.clone());
  }, d = function(m) {
    const S = Object.create(m, h);
    return Object.defineProperty(S, "baseMaterial", { value: a }), Object.defineProperty(S, "id", { value: jj++ }), S.uuid = Gj(), S.uniforms = bS({}, m.uniforms, e.uniforms), S.defines = bS({}, m.defines, e.defines), S.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", S.extensions = bS({}, m.extensions, e.extensions), S._listeners = void 0, S;
  }, h = {
    constructor: { value: l },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return a.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return o;
      },
      set(m) {
        this[i] = m;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(m) {
        return a.copy.call(this, m), !a.isShaderMaterial && !a.isDerivedMaterial && (bS(this.extensions, m.extensions), bS(this.defines, m.defines), bS(this.uniforms, $M.clone(m.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const m = new a.constructor();
        return d(m).copy(this);
      }
    },
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let m = this._depthMaterial;
        return m || (m = this._depthMaterial = O3(
          a.isDerivedMaterial ? a.getDepthMaterial() : new tT({ depthPacking: Zb }),
          e
        ), m.defines.IS_DEPTH_MATERIAL = "", m.uniforms = this.uniforms), m;
      }
    },
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let m = this._distanceMaterial;
        return m || (m = this._distanceMaterial = O3(
          a.isDerivedMaterial ? a.getDistanceMaterial() : new HC(),
          e
        ), m.defines.IS_DISTANCE_MATERIAL = "", m.uniforms = this.uniforms), m;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: m, _distanceMaterial: S } = this;
        m && m.dispose(), S && S.dispose(), a.dispose.call(this);
      }
    }
  };
  return r[t] = l, new l();
}
function Yj({ vertexShader: a, fragmentShader: e }, t, r) {
  let {
    vertexDefs: i,
    vertexMainIntro: o,
    vertexMainOutro: l,
    vertexTransform: d,
    fragmentDefs: h,
    fragmentMainIntro: m,
    fragmentMainOutro: S,
    fragmentColorTransform: _,
    customRewriter: T,
    timeUniform: C
  } = t;
  if (i = i || "", o = o || "", l = l || "", h = h || "", m = m || "", S = S || "", (d || T) && (a = P3(a)), (_ || T) && (e = e.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), e = P3(e)), T) {
    let D = T({ vertexShader: a, fragmentShader: e });
    a = D.vertexShader, e = D.fragmentShader;
  }
  if (_) {
    let D = [];
    e = e.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (P) => (D.push(P), "")
    ), S = `${_}
${D.join(`
`)}
${S}`;
  }
  if (C) {
    const D = `
uniform float ${C};
`;
    i = D + i, h = D + h;
  }
  return d && (a = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${a}
`, i = `${i}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${d}
}
`, o = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${o}
`, a = a.replace(/\b(position|normal|uv)\b/g, (D, P, U, B) => /\battribute\s+vec[23]\s+$/.test(B.substr(0, U)) ? P : `troika_${P}_${r}`)), a = Bz(a, r, i, o, l), e = Bz(e, r, h, m, S), {
    vertexShader: a,
    fragmentShader: e
  };
}
function Bz(a, e, t, r, i) {
  return (r || i || t) && (a = a.replace(
    J4,
    `
${t}
void troikaOrigMain${e}() {`
  ), a += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`), a;
}
function Xj(a, e) {
  return a === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let qj = 0;
const Hz = /* @__PURE__ */ new Map();
function Qj(a) {
  const e = JSON.stringify(a, Xj);
  let t = Hz.get(e);
  return t == null && Hz.set(e, t = ++qj), t;
}
function Zj(a, e, t) {
  const {
    defaultFontURL: r
  } = t, i = /* @__PURE__ */ Object.create(null), o = 1 / 0, l = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, d = /[\s\-\u007C\u00AD\u2010\u2012-\u2014\u2027\u2056\u2E17\u2E40]/;
  function h(B, k) {
    function V() {
      const I = (X) => {
        console.error(`Failure loading font ${B}${B === r ? "" : "; trying fallback"}`, X), B !== r && (B = r, V());
      };
      try {
        const X = new XMLHttpRequest();
        X.open("get", B, !0), X.responseType = "arraybuffer", X.onload = function() {
          if (X.status >= 400)
            I(new Error(X.statusText));
          else if (X.status > 0)
            try {
              const J = a(X.response);
              k(J);
            } catch (J) {
              I(J);
            }
        }, X.onerror = I, X.send();
      } catch (X) {
        I(X);
      }
    }
    V();
  }
  function m(B, k) {
    B || (B = r);
    let V = i[B];
    V ? V.pending ? V.pending.push(k) : k(V) : (i[B] = { pending: [k] }, h(B, (I) => {
      let X = i[B].pending;
      i[B] = I, X.forEach((J) => J(I));
    }));
  }
  function S({
    text: B = "",
    font: k = r,
    sdfGlyphSize: V = 64,
    fontSize: I = 1,
    letterSpacing: X = 0,
    lineHeight: J = "normal",
    maxWidth: $ = o,
    direction: W,
    textAlign: ee = "left",
    textIndent: ie = 0,
    whiteSpace: pe = "normal",
    overflowWrap: ce = "normal",
    anchorX: Ee = 0,
    anchorY: de = 0,
    includeCaretPositions: Fe = !1,
    chunkedBoundsSize: Ce = 8192,
    colorRanges: Be = null
  }, he, fe = !1) {
    const ue = D(), ye = { fontLoad: 0, typesetting: 0 };
    B.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), B = B.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), I = +I, X = +X, $ = +$, J = J || "normal", ie = +ie, m(k, (we) => {
      const Xe = isFinite($);
      let Je = null, st = null, Ue = null, ot = null, rt = null, _t = null, Rt = null, Ot = 0, He = 0, et = pe !== "nowrap";
      const { ascender: mt, descender: vt, unitsPerEm: bt } = we;
      ye.fontLoad = D() - ue;
      const Qt = D(), ft = I / bt;
      J === "normal" && (J = (mt - vt) / bt), J = J * I;
      const Vt = (J - (mt - vt) * ft) / 2, Jt = -(mt * ft + Vt), Mt = Math.min(J, (mt - vt) * ft), Me = (mt + vt) / 2 * ft - Mt / 2;
      let oe = ie, je = new P();
      const lt = [je];
      we.forEachGlyph(B, I, X, (Ut, tt, rn) => {
        const ze = B.charAt(rn), xe = Ut.advanceWidth * ft, Ie = je.count;
        let it;
        if ("isEmpty" in Ut || (Ut.isWhitespace = !!ze && /\s/.test(ze), Ut.canBreakAfter = !!ze && d.test(ze), Ut.isEmpty = Ut.xMin === Ut.xMax || Ut.yMin === Ut.yMax || l.test(ze)), !Ut.isWhitespace && !Ut.isEmpty && He++, et && Xe && !Ut.isWhitespace && tt + xe + oe > $ && Ie) {
          if (je.glyphAt(Ie - 1).glyphObj.canBreakAfter)
            it = new P(), oe = -tt;
          else
            for (let hn = Ie; hn--; )
              if (hn === 0 && ce === "break-word") {
                it = new P(), oe = -tt;
                break;
              } else if (je.glyphAt(hn).glyphObj.canBreakAfter) {
                it = je.splitAt(hn + 1);
                const De = it.glyphAt(0).x;
                oe -= De;
                for (let Tt = it.count; Tt--; )
                  it.glyphAt(Tt).x -= De;
                break;
              }
          it && (je.isSoftWrapped = !0, je = it, lt.push(je), Ot = $);
        }
        let at = je.glyphAt(je.count);
        at.glyphObj = Ut, at.x = tt + oe, at.width = xe, at.charIndex = rn, ze === `
` && (je = new P(), lt.push(je), oe = -(tt + xe + X * I) + ie);
      }), lt.forEach((Ut) => {
        for (let tt = Ut.count; tt--; ) {
          let { glyphObj: rn, x: ze, width: xe } = Ut.glyphAt(tt);
          if (!rn.isWhitespace) {
            Ut.width = ze + xe, Ut.width > Ot && (Ot = Ut.width);
            return;
          }
        }
      });
      let zt = 0, Nt = 0;
      if (Ee && (typeof Ee == "number" ? zt = -Ee : typeof Ee == "string" && (zt = -Ot * (Ee === "left" ? 0 : Ee === "center" ? 0.5 : Ee === "right" ? 1 : T(Ee)))), de) {
        if (typeof de == "number")
          Nt = -de;
        else if (typeof de == "string") {
          let Ut = lt.length * J;
          Nt = de === "top" ? 0 : de === "top-baseline" ? -Jt : de === "middle" ? Ut / 2 : de === "bottom" ? Ut : de === "bottom-baseline" ? Ut - Vt + vt * ft : T(de) * Ut;
        }
      }
      if (!fe) {
        const Ut = e.getEmbeddingLevels(B, W);
        Je = new Uint16Array(He), st = new Float32Array(He * 2), Ue = {}, _t = [o, o, -o, -o], Rt = [];
        let tt = Jt;
        Fe && (rt = new Float32Array(B.length * 3)), Be && (ot = new Uint8Array(He * 3));
        let rn = 0, ze = -1, xe = -1, Ie, it;
        if (lt.forEach((at, hn) => {
          let { count: De, width: Tt } = at;
          if (De > 0) {
            let Ne = 0;
            for (let Ur = De; Ur-- && at.glyphAt(Ur).glyphObj.isWhitespace; )
              Ne++;
            let Gt = 0, Pt = 0;
            if (ee === "center")
              Gt = (Ot - Tt) / 2;
            else if (ee === "right")
              Gt = Ot - Tt;
            else if (ee === "justify" && at.isSoftWrapped) {
              let Ur = 0;
              for (let ir = De - Ne; ir--; )
                at.glyphAt(ir).glyphObj.isWhitespace && Ur++;
              Pt = (Ot - Tt) / Ur;
            }
            if (Pt || Gt) {
              let Ur = 0;
              for (let ir = 0; ir < De; ir++) {
                let Vn = at.glyphAt(ir);
                const jr = Vn.glyphObj;
                Vn.x += Gt + Ur, Pt !== 0 && jr.isWhitespace && ir < De - Ne && (Ur += Pt, Vn.width += Pt);
              }
            }
            const fn = e.getReorderSegments(
              B,
              Ut,
              at.glyphAt(0).charIndex,
              at.glyphAt(at.count - 1).charIndex
            );
            for (let Ur = 0; Ur < fn.length; Ur++) {
              const [ir, Vn] = fn[Ur];
              let jr = 1 / 0, ti = -1 / 0;
              for (let ki = 0; ki < De; ki++)
                if (at.glyphAt(ki).charIndex >= ir) {
                  let Wi = ki, ni = ki;
                  for (; ni < De; ni++) {
                    let ji = at.glyphAt(ni);
                    if (ji.charIndex > Vn)
                      break;
                    ni < De - Ne && (jr = Math.min(jr, ji.x), ti = Math.max(ti, ji.x + ji.width));
                  }
                  for (let ji = Wi; ji < ni; ji++) {
                    const Si = at.glyphAt(ji);
                    Si.x = ti - (Si.x + Si.width - jr);
                  }
                  break;
                }
            }
            let Gr;
            const Wr = (Ur) => Gr = Ur;
            for (let Ur = 0; Ur < De; Ur++) {
              let ir = at.glyphAt(Ur);
              Gr = ir.glyphObj;
              const Vn = Gr.index, jr = Ut.levels[ir.charIndex] & 1;
              if (jr) {
                const ti = e.getMirroredCharacter(B[ir.charIndex]);
                ti && we.forEachGlyph(ti, 0, 0, Wr);
              }
              if (Fe) {
                const { charIndex: ti } = ir, ki = ir.x + zt, Wi = ir.x + ir.width + zt;
                rt[ti * 3] = jr ? Wi : ki, rt[ti * 3 + 1] = jr ? ki : Wi, rt[ti * 3 + 2] = tt + Me + Nt;
                const ni = ti - ze;
                ni > 1 && C(rt, ze, ni), ze = ti;
              }
              if (Be) {
                const { charIndex: ti } = ir;
                for (; ti > xe; )
                  xe++, Be.hasOwnProperty(xe) && (it = Be[xe]);
              }
              if (!Gr.isWhitespace && !Gr.isEmpty) {
                const ti = rn++;
                Ue[Vn] || (Ue[Vn] = {
                  path: Gr.path,
                  pathBounds: [Gr.xMin, Gr.yMin, Gr.xMax, Gr.yMax]
                });
                const ki = ir.x + zt, Wi = tt + Nt;
                st[ti * 2] = ki, st[ti * 2 + 1] = Wi;
                const ni = ki + Gr.xMin * ft, ji = Wi + Gr.yMin * ft, Si = ki + Gr.xMax * ft, Te = Wi + Gr.yMax * ft;
                ni < _t[0] && (_t[0] = ni), ji < _t[1] && (_t[1] = ji), Si > _t[2] && (_t[2] = Si), Te > _t[3] && (_t[3] = Te), ti % Ce === 0 && (Ie = { start: ti, end: ti, rect: [o, o, -o, -o] }, Rt.push(Ie)), Ie.end++;
                const ct = Ie.rect;
                if (ni < ct[0] && (ct[0] = ni), ji < ct[1] && (ct[1] = ji), Si > ct[2] && (ct[2] = Si), Te > ct[3] && (ct[3] = Te), Je[ti] = Vn, Be) {
                  const me = ti * 3;
                  ot[me] = it >> 16 & 255, ot[me + 1] = it >> 8 & 255, ot[me + 2] = it & 255;
                }
              }
            }
          }
          tt -= J;
        }), rt) {
          const at = B.length - ze;
          at > 1 && C(rt, ze, at);
        }
      }
      ye.typesetting = D() - Qt, he({
        glyphIds: Je,
        glyphPositions: st,
        glyphData: Ue,
        caretPositions: rt,
        caretHeight: Mt,
        glyphColors: ot,
        chunkedBounds: Rt,
        fontSize: I,
        unitsPerEm: bt,
        ascender: mt * ft,
        descender: vt * ft,
        lineHeight: J,
        topBaseline: Jt,
        blockBounds: [
          zt,
          Nt - lt.length * J,
          zt + Ot,
          Nt
        ],
        visibleBounds: _t,
        timings: ye
      });
    });
  }
  function _(B, k) {
    S(B, (V) => {
      const [I, X, J, $] = V.blockBounds;
      k({
        width: J - I,
        height: $ - X
      });
    }, { metricsOnly: !0 });
  }
  function T(B) {
    let k = B.match(/^([\d.]+)%$/), V = k ? parseFloat(k[1]) : NaN;
    return isNaN(V) ? 0 : V / 100;
  }
  function C(B, k, V) {
    const I = B[k * 3], X = B[k * 3 + 1], J = B[k * 3 + 2], $ = (X - I) / V;
    for (let W = 0; W < V; W++) {
      const ee = (k + W) * 3;
      B[ee] = I + $ * W, B[ee + 1] = I + $ * (W + 1), B[ee + 2] = J;
    }
  }
  function D() {
    return (self.performance || Date).now();
  }
  function P() {
    this.data = [];
  }
  const U = ["glyphObj", "x", "width", "charIndex"];
  return P.prototype = {
    width: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / U.length);
    },
    glyphAt(B) {
      let k = P.flyweight;
      return k.data = this.data, k.index = B, k;
    },
    splitAt(B) {
      let k = new P();
      return k.data = this.data.splice(B * U.length), k;
    }
  }, P.flyweight = U.reduce((B, k, V, I) => (Object.defineProperty(B, k, {
    get() {
      return this.data[this.index * U.length + V];
    },
    set(X) {
      this.data[this.index * U.length + V] = X;
    }
  }), B), { data: null, index: 0 }), {
    typeset: S,
    measure: _,
    loadFont: m
  };
}
const zS = () => (self.performance || Date).now(), $C = Z4();
let Vz;
function Jj(a, e, t, r, i, o, l, d, h, m, S = !0) {
  return S ? Kj(a, e, t, r, i, o, l, d, h, m).then(
    null,
    (_) => (Vz || (console.warn("WebGL SDF generation failed, falling back to JS", _), Vz = !0), Gz(a, e, t, r, i, o, l, d, h, m))
  ) : Gz(a, e, t, r, i, o, l, d, h, m);
}
const Kj = /* @__PURE__ */ function() {
  const a = [];
  let t = 0;
  function r() {
    const i = zS();
    for (; a.length && zS() - i < 5; )
      a.shift()();
    t = a.length ? setTimeout(r, 0) : 0;
  }
  return (...i) => {
    const o = O0();
    return a.push(() => {
      const l = zS();
      try {
        $C.webgl.generateIntoCanvas(...i), o.resolve({ timing: zS() - l });
      } catch (d) {
        o.reject(d);
      }
    }), t || (t = setTimeout(r, 0)), o;
  };
}(), Gz = /* @__PURE__ */ function() {
  const t = {};
  let r = 0;
  return function(i, o, l, d, h, m, S, _, T, C) {
    const D = "TroikaTextSDFGenerator_JS_" + r++ % 4;
    let P = t[D];
    return P || (P = t[D] = {
      workerModule: vw({
        name: D,
        workerId: D,
        dependencies: [
          Z4,
          zS
        ],
        init(U, B) {
          const k = U().javascript.generate;
          return function(...V) {
            const I = B();
            return {
              textureData: k(...V),
              timing: B() - I
            };
          };
        },
        getTransferables(U) {
          return [U.textureData.buffer];
        }
      }),
      requests: 0,
      idleTimer: null
    }), P.requests++, clearTimeout(P.idleTimer), P.workerModule(i, o, l, d, h, m).then(({ textureData: U, timing: B }) => {
      const k = zS(), V = new Uint8Array(U.length * 4);
      for (let I = 0; I < U.length; I++)
        V[I * 4 + C] = U[I];
      return $C.webglUtils.renderImageData(S, V, _, T, i, o, 1 << 3 - C), B += zS() - k, --P.requests === 0 && (P.idleTimer = setTimeout(() => {
        Ij(D);
      }, 2e3)), { timing: B };
    });
  };
}();
function $j(a) {
  a._warm || ($C.webgl.isSupported(a), a._warm = !0);
}
const eY = $C.webglUtils.resizeWebGLCanvasWithoutClearing;
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function tY() {
  return typeof window > "u" && (self.window = self), function(a) {
    var e = { parse: function(i) {
      var o = e._bin, l = new Uint8Array(i);
      if (o.readASCII(l, 0, 4) == "ttcf") {
        var d = 4;
        o.readUshort(l, d), d += 2, o.readUshort(l, d), d += 2;
        var h = o.readUint(l, d);
        d += 4;
        for (var m = [], S = 0; S < h; S++) {
          var _ = o.readUint(l, d);
          d += 4, m.push(e._readFont(l, _));
        }
        return m;
      }
      return [e._readFont(l, 0)];
    }, _readFont: function(i, o) {
      var l = e._bin, d = o;
      l.readFixed(i, o), o += 4;
      var h = l.readUshort(i, o);
      o += 2, l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2;
      for (var m = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], S = { _data: i, _offset: d }, _ = {}, T = 0; T < h; T++) {
        var C = l.readASCII(i, o, 4);
        o += 4, l.readUint(i, o), o += 4;
        var D = l.readUint(i, o);
        o += 4;
        var P = l.readUint(i, o);
        o += 4, _[C] = { offset: D, length: P };
      }
      for (T = 0; T < m.length; T++) {
        var U = m[T];
        _[U] && (S[U.trim()] = e[U.trim()].parse(i, _[U].offset, _[U].length, S));
      }
      return S;
    }, _tabOffset: function(i, o, l) {
      for (var d = e._bin, h = d.readUshort(i, l + 4), m = l + 12, S = 0; S < h; S++) {
        var _ = d.readASCII(i, m, 4);
        m += 4, d.readUint(i, m), m += 4;
        var T = d.readUint(i, m);
        if (m += 4, d.readUint(i, m), m += 4, _ == o)
          return T;
      }
      return 0;
    } };
    e._bin = { readFixed: function(i, o) {
      return (i[o] << 8 | i[o + 1]) + (i[o + 2] << 8 | i[o + 3]) / 65540;
    }, readF2dot14: function(i, o) {
      return e._bin.readShort(i, o) / 16384;
    }, readInt: function(i, o) {
      return e._bin._view(i).getInt32(o);
    }, readInt8: function(i, o) {
      return e._bin._view(i).getInt8(o);
    }, readShort: function(i, o) {
      return e._bin._view(i).getInt16(o);
    }, readUshort: function(i, o) {
      return e._bin._view(i).getUint16(o);
    }, readUshorts: function(i, o, l) {
      for (var d = [], h = 0; h < l; h++)
        d.push(e._bin.readUshort(i, o + 2 * h));
      return d;
    }, readUint: function(i, o) {
      return e._bin._view(i).getUint32(o);
    }, readUint64: function(i, o) {
      return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
    }, readASCII: function(i, o, l) {
      for (var d = "", h = 0; h < l; h++)
        d += String.fromCharCode(i[o + h]);
      return d;
    }, readUnicode: function(i, o, l) {
      for (var d = "", h = 0; h < l; h++) {
        var m = i[o++] << 8 | i[o++];
        d += String.fromCharCode(m);
      }
      return d;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(i, o, l) {
      var d = e._bin._tdec;
      return d && o == 0 && l == i.length ? d.decode(i) : e._bin.readASCII(i, o, l);
    }, readBytes: function(i, o, l) {
      for (var d = [], h = 0; h < l; h++)
        d.push(i[o + h]);
      return d;
    }, readASCIIArray: function(i, o, l) {
      for (var d = [], h = 0; h < l; h++)
        d.push(String.fromCharCode(i[o + h]));
      return d;
    }, _view: function(i) {
      return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(i, o, l, d, h) {
      var m = e._bin, S = {}, _ = o;
      m.readFixed(i, o), o += 4;
      var T = m.readUshort(i, o);
      o += 2;
      var C = m.readUshort(i, o);
      o += 2;
      var D = m.readUshort(i, o);
      return o += 2, S.scriptList = e._lctf.readScriptList(i, _ + T), S.featureList = e._lctf.readFeatureList(i, _ + C), S.lookupList = e._lctf.readLookupList(i, _ + D, h), S;
    }, e._lctf.readLookupList = function(i, o, l) {
      var d = e._bin, h = o, m = [], S = d.readUshort(i, o);
      o += 2;
      for (var _ = 0; _ < S; _++) {
        var T = d.readUshort(i, o);
        o += 2;
        var C = e._lctf.readLookupTable(i, h + T, l);
        m.push(C);
      }
      return m;
    }, e._lctf.readLookupTable = function(i, o, l) {
      var d = e._bin, h = o, m = { tabs: [] };
      m.ltype = d.readUshort(i, o), o += 2, m.flag = d.readUshort(i, o), o += 2;
      var S = d.readUshort(i, o);
      o += 2;
      for (var _ = m.ltype, T = 0; T < S; T++) {
        var C = d.readUshort(i, o);
        o += 2;
        var D = l(i, _, h + C, m);
        m.tabs.push(D);
      }
      return m;
    }, e._lctf.numOfOnes = function(i) {
      for (var o = 0, l = 0; l < 32; l++)
        (i >>> l & 1) != 0 && o++;
      return o;
    }, e._lctf.readClassDef = function(i, o) {
      var l = e._bin, d = [], h = l.readUshort(i, o);
      if (o += 2, h == 1) {
        var m = l.readUshort(i, o);
        o += 2;
        var S = l.readUshort(i, o);
        o += 2;
        for (var _ = 0; _ < S; _++)
          d.push(m + _), d.push(m + _), d.push(l.readUshort(i, o)), o += 2;
      }
      if (h == 2) {
        var T = l.readUshort(i, o);
        for (o += 2, _ = 0; _ < T; _++)
          d.push(l.readUshort(i, o)), o += 2, d.push(l.readUshort(i, o)), o += 2, d.push(l.readUshort(i, o)), o += 2;
      }
      return d;
    }, e._lctf.getInterval = function(i, o) {
      for (var l = 0; l < i.length; l += 3) {
        var d = i[l], h = i[l + 1];
        if (i[l + 2], d <= o && o <= h)
          return l;
      }
      return -1;
    }, e._lctf.readCoverage = function(i, o) {
      var l = e._bin, d = {};
      d.fmt = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      return o += 2, d.fmt == 1 && (d.tab = l.readUshorts(i, o, h)), d.fmt == 2 && (d.tab = l.readUshorts(i, o, 3 * h)), d;
    }, e._lctf.coverageIndex = function(i, o) {
      var l = i.tab;
      if (i.fmt == 1)
        return l.indexOf(o);
      if (i.fmt == 2) {
        var d = e._lctf.getInterval(l, o);
        if (d != -1)
          return l[d + 2] + (o - l[d]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(i, o) {
      var l = e._bin, d = o, h = [], m = l.readUshort(i, o);
      o += 2;
      for (var S = 0; S < m; S++) {
        var _ = l.readASCII(i, o, 4);
        o += 4;
        var T = l.readUshort(i, o);
        o += 2;
        var C = e._lctf.readFeatureTable(i, d + T);
        C.tag = _.trim(), h.push(C);
      }
      return h;
    }, e._lctf.readFeatureTable = function(i, o) {
      var l = e._bin, d = o, h = {}, m = l.readUshort(i, o);
      o += 2, m > 0 && (h.featureParams = d + m);
      var S = l.readUshort(i, o);
      o += 2, h.tab = [];
      for (var _ = 0; _ < S; _++)
        h.tab.push(l.readUshort(i, o + 2 * _));
      return h;
    }, e._lctf.readScriptList = function(i, o) {
      var l = e._bin, d = o, h = {}, m = l.readUshort(i, o);
      o += 2;
      for (var S = 0; S < m; S++) {
        var _ = l.readASCII(i, o, 4);
        o += 4;
        var T = l.readUshort(i, o);
        o += 2, h[_.trim()] = e._lctf.readScriptTable(i, d + T);
      }
      return h;
    }, e._lctf.readScriptTable = function(i, o) {
      var l = e._bin, d = o, h = {}, m = l.readUshort(i, o);
      o += 2, h.default = e._lctf.readLangSysTable(i, d + m);
      var S = l.readUshort(i, o);
      o += 2;
      for (var _ = 0; _ < S; _++) {
        var T = l.readASCII(i, o, 4);
        o += 4;
        var C = l.readUshort(i, o);
        o += 2, h[T.trim()] = e._lctf.readLangSysTable(i, d + C);
      }
      return h;
    }, e._lctf.readLangSysTable = function(i, o) {
      var l = e._bin, d = {};
      l.readUshort(i, o), o += 2, d.reqFeature = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      return o += 2, d.features = l.readUshorts(i, o, h), d;
    }, e.CFF = {}, e.CFF.parse = function(i, o, l) {
      var d = e._bin;
      (i = new Uint8Array(i.buffer, o, l))[o = 0], i[++o], i[++o], i[++o], o++;
      var h = [];
      o = e.CFF.readIndex(i, o, h);
      for (var m = [], S = 0; S < h.length - 1; S++)
        m.push(d.readASCII(i, o + h[S], h[S + 1] - h[S]));
      o += h[h.length - 1];
      var _ = [];
      o = e.CFF.readIndex(i, o, _);
      var T = [];
      for (S = 0; S < _.length - 1; S++)
        T.push(e.CFF.readDict(i, o + _[S], o + _[S + 1]));
      o += _[_.length - 1];
      var C = T[0], D = [];
      o = e.CFF.readIndex(i, o, D);
      var P = [];
      for (S = 0; S < D.length - 1; S++)
        P.push(d.readASCII(i, o + D[S], D[S + 1] - D[S]));
      if (o += D[D.length - 1], e.CFF.readSubrs(i, o, C), C.CharStrings) {
        o = C.CharStrings, D = [], o = e.CFF.readIndex(i, o, D);
        var U = [];
        for (S = 0; S < D.length - 1; S++)
          U.push(d.readBytes(i, o + D[S], D[S + 1] - D[S]));
        C.CharStrings = U;
      }
      if (C.ROS) {
        o = C.FDArray;
        var B = [];
        for (o = e.CFF.readIndex(i, o, B), C.FDArray = [], S = 0; S < B.length - 1; S++) {
          var k = e.CFF.readDict(i, o + B[S], o + B[S + 1]);
          e.CFF._readFDict(i, k, P), C.FDArray.push(k);
        }
        o += B[B.length - 1], o = C.FDSelect, C.FDSelect = [];
        var V = i[o];
        if (o++, V != 3)
          throw V;
        var I = d.readUshort(i, o);
        for (o += 2, S = 0; S < I + 1; S++)
          C.FDSelect.push(d.readUshort(i, o), i[o + 2]), o += 3;
      }
      return C.Encoding && (C.Encoding = e.CFF.readEncoding(i, C.Encoding, C.CharStrings.length)), C.charset && (C.charset = e.CFF.readCharset(i, C.charset, C.CharStrings.length)), e.CFF._readFDict(i, C, P), C;
    }, e.CFF._readFDict = function(i, o, l) {
      var d;
      for (var h in o.Private && (d = o.Private[1], o.Private = e.CFF.readDict(i, d, d + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(i, d + o.Private.Subrs, o.Private)), o)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(h) != -1 && (o[h] = l[o[h] - 426 + 35]);
    }, e.CFF.readSubrs = function(i, o, l) {
      var d = e._bin, h = [];
      o = e.CFF.readIndex(i, o, h);
      var m, S = h.length;
      m = S < 1240 ? 107 : S < 33900 ? 1131 : 32768, l.Bias = m, l.Subrs = [];
      for (var _ = 0; _ < h.length - 1; _++)
        l.Subrs.push(d.readBytes(i, o + h[_], h[_ + 1] - h[_]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, o) {
      for (var l = 0; l < i.charset.length; l++)
        if (i.charset[l] == o)
          return l;
      return -1;
    }, e.CFF.glyphBySE = function(i, o) {
      return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
    }, e.CFF.readEncoding = function(i, o, l) {
      e._bin;
      var d = [".notdef"], h = i[o];
      if (o++, h != 0)
        throw "error: unknown encoding format: " + h;
      var m = i[o];
      o++;
      for (var S = 0; S < m; S++)
        d.push(i[o + S]);
      return d;
    }, e.CFF.readCharset = function(i, o, l) {
      var d = e._bin, h = [".notdef"], m = i[o];
      if (o++, m == 0)
        for (var S = 0; S < l; S++) {
          var _ = d.readUshort(i, o);
          o += 2, h.push(_);
        }
      else {
        if (m != 1 && m != 2)
          throw "error: format: " + m;
        for (; h.length < l; ) {
          _ = d.readUshort(i, o), o += 2;
          var T = 0;
          for (m == 1 ? (T = i[o], o++) : (T = d.readUshort(i, o), o += 2), S = 0; S <= T; S++)
            h.push(_), _++;
        }
      }
      return h;
    }, e.CFF.readIndex = function(i, o, l) {
      var d = e._bin, h = d.readUshort(i, o) + 1, m = i[o += 2];
      if (o++, m == 1)
        for (var S = 0; S < h; S++)
          l.push(i[o + S]);
      else if (m == 2)
        for (S = 0; S < h; S++)
          l.push(d.readUshort(i, o + 2 * S));
      else if (m == 3)
        for (S = 0; S < h; S++)
          l.push(16777215 & d.readUint(i, o + 3 * S - 1));
      else if (h != 1)
        throw "unsupported offset size: " + m + ", count: " + h;
      return (o += h * m) - 1;
    }, e.CFF.getCharString = function(i, o, l) {
      var d = e._bin, h = i[o], m = i[o + 1];
      i[o + 2], i[o + 3], i[o + 4];
      var S = 1, _ = null, T = null;
      h <= 20 && (_ = h, S = 1), h == 12 && (_ = 100 * h + m, S = 2), 21 <= h && h <= 27 && (_ = h, S = 1), h == 28 && (T = d.readShort(i, o + 1), S = 3), 29 <= h && h <= 31 && (_ = h, S = 1), 32 <= h && h <= 246 && (T = h - 139, S = 1), 247 <= h && h <= 250 && (T = 256 * (h - 247) + m + 108, S = 2), 251 <= h && h <= 254 && (T = 256 * -(h - 251) - m - 108, S = 2), h == 255 && (T = d.readInt(i, o + 1) / 65535, S = 5), l.val = T != null ? T : "o" + _, l.size = S;
    }, e.CFF.readCharString = function(i, o, l) {
      for (var d = o + l, h = e._bin, m = []; o < d; ) {
        var S = i[o], _ = i[o + 1];
        i[o + 2], i[o + 3], i[o + 4];
        var T = 1, C = null, D = null;
        S <= 20 && (C = S, T = 1), S == 12 && (C = 100 * S + _, T = 2), S != 19 && S != 20 || (C = S, T = 2), 21 <= S && S <= 27 && (C = S, T = 1), S == 28 && (D = h.readShort(i, o + 1), T = 3), 29 <= S && S <= 31 && (C = S, T = 1), 32 <= S && S <= 246 && (D = S - 139, T = 1), 247 <= S && S <= 250 && (D = 256 * (S - 247) + _ + 108, T = 2), 251 <= S && S <= 254 && (D = 256 * -(S - 251) - _ - 108, T = 2), S == 255 && (D = h.readInt(i, o + 1) / 65535, T = 5), m.push(D != null ? D : "o" + C), o += T;
      }
      return m;
    }, e.CFF.readDict = function(i, o, l) {
      for (var d = e._bin, h = {}, m = []; o < l; ) {
        var S = i[o], _ = i[o + 1];
        i[o + 2], i[o + 3], i[o + 4];
        var T = 1, C = null, D = null;
        if (S == 28 && (D = d.readShort(i, o + 1), T = 3), S == 29 && (D = d.readInt(i, o + 1), T = 5), 32 <= S && S <= 246 && (D = S - 139, T = 1), 247 <= S && S <= 250 && (D = 256 * (S - 247) + _ + 108, T = 2), 251 <= S && S <= 254 && (D = 256 * -(S - 251) - _ - 108, T = 2), S == 255)
          throw D = d.readInt(i, o + 1) / 65535, T = 5, "unknown number";
        if (S == 30) {
          var P = [];
          for (T = 1; ; ) {
            var U = i[o + T];
            T++;
            var B = U >> 4, k = 15 & U;
            if (B != 15 && P.push(B), k != 15 && P.push(k), k == 15)
              break;
          }
          for (var V = "", I = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], X = 0; X < P.length; X++)
            V += I[P[X]];
          D = parseFloat(V);
        }
        S <= 21 && (C = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][S], T = 1, S == 12 && (C = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][_], T = 2)), C != null ? (h[C] = m.length == 1 ? m[0] : m, m = []) : m.push(D), o += T;
      }
      return h;
    }, e.cmap = {}, e.cmap.parse = function(i, o, l) {
      i = new Uint8Array(i.buffer, o, l), o = 0;
      var d = e._bin, h = {};
      d.readUshort(i, o), o += 2;
      var m = d.readUshort(i, o);
      o += 2;
      var S = [];
      h.tables = [];
      for (var _ = 0; _ < m; _++) {
        var T = d.readUshort(i, o);
        o += 2;
        var C = d.readUshort(i, o);
        o += 2;
        var D = d.readUint(i, o);
        o += 4;
        var P = "p" + T + "e" + C, U = S.indexOf(D);
        if (U == -1) {
          var B;
          U = h.tables.length, S.push(D);
          var k = d.readUshort(i, D);
          k == 0 ? B = e.cmap.parse0(i, D) : k == 4 ? B = e.cmap.parse4(i, D) : k == 6 ? B = e.cmap.parse6(i, D) : k == 12 ? B = e.cmap.parse12(i, D) : console.debug("unknown format: " + k, T, C, D), h.tables.push(B);
        }
        if (h[P] != null)
          throw "multiple tables for one platform+encoding";
        h[P] = U;
      }
      return h;
    }, e.cmap.parse0 = function(i, o) {
      var l = e._bin, d = {};
      d.format = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      o += 2, l.readUshort(i, o), o += 2, d.map = [];
      for (var m = 0; m < h - 6; m++)
        d.map.push(i[o + m]);
      return d;
    }, e.cmap.parse4 = function(i, o) {
      var l = e._bin, d = o, h = {};
      h.format = l.readUshort(i, o), o += 2;
      var m = l.readUshort(i, o);
      o += 2, l.readUshort(i, o), o += 2;
      var S = l.readUshort(i, o);
      o += 2;
      var _ = S / 2;
      h.searchRange = l.readUshort(i, o), o += 2, h.entrySelector = l.readUshort(i, o), o += 2, h.rangeShift = l.readUshort(i, o), o += 2, h.endCount = l.readUshorts(i, o, _), o += 2 * _, o += 2, h.startCount = l.readUshorts(i, o, _), o += 2 * _, h.idDelta = [];
      for (var T = 0; T < _; T++)
        h.idDelta.push(l.readShort(i, o)), o += 2;
      for (h.idRangeOffset = l.readUshorts(i, o, _), o += 2 * _, h.glyphIdArray = []; o < d + m; )
        h.glyphIdArray.push(l.readUshort(i, o)), o += 2;
      return h;
    }, e.cmap.parse6 = function(i, o) {
      var l = e._bin, d = {};
      d.format = l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2, l.readUshort(i, o), o += 2, d.firstCode = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      o += 2, d.glyphIdArray = [];
      for (var m = 0; m < h; m++)
        d.glyphIdArray.push(l.readUshort(i, o)), o += 2;
      return d;
    }, e.cmap.parse12 = function(i, o) {
      var l = e._bin, d = {};
      d.format = l.readUshort(i, o), o += 2, o += 2, l.readUint(i, o), o += 4, l.readUint(i, o), o += 4;
      var h = l.readUint(i, o);
      o += 4, d.groups = [];
      for (var m = 0; m < h; m++) {
        var S = o + 12 * m, _ = l.readUint(i, S + 0), T = l.readUint(i, S + 4), C = l.readUint(i, S + 8);
        d.groups.push([_, T, C]);
      }
      return d;
    }, e.glyf = {}, e.glyf.parse = function(i, o, l, d) {
      for (var h = [], m = 0; m < d.maxp.numGlyphs; m++)
        h.push(null);
      return h;
    }, e.glyf._parseGlyf = function(i, o) {
      var l = e._bin, d = i._data, h = e._tabOffset(d, "glyf", i._offset) + i.loca[o];
      if (i.loca[o] == i.loca[o + 1])
        return null;
      var m = {};
      if (m.noc = l.readShort(d, h), h += 2, m.xMin = l.readShort(d, h), h += 2, m.yMin = l.readShort(d, h), h += 2, m.xMax = l.readShort(d, h), h += 2, m.yMax = l.readShort(d, h), h += 2, m.xMin >= m.xMax || m.yMin >= m.yMax)
        return null;
      if (m.noc > 0) {
        m.endPts = [];
        for (var S = 0; S < m.noc; S++)
          m.endPts.push(l.readUshort(d, h)), h += 2;
        var _ = l.readUshort(d, h);
        if (h += 2, d.length - h < _)
          return null;
        m.instructions = l.readBytes(d, h, _), h += _;
        var T = m.endPts[m.noc - 1] + 1;
        for (m.flags = [], S = 0; S < T; S++) {
          var C = d[h];
          if (h++, m.flags.push(C), (8 & C) != 0) {
            var D = d[h];
            h++;
            for (var P = 0; P < D; P++)
              m.flags.push(C), S++;
          }
        }
        for (m.xs = [], S = 0; S < T; S++) {
          var U = (2 & m.flags[S]) != 0, B = (16 & m.flags[S]) != 0;
          U ? (m.xs.push(B ? d[h] : -d[h]), h++) : B ? m.xs.push(0) : (m.xs.push(l.readShort(d, h)), h += 2);
        }
        for (m.ys = [], S = 0; S < T; S++)
          U = (4 & m.flags[S]) != 0, B = (32 & m.flags[S]) != 0, U ? (m.ys.push(B ? d[h] : -d[h]), h++) : B ? m.ys.push(0) : (m.ys.push(l.readShort(d, h)), h += 2);
        var k = 0, V = 0;
        for (S = 0; S < T; S++)
          k += m.xs[S], V += m.ys[S], m.xs[S] = k, m.ys[S] = V;
      } else {
        var I;
        m.parts = [];
        do {
          I = l.readUshort(d, h), h += 2;
          var X = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (m.parts.push(X), X.glyphIndex = l.readUshort(d, h), h += 2, 1 & I) {
            var J = l.readShort(d, h);
            h += 2;
            var $ = l.readShort(d, h);
            h += 2;
          } else
            J = l.readInt8(d, h), h++, $ = l.readInt8(d, h), h++;
          2 & I ? (X.m.tx = J, X.m.ty = $) : (X.p1 = J, X.p2 = $), 8 & I ? (X.m.a = X.m.d = l.readF2dot14(d, h), h += 2) : 64 & I ? (X.m.a = l.readF2dot14(d, h), h += 2, X.m.d = l.readF2dot14(d, h), h += 2) : 128 & I && (X.m.a = l.readF2dot14(d, h), h += 2, X.m.b = l.readF2dot14(d, h), h += 2, X.m.c = l.readF2dot14(d, h), h += 2, X.m.d = l.readF2dot14(d, h), h += 2);
        } while (32 & I);
        if (256 & I) {
          var W = l.readUshort(d, h);
          for (h += 2, m.instr = [], S = 0; S < W; S++)
            m.instr.push(d[h]), h++;
        }
      }
      return m;
    }, e.GPOS = {}, e.GPOS.parse = function(i, o, l, d) {
      return e._lctf.parse(i, o, l, d, e.GPOS.subt);
    }, e.GPOS.subt = function(i, o, l, d) {
      var h = e._bin, m = l, S = {};
      if (S.fmt = h.readUshort(i, l), l += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && S.fmt <= 2) {
        var _ = h.readUshort(i, l);
        l += 2, S.coverage = e._lctf.readCoverage(i, _ + m);
      }
      if (o == 1 && S.fmt == 1) {
        var T = h.readUshort(i, l);
        l += 2;
        var C = e._lctf.numOfOnes(T);
        T != 0 && (S.pos = e.GPOS.readValueRecord(i, l, T));
      } else if (o == 2 && S.fmt >= 1 && S.fmt <= 2) {
        T = h.readUshort(i, l), l += 2;
        var D = h.readUshort(i, l);
        l += 2, C = e._lctf.numOfOnes(T);
        var P = e._lctf.numOfOnes(D);
        if (S.fmt == 1) {
          S.pairsets = [];
          var U = h.readUshort(i, l);
          l += 2;
          for (var B = 0; B < U; B++) {
            var k = m + h.readUshort(i, l);
            l += 2;
            var V = h.readUshort(i, k);
            k += 2;
            for (var I = [], X = 0; X < V; X++) {
              var J = h.readUshort(i, k);
              k += 2, T != 0 && (ce = e.GPOS.readValueRecord(i, k, T), k += 2 * C), D != 0 && (Ee = e.GPOS.readValueRecord(i, k, D), k += 2 * P), I.push({ gid2: J, val1: ce, val2: Ee });
            }
            S.pairsets.push(I);
          }
        }
        if (S.fmt == 2) {
          var $ = h.readUshort(i, l);
          l += 2;
          var W = h.readUshort(i, l);
          l += 2;
          var ee = h.readUshort(i, l);
          l += 2;
          var ie = h.readUshort(i, l);
          for (l += 2, S.classDef1 = e._lctf.readClassDef(i, m + $), S.classDef2 = e._lctf.readClassDef(i, m + W), S.matrix = [], B = 0; B < ee; B++) {
            var pe = [];
            for (X = 0; X < ie; X++) {
              var ce = null, Ee = null;
              T != 0 && (ce = e.GPOS.readValueRecord(i, l, T), l += 2 * C), D != 0 && (Ee = e.GPOS.readValueRecord(i, l, D), l += 2 * P), pe.push({ val1: ce, val2: Ee });
            }
            S.matrix.push(pe);
          }
        }
      } else {
        if (o == 9 && S.fmt == 1) {
          var de = h.readUshort(i, l);
          l += 2;
          var Fe = h.readUint(i, l);
          if (l += 4, d.ltype == 9)
            d.ltype = de;
          else if (d.ltype != de)
            throw "invalid extension substitution";
          return e.GPOS.subt(i, d.ltype, m + Fe);
        }
        console.debug("unsupported GPOS table LookupType", o, "format", S.fmt);
      }
      return S;
    }, e.GPOS.readValueRecord = function(i, o, l) {
      var d = e._bin, h = [];
      return h.push(1 & l ? d.readShort(i, o) : 0), o += 1 & l ? 2 : 0, h.push(2 & l ? d.readShort(i, o) : 0), o += 2 & l ? 2 : 0, h.push(4 & l ? d.readShort(i, o) : 0), o += 4 & l ? 2 : 0, h.push(8 & l ? d.readShort(i, o) : 0), o += 8 & l ? 2 : 0, h;
    }, e.GSUB = {}, e.GSUB.parse = function(i, o, l, d) {
      return e._lctf.parse(i, o, l, d, e.GSUB.subt);
    }, e.GSUB.subt = function(i, o, l, d) {
      var h = e._bin, m = l, S = {};
      if (S.fmt = h.readUshort(i, l), l += 2, o != 1 && o != 4 && o != 5 && o != 6)
        return null;
      if (o == 1 || o == 4 || o == 5 && S.fmt <= 2 || o == 6 && S.fmt <= 2) {
        var _ = h.readUshort(i, l);
        l += 2, S.coverage = e._lctf.readCoverage(i, m + _);
      }
      if (o == 1 && S.fmt >= 1 && S.fmt <= 2) {
        if (S.fmt == 1)
          S.delta = h.readShort(i, l), l += 2;
        else if (S.fmt == 2) {
          var T = h.readUshort(i, l);
          l += 2, S.newg = h.readUshorts(i, l, T), l += 2 * S.newg.length;
        }
      } else if (o == 4) {
        S.vals = [], T = h.readUshort(i, l), l += 2;
        for (var C = 0; C < T; C++) {
          var D = h.readUshort(i, l);
          l += 2, S.vals.push(e.GSUB.readLigatureSet(i, m + D));
        }
      } else if (o == 5 && S.fmt == 2) {
        if (S.fmt == 2) {
          var P = h.readUshort(i, l);
          l += 2, S.cDef = e._lctf.readClassDef(i, m + P), S.scset = [];
          var U = h.readUshort(i, l);
          for (l += 2, C = 0; C < U; C++) {
            var B = h.readUshort(i, l);
            l += 2, S.scset.push(B == 0 ? null : e.GSUB.readSubClassSet(i, m + B));
          }
        }
      } else if (o == 6 && S.fmt == 3) {
        if (S.fmt == 3) {
          for (C = 0; C < 3; C++) {
            T = h.readUshort(i, l), l += 2;
            for (var k = [], V = 0; V < T; V++)
              k.push(e._lctf.readCoverage(i, m + h.readUshort(i, l + 2 * V)));
            l += 2 * T, C == 0 && (S.backCvg = k), C == 1 && (S.inptCvg = k), C == 2 && (S.ahedCvg = k);
          }
          T = h.readUshort(i, l), l += 2, S.lookupRec = e.GSUB.readSubstLookupRecords(i, l, T);
        }
      } else {
        if (o == 7 && S.fmt == 1) {
          var I = h.readUshort(i, l);
          l += 2;
          var X = h.readUint(i, l);
          if (l += 4, d.ltype == 9)
            d.ltype = I;
          else if (d.ltype != I)
            throw "invalid extension substitution";
          return e.GSUB.subt(i, d.ltype, m + X);
        }
        console.debug("unsupported GSUB table LookupType", o, "format", S.fmt);
      }
      return S;
    }, e.GSUB.readSubClassSet = function(i, o) {
      var l = e._bin.readUshort, d = o, h = [], m = l(i, o);
      o += 2;
      for (var S = 0; S < m; S++) {
        var _ = l(i, o);
        o += 2, h.push(e.GSUB.readSubClassRule(i, d + _));
      }
      return h;
    }, e.GSUB.readSubClassRule = function(i, o) {
      var l = e._bin.readUshort, d = {}, h = l(i, o), m = l(i, o += 2);
      o += 2, d.input = [];
      for (var S = 0; S < h - 1; S++)
        d.input.push(l(i, o)), o += 2;
      return d.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, m), d;
    }, e.GSUB.readSubstLookupRecords = function(i, o, l) {
      for (var d = e._bin.readUshort, h = [], m = 0; m < l; m++)
        h.push(d(i, o), d(i, o + 2)), o += 4;
      return h;
    }, e.GSUB.readChainSubClassSet = function(i, o) {
      var l = e._bin, d = o, h = [], m = l.readUshort(i, o);
      o += 2;
      for (var S = 0; S < m; S++) {
        var _ = l.readUshort(i, o);
        o += 2, h.push(e.GSUB.readChainSubClassRule(i, d + _));
      }
      return h;
    }, e.GSUB.readChainSubClassRule = function(i, o) {
      for (var l = e._bin, d = {}, h = ["backtrack", "input", "lookahead"], m = 0; m < h.length; m++) {
        var S = l.readUshort(i, o);
        o += 2, m == 1 && S--, d[h[m]] = l.readUshorts(i, o, S), o += 2 * d[h[m]].length;
      }
      return S = l.readUshort(i, o), o += 2, d.subst = l.readUshorts(i, o, 2 * S), o += 2 * d.subst.length, d;
    }, e.GSUB.readLigatureSet = function(i, o) {
      var l = e._bin, d = o, h = [], m = l.readUshort(i, o);
      o += 2;
      for (var S = 0; S < m; S++) {
        var _ = l.readUshort(i, o);
        o += 2, h.push(e.GSUB.readLigature(i, d + _));
      }
      return h;
    }, e.GSUB.readLigature = function(i, o) {
      var l = e._bin, d = { chain: [] };
      d.nglyph = l.readUshort(i, o), o += 2;
      var h = l.readUshort(i, o);
      o += 2;
      for (var m = 0; m < h - 1; m++)
        d.chain.push(l.readUshort(i, o)), o += 2;
      return d;
    }, e.head = {}, e.head.parse = function(i, o, l) {
      var d = e._bin, h = {};
      return d.readFixed(i, o), o += 4, h.fontRevision = d.readFixed(i, o), o += 4, d.readUint(i, o), o += 4, d.readUint(i, o), o += 4, h.flags = d.readUshort(i, o), o += 2, h.unitsPerEm = d.readUshort(i, o), o += 2, h.created = d.readUint64(i, o), o += 8, h.modified = d.readUint64(i, o), o += 8, h.xMin = d.readShort(i, o), o += 2, h.yMin = d.readShort(i, o), o += 2, h.xMax = d.readShort(i, o), o += 2, h.yMax = d.readShort(i, o), o += 2, h.macStyle = d.readUshort(i, o), o += 2, h.lowestRecPPEM = d.readUshort(i, o), o += 2, h.fontDirectionHint = d.readShort(i, o), o += 2, h.indexToLocFormat = d.readShort(i, o), o += 2, h.glyphDataFormat = d.readShort(i, o), o += 2, h;
    }, e.hhea = {}, e.hhea.parse = function(i, o, l) {
      var d = e._bin, h = {};
      return d.readFixed(i, o), o += 4, h.ascender = d.readShort(i, o), o += 2, h.descender = d.readShort(i, o), o += 2, h.lineGap = d.readShort(i, o), o += 2, h.advanceWidthMax = d.readUshort(i, o), o += 2, h.minLeftSideBearing = d.readShort(i, o), o += 2, h.minRightSideBearing = d.readShort(i, o), o += 2, h.xMaxExtent = d.readShort(i, o), o += 2, h.caretSlopeRise = d.readShort(i, o), o += 2, h.caretSlopeRun = d.readShort(i, o), o += 2, h.caretOffset = d.readShort(i, o), o += 2, o += 8, h.metricDataFormat = d.readShort(i, o), o += 2, h.numberOfHMetrics = d.readUshort(i, o), o += 2, h;
    }, e.hmtx = {}, e.hmtx.parse = function(i, o, l, d) {
      for (var h = e._bin, m = { aWidth: [], lsBearing: [] }, S = 0, _ = 0, T = 0; T < d.maxp.numGlyphs; T++)
        T < d.hhea.numberOfHMetrics && (S = h.readUshort(i, o), o += 2, _ = h.readShort(i, o), o += 2), m.aWidth.push(S), m.lsBearing.push(_);
      return m;
    }, e.kern = {}, e.kern.parse = function(i, o, l, d) {
      var h = e._bin, m = h.readUshort(i, o);
      if (o += 2, m == 1)
        return e.kern.parseV1(i, o - 2, l, d);
      var S = h.readUshort(i, o);
      o += 2;
      for (var _ = { glyph1: [], rval: [] }, T = 0; T < S; T++) {
        o += 2, l = h.readUshort(i, o), o += 2;
        var C = h.readUshort(i, o);
        o += 2;
        var D = C >>> 8;
        if ((D &= 15) != 0)
          throw "unknown kern table format: " + D;
        o = e.kern.readFormat0(i, o, _);
      }
      return _;
    }, e.kern.parseV1 = function(i, o, l, d) {
      var h = e._bin;
      h.readFixed(i, o), o += 4;
      var m = h.readUint(i, o);
      o += 4;
      for (var S = { glyph1: [], rval: [] }, _ = 0; _ < m; _++) {
        h.readUint(i, o), o += 4;
        var T = h.readUshort(i, o);
        o += 2, h.readUshort(i, o), o += 2;
        var C = T >>> 8;
        if ((C &= 15) != 0)
          throw "unknown kern table format: " + C;
        o = e.kern.readFormat0(i, o, S);
      }
      return S;
    }, e.kern.readFormat0 = function(i, o, l) {
      var d = e._bin, h = -1, m = d.readUshort(i, o);
      o += 2, d.readUshort(i, o), o += 2, d.readUshort(i, o), o += 2, d.readUshort(i, o), o += 2;
      for (var S = 0; S < m; S++) {
        var _ = d.readUshort(i, o);
        o += 2;
        var T = d.readUshort(i, o);
        o += 2;
        var C = d.readShort(i, o);
        o += 2, _ != h && (l.glyph1.push(_), l.rval.push({ glyph2: [], vals: [] }));
        var D = l.rval[l.rval.length - 1];
        D.glyph2.push(T), D.vals.push(C), h = _;
      }
      return o;
    }, e.loca = {}, e.loca.parse = function(i, o, l, d) {
      var h = e._bin, m = [], S = d.head.indexToLocFormat, _ = d.maxp.numGlyphs + 1;
      if (S == 0)
        for (var T = 0; T < _; T++)
          m.push(h.readUshort(i, o + (T << 1)) << 1);
      if (S == 1)
        for (T = 0; T < _; T++)
          m.push(h.readUint(i, o + (T << 2)));
      return m;
    }, e.maxp = {}, e.maxp.parse = function(i, o, l) {
      var d = e._bin, h = {}, m = d.readUint(i, o);
      return o += 4, h.numGlyphs = d.readUshort(i, o), o += 2, m == 65536 && (h.maxPoints = d.readUshort(i, o), o += 2, h.maxContours = d.readUshort(i, o), o += 2, h.maxCompositePoints = d.readUshort(i, o), o += 2, h.maxCompositeContours = d.readUshort(i, o), o += 2, h.maxZones = d.readUshort(i, o), o += 2, h.maxTwilightPoints = d.readUshort(i, o), o += 2, h.maxStorage = d.readUshort(i, o), o += 2, h.maxFunctionDefs = d.readUshort(i, o), o += 2, h.maxInstructionDefs = d.readUshort(i, o), o += 2, h.maxStackElements = d.readUshort(i, o), o += 2, h.maxSizeOfInstructions = d.readUshort(i, o), o += 2, h.maxComponentElements = d.readUshort(i, o), o += 2, h.maxComponentDepth = d.readUshort(i, o), o += 2), h;
    }, e.name = {}, e.name.parse = function(i, o, l) {
      var d = e._bin, h = {};
      d.readUshort(i, o), o += 2;
      var m = d.readUshort(i, o);
      o += 2, d.readUshort(i, o);
      for (var S, _ = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], T = o += 2, C = 0; C < m; C++) {
        var D = d.readUshort(i, o);
        o += 2;
        var P = d.readUshort(i, o);
        o += 2;
        var U = d.readUshort(i, o);
        o += 2;
        var B = d.readUshort(i, o);
        o += 2;
        var k = d.readUshort(i, o);
        o += 2;
        var V = d.readUshort(i, o);
        o += 2;
        var I, X = _[B], J = T + 12 * m + V;
        if (D == 0)
          I = d.readUnicode(i, J, k / 2);
        else if (D == 3 && P == 0)
          I = d.readUnicode(i, J, k / 2);
        else if (P == 0)
          I = d.readASCII(i, J, k);
        else if (P == 1)
          I = d.readUnicode(i, J, k / 2);
        else if (P == 3)
          I = d.readUnicode(i, J, k / 2);
        else {
          if (D != 1)
            throw "unknown encoding " + P + ", platformID: " + D;
          I = d.readASCII(i, J, k), console.debug("reading unknown MAC encoding " + P + " as ASCII");
        }
        var $ = "p" + D + "," + U.toString(16);
        h[$] == null && (h[$] = {}), h[$][X !== void 0 ? X : B] = I, h[$]._lang = U;
      }
      for (var W in h)
        if (h[W].postScriptName != null && h[W]._lang == 1033)
          return h[W];
      for (var W in h)
        if (h[W].postScriptName != null && h[W]._lang == 0)
          return h[W];
      for (var W in h)
        if (h[W].postScriptName != null && h[W]._lang == 3084)
          return h[W];
      for (var W in h)
        if (h[W].postScriptName != null)
          return h[W];
      for (var W in h) {
        S = W;
        break;
      }
      return console.debug("returning name table with languageID " + h[S]._lang), h[S];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(i, o, l) {
      var d = e._bin.readUshort(i, o);
      o += 2;
      var h = {};
      if (d == 0)
        e["OS/2"].version0(i, o, h);
      else if (d == 1)
        e["OS/2"].version1(i, o, h);
      else if (d == 2 || d == 3 || d == 4)
        e["OS/2"].version2(i, o, h);
      else {
        if (d != 5)
          throw "unknown OS/2 table version: " + d;
        e["OS/2"].version5(i, o, h);
      }
      return h;
    }, e["OS/2"].version0 = function(i, o, l) {
      var d = e._bin;
      return l.xAvgCharWidth = d.readShort(i, o), o += 2, l.usWeightClass = d.readUshort(i, o), o += 2, l.usWidthClass = d.readUshort(i, o), o += 2, l.fsType = d.readUshort(i, o), o += 2, l.ySubscriptXSize = d.readShort(i, o), o += 2, l.ySubscriptYSize = d.readShort(i, o), o += 2, l.ySubscriptXOffset = d.readShort(i, o), o += 2, l.ySubscriptYOffset = d.readShort(i, o), o += 2, l.ySuperscriptXSize = d.readShort(i, o), o += 2, l.ySuperscriptYSize = d.readShort(i, o), o += 2, l.ySuperscriptXOffset = d.readShort(i, o), o += 2, l.ySuperscriptYOffset = d.readShort(i, o), o += 2, l.yStrikeoutSize = d.readShort(i, o), o += 2, l.yStrikeoutPosition = d.readShort(i, o), o += 2, l.sFamilyClass = d.readShort(i, o), o += 2, l.panose = d.readBytes(i, o, 10), o += 10, l.ulUnicodeRange1 = d.readUint(i, o), o += 4, l.ulUnicodeRange2 = d.readUint(i, o), o += 4, l.ulUnicodeRange3 = d.readUint(i, o), o += 4, l.ulUnicodeRange4 = d.readUint(i, o), o += 4, l.achVendID = [d.readInt8(i, o), d.readInt8(i, o + 1), d.readInt8(i, o + 2), d.readInt8(i, o + 3)], o += 4, l.fsSelection = d.readUshort(i, o), o += 2, l.usFirstCharIndex = d.readUshort(i, o), o += 2, l.usLastCharIndex = d.readUshort(i, o), o += 2, l.sTypoAscender = d.readShort(i, o), o += 2, l.sTypoDescender = d.readShort(i, o), o += 2, l.sTypoLineGap = d.readShort(i, o), o += 2, l.usWinAscent = d.readUshort(i, o), o += 2, l.usWinDescent = d.readUshort(i, o), o += 2;
    }, e["OS/2"].version1 = function(i, o, l) {
      var d = e._bin;
      return o = e["OS/2"].version0(i, o, l), l.ulCodePageRange1 = d.readUint(i, o), o += 4, l.ulCodePageRange2 = d.readUint(i, o), o += 4;
    }, e["OS/2"].version2 = function(i, o, l) {
      var d = e._bin;
      return o = e["OS/2"].version1(i, o, l), l.sxHeight = d.readShort(i, o), o += 2, l.sCapHeight = d.readShort(i, o), o += 2, l.usDefault = d.readUshort(i, o), o += 2, l.usBreak = d.readUshort(i, o), o += 2, l.usMaxContext = d.readUshort(i, o), o += 2;
    }, e["OS/2"].version5 = function(i, o, l) {
      var d = e._bin;
      return o = e["OS/2"].version2(i, o, l), l.usLowerOpticalPointSize = d.readUshort(i, o), o += 2, l.usUpperOpticalPointSize = d.readUshort(i, o), o += 2;
    }, e.post = {}, e.post.parse = function(i, o, l) {
      var d = e._bin, h = {};
      return h.version = d.readFixed(i, o), o += 4, h.italicAngle = d.readFixed(i, o), o += 4, h.underlinePosition = d.readShort(i, o), o += 2, h.underlineThickness = d.readShort(i, o), o += 2, h;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, o) {
      var l = i.cmap, d = -1;
      if (l.p0e4 != null ? d = l.p0e4 : l.p3e1 != null ? d = l.p3e1 : l.p1e0 != null ? d = l.p1e0 : l.p0e3 != null && (d = l.p0e3), d == -1)
        throw "no familiar platform and encoding!";
      var h = l.tables[d];
      if (h.format == 0)
        return o >= h.map.length ? 0 : h.map[o];
      if (h.format == 4) {
        for (var m = -1, S = 0; S < h.endCount.length; S++)
          if (o <= h.endCount[S]) {
            m = S;
            break;
          }
        return m == -1 || h.startCount[m] > o ? 0 : 65535 & (h.idRangeOffset[m] != 0 ? h.glyphIdArray[o - h.startCount[m] + (h.idRangeOffset[m] >> 1) - (h.idRangeOffset.length - m)] : o + h.idDelta[m]);
      }
      if (h.format == 12) {
        if (o > h.groups[h.groups.length - 1][1])
          return 0;
        for (S = 0; S < h.groups.length; S++) {
          var _ = h.groups[S];
          if (_[0] <= o && o <= _[1])
            return _[2] + (o - _[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + h.format;
    }, e.U.glyphToPath = function(i, o) {
      var l = { cmds: [], crds: [] };
      if (i.SVG && i.SVG.entries[o]) {
        var d = i.SVG.entries[o];
        return d == null ? l : (typeof d == "string" && (d = e.SVG.toPath(d), i.SVG.entries[o] = d), d);
      }
      if (i.CFF) {
        var h = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, m = i.CFF, S = i.CFF.Private;
        if (m.ROS) {
          for (var _ = 0; m.FDSelect[_ + 2] <= o; )
            _ += 2;
          S = m.FDArray[m.FDSelect[_ + 1]].Private;
        }
        e.U._drawCFF(i.CFF.CharStrings[o], h, m, S, l);
      } else
        i.glyf && e.U._drawGlyf(o, i, l);
      return l;
    }, e.U._drawGlyf = function(i, o, l) {
      var d = o.glyf[i];
      d == null && (d = o.glyf[i] = e.glyf._parseGlyf(o, i)), d != null && (d.noc > -1 ? e.U._simpleGlyph(d, l) : e.U._compoGlyph(d, o, l));
    }, e.U._simpleGlyph = function(i, o) {
      for (var l = 0; l < i.noc; l++) {
        for (var d = l == 0 ? 0 : i.endPts[l - 1] + 1, h = i.endPts[l], m = d; m <= h; m++) {
          var S = m == d ? h : m - 1, _ = m == h ? d : m + 1, T = 1 & i.flags[m], C = 1 & i.flags[S], D = 1 & i.flags[_], P = i.xs[m], U = i.ys[m];
          if (m == d)
            if (T) {
              if (!C) {
                e.U.P.moveTo(o, P, U);
                continue;
              }
              e.U.P.moveTo(o, i.xs[S], i.ys[S]);
            } else
              C ? e.U.P.moveTo(o, i.xs[S], i.ys[S]) : e.U.P.moveTo(o, (i.xs[S] + P) / 2, (i.ys[S] + U) / 2);
          T ? C && e.U.P.lineTo(o, P, U) : D ? e.U.P.qcurveTo(o, P, U, i.xs[_], i.ys[_]) : e.U.P.qcurveTo(o, P, U, (P + i.xs[_]) / 2, (U + i.ys[_]) / 2);
        }
        e.U.P.closePath(o);
      }
    }, e.U._compoGlyph = function(i, o, l) {
      for (var d = 0; d < i.parts.length; d++) {
        var h = { cmds: [], crds: [] }, m = i.parts[d];
        e.U._drawGlyf(m.glyphIndex, o, h);
        for (var S = m.m, _ = 0; _ < h.crds.length; _ += 2) {
          var T = h.crds[_], C = h.crds[_ + 1];
          l.crds.push(T * S.a + C * S.b + S.tx), l.crds.push(T * S.c + C * S.d + S.ty);
        }
        for (_ = 0; _ < h.cmds.length; _++)
          l.cmds.push(h.cmds[_]);
      }
    }, e.U._getGlyphClass = function(i, o) {
      var l = e._lctf.getInterval(o, i);
      return l == -1 ? 0 : o[l + 2];
    }, e.U.getPairAdjustment = function(i, o, l) {
      var d = 0, h = !1;
      if (i.GPOS)
        for (var m = i.GPOS, S = m.lookupList, _ = m.featureList, T = [], C = 0; C < _.length; C++) {
          var D = _[C];
          if (D.tag == "kern") {
            h = !0;
            for (var P = 0; P < D.tab.length; P++)
              if (!T[D.tab[P]]) {
                T[D.tab[P]] = !0;
                for (var U = S[D.tab[P]], B = 0; B < U.tabs.length; B++)
                  if (U.tabs[B] != null) {
                    var k, V = U.tabs[B];
                    if ((!V.coverage || (k = e._lctf.coverageIndex(V.coverage, o)) != -1) && U.ltype != 1) {
                      if (U.ltype == 2) {
                        var I;
                        if (V.fmt == 1) {
                          var X = V.pairsets[k];
                          for (C = 0; C < X.length; C++)
                            X[C].gid2 == l && (I = X[C]);
                        } else if (V.fmt == 2) {
                          var J = e.U._getGlyphClass(o, V.classDef1), $ = e.U._getGlyphClass(l, V.classDef2);
                          I = V.matrix[J][$];
                        }
                        I && I.val1 && I.val1[2] && (d += I.val1[2]), I && I.val2 && I.val2[0] && (d += I.val2[0]);
                      }
                    }
                  }
              }
          }
        }
      if (i.kern && !h) {
        var W = i.kern.glyph1.indexOf(o);
        if (W != -1) {
          var ee = i.kern.rval[W].glyph2.indexOf(l);
          ee != -1 && (d += i.kern.rval[W].vals[ee]);
        }
      }
      return d;
    }, e.U._applySubs = function(i, o, l, d) {
      for (var h = i.length - o - 1, m = 0; m < l.tabs.length; m++)
        if (l.tabs[m] != null) {
          var S, _ = l.tabs[m];
          if (!_.coverage || (S = e._lctf.coverageIndex(_.coverage, i[o])) != -1) {
            if (l.ltype == 1)
              i[o], _.fmt == 1 ? i[o] = i[o] + _.delta : i[o] = _.newg[S];
            else if (l.ltype == 4)
              for (var T = _.vals[S], C = 0; C < T.length; C++) {
                var D = T[C], P = D.chain.length;
                if (!(P > h)) {
                  for (var U = !0, B = 0, k = 0; k < P; k++) {
                    for (; i[o + B + (1 + k)] == -1; )
                      B++;
                    D.chain[k] != i[o + B + (1 + k)] && (U = !1);
                  }
                  if (U) {
                    for (i[o] = D.nglyph, k = 0; k < P + B; k++)
                      i[o + k + 1] = -1;
                    break;
                  }
                }
              }
            else if (l.ltype == 5 && _.fmt == 2)
              for (var V = e._lctf.getInterval(_.cDef, i[o]), I = _.cDef[V + 2], X = _.scset[I], J = 0; J < X.length; J++) {
                var $ = X[J], W = $.input;
                if (!(W.length > h)) {
                  for (U = !0, k = 0; k < W.length; k++) {
                    var ee = e._lctf.getInterval(_.cDef, i[o + 1 + k]);
                    if (V == -1 && _.cDef[ee + 2] != W[k]) {
                      U = !1;
                      break;
                    }
                  }
                  if (U) {
                    var ie = $.substLookupRecords;
                    for (C = 0; C < ie.length; C += 2)
                      ie[C], ie[C + 1];
                  }
                }
              }
            else if (l.ltype == 6 && _.fmt == 3) {
              if (!e.U._glsCovered(i, _.backCvg, o - _.backCvg.length) || !e.U._glsCovered(i, _.inptCvg, o) || !e.U._glsCovered(i, _.ahedCvg, o + _.inptCvg.length))
                continue;
              var pe = _.lookupRec;
              for (J = 0; J < pe.length; J += 2) {
                V = pe[J];
                var ce = d[pe[J + 1]];
                e.U._applySubs(i, o + V, ce, d);
              }
            }
          }
        }
    }, e.U._glsCovered = function(i, o, l) {
      for (var d = 0; d < o.length; d++)
        if (e._lctf.coverageIndex(o[d], i[l + d]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(i, o, l) {
      for (var d = { cmds: [], crds: [] }, h = 0, m = 0; m < o.length; m++) {
        var S = o[m];
        if (S != -1) {
          for (var _ = m < o.length - 1 && o[m + 1] != -1 ? o[m + 1] : 0, T = e.U.glyphToPath(i, S), C = 0; C < T.crds.length; C += 2)
            d.crds.push(T.crds[C] + h), d.crds.push(T.crds[C + 1]);
          for (l && d.cmds.push(l), C = 0; C < T.cmds.length; C++)
            d.cmds.push(T.cmds[C]);
          l && d.cmds.push("X"), h += i.hmtx.aWidth[S], m < o.length - 1 && (h += e.U.getPairAdjustment(i, S, _));
        }
      }
      return d;
    }, e.U.P = {}, e.U.P.moveTo = function(i, o, l) {
      i.cmds.push("M"), i.crds.push(o, l);
    }, e.U.P.lineTo = function(i, o, l) {
      i.cmds.push("L"), i.crds.push(o, l);
    }, e.U.P.curveTo = function(i, o, l, d, h, m, S) {
      i.cmds.push("C"), i.crds.push(o, l, d, h, m, S);
    }, e.U.P.qcurveTo = function(i, o, l, d, h) {
      i.cmds.push("Q"), i.crds.push(o, l, d, h);
    }, e.U.P.closePath = function(i) {
      i.cmds.push("Z");
    }, e.U._drawCFF = function(i, o, l, d, h) {
      for (var m = o.stack, S = o.nStems, _ = o.haveWidth, T = o.width, C = o.open, D = 0, P = o.x, U = o.y, B = 0, k = 0, V = 0, I = 0, X = 0, J = 0, $ = 0, W = 0, ee = 0, ie = 0, pe = { val: 0, size: 0 }; D < i.length; ) {
        e.CFF.getCharString(i, D, pe);
        var ce = pe.val;
        if (D += pe.size, ce == "o1" || ce == "o18")
          m.length % 2 != 0 && !_ && (T = m.shift() + d.nominalWidthX), S += m.length >> 1, m.length = 0, _ = !0;
        else if (ce == "o3" || ce == "o23")
          m.length % 2 != 0 && !_ && (T = m.shift() + d.nominalWidthX), S += m.length >> 1, m.length = 0, _ = !0;
        else if (ce == "o4")
          m.length > 1 && !_ && (T = m.shift() + d.nominalWidthX, _ = !0), C && e.U.P.closePath(h), U += m.pop(), e.U.P.moveTo(h, P, U), C = !0;
        else if (ce == "o5")
          for (; m.length > 0; )
            P += m.shift(), U += m.shift(), e.U.P.lineTo(h, P, U);
        else if (ce == "o6" || ce == "o7")
          for (var Ee = m.length, de = ce == "o6", Fe = 0; Fe < Ee; Fe++) {
            var Ce = m.shift();
            de ? P += Ce : U += Ce, de = !de, e.U.P.lineTo(h, P, U);
          }
        else if (ce == "o8" || ce == "o24") {
          Ee = m.length;
          for (var Be = 0; Be + 6 <= Ee; )
            B = P + m.shift(), k = U + m.shift(), V = B + m.shift(), I = k + m.shift(), P = V + m.shift(), U = I + m.shift(), e.U.P.curveTo(h, B, k, V, I, P, U), Be += 6;
          ce == "o24" && (P += m.shift(), U += m.shift(), e.U.P.lineTo(h, P, U));
        } else {
          if (ce == "o11")
            break;
          if (ce == "o1234" || ce == "o1235" || ce == "o1236" || ce == "o1237")
            ce == "o1234" && (k = U, V = (B = P + m.shift()) + m.shift(), ie = I = k + m.shift(), J = I, W = U, P = ($ = (X = (ee = V + m.shift()) + m.shift()) + m.shift()) + m.shift(), e.U.P.curveTo(h, B, k, V, I, ee, ie), e.U.P.curveTo(h, X, J, $, W, P, U)), ce == "o1235" && (B = P + m.shift(), k = U + m.shift(), V = B + m.shift(), I = k + m.shift(), ee = V + m.shift(), ie = I + m.shift(), X = ee + m.shift(), J = ie + m.shift(), $ = X + m.shift(), W = J + m.shift(), P = $ + m.shift(), U = W + m.shift(), m.shift(), e.U.P.curveTo(h, B, k, V, I, ee, ie), e.U.P.curveTo(h, X, J, $, W, P, U)), ce == "o1236" && (B = P + m.shift(), k = U + m.shift(), V = B + m.shift(), ie = I = k + m.shift(), J = I, $ = (X = (ee = V + m.shift()) + m.shift()) + m.shift(), W = J + m.shift(), P = $ + m.shift(), e.U.P.curveTo(h, B, k, V, I, ee, ie), e.U.P.curveTo(h, X, J, $, W, P, U)), ce == "o1237" && (B = P + m.shift(), k = U + m.shift(), V = B + m.shift(), I = k + m.shift(), ee = V + m.shift(), ie = I + m.shift(), X = ee + m.shift(), J = ie + m.shift(), $ = X + m.shift(), W = J + m.shift(), Math.abs($ - P) > Math.abs(W - U) ? P = $ + m.shift() : U = W + m.shift(), e.U.P.curveTo(h, B, k, V, I, ee, ie), e.U.P.curveTo(h, X, J, $, W, P, U));
          else if (ce == "o14") {
            if (m.length > 0 && !_ && (T = m.shift() + l.nominalWidthX, _ = !0), m.length == 4) {
              var he = m.shift(), fe = m.shift(), ue = m.shift(), ye = m.shift(), we = e.CFF.glyphBySE(l, ue), Xe = e.CFF.glyphBySE(l, ye);
              e.U._drawCFF(l.CharStrings[we], o, l, d, h), o.x = he, o.y = fe, e.U._drawCFF(l.CharStrings[Xe], o, l, d, h);
            }
            C && (e.U.P.closePath(h), C = !1);
          } else if (ce == "o19" || ce == "o20")
            m.length % 2 != 0 && !_ && (T = m.shift() + d.nominalWidthX), S += m.length >> 1, m.length = 0, _ = !0, D += S + 7 >> 3;
          else if (ce == "o21")
            m.length > 2 && !_ && (T = m.shift() + d.nominalWidthX, _ = !0), U += m.pop(), P += m.pop(), C && e.U.P.closePath(h), e.U.P.moveTo(h, P, U), C = !0;
          else if (ce == "o22")
            m.length > 1 && !_ && (T = m.shift() + d.nominalWidthX, _ = !0), P += m.pop(), C && e.U.P.closePath(h), e.U.P.moveTo(h, P, U), C = !0;
          else if (ce == "o25") {
            for (; m.length > 6; )
              P += m.shift(), U += m.shift(), e.U.P.lineTo(h, P, U);
            B = P + m.shift(), k = U + m.shift(), V = B + m.shift(), I = k + m.shift(), P = V + m.shift(), U = I + m.shift(), e.U.P.curveTo(h, B, k, V, I, P, U);
          } else if (ce == "o26")
            for (m.length % 2 && (P += m.shift()); m.length > 0; )
              B = P, k = U + m.shift(), P = V = B + m.shift(), U = (I = k + m.shift()) + m.shift(), e.U.P.curveTo(h, B, k, V, I, P, U);
          else if (ce == "o27")
            for (m.length % 2 && (U += m.shift()); m.length > 0; )
              k = U, V = (B = P + m.shift()) + m.shift(), I = k + m.shift(), P = V + m.shift(), U = I, e.U.P.curveTo(h, B, k, V, I, P, U);
          else if (ce == "o10" || ce == "o29") {
            var Je = ce == "o10" ? d : l;
            if (m.length == 0)
              console.debug("error: empty stack");
            else {
              var st = m.pop(), Ue = Je.Subrs[st + Je.Bias];
              o.x = P, o.y = U, o.nStems = S, o.haveWidth = _, o.width = T, o.open = C, e.U._drawCFF(Ue, o, l, d, h), P = o.x, U = o.y, S = o.nStems, _ = o.haveWidth, T = o.width, C = o.open;
            }
          } else if (ce == "o30" || ce == "o31") {
            var ot = m.length, rt = (Be = 0, ce == "o31");
            for (Be += ot - (Ee = -3 & ot); Be < Ee; )
              rt ? (k = U, V = (B = P + m.shift()) + m.shift(), U = (I = k + m.shift()) + m.shift(), Ee - Be == 5 ? (P = V + m.shift(), Be++) : P = V, rt = !1) : (B = P, k = U + m.shift(), V = B + m.shift(), I = k + m.shift(), P = V + m.shift(), Ee - Be == 5 ? (U = I + m.shift(), Be++) : U = I, rt = !0), e.U.P.curveTo(h, B, k, V, I, P, U), Be += 4;
          } else {
            if ((ce + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + ce, i), ce;
            m.push(ce);
          }
        }
      }
      o.x = P, o.y = U, o.nStems = S, o.haveWidth = _, o.width = T, o.open = C;
    };
    var t = e, r = { Typr: t };
    return a.Typr = t, a.default = r, Object.defineProperty(a, "__esModule", { value: !0 }), a;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function nY() {
  return function(a) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), l = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), d = function(ce, Ee) {
      for (var de = new t(31), Fe = 0; Fe < 31; ++Fe)
        de[Fe] = Ee += 1 << ce[Fe - 1];
      var Ce = new r(de[30]);
      for (Fe = 1; Fe < 30; ++Fe)
        for (var Be = de[Fe]; Be < de[Fe + 1]; ++Be)
          Ce[Be] = Be - de[Fe] << 5 | Fe;
      return [de, Ce];
    }, h = d(i, 2), m = h[0], S = h[1];
    m[28] = 258, S[258] = 28;
    for (var _ = d(o, 0)[0], T = new t(32768), C = 0; C < 32768; ++C) {
      var D = (43690 & C) >>> 1 | (21845 & C) << 1;
      D = (61680 & (D = (52428 & D) >>> 2 | (13107 & D) << 2)) >>> 4 | (3855 & D) << 4, T[C] = ((65280 & D) >>> 8 | (255 & D) << 8) >>> 1;
    }
    var P = function(ce, Ee, de) {
      for (var Fe = ce.length, Ce = 0, Be = new t(Ee); Ce < Fe; ++Ce)
        ++Be[ce[Ce] - 1];
      var he, fe = new t(Ee);
      for (Ce = 0; Ce < Ee; ++Ce)
        fe[Ce] = fe[Ce - 1] + Be[Ce - 1] << 1;
      if (de) {
        he = new t(1 << Ee);
        var ue = 15 - Ee;
        for (Ce = 0; Ce < Fe; ++Ce)
          if (ce[Ce])
            for (var ye = Ce << 4 | ce[Ce], we = Ee - ce[Ce], Xe = fe[ce[Ce] - 1]++ << we, Je = Xe | (1 << we) - 1; Xe <= Je; ++Xe)
              he[T[Xe] >>> ue] = ye;
      } else
        for (he = new t(Fe), Ce = 0; Ce < Fe; ++Ce)
          ce[Ce] && (he[Ce] = T[fe[ce[Ce] - 1]++] >>> 15 - ce[Ce]);
      return he;
    }, U = new e(288);
    for (C = 0; C < 144; ++C)
      U[C] = 8;
    for (C = 144; C < 256; ++C)
      U[C] = 9;
    for (C = 256; C < 280; ++C)
      U[C] = 7;
    for (C = 280; C < 288; ++C)
      U[C] = 8;
    var B = new e(32);
    for (C = 0; C < 32; ++C)
      B[C] = 5;
    var k = P(U, 9, 1), V = P(B, 5, 1), I = function(ce) {
      for (var Ee = ce[0], de = 1; de < ce.length; ++de)
        ce[de] > Ee && (Ee = ce[de]);
      return Ee;
    }, X = function(ce, Ee, de) {
      var Fe = Ee / 8 | 0;
      return (ce[Fe] | ce[Fe + 1] << 8) >> (7 & Ee) & de;
    }, J = function(ce, Ee) {
      var de = Ee / 8 | 0;
      return (ce[de] | ce[de + 1] << 8 | ce[de + 2] << 16) >> (7 & Ee);
    }, $ = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], W = function(ce, Ee, de) {
      var Fe = new Error(Ee || $[ce]);
      if (Fe.code = ce, Error.captureStackTrace && Error.captureStackTrace(Fe, W), !de)
        throw Fe;
      return Fe;
    }, ee = function(ce, Ee, de) {
      var Fe = ce.length;
      if (!Fe || de && !de.l && Fe < 5)
        return Ee || new e(0);
      var Ce = !Ee || de, Be = !de || de.i;
      de || (de = {}), Ee || (Ee = new e(3 * Fe));
      var he, fe = function(at) {
        var hn = Ee.length;
        if (at > hn) {
          var De = new e(Math.max(2 * hn, at));
          De.set(Ee), Ee = De;
        }
      }, ue = de.f || 0, ye = de.p || 0, we = de.b || 0, Xe = de.l, Je = de.d, st = de.m, Ue = de.n, ot = 8 * Fe;
      do {
        if (!Xe) {
          de.f = ue = X(ce, ye, 1);
          var rt = X(ce, ye + 1, 3);
          if (ye += 3, !rt) {
            var _t = ce[(Jt = ((he = ye) / 8 | 0) + (7 & he && 1) + 4) - 4] | ce[Jt - 3] << 8, Rt = Jt + _t;
            if (Rt > Fe) {
              Be && W(0);
              break;
            }
            Ce && fe(we + _t), Ee.set(ce.subarray(Jt, Rt), we), de.b = we += _t, de.p = ye = 8 * Rt;
            continue;
          }
          if (rt == 1)
            Xe = k, Je = V, st = 9, Ue = 5;
          else if (rt == 2) {
            var Ot = X(ce, ye, 31) + 257, He = X(ce, ye + 10, 15) + 4, et = Ot + X(ce, ye + 5, 31) + 1;
            ye += 14;
            for (var mt = new e(et), vt = new e(19), bt = 0; bt < He; ++bt)
              vt[l[bt]] = X(ce, ye + 3 * bt, 7);
            ye += 3 * He;
            var Qt = I(vt), ft = (1 << Qt) - 1, Vt = P(vt, Qt, 1);
            for (bt = 0; bt < et; ) {
              var Jt, Mt = Vt[X(ce, ye, ft)];
              if (ye += 15 & Mt, (Jt = Mt >>> 4) < 16)
                mt[bt++] = Jt;
              else {
                var Me = 0, oe = 0;
                for (Jt == 16 ? (oe = 3 + X(ce, ye, 3), ye += 2, Me = mt[bt - 1]) : Jt == 17 ? (oe = 3 + X(ce, ye, 7), ye += 3) : Jt == 18 && (oe = 11 + X(ce, ye, 127), ye += 7); oe--; )
                  mt[bt++] = Me;
              }
            }
            var je = mt.subarray(0, Ot), lt = mt.subarray(Ot);
            st = I(je), Ue = I(lt), Xe = P(je, st, 1), Je = P(lt, Ue, 1);
          } else
            W(1);
          if (ye > ot) {
            Be && W(0);
            break;
          }
        }
        Ce && fe(we + 131072);
        for (var zt = (1 << st) - 1, Nt = (1 << Ue) - 1, Ut = ye; ; Ut = ye) {
          var tt = (Me = Xe[J(ce, ye) & zt]) >>> 4;
          if ((ye += 15 & Me) > ot) {
            Be && W(0);
            break;
          }
          if (Me || W(2), tt < 256)
            Ee[we++] = tt;
          else {
            if (tt == 256) {
              Ut = ye, Xe = null;
              break;
            }
            var rn = tt - 254;
            if (tt > 264) {
              var ze = i[bt = tt - 257];
              rn = X(ce, ye, (1 << ze) - 1) + m[bt], ye += ze;
            }
            var xe = Je[J(ce, ye) & Nt], Ie = xe >>> 4;
            if (xe || W(3), ye += 15 & xe, lt = _[Ie], Ie > 3 && (ze = o[Ie], lt += J(ce, ye) & (1 << ze) - 1, ye += ze), ye > ot) {
              Be && W(0);
              break;
            }
            Ce && fe(we + 131072);
            for (var it = we + rn; we < it; we += 4)
              Ee[we] = Ee[we - lt], Ee[we + 1] = Ee[we + 1 - lt], Ee[we + 2] = Ee[we + 2 - lt], Ee[we + 3] = Ee[we + 3 - lt];
            we = it;
          }
        }
        de.l = Xe, de.p = Ut, de.b = we, Xe && (ue = 1, de.m = st, de.d = Je, de.n = Ue);
      } while (!ue);
      return we == Ee.length ? Ee : function(at, hn, De) {
        (hn == null || hn < 0) && (hn = 0), (De == null || De > at.length) && (De = at.length);
        var Tt = new (at instanceof t ? t : at instanceof r ? r : e)(De - hn);
        return Tt.set(at.subarray(hn, De)), Tt;
      }(Ee, 0, we);
    }, ie = new e(0), pe = typeof TextDecoder < "u" && new TextDecoder();
    try {
      pe.decode(ie, { stream: !0 });
    } catch {
    }
    return a.convert_streams = function(ce) {
      var Ee = new DataView(ce), de = 0;
      function Fe() {
        var Ot = Ee.getUint16(de);
        return de += 2, Ot;
      }
      function Ce() {
        var Ot = Ee.getUint32(de);
        return de += 4, Ot;
      }
      function Be(Ot) {
        _t.setUint16(Rt, Ot), Rt += 2;
      }
      function he(Ot) {
        _t.setUint32(Rt, Ot), Rt += 4;
      }
      for (var fe = { signature: Ce(), flavor: Ce(), length: Ce(), numTables: Fe(), reserved: Fe(), totalSfntSize: Ce(), majorVersion: Fe(), minorVersion: Fe(), metaOffset: Ce(), metaLength: Ce(), metaOrigLength: Ce(), privOffset: Ce(), privLength: Ce() }, ue = 0; Math.pow(2, ue) <= fe.numTables; )
        ue++;
      ue--;
      for (var ye = 16 * Math.pow(2, ue), we = 16 * fe.numTables - ye, Xe = 12, Je = [], st = 0; st < fe.numTables; st++)
        Je.push({ tag: Ce(), offset: Ce(), compLength: Ce(), origLength: Ce(), origChecksum: Ce() }), Xe += 16;
      var Ue, ot = new Uint8Array(12 + 16 * Je.length + Je.reduce(function(Ot, He) {
        return Ot + He.origLength + 4;
      }, 0)), rt = ot.buffer, _t = new DataView(rt), Rt = 0;
      return he(fe.flavor), Be(fe.numTables), Be(ye), Be(ue), Be(we), Je.forEach(function(Ot) {
        he(Ot.tag), he(Ot.origChecksum), he(Xe), he(Ot.origLength), Ot.outOffset = Xe, (Xe += Ot.origLength) % 4 != 0 && (Xe += 4 - Xe % 4);
      }), Je.forEach(function(Ot) {
        var He, et = ce.slice(Ot.offset, Ot.offset + Ot.compLength);
        if (Ot.compLength != Ot.origLength) {
          var mt = new Uint8Array(Ot.origLength);
          He = new Uint8Array(et, 2), ee(He, mt);
        } else
          mt = new Uint8Array(et);
        ot.set(mt, Ot.outOffset);
        var vt = 0;
        (Xe = Ot.outOffset + Ot.origLength) % 4 != 0 && (vt = 4 - Xe % 4), ot.set(new Uint8Array(vt).buffer, Ot.outOffset + Ot.origLength), Ue = Xe + vt;
      }), rt.slice(0, Ue);
    }, Object.defineProperty(a, "__esModule", { value: !0 }), a;
  }({}).convert_streams;
}
function rY(a, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, o = 2, l = 4, d = 8, h = 16, m = 32;
  let S;
  function _(I) {
    if (!S) {
      const X = {
        R: o,
        L: i,
        D: l,
        C: h,
        U: m,
        T: d
      };
      S = /* @__PURE__ */ new Map();
      for (let J in r) {
        let $ = 0;
        r[J].split(",").forEach((W) => {
          let [ee, ie] = W.split("+");
          ee = parseInt(ee, 36), ie = ie ? parseInt(ie, 36) : 0, S.set($ += ee, X[J]);
          for (let pe = ie; pe--; )
            S.set(++$, X[J]);
        });
      }
    }
    return S.get(I) || m;
  }
  const T = 1, C = 2, D = 3, P = 4, U = [null, "isol", "init", "fina", "medi"];
  function B(I) {
    const X = new Uint8Array(I.length);
    let J = m, $ = T, W = -1;
    for (let ee = 0; ee < I.length; ee++) {
      const ie = I.codePointAt(ee);
      let pe = _(ie) | 0, ce = T;
      pe & d || (J & (i | l | h) ? pe & (o | l | h) ? (ce = D, ($ === T || $ === D) && X[W]++) : pe & (i | m) && ($ === C || $ === P) && X[W]-- : J & (o | m) && ($ === C || $ === P) && X[W]--, $ = X[ee] = ce, J = pe, W = ee, ie > 65535 && ee++);
    }
    return X;
  }
  function k(I, X) {
    const J = [];
    for (let W = 0; W < X.length; W++) {
      const ee = X.codePointAt(W);
      ee > 65535 && W++, J.push(a.U.codeToGlyph(I, ee));
    }
    const $ = I.GSUB;
    if ($) {
      const { lookupList: W, featureList: ee } = $;
      let ie;
      const pe = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, ce = [];
      ee.forEach((Ee) => {
        if (pe.test(Ee.tag))
          for (let de = 0; de < Ee.tab.length; de++) {
            if (ce[Ee.tab[de]])
              continue;
            ce[Ee.tab[de]] = !0;
            const Fe = W[Ee.tab[de]], Ce = /^(isol|init|fina|medi)$/.test(Ee.tag);
            Ce && !ie && (ie = B(X));
            for (let Be = 0; Be < J.length; Be++)
              (!ie || !Ce || U[ie[Be]] === Ee.tag) && a.U._applySubs(J, Be, Fe, W);
          }
      });
    }
    return J;
  }
  function V(I) {
    const X = /* @__PURE__ */ Object.create(null), J = {
      unitsPerEm: I.head.unitsPerEm,
      ascender: I.hhea.ascender,
      descender: I.hhea.descender,
      forEachGlyph($, W, ee, ie) {
        let pe = 0;
        const ce = 1 / J.unitsPerEm * W, Ee = k(I, $);
        let de = 0, Fe = -1;
        return Ee.forEach((Ce, Be) => {
          if (Ce !== -1) {
            let he = X[Ce];
            if (!he) {
              const { cmds: fe, crds: ue } = a.U.glyphToPath(I, Ce);
              let ye = "", we = 0;
              for (let ot = 0, rt = fe.length; ot < rt; ot++) {
                const _t = t[fe[ot]];
                ye += fe[ot];
                for (let Rt = 1; Rt <= _t; Rt++)
                  ye += (Rt > 1 ? "," : "") + ue[we++];
              }
              let Xe, Je, st, Ue;
              if (ue.length) {
                Xe = Je = 1 / 0, st = Ue = -1 / 0;
                for (let ot = 0, rt = ue.length; ot < rt; ot += 2) {
                  let _t = ue[ot], Rt = ue[ot + 1];
                  _t < Xe && (Xe = _t), Rt < Je && (Je = Rt), _t > st && (st = _t), Rt > Ue && (Ue = Rt);
                }
              } else
                Xe = st = Je = Ue = 0;
              he = X[Ce] = {
                index: Ce,
                advanceWidth: I.hmtx.aWidth[Ce],
                xMin: Xe,
                yMin: Je,
                xMax: st,
                yMax: Ue,
                path: ye,
                pathCommandCount: fe.length
              };
            }
            Fe !== -1 && (pe += a.U.getPairAdjustment(I, Fe, Ce) * ce), ie.call(null, he, pe, de), he.advanceWidth && (pe += he.advanceWidth * ce), ee && (pe += ee * W), Fe = Ce;
          }
          de += $.codePointAt(de) > 65535 ? 2 : 1;
        }), pe;
      }
    };
    return J;
  }
  return function(X) {
    const J = new Uint8Array(X, 0, 4), $ = a._bin.readASCII(J, 0, 4);
    if ($ === "wOFF")
      X = e(X);
    else if ($ === "wOF2")
      throw new Error("woff2 fonts not supported");
    return V(a.parse(X)[0]);
  };
}
const iY = /* @__PURE__ */ vw({
  name: "Typr Font Parser",
  dependencies: [tY, nY, rY],
  init(a, e, t) {
    const r = a(), i = e();
    return t(r, i);
  }
}), Wb = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, aY = /* @__PURE__ */ new Pn();
function zb() {
  return (self.performance || Date).now();
}
const Wz = /* @__PURE__ */ Object.create(null);
function K4(a, e) {
  a = lY({}, a);
  const t = zb();
  if (a.font = uY(a.font || Wb.defaultFontURL), a.text = "" + a.text, a.sdfGlyphSize = a.sdfGlyphSize || Wb.sdfGlyphSize, a.colorRanges != null) {
    let _ = {};
    for (let T in a.colorRanges)
      if (a.colorRanges.hasOwnProperty(T)) {
        let C = a.colorRanges[T];
        typeof C != "number" && (C = aY.set(C).getHex()), _[T] = C;
      }
    a.colorRanges = _;
  }
  Object.freeze(a);
  const { textureWidth: r, sdfExponent: i } = Wb, { sdfGlyphSize: o } = a, l = r / o * 4;
  let d = Wz[o];
  if (!d) {
    const _ = document.createElement("canvas");
    _.width = r, _.height = o * 256 / l, d = Wz[o] = {
      glyphCount: 0,
      sdfGlyphSize: o,
      sdfCanvas: _,
      sdfTexture: new iu(
        _,
        void 0,
        void 0,
        void 0,
        Po,
        Po
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, d.sdfTexture.generateMipmaps = !1, sY(d);
  }
  const { sdfTexture: h, sdfCanvas: m } = d;
  let S = d.glyphsByFont.get(a.font);
  S || d.glyphsByFont.set(a.font, S = /* @__PURE__ */ new Map()), fY(a).then((_) => {
    const { glyphIds: T, glyphPositions: C, fontSize: D, unitsPerEm: P, timings: U } = _, B = [], k = new Float32Array(T.length * 4), V = D / P;
    let I = 0, X = 0;
    const J = zb();
    T.forEach((pe, ce) => {
      let Ee = S.get(pe);
      if (!Ee) {
        const { path: Be, pathBounds: he } = _.glyphData[pe], fe = Math.max(he[2] - he[0], he[3] - he[1]) / o * (Wb.sdfMargin * o + 0.5), ue = d.glyphCount++, ye = [
          he[0] - fe,
          he[1] - fe,
          he[2] + fe,
          he[3] + fe
        ];
        S.set(pe, Ee = { path: Be, atlasIndex: ue, sdfViewBox: ye }), B.push(Ee);
      }
      const { sdfViewBox: de } = Ee, Fe = C[X++], Ce = C[X++];
      k[I++] = Fe + de[0] * V, k[I++] = Ce + de[1] * V, k[I++] = Fe + de[2] * V, k[I++] = Ce + de[3] * V, T[ce] = Ee.atlasIndex;
    }), U.quads = (U.quads || 0) + (zb() - J);
    const $ = zb();
    U.sdf = {};
    const W = m.height, ee = Math.ceil(d.glyphCount / l), ie = Math.pow(2, Math.ceil(Math.log2(ee * o)));
    ie > W && (console.info(`Increasing SDF texture size ${W}->${ie}`), eY(m, r, ie), h.dispose()), O0.all(B.map(
      (pe) => $4(pe, d, a.gpuAccelerateSDF).then(({ timing: ce }) => {
        U.sdf[pe.atlasIndex] = ce;
      })
    )).then(() => {
      B.length && !d.contextLost && (ek(d), h.needsUpdate = !0), U.sdfTotal = zb() - $, U.total = zb() - t, e(Object.freeze({
        parameters: a,
        sdfTexture: h,
        sdfGlyphSize: o,
        sdfExponent: i,
        glyphBounds: k,
        glyphAtlasIndices: T,
        glyphColors: _.glyphColors,
        caretPositions: _.caretPositions,
        caretHeight: _.caretHeight,
        chunkedBounds: _.chunkedBounds,
        ascender: _.ascender,
        descender: _.descender,
        lineHeight: _.lineHeight,
        topBaseline: _.topBaseline,
        blockBounds: _.blockBounds,
        visibleBounds: _.visibleBounds,
        timings: _.timings,
        get totalBounds() {
          return console.log("totalBounds deprecated, use blockBounds instead"), _.blockBounds;
        },
        get totalBlockSize() {
          console.log("totalBlockSize deprecated, use blockBounds instead");
          const [pe, ce, Ee, de] = _.blockBounds;
          return [Ee - pe, de - ce];
        }
      }));
    });
  }), O0.all([]).then(() => {
    d.contextLost || $j(m);
  });
}
function $4({ path: a, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: i, contextLost: o }, l) {
  if (o)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: d, sdfExponent: h } = Wb, m = Math.max(t[2] - t[0], t[3] - t[1]), S = Math.floor(e / 4), _ = S % (d / r) * r, T = Math.floor(S / (d / r)) * r, C = e % 4;
  return Jj(r, r, a, t, m, h, i, _, T, C, l);
}
function sY(a) {
  const e = a.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), a.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), a.contextLost = !1;
    const r = [];
    a.glyphsByFont.forEach((i) => {
      i.forEach((o) => {
        r.push($4(o, a, !0));
      });
    }), O0.all(r).then(() => {
      ek(a), a.sdfTexture.needsUpdate = !0;
    });
  });
}
function oY({ font: a, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e) ? e.join(`
`) : "" + e;
  K4({ font: a, sdfGlyphSize: t, text: i }, r);
}
function lY(a, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (a[t] = e[t]);
  return a;
}
let iC;
function uY(a) {
  return iC || (iC = typeof document > "u" ? {} : document.createElement("a")), iC.href = a, iC.href;
}
function ek(a) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = a, { width: r, height: i } = e, o = a.sdfCanvas.getContext("webgl");
    let l = t.image.data;
    (!l || l.length !== r * i * 4) && (l = new Uint8Array(r * i * 4), t.image = { width: r, height: i, data: l }, t.flipY = !1, t.isDataTexture = !0), o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, l);
  }
}
const cY = /* @__PURE__ */ vw({
  name: "Typesetter",
  dependencies: [
    Wb,
    iY,
    Zj,
    Vj
  ],
  init(a, e, t, r) {
    const { defaultFontURL: i } = a;
    return t(e, r(), { defaultFontURL: i });
  }
}), fY = /* @__PURE__ */ vw({
  name: "Typesetter",
  dependencies: [
    cY,
    Hj
  ],
  init(a, e) {
    return function(t) {
      const r = new e();
      return a.typeset(t, r.resolve), r;
    };
  },
  getTransferables(a) {
    const e = [
      a.glyphPositions.buffer,
      a.glyphIds.buffer
    ];
    return a.caretPositions && e.push(a.caretPositions.buffer), a.glyphColors && e.push(a.glyphColors.buffer), e;
  }
}), dY = /* @__PURE__ */ (() => {
  const a = {};
  function e(h) {
    let m = a[h];
    if (!m) {
      const S = new ig(1, 1, h, h), _ = S.clone(), T = S.attributes, C = _.attributes, D = new ui(), P = T.uv.count;
      for (let U = 0; U < P; U++)
        C.position.array[U * 3] *= -1, C.normal.array[U * 3 + 2] *= -1;
      ["position", "normal", "uv"].forEach((U) => {
        D.setAttribute(
          U,
          new sr(
            [...T[U].array, ...C[U].array],
            T[U].itemSize
          )
        );
      }), D.setIndex([...S.index.array, ..._.index.array.map((U) => U + P)]), D.translate(0.5, 0.5, 0), m = a[h] = D;
    }
    return m;
  }
  const t = "aTroikaGlyphBounds", r = "aTroikaGlyphIndex", i = "aTroikaGlyphColor";
  class o extends JC {
    constructor() {
      super(), this.detail = 1, this.curveRadius = 0, this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 }
      ], this.boundingSphere = new vy(), this.boundingBox = new sg();
    }
    computeBoundingSphere() {
    }
    computeBoundingBox() {
    }
    setSide(m) {
      const S = this.getIndex().count;
      this.setDrawRange(m === uf ? S / 2 : 0, m === Pp ? S : S / 2);
    }
    set detail(m) {
      if (m !== this._detail) {
        this._detail = m, (typeof m != "number" || m < 1) && (m = 1);
        let S = e(m);
        ["position", "normal", "uv"].forEach((_) => {
          this.attributes[_] = S.attributes[_].clone();
        }), this.setIndex(S.getIndex().clone());
      }
    }
    get detail() {
      return this._detail;
    }
    set curveRadius(m) {
      m !== this._curveRadius && (this._curveRadius = m, this._updateBounds());
    }
    get curveRadius() {
      return this._curveRadius;
    }
    updateGlyphs(m, S, _, T, C) {
      l(this, t, m, 4), l(this, r, S, 1), l(this, i, C, 3), this._blockBounds = _, this._chunkedBounds = T, d(this, S.length), this._updateBounds();
    }
    _updateBounds() {
      const m = this._blockBounds;
      if (m) {
        const { curveRadius: S, boundingBox: _ } = this;
        if (S) {
          const { PI: T, floor: C, min: D, max: P, sin: U, cos: B } = Math, k = T / 2, V = T * 2, I = Math.abs(S), X = m[0] / I, J = m[2] / I, $ = C((X + k) / V) !== C((J + k) / V) ? -I : D(U(X) * I, U(J) * I), W = C((X - k) / V) !== C((J - k) / V) ? I : P(U(X) * I, U(J) * I), ee = C((X + T) / V) !== C((J + T) / V) ? I * 2 : P(I - B(X) * I, I - B(J) * I);
          _.min.set($, m[1], S < 0 ? -ee : 0), _.max.set(W, m[3], S < 0 ? 0 : ee);
        } else
          _.min.set(m[0], m[1], 0), _.max.set(m[2], m[3], 0);
        _.getBoundingSphere(this.boundingSphere);
      }
    }
    applyClipRect(m) {
      let S = this.getAttribute(r).count, _ = this._chunkedBounds;
      if (_)
        for (let T = _.length; T--; ) {
          S = _[T].end;
          let C = _[T].rect;
          if (C[1] < m.w && C[3] > m.y && C[0] < m.z && C[2] > m.x)
            break;
        }
      d(this, S);
    }
  }
  o.prototype.setAttribute || (o.prototype.setAttribute = function(h, m) {
    return this.attributes[h] = m, this;
  });
  function l(h, m, S, _) {
    const T = h.getAttribute(m);
    S ? T && T.array.length === S.length ? (T.array.set(S), T.needsUpdate = !0) : (h.setAttribute(m, new WS(S, _)), delete h._maxInstanceCount, h.dispose()) : T && h.deleteAttribute(m);
  }
  function d(h, m) {
    h[h.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = m;
  }
  return o;
})(), hY = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, pY = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, mY = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, vY = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function gY(a) {
  const e = O3(a, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new Ft() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new la(0, 0, 0, 0) },
      uTroikaClipRect: { value: new la(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new Ft() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Pn() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new jh() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: hY,
    vertexTransform: pY,
    fragmentDefs: mY,
    fragmentColorTransform: vY,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return i.test(r) && (r = r.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(
        J4,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const yY = /* @__PURE__ */ (() => {
  const a = new og({
    color: 16777215,
    side: Pp,
    transparent: !0
  }), e = 8421504, t = new si(), r = new ge(), i = new ge(), o = [], l = new ge(), d = "+x+y";
  function h(B) {
    return Array.isArray(B) ? B[0] : B;
  }
  let m = () => {
    const B = new zn(
      new ig(1, 1),
      a
    );
    return m = () => B, B;
  }, S = () => {
    const B = new zn(
      new ig(1, 1, 32, 1),
      a
    );
    return S = () => B, B;
  };
  const _ = { type: "syncstart" }, T = { type: "synccomplete" }, C = [
    "font",
    "fontSize",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize"
  ], D = C.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
  class P extends zn {
    constructor() {
      const k = new dY();
      super(k, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = 0.1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = e, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = d, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
    }
    sync(k) {
      this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(k) : (this._isSyncing = !0, this.dispatchEvent(_), K4({
        text: this.text,
        font: this.font,
        fontSize: this.fontSize || 0.1,
        letterSpacing: this.letterSpacing || 0,
        lineHeight: this.lineHeight || "normal",
        maxWidth: this.maxWidth,
        direction: this.direction || "auto",
        textAlign: this.textAlign,
        textIndent: this.textIndent,
        whiteSpace: this.whiteSpace,
        overflowWrap: this.overflowWrap,
        anchorX: this.anchorX,
        anchorY: this.anchorY,
        colorRanges: this.colorRanges,
        includeCaretPositions: !0,
        sdfGlyphSize: this.sdfGlyphSize,
        gpuAccelerateSDF: this.gpuAccelerateSDF
      }, (V) => {
        this._isSyncing = !1, this._textRenderInfo = V, this.geometry.updateGlyphs(
          V.glyphBounds,
          V.glyphAtlasIndices,
          V.blockBounds,
          V.chunkedBounds,
          V.glyphColors
        );
        const I = this._queuedSyncs;
        I && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
          I.forEach((X) => X && X());
        })), this.dispatchEvent(T), k && k();
      })));
    }
    onBeforeRender(k, V, I, X, J, $) {
      this.sync(), J.isTroikaTextMaterial && this._prepareForRender(J), J._hadOwnSide = J.hasOwnProperty("side"), this.geometry.setSide(J._actualSide = J.side), J.side = py;
    }
    onAfterRender(k, V, I, X, J, $) {
      J._hadOwnSide ? J.side = J._actualSide : delete J.side;
    }
    dispose() {
      this.geometry.dispose();
    }
    get textRenderInfo() {
      return this._textRenderInfo || null;
    }
    get material() {
      let k = this._derivedMaterial;
      const V = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = a.clone());
      if ((!k || k.baseMaterial !== V) && (k = this._derivedMaterial = gY(V), V.addEventListener("dispose", function I() {
        V.removeEventListener("dispose", I), k.dispose();
      })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
        let I = k._outlineMtl;
        return I || (I = k._outlineMtl = Object.create(k, {
          id: { value: k.id + 0.1 }
        }), I.isTextOutlineMaterial = !0, I.depthWrite = !1, I.map = null, k.addEventListener("dispose", function X() {
          k.removeEventListener("dispose", X), I.dispose();
        })), [
          I,
          k
        ];
      } else
        return k;
    }
    set material(k) {
      k && k.isTroikaTextMaterial ? (this._derivedMaterial = k, this._baseMaterial = k.baseMaterial) : this._baseMaterial = k;
    }
    get glyphGeometryDetail() {
      return this.geometry.detail;
    }
    set glyphGeometryDetail(k) {
      this.geometry.detail = k;
    }
    get curveRadius() {
      return this.geometry.curveRadius;
    }
    set curveRadius(k) {
      this.geometry.curveRadius = k;
    }
    get customDepthMaterial() {
      return h(this.material).getDepthMaterial();
    }
    get customDistanceMaterial() {
      return h(this.material).getDistanceMaterial();
    }
    _prepareForRender(k) {
      const V = k.isTextOutlineMaterial, I = k.uniforms, X = this.textRenderInfo;
      if (X) {
        const { sdfTexture: W, blockBounds: ee } = X;
        I.uTroikaSDFTexture.value = W, I.uTroikaSDFTextureSize.value.set(W.image.width, W.image.height), I.uTroikaSDFGlyphSize.value = X.sdfGlyphSize, I.uTroikaSDFExponent.value = X.sdfExponent, I.uTroikaTotalBounds.value.fromArray(ee), I.uTroikaUseGlyphColors.value = !V && !!X.glyphColors;
        let ie = 0, pe = 0, ce = 0, Ee, de, Fe, Ce = 0, Be = 0;
        if (V) {
          let { outlineWidth: fe, outlineOffsetX: ue, outlineOffsetY: ye, outlineBlur: we, outlineOpacity: Xe } = this;
          ie = this._parsePercent(fe) || 0, pe = Math.max(0, this._parsePercent(we) || 0), Ee = Xe, Ce = this._parsePercent(ue) || 0, Be = this._parsePercent(ye) || 0;
        } else
          ce = Math.max(0, this._parsePercent(this.strokeWidth) || 0), ce && (Fe = this.strokeColor, I.uTroikaStrokeColor.value.set(Fe == null ? e : Fe), de = this.strokeOpacity, de == null && (de = 1)), Ee = this.fillOpacity;
        I.uTroikaDistanceOffset.value = ie, I.uTroikaPositionOffset.value.set(Ce, Be), I.uTroikaBlurRadius.value = pe, I.uTroikaStrokeWidth.value = ce, I.uTroikaStrokeOpacity.value = de, I.uTroikaFillOpacity.value = Ee == null ? 1 : Ee, I.uTroikaCurveRadius.value = this.curveRadius || 0;
        let he = this.clipRect;
        if (he && Array.isArray(he) && he.length === 4)
          I.uTroikaClipRect.value.fromArray(he);
        else {
          const fe = (this.fontSize || 0.1) * 100;
          I.uTroikaClipRect.value.set(
            ee[0] - fe,
            ee[1] - fe,
            ee[2] + fe,
            ee[3] + fe
          );
        }
        this.geometry.applyClipRect(I.uTroikaClipRect.value);
      }
      I.uTroikaSDFDebug.value = !!this.debugSDF, k.polygonOffset = !!this.depthOffset, k.polygonOffsetFactor = k.polygonOffsetUnits = this.depthOffset || 0;
      const J = V ? this.outlineColor || 0 : this.color;
      if (J == null)
        delete k.color;
      else {
        const W = k.hasOwnProperty("color") ? k.color : k.color = new Pn();
        (J !== W._input || typeof J == "object") && W.set(W._input = J);
      }
      let $ = this.orientation || d;
      if ($ !== k._orientation) {
        let W = I.uTroikaOrient.value;
        $ = $.replace(/[^-+xyz]/g, "");
        let ee = $ !== d && $.match(/^([-+])([xyz])([-+])([xyz])$/);
        if (ee) {
          let [, ie, pe, ce, Ee] = ee;
          r.set(0, 0, 0)[pe] = ie === "-" ? 1 : -1, i.set(0, 0, 0)[Ee] = ce === "-" ? -1 : 1, t.lookAt(l, r.cross(i), i), W.setFromMatrix4(t);
        } else
          W.identity();
        k._orientation = $;
      }
    }
    _parsePercent(k) {
      if (typeof k == "string") {
        let V = k.match(/^(-?[\d.]+)%$/), I = V ? parseFloat(V[1]) : NaN;
        k = (isNaN(I) ? 0 : I / 100) * this.fontSize;
      }
      return k;
    }
    localPositionToTextCoords(k, V = new Ft()) {
      V.copy(k);
      const I = this.curveRadius;
      return I && (V.x = Math.atan2(k.x, Math.abs(I) - Math.abs(k.z)) * Math.abs(I)), V;
    }
    worldPositionToTextCoords(k, V = new Ft()) {
      return r.copy(k), this.localPositionToTextCoords(this.worldToLocal(r), V);
    }
    raycast(k, V) {
      const { textRenderInfo: I, curveRadius: X } = this;
      if (I) {
        const J = I.blockBounds, $ = X ? S() : m(), W = $.geometry, { position: ee, uv: ie } = W.attributes;
        for (let pe = 0; pe < ie.count; pe++) {
          let ce = J[0] + ie.getX(pe) * (J[2] - J[0]);
          const Ee = J[1] + ie.getY(pe) * (J[3] - J[1]);
          let de = 0;
          X && (de = X - Math.cos(ce / X) * X, ce = Math.sin(ce / X) * X), ee.setXYZ(pe, ce, Ee, de);
        }
        W.boundingSphere = this.geometry.boundingSphere, W.boundingBox = this.geometry.boundingBox, $.matrixWorld = this.matrixWorld, $.material.side = this.material.side, o.length = 0, $.raycast(k, o);
        for (let pe = 0; pe < o.length; pe++)
          o[pe].object = this, V.push(o[pe]);
      }
    }
    copy(k) {
      const V = this.geometry;
      return super.copy(k), this.geometry = V, D.forEach((I) => {
        this[I] = k[I];
      }), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  C.forEach((B) => {
    const k = "_private_" + B;
    Object.defineProperty(P.prototype, B, {
      get() {
        return this[k];
      },
      set(V) {
        V !== this[k] && (this[k] = V, this._needsSync = !0);
      }
    });
  });
  let U = !1;
  return Object.defineProperty(P.prototype, "anchor", {
    get() {
      return this._deprecated_anchor;
    },
    set(B) {
      this._deprecated_anchor = B, U || (console.warn("TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead."), U = !0), Array.isArray(B) ? (this.anchorX = `${(+B[0] || 0) * 100}%`, this.anchorY = `${(+B[1] || 0) * 100}%`) : this.anchorX = this.anchorY = 0;
    }
  }), P;
})(), xY = /* @__PURE__ */ Or.forwardRef(({
  anchorX: a = "center",
  anchorY: e = "middle",
  font: t,
  children: r,
  characters: i,
  onSync: o,
  ...l
}, d) => {
  const h = Od(({
    invalidate: T
  }) => T), [m] = Or.useState(() => new yY()), [S, _] = Or.useMemo(() => {
    const T = [];
    let C = "";
    return Or.Children.forEach(r, (D) => {
      typeof D == "string" || typeof D == "number" ? C += D : T.push(D);
    }), [T, C];
  }, [r]);
  return y9(() => new Promise((T) => oY({
    font: t,
    characters: i
  }, T)), ["troika-text", t, i]), Or.useLayoutEffect(() => void m.sync(() => {
    h(), o && o(m);
  })), Or.useEffect(() => () => m.dispose(), [m]), /* @__PURE__ */ _n("primitive", {
    object: m,
    ref: d,
    font: t,
    text: _,
    anchorX: a,
    anchorY: e,
    ...l,
    children: S
  });
});
var SY = 1 / 0, _Y = 9007199254740991, bY = "[object Arguments]", wY = "[object Function]", EY = "[object GeneratorFunction]", MY = "[object Symbol]", TY = typeof A0 == "object" && A0 && A0.Object === Object && A0, CY = typeof self == "object" && self && self.Object === Object && self, RY = TY || CY || Function("return this")();
function AY(a, e, t) {
  switch (t.length) {
    case 0:
      return a.call(e);
    case 1:
      return a.call(e, t[0]);
    case 2:
      return a.call(e, t[0], t[1]);
    case 3:
      return a.call(e, t[0], t[1], t[2]);
  }
  return a.apply(e, t);
}
function DY(a, e) {
  for (var t = -1, r = a ? a.length : 0, i = Array(r); ++t < r; )
    i[t] = e(a[t], t, a);
  return i;
}
function LY(a, e) {
  for (var t = -1, r = e.length, i = a.length; ++t < r; )
    a[i + t] = e[t];
  return a;
}
var CL = Object.prototype, PY = CL.hasOwnProperty, RL = CL.toString, jz = RY.Symbol, OY = CL.propertyIsEnumerable, Yz = jz ? jz.isConcatSpreadable : void 0, Xz = Math.max;
function tk(a, e, t, r, i) {
  var o = -1, l = a.length;
  for (t || (t = FY), i || (i = []); ++o < l; ) {
    var d = a[o];
    e > 0 && t(d) ? e > 1 ? tk(d, e - 1, t, r, i) : LY(i, d) : r || (i[i.length] = d);
  }
  return i;
}
function UY(a, e) {
  return a = Object(a), zY(a, e, function(t, r) {
    return r in a;
  });
}
function zY(a, e, t) {
  for (var r = -1, i = e.length, o = {}; ++r < i; ) {
    var l = e[r], d = a[l];
    t(d, l) && (o[l] = d);
  }
  return o;
}
function NY(a, e) {
  return e = Xz(e === void 0 ? a.length - 1 : e, 0), function() {
    for (var t = arguments, r = -1, i = Xz(t.length - e, 0), o = Array(i); ++r < i; )
      o[r] = t[e + r];
    r = -1;
    for (var l = Array(e + 1); ++r < e; )
      l[r] = t[r];
    return l[e] = o, AY(a, this, l);
  };
}
function FY(a) {
  return BY(a) || IY(a) || !!(Yz && a && a[Yz]);
}
function kY(a) {
  if (typeof a == "string" || YY(a))
    return a;
  var e = a + "";
  return e == "0" && 1 / a == -SY ? "-0" : e;
}
function IY(a) {
  return VY(a) && PY.call(a, "callee") && (!OY.call(a, "callee") || RL.call(a) == bY);
}
var BY = Array.isArray;
function HY(a) {
  return a != null && WY(a.length) && !GY(a);
}
function VY(a) {
  return nk(a) && HY(a);
}
function GY(a) {
  var e = jY(a) ? RL.call(a) : "";
  return e == wY || e == EY;
}
function WY(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= _Y;
}
function jY(a) {
  var e = typeof a;
  return !!a && (e == "object" || e == "function");
}
function nk(a) {
  return !!a && typeof a == "object";
}
function YY(a) {
  return typeof a == "symbol" || nk(a) && RL.call(a) == MY;
}
var XY = NY(function(a, e) {
  return a == null ? {} : UY(a, DY(tk(e, 1), kY));
}), ED = XY;
const qY = /* @__PURE__ */ Or.forwardRef(({
  makeDefault: a,
  camera: e,
  regress: t,
  domElement: r,
  enableDamping: i = !0,
  onChange: o,
  onStart: l,
  onEnd: d,
  ...h
}, m) => {
  const S = Od((I) => I.invalidate), _ = Od((I) => I.camera), T = Od((I) => I.gl), C = Od((I) => I.events), D = Od((I) => I.set), P = Od((I) => I.get), U = Od((I) => I.performance), B = e || _, k = r || C.connected || T.domElement, V = Or.useMemo(() => new Cj(B), [B]);
  return yy(() => {
    V.enabled && V.update();
  }, -1), Or.useEffect(() => (V.connect(k), () => void V.dispose()), [k, t, V, S]), Or.useEffect(() => {
    const I = (X) => {
      S(), t && U.regress(), o && o(X);
    };
    return V.addEventListener("change", I), l && V.addEventListener("start", l), d && V.addEventListener("end", d), () => {
      l && V.removeEventListener("start", l), d && V.removeEventListener("end", d), V.removeEventListener("change", I);
    };
  }, [o, l, d, V, S]), Or.useEffect(() => {
    if (a) {
      const I = P().controls;
      return D({
        controls: V
      }), () => D({
        controls: I
      });
    }
  }, [a, V]), /* @__PURE__ */ _n("primitive", {
    ref: m,
    object: V,
    enableDamping: i,
    ...h
  });
});
function QY(a) {
  const e = a + "Geometry";
  return /* @__PURE__ */ Or.forwardRef(({
    args: t,
    children: r,
    ...i
  }, o) => /* @__PURE__ */ dh("mesh", {
    ref: o,
    ...i,
    children: [/* @__PURE__ */ _n(e, {
      attach: "geometry",
      args: t
    }), r]
  }));
}
const ZY = QY("circle"), qz = (a) => {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (h, m) => {
    const S = typeof h == "function" ? h(e) : h;
    if (S !== e) {
      const _ = e;
      e = m ? S : Object.assign({}, e, S), t.forEach((T) => T(e, _));
    }
  }, i = () => e, d = { setState: r, getState: i, subscribe: (h) => (t.add(h), () => t.delete(h)), destroy: () => t.clear() };
  return e = a(
    r,
    i,
    d
  ), d;
}, JY = (a) => a ? qz(a) : qz;
var rk = { exports: {} }, MD = {}, TD = { exports: {} }, CD = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Qz;
function KY() {
  if (Qz)
    return CD;
  Qz = 1;
  var a = hh;
  function e(_, T) {
    return _ === T && (_ !== 0 || 1 / _ === 1 / T) || _ !== _ && T !== T;
  }
  var t = typeof Object.is == "function" ? Object.is : e, r = a.useState, i = a.useEffect, o = a.useLayoutEffect, l = a.useDebugValue;
  function d(_, T) {
    var C = T(), D = r({ inst: { value: C, getSnapshot: T } }), P = D[0].inst, U = D[1];
    return o(function() {
      P.value = C, P.getSnapshot = T, h(P) && U({ inst: P });
    }, [_, C, T]), i(function() {
      return h(P) && U({ inst: P }), _(function() {
        h(P) && U({ inst: P });
      });
    }, [_]), l(C), C;
  }
  function h(_) {
    var T = _.getSnapshot;
    _ = _.value;
    try {
      var C = T();
      return !t(_, C);
    } catch {
      return !0;
    }
  }
  function m(_, T) {
    return T();
  }
  var S = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? m : d;
  return CD.useSyncExternalStore = a.useSyncExternalStore !== void 0 ? a.useSyncExternalStore : S, CD;
}
var RD = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zz;
function $Y() {
  return Zz || (Zz = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var a = hh, e = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function t(V) {
      {
        for (var I = arguments.length, X = new Array(I > 1 ? I - 1 : 0), J = 1; J < I; J++)
          X[J - 1] = arguments[J];
        r("error", V, X);
      }
    }
    function r(V, I, X) {
      {
        var J = e.ReactDebugCurrentFrame, $ = J.getStackAddendum();
        $ !== "" && (I += "%s", X = X.concat([$]));
        var W = X.map(function(ee) {
          return String(ee);
        });
        W.unshift("Warning: " + I), Function.prototype.apply.call(console[V], console, W);
      }
    }
    function i(V, I) {
      return V === I && (V !== 0 || 1 / V === 1 / I) || V !== V && I !== I;
    }
    var o = typeof Object.is == "function" ? Object.is : i, l = a.useState, d = a.useEffect, h = a.useLayoutEffect, m = a.useDebugValue, S = !1, _ = !1;
    function T(V, I, X) {
      S || a.startTransition !== void 0 && (S = !0, t("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var J = I();
      if (!_) {
        var $ = I();
        o(J, $) || (t("The result of getSnapshot should be cached to avoid an infinite loop"), _ = !0);
      }
      var W = l({
        inst: {
          value: J,
          getSnapshot: I
        }
      }), ee = W[0].inst, ie = W[1];
      return h(function() {
        ee.value = J, ee.getSnapshot = I, C(ee) && ie({
          inst: ee
        });
      }, [V, J, I]), d(function() {
        C(ee) && ie({
          inst: ee
        });
        var pe = function() {
          C(ee) && ie({
            inst: ee
          });
        };
        return V(pe);
      }, [V]), m(J), J;
    }
    function C(V) {
      var I = V.getSnapshot, X = V.value;
      try {
        var J = I();
        return !o(X, J);
      } catch {
        return !0;
      }
    }
    function D(V, I, X) {
      return I();
    }
    var P = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", U = !P, B = U ? D : T, k = a.useSyncExternalStore !== void 0 ? a.useSyncExternalStore : B;
    RD.useSyncExternalStore = k, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), RD;
}
var Jz;
function ik() {
  return Jz || (Jz = 1, function(a) {
    process.env.NODE_ENV === "production" ? a.exports = KY() : a.exports = $Y();
  }(TD)), TD.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kz;
function eX() {
  if (Kz)
    return MD;
  Kz = 1;
  var a = hh, e = ik();
  function t(m, S) {
    return m === S && (m !== 0 || 1 / m === 1 / S) || m !== m && S !== S;
  }
  var r = typeof Object.is == "function" ? Object.is : t, i = e.useSyncExternalStore, o = a.useRef, l = a.useEffect, d = a.useMemo, h = a.useDebugValue;
  return MD.useSyncExternalStoreWithSelector = function(m, S, _, T, C) {
    var D = o(null);
    if (D.current === null) {
      var P = { hasValue: !1, value: null };
      D.current = P;
    } else
      P = D.current;
    D = d(function() {
      function B(J) {
        if (!k) {
          if (k = !0, V = J, J = T(J), C !== void 0 && P.hasValue) {
            var $ = P.value;
            if (C($, J))
              return I = $;
          }
          return I = J;
        }
        if ($ = I, r(V, J))
          return $;
        var W = T(J);
        return C !== void 0 && C($, W) ? $ : (V = J, I = W);
      }
      var k = !1, V, I, X = _ === void 0 ? null : _;
      return [function() {
        return B(S());
      }, X === null ? void 0 : function() {
        return B(X());
      }];
    }, [S, _, T, C]);
    var U = i(m, D[0], D[1]);
    return l(function() {
      P.hasValue = !0, P.value = U;
    }, [U]), h(U), U;
  }, MD;
}
var AD = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $z;
function tX() {
  return $z || ($z = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var a = hh, e = ik();
    function t(S, _) {
      return S === _ && (S !== 0 || 1 / S === 1 / _) || S !== S && _ !== _;
    }
    var r = typeof Object.is == "function" ? Object.is : t, i = e.useSyncExternalStore, o = a.useRef, l = a.useEffect, d = a.useMemo, h = a.useDebugValue;
    function m(S, _, T, C, D) {
      var P = o(null), U;
      P.current === null ? (U = {
        hasValue: !1,
        value: null
      }, P.current = U) : U = P.current;
      var B = d(function() {
        var X = !1, J, $, W = function(ce) {
          if (!X) {
            X = !0, J = ce;
            var Ee = C(ce);
            if (D !== void 0 && U.hasValue) {
              var de = U.value;
              if (D(de, Ee))
                return $ = de, de;
            }
            return $ = Ee, Ee;
          }
          var Fe = J, Ce = $;
          if (r(Fe, ce))
            return Ce;
          var Be = C(ce);
          return D !== void 0 && D(Ce, Be) ? Ce : (J = ce, $ = Be, Be);
        }, ee = T === void 0 ? null : T, ie = function() {
          return W(_());
        }, pe = ee === null ? void 0 : function() {
          return W(ee());
        };
        return [ie, pe];
      }, [_, T, C, D]), k = B[0], V = B[1], I = i(S, k, V);
      return l(function() {
        U.hasValue = !0, U.value = I;
      }, [I]), h(I), I;
    }
    AD.useSyncExternalStoreWithSelector = m, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), AD;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = eX() : a.exports = tX();
})(rk);
const nX = /* @__PURE__ */ y4(rk.exports), { useSyncExternalStoreWithSelector: rX } = nX;
function ak(a, e = a.getState, t) {
  const r = rX(
    a.subscribe,
    a.getState,
    a.getServerState || a.getState,
    e,
    t
  );
  return _N(r), r;
}
const eN = (a) => {
  const e = typeof a == "function" ? JY(a) : a, t = (r, i) => ak(e, r, i);
  return Object.assign(t, e), t;
}, iX = (a) => a ? eN(a) : eN;
var aX = iX;
const sX = (a) => (e, t, r) => {
  const i = r.subscribe;
  return r.subscribe = (l, d, h) => {
    let m = l;
    if (d) {
      const S = (h == null ? void 0 : h.equalityFn) || Object.is;
      let _ = l(r.getState());
      m = (T) => {
        const C = l(T);
        if (!S(_, C)) {
          const D = _;
          d(_ = C, D);
        }
      }, h != null && h.fireImmediately && d(_, _);
    }
    return i(m);
  }, a(e, t, r);
}, oX = sX;
function Ud(a) {
  for (var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    t[r - 1] = arguments[r];
  if (process.env.NODE_ENV !== "production") {
    var i = mX[a], o = i ? typeof i == "function" ? i.apply(null, t) : i : "unknown error nr: " + a;
    throw Error("[Immer] " + o);
  }
  throw Error("[Immer] minified error nr: " + a + (t.length ? " " + t.map(function(l) {
    return "'" + l + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function cw(a) {
  return !!a && !!a[wm];
}
function XS(a) {
  return !!a && (function(e) {
    if (!e || typeof e != "object")
      return !1;
    var t = Object.getPrototypeOf(e);
    if (t === null)
      return !0;
    var r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return r === Object || typeof r == "function" && Function.toString.call(r) === vX;
  }(a) || Array.isArray(a) || !!a[lN] || !!a.constructor[lN] || AL(a) || DL(a));
}
function XM(a, e, t) {
  t === void 0 && (t = !1), gw(a) === 0 ? (t ? Object.keys : zL)(a).forEach(function(r) {
    t && typeof r == "symbol" || e(r, a[r], a);
  }) : a.forEach(function(r, i) {
    return e(i, r, a);
  });
}
function gw(a) {
  var e = a[wm];
  return e ? e.i > 3 ? e.i - 4 : e.i : Array.isArray(a) ? 1 : AL(a) ? 2 : DL(a) ? 3 : 0;
}
function U3(a, e) {
  return gw(a) === 2 ? a.has(e) : Object.prototype.hasOwnProperty.call(a, e);
}
function lX(a, e) {
  return gw(a) === 2 ? a.get(e) : a[e];
}
function sk(a, e, t) {
  var r = gw(a);
  r === 2 ? a.set(e, t) : r === 3 ? (a.delete(e), a.add(t)) : a[e] = t;
}
function uX(a, e) {
  return a === e ? a !== 0 || 1 / a == 1 / e : a != a && e != e;
}
function AL(a) {
  return hX && a instanceof Map;
}
function DL(a) {
  return pX && a instanceof Set;
}
function CS(a) {
  return a.o || a.t;
}
function LL(a) {
  if (Array.isArray(a))
    return Array.prototype.slice.call(a);
  var e = gX(a);
  delete e[wm];
  for (var t = zL(e), r = 0; r < t.length; r++) {
    var i = t[r], o = e[i];
    o.writable === !1 && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (e[i] = { configurable: !0, writable: !0, enumerable: o.enumerable, value: a[i] });
  }
  return Object.create(Object.getPrototypeOf(a), e);
}
function PL(a, e) {
  return e === void 0 && (e = !1), OL(a) || cw(a) || !XS(a) || (gw(a) > 1 && (a.set = a.add = a.clear = a.delete = cX), Object.freeze(a), e && XM(a, function(t, r) {
    return PL(r, !0);
  }, !0)), a;
}
function cX() {
  Ud(2);
}
function OL(a) {
  return a == null || typeof a != "object" || Object.isFrozen(a);
}
function dy(a) {
  var e = yX[a];
  return e || Ud(18, a), e;
}
function tN() {
  return process.env.NODE_ENV === "production" || fw || Ud(0), fw;
}
function DD(a, e) {
  e && (dy("Patches"), a.u = [], a.s = [], a.v = e);
}
function DC(a) {
  z3(a), a.p.forEach(fX), a.p = null;
}
function z3(a) {
  a === fw && (fw = a.l);
}
function nN(a) {
  return fw = { p: [], l: fw, h: a, m: !0, _: 0 };
}
function fX(a) {
  var e = a[wm];
  e.i === 0 || e.i === 1 ? e.j() : e.O = !0;
}
function LD(a, e) {
  e._ = e.p.length;
  var t = e.p[0], r = a !== void 0 && a !== t;
  return e.h.g || dy("ES5").S(e, a, r), r ? (t[wm].P && (DC(e), Ud(4)), XS(a) && (a = LC(e, a), e.l || PC(e, a)), e.u && dy("Patches").M(t[wm].t, a, e.u, e.s)) : a = LC(e, t, []), DC(e), e.u && e.v(e.u, e.s), a !== ok ? a : void 0;
}
function LC(a, e, t) {
  if (OL(e))
    return e;
  var r = e[wm];
  if (!r)
    return XM(e, function(o, l) {
      return rN(a, r, e, o, l, t);
    }, !0), e;
  if (r.A !== a)
    return e;
  if (!r.P)
    return PC(a, r.t, !0), r.t;
  if (!r.I) {
    r.I = !0, r.A._--;
    var i = r.i === 4 || r.i === 5 ? r.o = LL(r.k) : r.o;
    XM(r.i === 3 ? new Set(i) : i, function(o, l) {
      return rN(a, r, i, o, l, t);
    }), PC(a, i, !1), t && a.u && dy("Patches").R(r, t, a.u, a.s);
  }
  return r.o;
}
function rN(a, e, t, r, i, o) {
  if (process.env.NODE_ENV !== "production" && i === t && Ud(5), cw(i)) {
    var l = LC(a, i, o && e && e.i !== 3 && !U3(e.D, r) ? o.concat(r) : void 0);
    if (sk(t, r, l), !cw(l))
      return;
    a.m = !1;
  }
  if (XS(i) && !OL(i)) {
    if (!a.h.F && a._ < 1)
      return;
    LC(a, i), e && e.A.l || PC(a, i);
  }
}
function PC(a, e, t) {
  t === void 0 && (t = !1), a.h.F && a.m && PL(e, t);
}
function PD(a, e) {
  var t = a[wm];
  return (t ? CS(t) : a)[e];
}
function iN(a, e) {
  if (e in a)
    for (var t = Object.getPrototypeOf(a); t; ) {
      var r = Object.getOwnPropertyDescriptor(t, e);
      if (r)
        return r;
      t = Object.getPrototypeOf(t);
    }
}
function N3(a) {
  a.P || (a.P = !0, a.l && N3(a.l));
}
function OD(a) {
  a.o || (a.o = LL(a.t));
}
function F3(a, e, t) {
  var r = AL(e) ? dy("MapSet").N(e, t) : DL(e) ? dy("MapSet").T(e, t) : a.g ? function(i, o) {
    var l = Array.isArray(i), d = { i: l ? 1 : 0, A: o ? o.A : tN(), P: !1, I: !1, D: {}, l: o, t: i, k: null, o: null, j: null, C: !1 }, h = d, m = k3;
    l && (h = [d], m = mM);
    var S = Proxy.revocable(h, m), _ = S.revoke, T = S.proxy;
    return d.k = T, d.j = _, T;
  }(e, t) : dy("ES5").J(e, t);
  return (t ? t.A : tN()).p.push(r), r;
}
function dX(a) {
  return cw(a) || Ud(22, a), function e(t) {
    if (!XS(t))
      return t;
    var r, i = t[wm], o = gw(t);
    if (i) {
      if (!i.P && (i.i < 4 || !dy("ES5").K(i)))
        return i.t;
      i.I = !0, r = aN(t, o), i.I = !1;
    } else
      r = aN(t, o);
    return XM(r, function(l, d) {
      i && lX(i.t, l) === d || sk(r, l, e(d));
    }), o === 3 ? new Set(r) : r;
  }(a);
}
function aN(a, e) {
  switch (e) {
    case 2:
      return new Map(a);
    case 3:
      return Array.from(a);
  }
  return LL(a);
}
var sN, fw, UL = typeof Symbol < "u" && typeof Symbol("x") == "symbol", hX = typeof Map < "u", pX = typeof Set < "u", oN = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", ok = UL ? Symbol.for("immer-nothing") : ((sN = {})["immer-nothing"] = !0, sN), lN = UL ? Symbol.for("immer-draftable") : "__$immer_draftable", wm = UL ? Symbol.for("immer-state") : "__$immer_state", mX = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(a) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + a;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(a) {
  return "Cannot apply patch, path doesn't resolve: " + a;
}, 16: 'Sets cannot have "replace" patches.', 17: function(a) {
  return "Unsupported patch operation: " + a;
}, 18: function(a) {
  return "The plugin for '" + a + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + a + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(a) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + a + "'";
}, 22: function(a) {
  return "'current' expects a draft, got: " + a;
}, 23: function(a) {
  return "'original' expects a draft, got: " + a;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, vX = "" + Object.prototype.constructor, zL = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(a) {
  return Object.getOwnPropertyNames(a).concat(Object.getOwnPropertySymbols(a));
} : Object.getOwnPropertyNames, gX = Object.getOwnPropertyDescriptors || function(a) {
  var e = {};
  return zL(a).forEach(function(t) {
    e[t] = Object.getOwnPropertyDescriptor(a, t);
  }), e;
}, yX = {}, k3 = { get: function(a, e) {
  if (e === wm)
    return a;
  var t = CS(a);
  if (!U3(t, e))
    return function(i, o, l) {
      var d, h = iN(o, l);
      return h ? "value" in h ? h.value : (d = h.get) === null || d === void 0 ? void 0 : d.call(i.k) : void 0;
    }(a, t, e);
  var r = t[e];
  return a.I || !XS(r) ? r : r === PD(a.t, e) ? (OD(a), a.o[e] = F3(a.A.h, r, a)) : r;
}, has: function(a, e) {
  return e in CS(a);
}, ownKeys: function(a) {
  return Reflect.ownKeys(CS(a));
}, set: function(a, e, t) {
  var r = iN(CS(a), e);
  if (r != null && r.set)
    return r.set.call(a.k, t), !0;
  if (!a.P) {
    var i = PD(CS(a), e), o = i == null ? void 0 : i[wm];
    if (o && o.t === t)
      return a.o[e] = t, a.D[e] = !1, !0;
    if (uX(t, i) && (t !== void 0 || U3(a.t, e)))
      return !0;
    OD(a), N3(a);
  }
  return a.o[e] === t && typeof t != "number" && (t !== void 0 || e in a.o) || (a.o[e] = t, a.D[e] = !0, !0);
}, deleteProperty: function(a, e) {
  return PD(a.t, e) !== void 0 || e in a.t ? (a.D[e] = !1, OD(a), N3(a)) : delete a.D[e], a.o && delete a.o[e], !0;
}, getOwnPropertyDescriptor: function(a, e) {
  var t = CS(a), r = Reflect.getOwnPropertyDescriptor(t, e);
  return r && { writable: !0, configurable: a.i !== 1 || e !== "length", enumerable: r.enumerable, value: t[e] };
}, defineProperty: function() {
  Ud(11);
}, getPrototypeOf: function(a) {
  return Object.getPrototypeOf(a.t);
}, setPrototypeOf: function() {
  Ud(12);
} }, mM = {};
XM(k3, function(a, e) {
  mM[a] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
}), mM.deleteProperty = function(a, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && Ud(13), mM.set.call(this, a, e, void 0);
}, mM.set = function(a, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && Ud(14), k3.set.call(this, a[0], e, t, a[0]);
};
var xX = function() {
  function a(t) {
    var r = this;
    this.g = oN, this.F = !0, this.produce = function(i, o, l) {
      if (typeof i == "function" && typeof o != "function") {
        var d = o;
        o = i;
        var h = r;
        return function(P) {
          var U = this;
          P === void 0 && (P = d);
          for (var B = arguments.length, k = Array(B > 1 ? B - 1 : 0), V = 1; V < B; V++)
            k[V - 1] = arguments[V];
          return h.produce(P, function(I) {
            var X;
            return (X = o).call.apply(X, [U, I].concat(k));
          });
        };
      }
      var m;
      if (typeof o != "function" && Ud(6), l !== void 0 && typeof l != "function" && Ud(7), XS(i)) {
        var S = nN(r), _ = F3(r, i, void 0), T = !0;
        try {
          m = o(_), T = !1;
        } finally {
          T ? DC(S) : z3(S);
        }
        return typeof Promise < "u" && m instanceof Promise ? m.then(function(P) {
          return DD(S, l), LD(P, S);
        }, function(P) {
          throw DC(S), P;
        }) : (DD(S, l), LD(m, S));
      }
      if (!i || typeof i != "object") {
        if ((m = o(i)) === void 0 && (m = i), m === ok && (m = void 0), r.F && PL(m, !0), l) {
          var C = [], D = [];
          dy("Patches").M(i, m, C, D), l(C, D);
        }
        return m;
      }
      Ud(21, i);
    }, this.produceWithPatches = function(i, o) {
      if (typeof i == "function")
        return function(m) {
          for (var S = arguments.length, _ = Array(S > 1 ? S - 1 : 0), T = 1; T < S; T++)
            _[T - 1] = arguments[T];
          return r.produceWithPatches(m, function(C) {
            return i.apply(void 0, [C].concat(_));
          });
        };
      var l, d, h = r.produce(i, o, function(m, S) {
        l = m, d = S;
      });
      return typeof Promise < "u" && h instanceof Promise ? h.then(function(m) {
        return [m, l, d];
      }) : [h, l, d];
    }, typeof (t == null ? void 0 : t.useProxies) == "boolean" && this.setUseProxies(t.useProxies), typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze);
  }
  var e = a.prototype;
  return e.createDraft = function(t) {
    XS(t) || Ud(8), cw(t) && (t = dX(t));
    var r = nN(this), i = F3(this, t, void 0);
    return i[wm].C = !0, z3(r), i;
  }, e.finishDraft = function(t, r) {
    var i = t && t[wm];
    process.env.NODE_ENV !== "production" && (i && i.C || Ud(9), i.I && Ud(10));
    var o = i.A;
    return DD(o, r), LD(void 0, o);
  }, e.setAutoFreeze = function(t) {
    this.F = t;
  }, e.setUseProxies = function(t) {
    t && !oN && Ud(20), this.g = t;
  }, e.applyPatches = function(t, r) {
    var i;
    for (i = r.length - 1; i >= 0; i--) {
      var o = r[i];
      if (o.path.length === 0 && o.op === "replace") {
        t = o.value;
        break;
      }
    }
    i > -1 && (r = r.slice(i + 1));
    var l = dy("Patches").$;
    return cw(t) ? l(t, r) : this.produce(t, function(d) {
      return l(d, r);
    });
  }, a;
}(), Em = new xX(), SX = Em.produce;
Em.produceWithPatches.bind(Em);
Em.setAutoFreeze.bind(Em);
Em.setUseProxies.bind(Em);
Em.applyPatches.bind(Em);
Em.createDraft.bind(Em);
Em.finishDraft.bind(Em);
const _X = SX;
class bX {
  constructor() {
    this._previousTime = 0, this._currentTime = 0, this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = !1, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === !0 && (this._pageVisibilityHandler = wX.bind(this), document.addEventListener("visibilitychange", this._pageVisibilityHandler, !1));
  }
  disableFixedDelta() {
    return this._useFixedDelta = !1, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === !0 && document.removeEventListener("visibilitychange", this._pageVisibilityHandler), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = !0, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = this._now(), this;
  }
  setFixedDelta(e) {
    return this._fixedDelta = e * 1e3, this;
  }
  setTimescale(e) {
    return this._timescale = e, this;
  }
  update() {
    return this._useFixedDelta === !0 ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = this._now(), this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
  _now() {
    return (typeof performance > "u" ? Date : performance).now();
  }
}
function wX() {
  document.hidden === !1 && this.reset();
}
var ly = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(a, e) {
  (function() {
    var t, r = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", l = "Expected a function", d = "Invalid `variable` option passed into `_.template`", h = "__lodash_hash_undefined__", m = 500, S = "__lodash_placeholder__", _ = 1, T = 2, C = 4, D = 1, P = 2, U = 1, B = 2, k = 4, V = 8, I = 16, X = 32, J = 64, $ = 128, W = 256, ee = 512, ie = 30, pe = "...", ce = 800, Ee = 16, de = 1, Fe = 2, Ce = 3, Be = 1 / 0, he = 9007199254740991, fe = 17976931348623157e292, ue = 0 / 0, ye = 4294967295, we = ye - 1, Xe = ye >>> 1, Je = [
      ["ary", $],
      ["bind", U],
      ["bindKey", B],
      ["curry", V],
      ["curryRight", I],
      ["flip", ee],
      ["partial", X],
      ["partialRight", J],
      ["rearg", W]
    ], st = "[object Arguments]", Ue = "[object Array]", ot = "[object AsyncFunction]", rt = "[object Boolean]", _t = "[object Date]", Rt = "[object DOMException]", Ot = "[object Error]", He = "[object Function]", et = "[object GeneratorFunction]", mt = "[object Map]", vt = "[object Number]", bt = "[object Null]", Qt = "[object Object]", ft = "[object Promise]", Vt = "[object Proxy]", Jt = "[object RegExp]", Mt = "[object Set]", Me = "[object String]", oe = "[object Symbol]", je = "[object Undefined]", lt = "[object WeakMap]", zt = "[object WeakSet]", Nt = "[object ArrayBuffer]", Ut = "[object DataView]", tt = "[object Float32Array]", rn = "[object Float64Array]", ze = "[object Int8Array]", xe = "[object Int16Array]", Ie = "[object Int32Array]", it = "[object Uint8Array]", at = "[object Uint8ClampedArray]", hn = "[object Uint16Array]", De = "[object Uint32Array]", Tt = /\b__p \+= '';/g, Ne = /\b(__p \+=) '' \+/g, Gt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Pt = /&(?:amp|lt|gt|quot|#39);/g, fn = /[&<>"']/g, Gr = RegExp(Pt.source), Wr = RegExp(fn.source), Ur = /<%-([\s\S]+?)%>/g, ir = /<%([\s\S]+?)%>/g, Vn = /<%=([\s\S]+?)%>/g, jr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ti = /^\w*$/, ki = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Wi = /[\\^$.*+?()[\]{}|]/g, ni = RegExp(Wi.source), ji = /^\s+/, Si = /\s/, Te = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ct = /\{\n\/\* \[wrapped with (.+)\] \*/, me = /,? & /, Oe = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, qe = /[()=,{}\[\]\/\s]/, on = /\\(\\)?/g, yn = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Rn = /\w*$/, mn = /^[-+]0x[0-9a-f]+$/i, vn = /^0b[01]+$/i, Zn = /^\[object .+?Constructor\]$/, nr = /^0o[0-7]+$/i, br = /^(?:0|[1-9]\d*)$/, Yi = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, La = /($^)/, Ys = /['\n\r\u2028\u2029\\]/g, $t = "\\ud800-\\udfff", Zr = "\\u0300-\\u036f", ls = "\\ufe20-\\ufe2f", Xn = "\\u20d0-\\u20ff", qa = Zr + ls + Xn, mo = "\\u2700-\\u27bf", Ds = "a-z\\xdf-\\xf6\\xf8-\\xff", us = "\\xac\\xb1\\xd7\\xf7", mr = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", pi = "\\u2000-\\u206f", Ea = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", _i = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ti = "\\ufe0e\\ufe0f", Oo = us + mr + pi + Ea, Uo = "['\u2019]", Pa = "[" + $t + "]", Rl = "[" + Oo + "]", vo = "[" + qa + "]", Wf = "\\d+", Al = "[" + mo + "]", zd = "[" + Ds + "]", Ls = "[^" + $t + Oo + Wf + mo + Ds + _i + "]", Ju = "\\ud83c[\\udffb-\\udfff]", au = "(?:" + vo + "|" + Ju + ")", qh = "[^" + $t + "]", Dl = "(?:\\ud83c[\\udde6-\\uddff]){2}", ri = "[\\ud800-\\udbff][\\udc00-\\udfff]", go = "[" + _i + "]", jf = "\\u200d", zo = "(?:" + zd + "|" + Ls + ")", Ci = "(?:" + go + "|" + Ls + ")", cs = "(?:" + Uo + "(?:d|ll|m|re|s|t|ve))?", Yf = "(?:" + Uo + "(?:D|LL|M|RE|S|T|VE))?", xr = au + "?", Eu = "[" + Ti + "]?", ua = "(?:" + jf + "(?:" + [qh, Dl, ri].join("|") + ")" + Eu + xr + ")*", Cr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", fl = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", yo = Eu + xr + ua, Ka = "(?:" + [Al, Dl, ri].join("|") + ")" + yo, Xi = "(?:" + [qh + vo + "?", vo, Dl, ri, Pa].join("|") + ")", Rm = RegExp(Uo, "g"), mi = RegExp(vo, "g"), Qa = RegExp(Ju + "(?=" + Ju + ")|" + Xi + yo, "g"), Sc = RegExp([
      go + "?" + zd + "+" + cs + "(?=" + [Rl, go, "$"].join("|") + ")",
      Ci + "+" + Yf + "(?=" + [Rl, go + zo, "$"].join("|") + ")",
      go + "?" + zo + "+" + cs,
      go + "+" + Yf,
      fl,
      Cr,
      Wf,
      Ka
    ].join("|"), "g"), dl = RegExp("[" + jf + $t + qa + Ti + "]"), df = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, hf = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], su = -1, Ii = {};
    Ii[tt] = Ii[rn] = Ii[ze] = Ii[xe] = Ii[Ie] = Ii[it] = Ii[at] = Ii[hn] = Ii[De] = !0, Ii[st] = Ii[Ue] = Ii[Nt] = Ii[rt] = Ii[Ut] = Ii[_t] = Ii[Ot] = Ii[He] = Ii[mt] = Ii[vt] = Ii[Qt] = Ii[Jt] = Ii[Mt] = Ii[Me] = Ii[lt] = !1;
    var Ri = {};
    Ri[st] = Ri[Ue] = Ri[Nt] = Ri[Ut] = Ri[rt] = Ri[_t] = Ri[tt] = Ri[rn] = Ri[ze] = Ri[xe] = Ri[Ie] = Ri[mt] = Ri[vt] = Ri[Qt] = Ri[Jt] = Ri[Mt] = Ri[Me] = Ri[oe] = Ri[it] = Ri[at] = Ri[hn] = Ri[De] = !0, Ri[Ot] = Ri[He] = Ri[lt] = !1;
    var No = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    }, Ps = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, _c = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Ll = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Xf = parseFloat, qf = parseInt, Fo = typeof A0 == "object" && A0 && A0.Object === Object && A0, Qf = typeof self == "object" && self && self.Object === Object && self, Ki = Fo || Qf || Function("return this")(), Mu = e && !e.nodeType && e, Oa = Mu && !0 && a && !a.nodeType && a, ys = Oa && Oa.exports === Mu, ou = ys && Fo.process, Ua = function() {
      try {
        var Ye = Oa && Oa.require && Oa.require("util").types;
        return Ye || ou && ou.binding && ou.binding("util");
      } catch {
      }
    }(), bc = Ua && Ua.isArrayBuffer, xo = Ua && Ua.isDate, Tu = Ua && Ua.isMap, Pl = Ua && Ua.isRegExp, za = Ua && Ua.isSet, Xs = Ua && Ua.isTypedArray;
    function Jr(Ye, Bt, pt) {
      switch (pt.length) {
        case 0:
          return Ye.call(Bt);
        case 1:
          return Ye.call(Bt, pt[0]);
        case 2:
          return Ye.call(Bt, pt[0], pt[1]);
        case 3:
          return Ye.call(Bt, pt[0], pt[1], pt[2]);
      }
      return Ye.apply(Bt, pt);
    }
    function xs(Ye, Bt, pt, Mn) {
      for (var Kn = -1, or = Ye == null ? 0 : Ye.length; ++Kn < or; ) {
        var Ta = Ye[Kn];
        Bt(Mn, Ta, pt(Ta), Ye);
      }
      return Mn;
    }
    function va(Ye, Bt) {
      for (var pt = -1, Mn = Ye == null ? 0 : Ye.length; ++pt < Mn && Bt(Ye[pt], pt, Ye) !== !1; )
        ;
      return Ye;
    }
    function qs(Ye, Bt) {
      for (var pt = Ye == null ? 0 : Ye.length; pt-- && Bt(Ye[pt], pt, Ye) !== !1; )
        ;
      return Ye;
    }
    function Zf(Ye, Bt) {
      for (var pt = -1, Mn = Ye == null ? 0 : Ye.length; ++pt < Mn; )
        if (!Bt(Ye[pt], pt, Ye))
          return !1;
      return !0;
    }
    function $o(Ye, Bt) {
      for (var pt = -1, Mn = Ye == null ? 0 : Ye.length, Kn = 0, or = []; ++pt < Mn; ) {
        var Ta = Ye[pt];
        Bt(Ta, pt, Ye) && (or[Kn++] = Ta);
      }
      return or;
    }
    function Ku(Ye, Bt) {
      var pt = Ye == null ? 0 : Ye.length;
      return !!pt && $u(Ye, Bt, 0) > -1;
    }
    function Qh(Ye, Bt, pt) {
      for (var Mn = -1, Kn = Ye == null ? 0 : Ye.length; ++Mn < Kn; )
        if (pt(Bt, Ye[Mn]))
          return !0;
      return !1;
    }
    function qi(Ye, Bt) {
      for (var pt = -1, Mn = Ye == null ? 0 : Ye.length, Kn = Array(Mn); ++pt < Mn; )
        Kn[pt] = Bt(Ye[pt], pt, Ye);
      return Kn;
    }
    function Cu(Ye, Bt) {
      for (var pt = -1, Mn = Bt.length, Kn = Ye.length; ++pt < Mn; )
        Ye[Kn + pt] = Bt[pt];
      return Ye;
    }
    function Up(Ye, Bt, pt, Mn) {
      var Kn = -1, or = Ye == null ? 0 : Ye.length;
      for (Mn && or && (pt = Ye[++Kn]); ++Kn < or; )
        pt = Bt(pt, Ye[Kn], Kn, Ye);
      return pt;
    }
    function cg(Ye, Bt, pt, Mn) {
      var Kn = Ye == null ? 0 : Ye.length;
      for (Mn && Kn && (pt = Ye[--Kn]); Kn--; )
        pt = Bt(pt, Ye[Kn], Kn, Ye);
      return pt;
    }
    function Zh(Ye, Bt) {
      for (var pt = -1, Mn = Ye == null ? 0 : Ye.length; ++pt < Mn; )
        if (Bt(Ye[pt], pt, Ye))
          return !0;
      return !1;
    }
    var Am = hl("length");
    function Dm(Ye) {
      return Ye.split("");
    }
    function Lm(Ye) {
      return Ye.match(Oe) || [];
    }
    function Pm(Ye, Bt, pt) {
      var Mn;
      return pt(Ye, function(Kn, or, Ta) {
        if (Bt(Kn, or, Ta))
          return Mn = or, !1;
      }), Mn;
    }
    function vh(Ye, Bt, pt, Mn) {
      for (var Kn = Ye.length, or = pt + (Mn ? 1 : -1); Mn ? or-- : ++or < Kn; )
        if (Bt(Ye[or], or, Ye))
          return or;
      return -1;
    }
    function $u(Ye, Bt, pt) {
      return Bt === Bt ? wc(Ye, Bt, pt) : vh(Ye, Ru, pt);
    }
    function Nd(Ye, Bt, pt, Mn) {
      for (var Kn = pt - 1, or = Ye.length; ++Kn < or; )
        if (Mn(Ye[Kn], Bt))
          return Kn;
      return -1;
    }
    function Ru(Ye) {
      return Ye !== Ye;
    }
    function zp(Ye, Bt) {
      var pt = Ye == null ? 0 : Ye.length;
      return pt ? lu(Ye, Bt) / pt : ue;
    }
    function hl(Ye) {
      return function(Bt) {
        return Bt == null ? t : Bt[Ye];
      };
    }
    function el(Ye) {
      return function(Bt) {
        return Ye == null ? t : Ye[Bt];
      };
    }
    function pf(Ye, Bt, pt, Mn, Kn) {
      return Kn(Ye, function(or, Ta, $n) {
        pt = Mn ? (Mn = !1, or) : Bt(pt, or, Ta, $n);
      }), pt;
    }
    function Jf(Ye, Bt) {
      var pt = Ye.length;
      for (Ye.sort(Bt); pt--; )
        Ye[pt] = Ye[pt].value;
      return Ye;
    }
    function lu(Ye, Bt) {
      for (var pt, Mn = -1, Kn = Ye.length; ++Mn < Kn; ) {
        var or = Bt(Ye[Mn]);
        or !== t && (pt = pt === t ? or : pt + or);
      }
      return pt;
    }
    function mf(Ye, Bt) {
      for (var pt = -1, Mn = Array(Ye); ++pt < Ye; )
        Mn[pt] = Bt(pt);
      return Mn;
    }
    function Ol(Ye, Bt) {
      return qi(Bt, function(pt) {
        return [pt, Ye[pt]];
      });
    }
    function ec(Ye) {
      return Ye && Ye.slice(0, Bd(Ye) + 1).replace(ji, "");
    }
    function Oi(Ye) {
      return function(Bt) {
        return Ye(Bt);
      };
    }
    function Za(Ye, Bt) {
      return qi(Bt, function(pt) {
        return Ye[pt];
      });
    }
    function Ma(Ye, Bt) {
      return Ye.has(Bt);
    }
    function ca(Ye, Bt) {
      for (var pt = -1, Mn = Ye.length; ++pt < Mn && $u(Bt, Ye[pt], 0) > -1; )
        ;
      return pt;
    }
    function Fd(Ye, Bt) {
      for (var pt = Ye.length; pt-- && $u(Bt, Ye[pt], 0) > -1; )
        ;
      return pt;
    }
    function tl(Ye, Bt) {
      for (var pt = Ye.length, Mn = 0; pt--; )
        Ye[pt] === Bt && ++Mn;
      return Mn;
    }
    var Om = el(No), Um = el(Ps);
    function gh(Ye) {
      return "\\" + Ll[Ye];
    }
    function Kf(Ye, Bt) {
      return Ye == null ? t : Ye[Bt];
    }
    function kd(Ye) {
      return dl.test(Ye);
    }
    function Np(Ye) {
      return df.test(Ye);
    }
    function yh(Ye) {
      for (var Bt, pt = []; !(Bt = Ye.next()).done; )
        pt.push(Bt.value);
      return pt;
    }
    function Id(Ye) {
      var Bt = -1, pt = Array(Ye.size);
      return Ye.forEach(function(Mn, Kn) {
        pt[++Bt] = [Kn, Mn];
      }), pt;
    }
    function $f(Ye, Bt) {
      return function(pt) {
        return Ye(Bt(pt));
      };
    }
    function Ss(Ye, Bt) {
      for (var pt = -1, Mn = Ye.length, Kn = 0, or = []; ++pt < Mn; ) {
        var Ta = Ye[pt];
        (Ta === Bt || Ta === S) && (Ye[pt] = S, or[Kn++] = pt);
      }
      return or;
    }
    function tc(Ye) {
      var Bt = -1, pt = Array(Ye.size);
      return Ye.forEach(function(Mn) {
        pt[++Bt] = Mn;
      }), pt;
    }
    function vf(Ye) {
      var Bt = -1, pt = Array(Ye.size);
      return Ye.forEach(function(Mn) {
        pt[++Bt] = [Mn, Mn];
      }), pt;
    }
    function wc(Ye, Bt, pt) {
      for (var Mn = pt - 1, Kn = Ye.length; ++Mn < Kn; )
        if (Ye[Mn] === Bt)
          return Mn;
      return -1;
    }
    function Fp(Ye, Bt, pt) {
      for (var Mn = pt + 1; Mn--; )
        if (Ye[Mn] === Bt)
          return Mn;
      return Mn;
    }
    function nc(Ye) {
      return kd(Ye) ? rc(Ye) : Am(Ye);
    }
    function Na(Ye) {
      return kd(Ye) ? kp(Ye) : Dm(Ye);
    }
    function Bd(Ye) {
      for (var Bt = Ye.length; Bt-- && Si.test(Ye.charAt(Bt)); )
        ;
      return Bt;
    }
    var ed = el(_c);
    function rc(Ye) {
      for (var Bt = Qa.lastIndex = 0; Qa.test(Ye); )
        ++Bt;
      return Bt;
    }
    function kp(Ye) {
      return Ye.match(Qa) || [];
    }
    function xh(Ye) {
      return Ye.match(Sc) || [];
    }
    var Ip = function Ye(Bt) {
      Bt = Bt == null ? Ki : ko.defaults(Ki.Object(), Bt, ko.pick(Ki, hf));
      var pt = Bt.Array, Mn = Bt.Date, Kn = Bt.Error, or = Bt.Function, Ta = Bt.Math, $n = Bt.Object, Ui = Bt.RegExp, ra = Bt.String, Io = Bt.TypeError, fs = pt.prototype, Hd = or.prototype, Ul = $n.prototype, $a = Bt["__core-js_shared__"], pl = Hd.toString, xi = Ul.hasOwnProperty, Ec = 0, Au = function() {
        var g = /[^.]+$/.exec($a && $a.keys && $a.keys.IE_PROTO || "");
        return g ? "Symbol(src)_1." + g : "";
      }(), ml = Ul.toString, Ca = pl.call($n), Sh = Ki._, Bp = Ui(
        "^" + pl.call(xi).replace(Wi, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Mc = ys ? Bt.Buffer : t, Tc = Bt.Symbol, Mr = Bt.Uint8Array, $i = Mc ? Mc.allocUnsafe : t, Br = $f($n.getPrototypeOf, $n), Fa = $n.create, So = Ul.propertyIsEnumerable, td = fs.splice, _h = Tc ? Tc.isConcatSpreadable : t, ic = Tc ? Tc.iterator : t, gf = Tc ? Tc.toStringTag : t, nd = function() {
        try {
          var g = Of($n, "defineProperty");
          return g({}, "", {}), g;
        } catch {
        }
      }(), an = Bt.clearTimeout !== Ki.clearTimeout && Bt.clearTimeout, Ir = Mn && Mn.now !== Ki.Date.now && Mn.now, Hr = Bt.setTimeout !== Ki.setTimeout && Bt.setTimeout, Bo = Ta.ceil, nl = Ta.floor, ac = $n.getOwnPropertySymbols, Du = Mc ? Mc.isBuffer : t, Cc = Bt.isFinite, yf = fs.join, sc = $f($n.keys, $n), ds = Ta.max, Qs = Ta.min, zm = Mn.now, Jh = Bt.parseInt, Vd = Ta.random, bh = fs.reverse, xf = Of(Bt, "DataView"), Lu = Of(Bt, "Map"), rd = Of(Bt, "Promise"), uu = Of(Bt, "Set"), Sf = Of(Bt, "WeakMap"), Rc = Of($n, "create"), Gd = Sf && new Sf(), id = {}, Ac = md(xf), zl = md(Lu), Dc = md(rd), Lc = md(uu), Os = md(Sf), Pu = Tc ? Tc.prototype : t, _o = Pu ? Pu.valueOf : t, ad = Pu ? Pu.toString : t;
      function ve(g) {
        if (io(g) && !ei(g) && !(g instanceof Hn)) {
          if (g instanceof ka)
            return g;
          if (xi.call(g, "__wrapped__"))
            return bv(g);
        }
        return new ka(g);
      }
      var oc = function() {
        function g() {
        }
        return function(w) {
          if (!Hs(w))
            return {};
          if (Fa)
            return Fa(w);
          g.prototype = w;
          var N = new g();
          return g.prototype = t, N;
        };
      }();
      function Zs() {
      }
      function ka(g, w) {
        this.__wrapped__ = g, this.__actions__ = [], this.__chain__ = !!w, this.__index__ = 0, this.__values__ = t;
      }
      ve.templateSettings = {
        escape: Ur,
        evaluate: ir,
        interpolate: Vn,
        variable: "",
        imports: {
          _: ve
        }
      }, ve.prototype = Zs.prototype, ve.prototype.constructor = ve, ka.prototype = oc(Zs.prototype), ka.prototype.constructor = ka;
      function Hn(g) {
        this.__wrapped__ = g, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ye, this.__views__ = [];
      }
      function vr() {
        var g = new Hn(this.__wrapped__);
        return g.__actions__ = Ms(this.__actions__), g.__dir__ = this.__dir__, g.__filtered__ = this.__filtered__, g.__iteratees__ = Ms(this.__iteratees__), g.__takeCount__ = this.__takeCount__, g.__views__ = Ms(this.__views__), g;
      }
      function Bi() {
        if (this.__filtered__) {
          var g = new Hn(this);
          g.__dir__ = -1, g.__filtered__ = !0;
        } else
          g = this.clone(), g.__dir__ *= -1;
        return g;
      }
      function oi() {
        var g = this.__wrapped__.value(), w = this.__dir__, N = ei(g), Z = w < 0, ae = N ? g.length : 0, be = Wp(0, ae, this.__views__), ke = be.start, We = be.end, ut = We - ke, tn = Z ? We : ke - 1, Kt = this.__iteratees__, sn = Kt.length, Cn = 0, Ln = Qs(ut, this.__takeCount__);
        if (!N || !Z && ae == ut && Ln == ut)
          return Yl(g, this.__actions__);
        var dr = [];
        e:
          for (; ut-- && Cn < Ln; ) {
            tn += w;
            for (var gi = -1, kr = g[tn]; ++gi < sn; ) {
              var Fi = Kt[gi], Ji = Fi.iteratee, Hu = Fi.type, Vs = Ji(kr);
              if (Hu == Fe)
                kr = Vs;
              else if (!Vs) {
                if (Hu == de)
                  continue e;
                break e;
              }
            }
            dr[Cn++] = kr;
          }
        return dr;
      }
      Hn.prototype = oc(Zs.prototype), Hn.prototype.constructor = Hn;
      function Gn(g) {
        var w = -1, N = g == null ? 0 : g.length;
        for (this.clear(); ++w < N; ) {
          var Z = g[w];
          this.set(Z[0], Z[1]);
        }
      }
      function bi() {
        this.__data__ = Rc ? Rc(null) : {}, this.size = 0;
      }
      function zi(g) {
        var w = this.has(g) && delete this.__data__[g];
        return this.size -= w ? 1 : 0, w;
      }
      function Pc(g) {
        var w = this.__data__;
        if (Rc) {
          var N = w[g];
          return N === h ? t : N;
        }
        return xi.call(w, g) ? w[g] : t;
      }
      function Rr(g) {
        var w = this.__data__;
        return Rc ? w[g] !== t : xi.call(w, g);
      }
      function hs(g, w) {
        var N = this.__data__;
        return this.size += this.has(g) ? 0 : 1, N[g] = Rc && w === t ? h : w, this;
      }
      Gn.prototype.clear = bi, Gn.prototype.delete = zi, Gn.prototype.get = Pc, Gn.prototype.has = Rr, Gn.prototype.set = hs;
      function es(g) {
        var w = -1, N = g == null ? 0 : g.length;
        for (this.clear(); ++w < N; ) {
          var Z = g[w];
          this.set(Z[0], Z[1]);
        }
      }
      function Nl() {
        this.__data__ = [], this.size = 0;
      }
      function Ia(g) {
        var w = this.__data__, N = bs(w, g);
        if (N < 0)
          return !1;
        var Z = w.length - 1;
        return N == Z ? w.pop() : td.call(w, N, 1), --this.size, !0;
      }
      function Fl(g) {
        var w = this.__data__, N = bs(w, g);
        return N < 0 ? t : w[N][1];
      }
      function _f(g) {
        return bs(this.__data__, g) > -1;
      }
      function Wd(g, w) {
        var N = this.__data__, Z = bs(N, g);
        return Z < 0 ? (++this.size, N.push([g, w])) : N[Z][1] = w, this;
      }
      es.prototype.clear = Nl, es.prototype.delete = Ia, es.prototype.get = Fl, es.prototype.has = _f, es.prototype.set = Wd;
      function Ho(g) {
        var w = -1, N = g == null ? 0 : g.length;
        for (this.clear(); ++w < N; ) {
          var Z = g[w];
          this.set(Z[0], Z[1]);
        }
      }
      function Sv() {
        this.size = 0, this.__data__ = {
          hash: new Gn(),
          map: new (Lu || es)(),
          string: new Gn()
        };
      }
      function vl(g) {
        var w = Gp(this, g).delete(g);
        return this.size -= w ? 1 : 0, w;
      }
      function bo(g) {
        return Gp(this, g).get(g);
      }
      function Kh(g) {
        return Gp(this, g).has(g);
      }
      function lc(g, w) {
        var N = Gp(this, g), Z = N.size;
        return N.set(g, w), this.size += N.size == Z ? 0 : 1, this;
      }
      Ho.prototype.clear = Sv, Ho.prototype.delete = vl, Ho.prototype.get = bo, Ho.prototype.has = Kh, Ho.prototype.set = lc;
      function cu(g) {
        var w = -1, N = g == null ? 0 : g.length;
        for (this.__data__ = new Ho(); ++w < N; )
          this.add(g[w]);
      }
      function _s(g) {
        return this.__data__.set(g, h), this;
      }
      function Oc(g) {
        return this.__data__.has(g);
      }
      cu.prototype.add = cu.prototype.push = _s, cu.prototype.has = Oc;
      function Vr(g) {
        var w = this.__data__ = new es(g);
        this.size = w.size;
      }
      function uc() {
        this.__data__ = new es(), this.size = 0;
      }
      function zr(g) {
        var w = this.__data__, N = w.delete(g);
        return this.size = w.size, N;
      }
      function Js(g) {
        return this.__data__.get(g);
      }
      function ps(g) {
        return this.__data__.has(g);
      }
      function Uc(g, w) {
        var N = this.__data__;
        if (N instanceof es) {
          var Z = N.__data__;
          if (!Lu || Z.length < i - 1)
            return Z.push([g, w]), this.size = ++N.size, this;
          N = this.__data__ = new Ho(Z);
        }
        return N.set(g, w), this.size = N.size, this;
      }
      Vr.prototype.clear = uc, Vr.prototype.delete = zr, Vr.prototype.get = Js, Vr.prototype.has = ps, Vr.prototype.set = Uc;
      function pn(g, w) {
        var N = ei(g), Z = !N && em(g), ae = !N && !Z && xd(g), be = !N && !Z && !ae && nm(g), ke = N || Z || ae || be, We = ke ? mf(g.length, ra) : [], ut = We.length;
        for (var tn in g)
          (w || xi.call(g, tn)) && !(ke && (tn == "length" || ae && (tn == "offset" || tn == "parent") || be && (tn == "buffer" || tn == "byteLength" || tn == "byteOffset") || Fu(tn, ut))) && We.push(tn);
        return We;
      }
      function kl(g) {
        var w = g.length;
        return w ? g[Ns(0, w - 1)] : t;
      }
      function wo(g, w) {
        return al(Ms(g), Il(w, 0, g.length));
      }
      function Nm(g) {
        return al(Ms(g));
      }
      function wh(g, w, N) {
        (N !== t && !Bu(g[w], N) || N === t && !(w in g)) && Us(g, w, N);
      }
      function Ou(g, w, N) {
        var Z = g[w];
        (!(xi.call(g, w) && Bu(Z, N)) || N === t && !(w in g)) && Us(g, w, N);
      }
      function bs(g, w) {
        for (var N = g.length; N--; )
          if (Bu(g[N][0], w))
            return N;
        return -1;
      }
      function gl(g, w, N, Z) {
        return Uu(g, function(ae, be, ke) {
          w(Z, ae, N(ae), ke);
        }), Z;
      }
      function ga(g, w) {
        return g && ks(w, Ql(w), g);
      }
      function fu(g, w) {
        return g && ks(w, Xc(w), g);
      }
      function Us(g, w, N) {
        w == "__proto__" && nd ? nd(g, w, {
          configurable: !0,
          enumerable: !0,
          value: N,
          writable: !0
        }) : g[w] = N;
      }
      function sd(g, w) {
        for (var N = -1, Z = w.length, ae = pt(Z), be = g == null; ++N < Z; )
          ae[N] = be ? t : m1(g, w[N]);
        return ae;
      }
      function Il(g, w, N) {
        return g === g && (N !== t && (g = g <= N ? g : N), w !== t && (g = g >= w ? g : w)), g;
      }
      function Vo(g, w, N, Z, ae, be) {
        var ke, We = w & _, ut = w & T, tn = w & C;
        if (N && (ke = ae ? N(g, Z, ae, be) : N(g)), ke !== t)
          return ke;
        if (!Hs(g))
          return g;
        var Kt = ei(g);
        if (Kt) {
          if (ke = to(g), !We)
            return Ms(g, ke);
        } else {
          var sn = rs(g), Cn = sn == He || sn == et;
          if (xd(g))
            return Df(g, We);
          if (sn == Qt || sn == st || Cn && !ae) {
            if (ke = ut || Cn ? {} : rp(g), !We)
              return ut ? fg(g, fu(ke, g)) : vu(g, ga(ke, g));
          } else {
            if (!Ri[sn])
              return ae ? g : {};
            ke = yl(g, sn, We);
          }
        }
        be || (be = new Vr());
        var Ln = be.get(g);
        if (Ln)
          return Ln;
        be.set(g, ke), q0(g) ? g.forEach(function(kr) {
          ke.add(Vo(kr, w, N, kr, g, be));
        }) : d1(g) && g.forEach(function(kr, Fi) {
          ke.set(Fi, Vo(kr, w, N, Fi, g, be));
        });
        var dr = tn ? ut ? $r : Va : ut ? Xc : Ql, gi = Kt ? t : dr(g);
        return va(gi || g, function(kr, Fi) {
          gi && (Fi = kr, kr = g[Fi]), Ou(ke, Fi, Vo(kr, w, N, Fi, g, be));
        }), ke;
      }
      function jd(g) {
        var w = Ql(g);
        return function(N) {
          return rl(N, g, w);
        };
      }
      function rl(g, w, N) {
        var Z = N.length;
        if (g == null)
          return !Z;
        for (g = $n(g); Z--; ) {
          var ae = N[Z], be = w[ae], ke = g[ae];
          if (ke === t && !(ae in g) || !be(ke))
            return !1;
        }
        return !0;
      }
      function zs(g, w, N) {
        if (typeof g != "function")
          throw new Io(l);
        return xl(function() {
          g.apply(t, N);
        }, w);
      }
      function fa(g, w, N, Z) {
        var ae = -1, be = Ku, ke = !0, We = g.length, ut = [], tn = w.length;
        if (!We)
          return ut;
        N && (w = qi(w, Oi(N))), Z ? (be = Qh, ke = !1) : w.length >= i && (be = Ma, ke = !1, w = new cu(w));
        e:
          for (; ++ae < We; ) {
            var Kt = g[ae], sn = N == null ? Kt : N(Kt);
            if (Kt = Z || Kt !== 0 ? Kt : 0, ke && sn === sn) {
              for (var Cn = tn; Cn--; )
                if (w[Cn] === sn)
                  continue e;
              ut.push(Kt);
            } else
              be(w, sn, Z) || ut.push(Kt);
          }
        return ut;
      }
      var Uu = Lf(Hi), Hp = Lf(wn, !0);
      function du(g, w) {
        var N = !0;
        return Uu(g, function(Z, ae, be) {
          return N = !!w(Z, ae, be), N;
        }), N;
      }
      function Bl(g, w, N) {
        for (var Z = -1, ae = g.length; ++Z < ae; ) {
          var be = g[Z], ke = w(be);
          if (ke != null && (We === t ? ke === ke && !Ni(ke) : N(ke, We)))
            var We = ke, ut = be;
        }
        return ut;
      }
      function $h(g, w, N, Z) {
        var ae = g.length;
        for (N = qr(N), N < 0 && (N = -N > ae ? 0 : ae + N), Z = Z === t || Z > ae ? ae : qr(Z), Z < 0 && (Z += ae), Z = N > Z ? 0 : Oh(Z); N < Z; )
          g[N++] = w;
        return g;
      }
      function bf(g, w) {
        var N = [];
        return Uu(g, function(Z, ae, be) {
          w(Z, ae, be) && N.push(Z);
        }), N;
      }
      function Ks(g, w, N, Z, ae) {
        var be = -1, ke = g.length;
        for (N || (N = hg), ae || (ae = []); ++be < ke; ) {
          var We = g[be];
          w > 0 && N(We) ? w > 1 ? Ks(We, w - 1, N, Z, ae) : Cu(ae, We) : Z || (ae[ae.length] = We);
        }
        return ae;
      }
      var Yd = dc(), da = dc(!0);
      function Hi(g, w) {
        return g && Yd(g, w, Ql);
      }
      function wn(g, w) {
        return g && da(g, w, Ql);
      }
      function Qi(g, w) {
        return $o(w, function(N) {
          return yp(g[N]);
        });
      }
      function ya(g, w) {
        w = eo(w, g);
        for (var N = 0, Z = w.length; g != null && N < Z; )
          g = g[ql(w[N++])];
        return N && N == Z ? g : t;
      }
      function ep(g, w, N) {
        var Z = w(g);
        return ei(g) ? Z : Cu(Z, N(g));
      }
      function Go(g) {
        return g == null ? g === t ? je : bt : gf && gf in $n(g) ? dg(g) : Xp(g);
      }
      function Wo(g, w) {
        return g > w;
      }
      function ts(g, w) {
        return g != null && xi.call(g, w);
      }
      function An(g, w) {
        return g != null && w in $n(g);
      }
      function xa(g, w, N) {
        return g >= Qs(w, N) && g < ds(w, N);
      }
      function ns(g, w, N) {
        for (var Z = N ? Qh : Ku, ae = g[0].length, be = g.length, ke = be, We = pt(be), ut = 1 / 0, tn = []; ke--; ) {
          var Kt = g[ke];
          ke && w && (Kt = qi(Kt, Oi(w))), ut = Qs(Kt.length, ut), We[ke] = !N && (w || ae >= 120 && Kt.length >= 120) ? new cu(ke && Kt) : t;
        }
        Kt = g[0];
        var sn = -1, Cn = We[0];
        e:
          for (; ++sn < ae && tn.length < ut; ) {
            var Ln = Kt[sn], dr = w ? w(Ln) : Ln;
            if (Ln = N || Ln !== 0 ? Ln : 0, !(Cn ? Ma(Cn, dr) : Z(tn, dr, N))) {
              for (ke = be; --ke; ) {
                var gi = We[ke];
                if (!(gi ? Ma(gi, dr) : Z(g[ke], dr, N)))
                  continue e;
              }
              Cn && Cn.push(dr), tn.push(Ln);
            }
          }
        return tn;
      }
      function wf(g, w, N, Z) {
        return Hi(g, function(ae, be, ke) {
          w(Z, N(ae), be, ke);
        }), Z;
      }
      function Sa(g, w, N) {
        w = eo(w, g), g = no(g, w);
        var Z = g == null ? g : g[ql(Qo(w))];
        return Z == null ? t : Jr(Z, g, N);
      }
      function Kr(g) {
        return io(g) && Go(g) == st;
      }
      function Ra(g) {
        return io(g) && Go(g) == Nt;
      }
      function Ba(g) {
        return io(g) && Go(g) == _t;
      }
      function ci(g, w, N, Z, ae) {
        return g === w ? !0 : g == null || w == null || !io(g) && !io(w) ? g !== g && w !== w : Hl(g, w, N, Z, ci, ae);
      }
      function Hl(g, w, N, Z, ae, be) {
        var ke = ei(g), We = ei(w), ut = ke ? Ue : rs(g), tn = We ? Ue : rs(w);
        ut = ut == st ? Qt : ut, tn = tn == st ? Qt : tn;
        var Kt = ut == Qt, sn = tn == Qt, Cn = ut == tn;
        if (Cn && xd(g)) {
          if (!xd(w))
            return !1;
          ke = !0, Kt = !1;
        }
        if (Cn && !Kt)
          return be || (be = new Vr()), ke || nm(g) ? Wn(g, w, N, Z, ae, be) : Xr(g, w, ut, N, Z, ae, be);
        if (!(N & D)) {
          var Ln = Kt && xi.call(g, "__wrapped__"), dr = sn && xi.call(w, "__wrapped__");
          if (Ln || dr) {
            var gi = Ln ? g.value() : g, kr = dr ? w.value() : w;
            return be || (be = new Vr()), ae(gi, kr, N, Z, be);
          }
        }
        return Cn ? (be || (be = new Vr()), Er(g, w, N, Z, ae, be)) : !1;
      }
      function od(g) {
        return io(g) && rs(g) == mt;
      }
      function ws(g, w, N, Z) {
        var ae = N.length, be = ae, ke = !Z;
        if (g == null)
          return !be;
        for (g = $n(g); ae--; ) {
          var We = N[ae];
          if (ke && We[2] ? We[1] !== g[We[0]] : !(We[0] in g))
            return !1;
        }
        for (; ++ae < be; ) {
          We = N[ae];
          var ut = We[0], tn = g[ut], Kt = We[1];
          if (ke && We[2]) {
            if (tn === t && !(ut in g))
              return !1;
          } else {
            var sn = new Vr();
            if (Z)
              var Cn = Z(tn, Kt, ut, g, w, sn);
            if (!(Cn === t ? ci(Kt, tn, D | P, Z, sn) : Cn))
              return !1;
          }
        }
        return !0;
      }
      function Xd(g) {
        if (!Hs(g) || Im(g))
          return !1;
        var w = yp(g) ? Bp : Zn;
        return w.test(md(g));
      }
      function zc(g) {
        return io(g) && Go(g) == Jt;
      }
      function cc(g) {
        return io(g) && rs(g) == Mt;
      }
      function qd(g) {
        return io(g) && Cg(g.length) && !!Ii[Go(g)];
      }
      function ld(g) {
        return typeof g == "function" ? g : g == null ? Bf : typeof g == "object" ? ei(g) ? Vl(g[0], g[1]) : Mf(g) : Ng(g);
      }
      function il(g) {
        if (!jp(g))
          return sc(g);
        var w = [];
        for (var N in $n(g))
          xi.call(g, N) && N != "constructor" && w.push(N);
        return w;
      }
      function Fm(g) {
        if (!Hs(g))
          return Yp(g);
        var w = jp(g), N = [];
        for (var Z in g)
          Z == "constructor" && (w || !xi.call(g, Z)) || N.push(Z);
        return N;
      }
      function Ef(g, w) {
        return g < w;
      }
      function Qd(g, w) {
        var N = -1, Z = ll(g) ? pt(g.length) : [];
        return Uu(g, function(ae, be, ke) {
          Z[++N] = w(ae, be, ke);
        }), Z;
      }
      function Mf(g) {
        var w = km(g);
        return w.length == 1 && w[0][2] ? Bm(w[0][0], w[0][1]) : function(N) {
          return N === g || ws(N, g, w);
        };
      }
      function Vl(g, w) {
        return _v(g) && ip(w) ? Bm(ql(g), w) : function(N) {
          var Z = m1(N, g);
          return Z === t && Z === w ? Km(N, g) : ci(w, Z, D | P);
        };
      }
      function Gl(g, w, N, Z, ae) {
        g !== w && Yd(w, function(be, ke) {
          if (ae || (ae = new Vr()), Hs(be))
            ud(g, w, ke, N, Gl, Z, ae);
          else {
            var We = Z ? Z(is(g, ke), be, ke + "", g, w, ae) : t;
            We === t && (We = be), wh(g, ke, We);
          }
        }, Xc);
      }
      function ud(g, w, N, Z, ae, be, ke) {
        var We = is(g, N), ut = is(w, N), tn = ke.get(ut);
        if (tn) {
          wh(g, N, tn);
          return;
        }
        var Kt = be ? be(We, ut, N + "", g, w, ke) : t, sn = Kt === t;
        if (sn) {
          var Cn = ei(ut), Ln = !Cn && xd(ut), dr = !Cn && !Ln && nm(ut);
          Kt = ut, Cn || Ln || dr ? ei(We) ? Kt = We : Rs(We) ? Kt = Ms(We) : Ln ? (sn = !1, Kt = Df(ut, !0)) : dr ? (sn = !1, Kt = cd(ut, !0)) : Kt = [] : Zm(ut) || em(ut) ? (Kt = We, em(We) ? Kt = zy(We) : (!Hs(We) || yp(We)) && (Kt = rp(ut))) : sn = !1;
        }
        sn && (ke.set(ut, Kt), ae(Kt, ut, Z, be, ke), ke.delete(ut)), wh(g, N, Kt);
      }
      function Wl(g, w) {
        var N = g.length;
        if (!!N)
          return w += w < 0 ? N : 0, Fu(w, N) ? g[w] : t;
      }
      function Eh(g, w, N) {
        w.length ? w = qi(w, function(be) {
          return ei(be) ? function(ke) {
            return ya(ke, be.length === 1 ? be[0] : be);
          } : be;
        }) : w = [Bf];
        var Z = -1;
        w = qi(w, Oi(gr()));
        var ae = Qd(g, function(be, ke, We) {
          var ut = qi(w, function(tn) {
            return tn(be);
          });
          return { criteria: ut, index: ++Z, value: be };
        });
        return Jf(ae, function(be, ke) {
          return fd(be, ke, N);
        });
      }
      function fc(g, w) {
        return hr(g, w, function(N, Z) {
          return Km(g, Z);
        });
      }
      function hr(g, w, N) {
        for (var Z = -1, ae = w.length, be = {}; ++Z < ae; ) {
          var ke = w[Z], We = ya(g, ke);
          N(We, ke) && Ht(be, eo(ke, g), We);
        }
        return be;
      }
      function Yr(g) {
        return function(w) {
          return ya(w, g);
        };
      }
      function fr(g, w, N, Z) {
        var ae = Z ? Nd : $u, be = -1, ke = w.length, We = g;
        for (g === w && (w = Ms(w)), N && (We = qi(g, Oi(N))); ++be < ke; )
          for (var ut = 0, tn = w[be], Kt = N ? N(tn) : tn; (ut = ae(We, Kt, ut, Z)) > -1; )
            We !== g && td.call(We, ut, 1), td.call(g, ut, 1);
        return g;
      }
      function fi(g, w) {
        for (var N = g ? w.length : 0, Z = N - 1; N--; ) {
          var ae = w[N];
          if (N == Z || ae !== be) {
            var be = ae;
            Fu(ae) ? td.call(g, ae, 1) : Af(g, ae);
          }
        }
        return g;
      }
      function Ns(g, w) {
        return g + nl(Vd() * (w - g + 1));
      }
      function jl(g, w, N, Z) {
        for (var ae = -1, be = ds(Bo((w - g) / (N || 1)), 0), ke = pt(be); be--; )
          ke[Z ? be : ++ae] = g, g += N;
        return ke;
      }
      function Nc(g, w) {
        var N = "";
        if (!g || w < 1 || w > he)
          return N;
        do
          w % 2 && (N += g), w = nl(w / 2), w && (g += g);
        while (w);
        return N;
      }
      function Sr(g, w) {
        return pd(Jd(g, w, Bf), g + "");
      }
      function Eo(g) {
        return kl($m(g));
      }
      function Ai(g, w) {
        var N = $m(g);
        return al(N, Il(w, 0, N.length));
      }
      function Ht(g, w, N, Z) {
        if (!Hs(g))
          return g;
        w = eo(w, g);
        for (var ae = -1, be = w.length, ke = be - 1, We = g; We != null && ++ae < be; ) {
          var ut = ql(w[ae]), tn = N;
          if (ut === "__proto__" || ut === "constructor" || ut === "prototype")
            return g;
          if (ae != ke) {
            var Kt = We[ut];
            tn = Z ? Z(Kt, ut, We) : t, tn === t && (tn = Hs(Kt) ? Kt : Fu(w[ae + 1]) ? [] : {});
          }
          Ou(We, ut, tn), We = We[ut];
        }
        return g;
      }
      var vi = Gd ? function(g, w) {
        return Gd.set(g, w), g;
      } : Bf, lr = nd ? function(g, w) {
        return nd(g, "toString", {
          configurable: !0,
          enumerable: !1,
          value: nx(w),
          writable: !0
        });
      } : Bf;
      function Fc(g) {
        return al($m(g));
      }
      function Ha(g, w, N) {
        var Z = -1, ae = g.length;
        w < 0 && (w = -w > ae ? 0 : ae + w), N = N > ae ? ae : N, N < 0 && (N += ae), ae = w > N ? 0 : N - w >>> 0, w >>>= 0;
        for (var be = pt(ae); ++Z < ae; )
          be[Z] = g[Z + w];
        return be;
      }
      function jo(g, w) {
        var N;
        return Uu(g, function(Z, ae, be) {
          return N = w(Z, ae, be), !N;
        }), !!N;
      }
      function Di(g, w, N) {
        var Z = 0, ae = g == null ? Z : g.length;
        if (typeof w == "number" && w === w && ae <= Xe) {
          for (; Z < ae; ) {
            var be = Z + ae >>> 1, ke = g[be];
            ke !== null && !Ni(ke) && (N ? ke <= w : ke < w) ? Z = be + 1 : ae = be;
          }
          return ae;
        }
        return Tf(g, w, Bf, N);
      }
      function Tf(g, w, N, Z) {
        var ae = 0, be = g == null ? 0 : g.length;
        if (be === 0)
          return 0;
        w = N(w);
        for (var ke = w !== w, We = w === null, ut = Ni(w), tn = w === t; ae < be; ) {
          var Kt = nl((ae + be) / 2), sn = N(g[Kt]), Cn = sn !== t, Ln = sn === null, dr = sn === sn, gi = Ni(sn);
          if (ke)
            var kr = Z || dr;
          else
            tn ? kr = dr && (Z || Cn) : We ? kr = dr && Cn && (Z || !Ln) : ut ? kr = dr && Cn && !Ln && (Z || !gi) : Ln || gi ? kr = !1 : kr = Z ? sn <= w : sn < w;
          kr ? ae = Kt + 1 : be = Kt;
        }
        return Qs(be, we);
      }
      function Cf(g, w) {
        for (var N = -1, Z = g.length, ae = 0, be = []; ++N < Z; ) {
          var ke = g[N], We = w ? w(ke) : ke;
          if (!N || !Bu(We, ut)) {
            var ut = We;
            be[ae++] = ke === 0 ? 0 : ke;
          }
        }
        return be;
      }
      function Rf(g) {
        return typeof g == "number" ? g : Ni(g) ? ue : +g;
      }
      function ia(g) {
        if (typeof g == "string")
          return g;
        if (ei(g))
          return qi(g, ia) + "";
        if (Ni(g))
          return ad ? ad.call(g) : "";
        var w = g + "";
        return w == "0" && 1 / g == -Be ? "-0" : w;
      }
      function Fs(g, w, N) {
        var Z = -1, ae = Ku, be = g.length, ke = !0, We = [], ut = We;
        if (N)
          ke = !1, ae = Qh;
        else if (be >= i) {
          var tn = w ? null : Li(g);
          if (tn)
            return tc(tn);
          ke = !1, ae = Ma, ut = new cu();
        } else
          ut = w ? [] : We;
        e:
          for (; ++Z < be; ) {
            var Kt = g[Z], sn = w ? w(Kt) : Kt;
            if (Kt = N || Kt !== 0 ? Kt : 0, ke && sn === sn) {
              for (var Cn = ut.length; Cn--; )
                if (ut[Cn] === sn)
                  continue e;
              w && ut.push(sn), We.push(Kt);
            } else
              ae(ut, sn, N) || (ut !== We && ut.push(sn), We.push(Kt));
          }
        return We;
      }
      function Af(g, w) {
        return w = eo(w, g), g = no(g, w), g == null || delete g[ql(Qo(w))];
      }
      function Zd(g, w, N, Z) {
        return Ht(g, w, N(ya(g, w)), Z);
      }
      function $s(g, w, N, Z) {
        for (var ae = g.length, be = Z ? ae : -1; (Z ? be-- : ++be < ae) && w(g[be], be, g); )
          ;
        return N ? Ha(g, Z ? 0 : be, Z ? be + 1 : ae) : Ha(g, Z ? be + 1 : 0, Z ? ae : be);
      }
      function Yl(g, w) {
        var N = g;
        return N instanceof Hn && (N = N.value()), Up(w, function(Z, ae) {
          return ae.func.apply(ae.thisArg, Cu([Z], ae.args));
        }, N);
      }
      function tp(g, w, N) {
        var Z = g.length;
        if (Z < 2)
          return Z ? Fs(g[0]) : [];
        for (var ae = -1, be = pt(Z); ++ae < Z; )
          for (var ke = g[ae], We = -1; ++We < Z; )
            We != ae && (be[ae] = fa(be[ae] || ke, g[We], w, N));
        return Fs(Ks(be, 1), w, N);
      }
      function kc(g, w, N) {
        for (var Z = -1, ae = g.length, be = w.length, ke = {}; ++Z < ae; ) {
          var We = Z < be ? w[Z] : t;
          N(ke, g[Z], We);
        }
        return ke;
      }
      function Es(g) {
        return Rs(g) ? g : [];
      }
      function wi(g) {
        return typeof g == "function" ? g : Bf;
      }
      function eo(g, w) {
        return ei(g) ? g : _v(g, w) ? [g] : pg(Da(g));
      }
      var Xl = Sr;
      function Ic(g, w, N) {
        var Z = g.length;
        return N = N === t ? Z : N, !w && N >= Z ? g : Ha(g, w, N);
      }
      var hu = an || function(g) {
        return Ki.clearTimeout(g);
      };
      function Df(g, w) {
        if (w)
          return g.slice();
        var N = g.length, Z = $i ? $i(N) : new g.constructor(N);
        return g.copy(Z), Z;
      }
      function pu(g) {
        var w = new g.constructor(g.byteLength);
        return new Mr(w).set(new Mr(g)), w;
      }
      function zu(g, w) {
        var N = w ? pu(g.buffer) : g.buffer;
        return new g.constructor(N, g.byteOffset, g.byteLength);
      }
      function Mo(g) {
        var w = new g.constructor(g.source, Rn.exec(g));
        return w.lastIndex = g.lastIndex, w;
      }
      function Bc(g) {
        return _o ? $n(_o.call(g)) : {};
      }
      function cd(g, w) {
        var N = w ? pu(g.buffer) : g.buffer;
        return new g.constructor(N, g.byteOffset, g.length);
      }
      function Yo(g, w) {
        if (g !== w) {
          var N = g !== t, Z = g === null, ae = g === g, be = Ni(g), ke = w !== t, We = w === null, ut = w === w, tn = Ni(w);
          if (!We && !tn && !be && g > w || be && ke && ut && !We && !tn || Z && ke && ut || !N && ut || !ae)
            return 1;
          if (!Z && !be && !tn && g < w || tn && N && ae && !Z && !be || We && N && ae || !ke && ae || !ut)
            return -1;
        }
        return 0;
      }
      function fd(g, w, N) {
        for (var Z = -1, ae = g.criteria, be = w.criteria, ke = ae.length, We = N.length; ++Z < ke; ) {
          var ut = Yo(ae[Z], be[Z]);
          if (ut) {
            if (Z >= We)
              return ut;
            var tn = N[Z];
            return ut * (tn == "desc" ? -1 : 1);
          }
        }
        return g.index - w.index;
      }
      function mu(g, w, N, Z) {
        for (var ae = -1, be = g.length, ke = N.length, We = -1, ut = w.length, tn = ds(be - ke, 0), Kt = pt(ut + tn), sn = !Z; ++We < ut; )
          Kt[We] = w[We];
        for (; ++ae < ke; )
          (sn || ae < be) && (Kt[N[ae]] = g[ae]);
        for (; tn--; )
          Kt[We++] = g[ae++];
        return Kt;
      }
      function dd(g, w, N, Z) {
        for (var ae = -1, be = g.length, ke = -1, We = N.length, ut = -1, tn = w.length, Kt = ds(be - We, 0), sn = pt(Kt + tn), Cn = !Z; ++ae < Kt; )
          sn[ae] = g[ae];
        for (var Ln = ae; ++ut < tn; )
          sn[Ln + ut] = w[ut];
        for (; ++ke < We; )
          (Cn || ae < be) && (sn[Ln + N[ke]] = g[ae++]);
        return sn;
      }
      function Ms(g, w) {
        var N = -1, Z = g.length;
        for (w || (w = pt(Z)); ++N < Z; )
          w[N] = g[N];
        return w;
      }
      function ks(g, w, N, Z) {
        var ae = !N;
        N || (N = {});
        for (var be = -1, ke = w.length; ++be < ke; ) {
          var We = w[be], ut = Z ? Z(N[We], g[We], We, N, g) : t;
          ut === t && (ut = g[We]), ae ? Us(N, We, ut) : Ou(N, We, ut);
        }
        return N;
      }
      function vu(g, w) {
        return ks(g, Xo(g), w);
      }
      function fg(g, w) {
        return ks(g, qo(g), w);
      }
      function ii(g, w) {
        return function(N, Z) {
          var ae = ei(N) ? xs : gl, be = w ? w() : {};
          return ae(N, g, gr(Z, 2), be);
        };
      }
      function Nu(g) {
        return Sr(function(w, N) {
          var Z = -1, ae = N.length, be = ae > 1 ? N[ae - 1] : t, ke = ae > 2 ? N[2] : t;
          for (be = g.length > 3 && typeof be == "function" ? (ae--, be) : t, ke && Vi(N[0], N[1], ke) && (be = ae < 3 ? t : be, ae = 1), w = $n(w); ++Z < ae; ) {
            var We = N[Z];
            We && g(w, We, Z, be);
          }
          return w;
        });
      }
      function Lf(g, w) {
        return function(N, Z) {
          if (N == null)
            return N;
          if (!ll(N))
            return g(N, Z);
          for (var ae = N.length, be = w ? ae : -1, ke = $n(N); (w ? be-- : ++be < ae) && Z(ke[be], be, ke) !== !1; )
            ;
          return N;
        };
      }
      function dc(g) {
        return function(w, N, Z) {
          for (var ae = -1, be = $n(w), ke = Z(w), We = ke.length; We--; ) {
            var ut = ke[g ? We : ++ae];
            if (N(be[ut], ut, be) === !1)
              break;
          }
          return w;
        };
      }
      function Pf(g, w, N) {
        var Z = w & U, ae = x(g);
        function be() {
          var ke = this && this !== Ki && this instanceof be ? ae : g;
          return ke.apply(Z ? N : this, arguments);
        }
        return be;
      }
      function Vp(g) {
        return function(w) {
          w = Da(w);
          var N = kd(w) ? Na(w) : t, Z = N ? N[0] : w.charAt(0), ae = N ? Ic(N, 1).join("") : w.slice(1);
          return Z[g]() + ae;
        };
      }
      function y(g) {
        return function(w) {
          return Up(jy(Vy(w).replace(Rm, "")), g, "");
        };
      }
      function x(g) {
        return function() {
          var w = arguments;
          switch (w.length) {
            case 0:
              return new g();
            case 1:
              return new g(w[0]);
            case 2:
              return new g(w[0], w[1]);
            case 3:
              return new g(w[0], w[1], w[2]);
            case 4:
              return new g(w[0], w[1], w[2], w[3]);
            case 5:
              return new g(w[0], w[1], w[2], w[3], w[4]);
            case 6:
              return new g(w[0], w[1], w[2], w[3], w[4], w[5]);
            case 7:
              return new g(w[0], w[1], w[2], w[3], w[4], w[5], w[6]);
          }
          var N = oc(g.prototype), Z = g.apply(N, w);
          return Hs(Z) ? Z : N;
        };
      }
      function L(g, w, N) {
        var Z = x(g);
        function ae() {
          for (var be = arguments.length, ke = pt(be), We = be, ut = np(ae); We--; )
            ke[We] = arguments[We];
          var tn = be < 3 && ke[0] !== ut && ke[be - 1] !== ut ? [] : Ss(ke, ut);
          if (be -= tn.length, be < N)
            return _a(
              g,
              w,
              te,
              ae.placeholder,
              t,
              ke,
              tn,
              t,
              t,
              N - be
            );
          var Kt = this && this !== Ki && this instanceof ae ? Z : g;
          return Jr(Kt, this, ke);
        }
        return ae;
      }
      function H(g) {
        return function(w, N, Z) {
          var ae = $n(w);
          if (!ll(w)) {
            var be = gr(N, 3);
            w = Ql(w), N = function(We) {
              return be(ae[We], We, ae);
            };
          }
          var ke = g(w, N, Z);
          return ke > -1 ? ae[be ? w[ke] : ke] : t;
        };
      }
      function q(g) {
        return Ar(function(w) {
          var N = w.length, Z = N, ae = ka.prototype.thru;
          for (g && w.reverse(); Z--; ) {
            var be = w[Z];
            if (typeof be != "function")
              throw new Io(l);
            if (ae && !ke && hd(be) == "wrapper")
              var ke = new ka([], !0);
          }
          for (Z = ke ? Z : N; ++Z < N; ) {
            be = w[Z];
            var We = hd(be), ut = We == "wrapper" ? hc(be) : t;
            ut && Th(ut[0]) && ut[1] == ($ | V | X | W) && !ut[4].length && ut[9] == 1 ? ke = ke[hd(ut[0])].apply(ke, ut[3]) : ke = be.length == 1 && Th(be) ? ke[We]() : ke.thru(be);
          }
          return function() {
            var tn = arguments, Kt = tn[0];
            if (ke && tn.length == 1 && ei(Kt))
              return ke.plant(Kt).value();
            for (var sn = 0, Cn = N ? w[sn].apply(this, tn) : Kt; ++sn < N; )
              Cn = w[sn].call(this, Cn);
            return Cn;
          };
        });
      }
      function te(g, w, N, Z, ae, be, ke, We, ut, tn) {
        var Kt = w & $, sn = w & U, Cn = w & B, Ln = w & (V | I), dr = w & ee, gi = Cn ? t : x(g);
        function kr() {
          for (var Fi = arguments.length, Ji = pt(Fi), Hu = Fi; Hu--; )
            Ji[Hu] = arguments[Hu];
          if (Ln)
            var Vs = np(kr), gc = tl(Ji, Vs);
          if (Z && (Ji = mu(Ji, Z, ae, Ln)), be && (Ji = dd(Ji, be, ke, Ln)), Fi -= gc, Ln && Fi < tn) {
            var Gs = Ss(Ji, Vs);
            return _a(
              g,
              w,
              te,
              kr.placeholder,
              N,
              Ji,
              Gs,
              We,
              ut,
              tn - Fi
            );
          }
          var Jl = sn ? N : this, Vu = Cn ? Jl[g] : g;
          return Fi = Ji.length, We ? Ji = Gi(Ji, We) : dr && Fi > 1 && Ji.reverse(), Kt && ut < Fi && (Ji.length = ut), this && this !== Ki && this instanceof kr && (Vu = gi || x(Vu)), Vu.apply(Jl, Ji);
        }
        return kr;
      }
      function Ae(g, w) {
        return function(N, Z) {
          return wf(N, g, w(Z), {});
        };
      }
      function Ke(g, w) {
        return function(N, Z) {
          var ae;
          if (N === t && Z === t)
            return w;
          if (N !== t && (ae = N), Z !== t) {
            if (ae === t)
              return Z;
            typeof N == "string" || typeof Z == "string" ? (N = ia(N), Z = ia(Z)) : (N = Rf(N), Z = Rf(Z)), ae = g(N, Z);
          }
          return ae;
        };
      }
      function kt(g) {
        return Ar(function(w) {
          return w = qi(w, Oi(gr())), Sr(function(N) {
            var Z = this;
            return g(w, function(ae) {
              return Jr(ae, Z, N);
            });
          });
        });
      }
      function cn(g, w) {
        w = w === t ? " " : ia(w);
        var N = w.length;
        if (N < 2)
          return N ? Nc(w, g) : w;
        var Z = Nc(w, Bo(g / nc(w)));
        return kd(w) ? Ic(Na(Z), 0, g).join("") : Z.slice(0, g);
      }
      function bn(g, w, N, Z) {
        var ae = w & U, be = x(g);
        function ke() {
          for (var We = -1, ut = arguments.length, tn = -1, Kt = Z.length, sn = pt(Kt + ut), Cn = this && this !== Ki && this instanceof ke ? be : g; ++tn < Kt; )
            sn[tn] = Z[tn];
          for (; ut--; )
            sn[tn++] = arguments[++We];
          return Jr(Cn, ae ? N : this, sn);
        }
        return ke;
      }
      function wr(g) {
        return function(w, N, Z) {
          return Z && typeof Z != "number" && Vi(w, N, Z) && (N = Z = t), w = xp(w), N === t ? (N = w, w = 0) : N = xp(N), Z = Z === t ? w < N ? 1 : -1 : xp(Z), jl(w, N, Z, g);
        };
      }
      function ur(g) {
        return function(w, N) {
          return typeof w == "string" && typeof N == "string" || (w = Yc(w), N = Yc(N)), g(w, N);
        };
      }
      function _a(g, w, N, Z, ae, be, ke, We, ut, tn) {
        var Kt = w & V, sn = Kt ? ke : t, Cn = Kt ? t : ke, Ln = Kt ? be : t, dr = Kt ? t : be;
        w |= Kt ? X : J, w &= ~(Kt ? J : X), w & k || (w &= ~(U | B));
        var gi = [
          g,
          w,
          ae,
          Ln,
          sn,
          dr,
          Cn,
          We,
          ut,
          tn
        ], kr = N.apply(t, gi);
        return Th(g) && To(kr, gi), kr.placeholder = Z, Uf(kr, g, w);
      }
      function Tn(g) {
        var w = Ta[g];
        return function(N, Z) {
          if (N = Yc(N), Z = Z == null ? 0 : Qs(qr(Z), 292), Z && Cc(N)) {
            var ae = (Da(N) + "e").split("e"), be = w(ae[0] + "e" + (+ae[1] + Z));
            return ae = (Da(be) + "e").split("e"), +(ae[0] + "e" + (+ae[1] - Z));
          }
          return w(N);
        };
      }
      var Li = uu && 1 / tc(new uu([, -0]))[1] == Be ? function(g) {
        return new uu(g);
      } : Yy;
      function ms(g) {
        return function(w) {
          var N = rs(w);
          return N == mt ? Id(w) : N == Mt ? vf(w) : Ol(w, g(w));
        };
      }
      function dt(g, w, N, Z, ae, be, ke, We) {
        var ut = w & B;
        if (!ut && typeof g != "function")
          throw new Io(l);
        var tn = Z ? Z.length : 0;
        if (tn || (w &= ~(X | J), Z = ae = t), ke = ke === t ? ke : ds(qr(ke), 0), We = We === t ? We : qr(We), tn -= ae ? ae.length : 0, w & J) {
          var Kt = Z, sn = ae;
          Z = ae = t;
        }
        var Cn = ut ? t : hc(g), Ln = [
          g,
          w,
          N,
          Z,
          ae,
          Kt,
          sn,
          be,
          ke,
          We
        ];
        if (Cn && ap(Ln, Cn), g = Ln[0], w = Ln[1], N = Ln[2], Z = Ln[3], ae = Ln[4], We = Ln[9] = Ln[9] === t ? ut ? 0 : g.length : ds(Ln[9] - tn, 0), !We && w & (V | I) && (w &= ~(V | I)), !w || w == U)
          var dr = Pf(g, w, N);
        else
          w == V || w == I ? dr = L(g, w, We) : (w == X || w == (U | X)) && !ae.length ? dr = bn(g, w, N, Z) : dr = te.apply(t, Ln);
        var gi = Cn ? vi : To;
        return Uf(gi(dr, Ln), g, w);
      }
      function Qe(g, w, N, Z) {
        return g === t || Bu(g, Ul[N]) && !xi.call(Z, N) ? w : g;
      }
      function At(g, w, N, Z, ae, be) {
        return Hs(g) && Hs(w) && (be.set(w, g), Gl(g, w, t, At, be), be.delete(w)), g;
      }
      function qt(g) {
        return Zm(g) ? t : g;
      }
      function Wn(g, w, N, Z, ae, be) {
        var ke = N & D, We = g.length, ut = w.length;
        if (We != ut && !(ke && ut > We))
          return !1;
        var tn = be.get(g), Kt = be.get(w);
        if (tn && Kt)
          return tn == w && Kt == g;
        var sn = -1, Cn = !0, Ln = N & P ? new cu() : t;
        for (be.set(g, w), be.set(w, g); ++sn < We; ) {
          var dr = g[sn], gi = w[sn];
          if (Z)
            var kr = ke ? Z(gi, dr, sn, w, g, be) : Z(dr, gi, sn, g, w, be);
          if (kr !== t) {
            if (kr)
              continue;
            Cn = !1;
            break;
          }
          if (Ln) {
            if (!Zh(w, function(Fi, Ji) {
              if (!Ma(Ln, Ji) && (dr === Fi || ae(dr, Fi, N, Z, be)))
                return Ln.push(Ji);
            })) {
              Cn = !1;
              break;
            }
          } else if (!(dr === gi || ae(dr, gi, N, Z, be))) {
            Cn = !1;
            break;
          }
        }
        return be.delete(g), be.delete(w), Cn;
      }
      function Xr(g, w, N, Z, ae, be, ke) {
        switch (N) {
          case Ut:
            if (g.byteLength != w.byteLength || g.byteOffset != w.byteOffset)
              return !1;
            g = g.buffer, w = w.buffer;
          case Nt:
            return !(g.byteLength != w.byteLength || !be(new Mr(g), new Mr(w)));
          case rt:
          case _t:
          case vt:
            return Bu(+g, +w);
          case Ot:
            return g.name == w.name && g.message == w.message;
          case Jt:
          case Me:
            return g == w + "";
          case mt:
            var We = Id;
          case Mt:
            var ut = Z & D;
            if (We || (We = tc), g.size != w.size && !ut)
              return !1;
            var tn = ke.get(g);
            if (tn)
              return tn == w;
            Z |= P, ke.set(g, w);
            var Kt = Wn(We(g), We(w), Z, ae, be, ke);
            return ke.delete(g), Kt;
          case oe:
            if (_o)
              return _o.call(g) == _o.call(w);
        }
        return !1;
      }
      function Er(g, w, N, Z, ae, be) {
        var ke = N & D, We = Va(g), ut = We.length, tn = Va(w), Kt = tn.length;
        if (ut != Kt && !ke)
          return !1;
        for (var sn = ut; sn--; ) {
          var Cn = We[sn];
          if (!(ke ? Cn in w : xi.call(w, Cn)))
            return !1;
        }
        var Ln = be.get(g), dr = be.get(w);
        if (Ln && dr)
          return Ln == w && dr == g;
        var gi = !0;
        be.set(g, w), be.set(w, g);
        for (var kr = ke; ++sn < ut; ) {
          Cn = We[sn];
          var Fi = g[Cn], Ji = w[Cn];
          if (Z)
            var Hu = ke ? Z(Ji, Fi, Cn, w, g, be) : Z(Fi, Ji, Cn, g, w, be);
          if (!(Hu === t ? Fi === Ji || ae(Fi, Ji, N, Z, be) : Hu)) {
            gi = !1;
            break;
          }
          kr || (kr = Cn == "constructor");
        }
        if (gi && !kr) {
          var Vs = g.constructor, gc = w.constructor;
          Vs != gc && "constructor" in g && "constructor" in w && !(typeof Vs == "function" && Vs instanceof Vs && typeof gc == "function" && gc instanceof gc) && (gi = !1);
        }
        return be.delete(g), be.delete(w), gi;
      }
      function Ar(g) {
        return pd(Jd(g, t, Gm), g + "");
      }
      function Va(g) {
        return ep(g, Ql, Xo);
      }
      function $r(g) {
        return ep(g, Xc, qo);
      }
      var hc = Gd ? function(g) {
        return Gd.get(g);
      } : Yy;
      function hd(g) {
        for (var w = g.name + "", N = id[w], Z = xi.call(id, w) ? N.length : 0; Z--; ) {
          var ae = N[Z], be = ae.func;
          if (be == null || be == g)
            return ae.name;
        }
        return w;
      }
      function np(g) {
        var w = xi.call(ve, "placeholder") ? ve : g;
        return w.placeholder;
      }
      function gr() {
        var g = ve.iteratee || ix;
        return g = g === ix ? ld : g, arguments.length ? g(arguments[0], arguments[1]) : g;
      }
      function Gp(g, w) {
        var N = g.__data__;
        return Jn(w) ? N[typeof w == "string" ? "string" : "hash"] : N.map;
      }
      function km(g) {
        for (var w = Ql(g), N = w.length; N--; ) {
          var Z = w[N], ae = g[Z];
          w[N] = [Z, ae, ip(ae)];
        }
        return w;
      }
      function Of(g, w) {
        var N = Kf(g, w);
        return Xd(N) ? N : t;
      }
      function dg(g) {
        var w = xi.call(g, gf), N = g[gf];
        try {
          g[gf] = t;
          var Z = !0;
        } catch {
        }
        var ae = ml.call(g);
        return Z && (w ? g[gf] = N : delete g[gf]), ae;
      }
      var Xo = ac ? function(g) {
        return g == null ? [] : (g = $n(g), $o(ac(g), function(w) {
          return So.call(g, w);
        }));
      } : P1, qo = ac ? function(g) {
        for (var w = []; g; )
          Cu(w, Xo(g)), g = Br(g);
        return w;
      } : P1, rs = Go;
      (xf && rs(new xf(new ArrayBuffer(1))) != Ut || Lu && rs(new Lu()) != mt || rd && rs(rd.resolve()) != ft || uu && rs(new uu()) != Mt || Sf && rs(new Sf()) != lt) && (rs = function(g) {
        var w = Go(g), N = w == Qt ? g.constructor : t, Z = N ? md(N) : "";
        if (Z)
          switch (Z) {
            case Ac:
              return Ut;
            case zl:
              return mt;
            case Dc:
              return ft;
            case Lc:
              return Mt;
            case Os:
              return lt;
          }
        return w;
      });
      function Wp(g, w, N) {
        for (var Z = -1, ae = N.length; ++Z < ae; ) {
          var be = N[Z], ke = be.size;
          switch (be.type) {
            case "drop":
              g += ke;
              break;
            case "dropRight":
              w -= ke;
              break;
            case "take":
              w = Qs(w, g + ke);
              break;
            case "takeRight":
              g = ds(g, w - ke);
              break;
          }
        }
        return { start: g, end: w };
      }
      function Mh(g) {
        var w = g.match(ct);
        return w ? w[1].split(me) : [];
      }
      function pc(g, w, N) {
        w = eo(w, g);
        for (var Z = -1, ae = w.length, be = !1; ++Z < ae; ) {
          var ke = ql(w[Z]);
          if (!(be = g != null && N(g, ke)))
            break;
          g = g[ke];
        }
        return be || ++Z != ae ? be : (ae = g == null ? 0 : g.length, !!ae && Cg(ae) && Fu(ke, ae) && (ei(g) || em(g)));
      }
      function to(g) {
        var w = g.length, N = new g.constructor(w);
        return w && typeof g[0] == "string" && xi.call(g, "index") && (N.index = g.index, N.input = g.input), N;
      }
      function rp(g) {
        return typeof g.constructor == "function" && !jp(g) ? oc(Br(g)) : {};
      }
      function yl(g, w, N) {
        var Z = g.constructor;
        switch (w) {
          case Nt:
            return pu(g);
          case rt:
          case _t:
            return new Z(+g);
          case Ut:
            return zu(g, N);
          case tt:
          case rn:
          case ze:
          case xe:
          case Ie:
          case it:
          case at:
          case hn:
          case De:
            return cd(g, N);
          case mt:
            return new Z();
          case vt:
          case Me:
            return new Z(g);
          case Jt:
            return Mo(g);
          case Mt:
            return new Z();
          case oe:
            return Bc(g);
        }
      }
      function xy(g, w) {
        var N = w.length;
        if (!N)
          return g;
        var Z = N - 1;
        return w[Z] = (N > 1 ? "& " : "") + w[Z], w = w.join(N > 2 ? ", " : " "), g.replace(Te, `{
/* [wrapped with ` + w + `] */
`);
      }
      function hg(g) {
        return ei(g) || em(g) || !!(_h && g && g[_h]);
      }
      function Fu(g, w) {
        var N = typeof g;
        return w = w == null ? he : w, !!w && (N == "number" || N != "symbol" && br.test(g)) && g > -1 && g % 1 == 0 && g < w;
      }
      function Vi(g, w, N) {
        if (!Hs(N))
          return !1;
        var Z = typeof w;
        return (Z == "number" ? ll(N) && Fu(w, N.length) : Z == "string" && w in N) ? Bu(N[w], g) : !1;
      }
      function _v(g, w) {
        if (ei(g))
          return !1;
        var N = typeof g;
        return N == "number" || N == "symbol" || N == "boolean" || g == null || Ni(g) ? !0 : ti.test(g) || !jr.test(g) || w != null && g in $n(w);
      }
      function Jn(g) {
        var w = typeof g;
        return w == "string" || w == "number" || w == "symbol" || w == "boolean" ? g !== "__proto__" : g === null;
      }
      function Th(g) {
        var w = hd(g), N = ve[w];
        if (typeof N != "function" || !(w in Hn.prototype))
          return !1;
        if (g === N)
          return !0;
        var Z = hc(N);
        return !!Z && g === Z[0];
      }
      function Im(g) {
        return !!Au && Au in g;
      }
      var z0 = $a ? yp : qy;
      function jp(g) {
        var w = g && g.constructor, N = typeof w == "function" && w.prototype || Ul;
        return g === N;
      }
      function ip(g) {
        return g === g && !Hs(g);
      }
      function Bm(g, w) {
        return function(N) {
          return N == null ? !1 : N[g] === w && (w !== t || g in $n(N));
        };
      }
      function Sy(g) {
        var w = Ze(g, function(Z) {
          return N.size === m && N.clear(), Z;
        }), N = w.cache;
        return w;
      }
      function ap(g, w) {
        var N = g[1], Z = w[1], ae = N | Z, be = ae < (U | B | $), ke = Z == $ && N == V || Z == $ && N == W && g[7].length <= w[8] || Z == ($ | W) && w[7].length <= w[8] && N == V;
        if (!(be || ke))
          return g;
        Z & U && (g[2] = w[2], ae |= N & U ? 0 : k);
        var We = w[3];
        if (We) {
          var ut = g[3];
          g[3] = ut ? mu(ut, We, w[4]) : We, g[4] = ut ? Ss(g[3], S) : w[4];
        }
        return We = w[5], We && (ut = g[5], g[5] = ut ? dd(ut, We, w[6]) : We, g[6] = ut ? Ss(g[5], S) : w[6]), We = w[7], We && (g[7] = We), Z & $ && (g[8] = g[8] == null ? w[8] : Qs(g[8], w[8])), g[9] == null && (g[9] = w[9]), g[0] = w[0], g[1] = ae, g;
      }
      function Yp(g) {
        var w = [];
        if (g != null)
          for (var N in $n(g))
            w.push(N);
        return w;
      }
      function Xp(g) {
        return ml.call(g);
      }
      function Jd(g, w, N) {
        return w = ds(w === t ? g.length - 1 : w, 0), function() {
          for (var Z = arguments, ae = -1, be = ds(Z.length - w, 0), ke = pt(be); ++ae < be; )
            ke[ae] = Z[w + ae];
          ae = -1;
          for (var We = pt(w + 1); ++ae < w; )
            We[ae] = Z[ae];
          return We[w] = N(ke), Jr(g, this, We);
        };
      }
      function no(g, w) {
        return w.length < 2 ? g : ya(g, Ha(w, 0, -1));
      }
      function Gi(g, w) {
        for (var N = g.length, Z = Qs(w.length, N), ae = Ms(g); Z--; ) {
          var be = w[Z];
          g[Z] = Fu(be, N) ? ae[be] : t;
        }
        return g;
      }
      function is(g, w) {
        if (!(w === "constructor" && typeof g[w] == "function") && w != "__proto__")
          return g[w];
      }
      var To = _y(vi), xl = Hr || function(g, w) {
        return Ki.setTimeout(g, w);
      }, pd = _y(lr);
      function Uf(g, w, N) {
        var Z = w + "";
        return pd(g, xy(Z, by(Mh(Z), N)));
      }
      function _y(g) {
        var w = 0, N = 0;
        return function() {
          var Z = zm(), ae = Ee - (Z - N);
          if (N = Z, ae > 0) {
            if (++w >= ce)
              return arguments[0];
          } else
            w = 0;
          return g.apply(t, arguments);
        };
      }
      function al(g, w) {
        var N = -1, Z = g.length, ae = Z - 1;
        for (w = w === t ? Z : w; ++N < w; ) {
          var be = Ns(N, ae), ke = g[be];
          g[be] = g[N], g[N] = ke;
        }
        return g.length = w, g;
      }
      var pg = Sy(function(g) {
        var w = [];
        return g.charCodeAt(0) === 46 && w.push(""), g.replace(ki, function(N, Z, ae, be) {
          w.push(ae ? be.replace(on, "$1") : Z || N);
        }), w;
      });
      function ql(g) {
        if (typeof g == "string" || Ni(g))
          return g;
        var w = g + "";
        return w == "0" && 1 / g == -Be ? "-0" : w;
      }
      function md(g) {
        if (g != null) {
          try {
            return pl.call(g);
          } catch {
          }
          try {
            return g + "";
          } catch {
          }
        }
        return "";
      }
      function by(g, w) {
        return va(Je, function(N) {
          var Z = "_." + N[0];
          w & N[1] && !Ku(g, Z) && g.push(Z);
        }), g.sort();
      }
      function bv(g) {
        if (g instanceof Hn)
          return g.clone();
        var w = new ka(g.__wrapped__, g.__chain__);
        return w.__actions__ = Ms(g.__actions__), w.__index__ = g.__index__, w.__values__ = g.__values__, w;
      }
      function mg(g, w, N) {
        (N ? Vi(g, w, N) : w === t) ? w = 1 : w = ds(qr(w), 0);
        var Z = g == null ? 0 : g.length;
        if (!Z || w < 1)
          return [];
        for (var ae = 0, be = 0, ke = pt(Bo(Z / w)); ae < Z; )
          ke[be++] = Ha(g, ae, ae += w);
        return ke;
      }
      function wv(g) {
        for (var w = -1, N = g == null ? 0 : g.length, Z = 0, ae = []; ++w < N; ) {
          var be = g[w];
          be && (ae[Z++] = be);
        }
        return ae;
      }
      function Ch() {
        var g = arguments.length;
        if (!g)
          return [];
        for (var w = pt(g - 1), N = arguments[0], Z = g; Z--; )
          w[Z - 1] = arguments[Z];
        return Cu(ei(N) ? Ms(N) : [N], Ks(w, 1));
      }
      var aa = Sr(function(g, w) {
        return Rs(g) ? fa(g, Ks(w, 1, Rs, !0)) : [];
      }), Nr = Sr(function(g, w) {
        var N = Qo(w);
        return Rs(N) && (N = t), Rs(g) ? fa(g, Ks(w, 1, Rs, !0), gr(N, 2)) : [];
      }), ea = Sr(function(g, w) {
        var N = Qo(w);
        return Rs(N) && (N = t), Rs(g) ? fa(g, Ks(w, 1, Rs, !0), t, N) : [];
      });
      function Ga(g, w, N) {
        var Z = g == null ? 0 : g.length;
        return Z ? (w = N || w === t ? 1 : qr(w), Ha(g, w < 0 ? 0 : w, Z)) : [];
      }
      function vs(g, w, N) {
        var Z = g == null ? 0 : g.length;
        return Z ? (w = N || w === t ? 1 : qr(w), w = Z - w, Ha(g, 0, w < 0 ? 0 : w)) : [];
      }
      function Hc(g, w) {
        return g && g.length ? $s(g, gr(w, 3), !0, !0) : [];
      }
      function Hm(g, w) {
        return g && g.length ? $s(g, gr(w, 3), !0) : [];
      }
      function sl(g, w, N, Z) {
        var ae = g == null ? 0 : g.length;
        return ae ? (N && typeof N != "number" && Vi(g, w, N) && (N = 0, Z = ae), $h(g, w, N, Z)) : [];
      }
      function Vm(g, w, N) {
        var Z = g == null ? 0 : g.length;
        if (!Z)
          return -1;
        var ae = N == null ? 0 : qr(N);
        return ae < 0 && (ae = ds(Z + ae, 0)), vh(g, gr(w, 3), ae);
      }
      function vd(g, w, N) {
        var Z = g == null ? 0 : g.length;
        if (!Z)
          return -1;
        var ae = Z - 1;
        return N !== t && (ae = qr(N), ae = N < 0 ? ds(Z + ae, 0) : Qs(ae, Z - 1)), vh(g, gr(w, 3), ae, !0);
      }
      function Gm(g) {
        var w = g == null ? 0 : g.length;
        return w ? Ks(g, 1) : [];
      }
      function sp(g) {
        var w = g == null ? 0 : g.length;
        return w ? Ks(g, Be) : [];
      }
      function op(g, w) {
        var N = g == null ? 0 : g.length;
        return N ? (w = w === t ? 1 : qr(w), Ks(g, w)) : [];
      }
      function gu(g) {
        for (var w = -1, N = g == null ? 0 : g.length, Z = {}; ++w < N; ) {
          var ae = g[w];
          Z[ae[0]] = ae[1];
        }
        return Z;
      }
      function Wm(g) {
        return g && g.length ? g[0] : t;
      }
      function lp(g, w, N) {
        var Z = g == null ? 0 : g.length;
        if (!Z)
          return -1;
        var ae = N == null ? 0 : qr(N);
        return ae < 0 && (ae = ds(Z + ae, 0)), $u(g, w, ae);
      }
      function gd(g) {
        var w = g == null ? 0 : g.length;
        return w ? Ha(g, 0, -1) : [];
      }
      var vg = Sr(function(g) {
        var w = qi(g, Es);
        return w.length && w[0] === g[0] ? ns(w) : [];
      }), qp = Sr(function(g) {
        var w = Qo(g), N = qi(g, Es);
        return w === Qo(N) ? w = t : N.pop(), N.length && N[0] === g[0] ? ns(N, gr(w, 2)) : [];
      }), Kd = Sr(function(g) {
        var w = Qo(g), N = qi(g, Es);
        return w = typeof w == "function" ? w : t, w && N.pop(), N.length && N[0] === g[0] ? ns(N, t, w) : [];
      });
      function up(g, w) {
        return g == null ? "" : yf.call(g, w);
      }
      function Qo(g) {
        var w = g == null ? 0 : g.length;
        return w ? g[w - 1] : t;
      }
      function cp(g, w, N) {
        var Z = g == null ? 0 : g.length;
        if (!Z)
          return -1;
        var ae = Z;
        return N !== t && (ae = qr(N), ae = ae < 0 ? ds(Z + ae, 0) : Qs(ae, Z - 1)), w === w ? Fp(g, w, ae) : vh(g, Ru, ae, !0);
      }
      function jm(g, w) {
        return g && g.length ? Wl(g, qr(w)) : t;
      }
      var Ev = Sr(Vc);
      function Vc(g, w) {
        return g && g.length && w && w.length ? fr(g, w) : g;
      }
      function fp(g, w, N) {
        return g && g.length && w && w.length ? fr(g, w, gr(N, 2)) : g;
      }
      function ha(g, w, N) {
        return g && g.length && w && w.length ? fr(g, w, t, N) : g;
      }
      var ro = Ar(function(g, w) {
        var N = g == null ? 0 : g.length, Z = sd(g, w);
        return fi(g, qi(w, function(ae) {
          return Fu(ae, N) ? +ae : ae;
        }).sort(Yo)), Z;
      });
      function Sl(g, w) {
        var N = [];
        if (!(g && g.length))
          return N;
        var Z = -1, ae = [], be = g.length;
        for (w = gr(w, 3); ++Z < be; ) {
          var ke = g[Z];
          w(ke, Z, g) && (N.push(ke), ae.push(Z));
        }
        return fi(g, ae), N;
      }
      function Zo(g) {
        return g == null ? g : bh.call(g);
      }
      function dp(g, w, N) {
        var Z = g == null ? 0 : g.length;
        return Z ? (N && typeof N != "number" && Vi(g, w, N) ? (w = 0, N = Z) : (w = w == null ? 0 : qr(w), N = N === t ? Z : qr(N)), Ha(g, w, N)) : [];
      }
      function Mv(g, w) {
        return Di(g, w);
      }
      function Qp(g, w, N) {
        return Tf(g, w, gr(N, 2));
      }
      function gg(g, w) {
        var N = g == null ? 0 : g.length;
        if (N) {
          var Z = Di(g, w);
          if (Z < N && Bu(g[Z], w))
            return Z;
        }
        return -1;
      }
      function yu(g, w) {
        return Di(g, w, !0);
      }
      function Tv(g, w, N) {
        return Tf(g, w, gr(N, 2), !0);
      }
      function Rh(g, w) {
        var N = g == null ? 0 : g.length;
        if (N) {
          var Z = Di(g, w, !0) - 1;
          if (Bu(g[Z], w))
            return Z;
        }
        return -1;
      }
      function Ah(g) {
        return g && g.length ? Cf(g) : [];
      }
      function yg(g, w) {
        return g && g.length ? Cf(g, gr(w, 2)) : [];
      }
      function zf(g) {
        var w = g == null ? 0 : g.length;
        return w ? Ha(g, 1, w) : [];
      }
      function wy(g, w, N) {
        return g && g.length ? (w = N || w === t ? 1 : qr(w), Ha(g, 0, w < 0 ? 0 : w)) : [];
      }
      function xg(g, w, N) {
        var Z = g == null ? 0 : g.length;
        return Z ? (w = N || w === t ? 1 : qr(w), w = Z - w, Ha(g, w < 0 ? 0 : w, Z)) : [];
      }
      function Ey(g, w) {
        return g && g.length ? $s(g, gr(w, 3), !1, !0) : [];
      }
      function hp(g, w) {
        return g && g.length ? $s(g, gr(w, 3)) : [];
      }
      var pp = Sr(function(g) {
        return Fs(Ks(g, 1, Rs, !0));
      }), Cv = Sr(function(g) {
        var w = Qo(g);
        return Rs(w) && (w = t), Fs(Ks(g, 1, Rs, !0), gr(w, 2));
      }), Rv = Sr(function(g) {
        var w = Qo(g);
        return w = typeof w == "function" ? w : t, Fs(Ks(g, 1, Rs, !0), t, w);
      });
      function Ym(g) {
        return g && g.length ? Fs(g) : [];
      }
      function Dh(g, w) {
        return g && g.length ? Fs(g, gr(w, 2)) : [];
      }
      function My(g, w) {
        return w = typeof w == "function" ? w : t, g && g.length ? Fs(g, t, w) : [];
      }
      function Gc(g) {
        if (!(g && g.length))
          return [];
        var w = 0;
        return g = $o(g, function(N) {
          if (Rs(N))
            return w = ds(N.length, w), !0;
        }), mf(w, function(N) {
          return qi(g, hl(N));
        });
      }
      function Zp(g, w) {
        if (!(g && g.length))
          return [];
        var N = Gc(g);
        return w == null ? N : qi(N, function(Z) {
          return Jr(w, t, Z);
        });
      }
      var Is = Sr(function(g, w) {
        return Rs(g) ? fa(g, w) : [];
      }), Ty = Sr(function(g) {
        return tp($o(g, Rs));
      }), Sg = Sr(function(g) {
        var w = Qo(g);
        return Rs(w) && (w = t), tp($o(g, Rs), gr(w, 2));
      }), N0 = Sr(function(g) {
        var w = Qo(g);
        return w = typeof w == "function" ? w : t, tp($o(g, Rs), t, w);
      }), F0 = Sr(Gc);
      function Xm(g, w) {
        return kc(g || [], w || [], Ou);
      }
      function Wc(g, w) {
        return kc(g || [], w || [], Ht);
      }
      var Cy = Sr(function(g) {
        var w = g.length, N = w > 1 ? g[w - 1] : t;
        return N = typeof N == "function" ? (g.pop(), N) : t, Zp(g, N);
      });
      function _l(g) {
        var w = ve(g);
        return w.__chain__ = !0, w;
      }
      function Av(g, w) {
        return w(g), g;
      }
      function _g(g, w) {
        return w(g);
      }
      var ku = Ar(function(g) {
        var w = g.length, N = w ? g[0] : 0, Z = this.__wrapped__, ae = function(be) {
          return sd(be, g);
        };
        return w > 1 || this.__actions__.length || !(Z instanceof Hn) || !Fu(N) ? this.thru(ae) : (Z = Z.slice(N, +N + (w ? 1 : 0)), Z.__actions__.push({
          func: _g,
          args: [ae],
          thisArg: t
        }), new ka(Z, this.__chain__).thru(function(be) {
          return w && !be.length && be.push(t), be;
        }));
      });
      function Lh() {
        return _l(this);
      }
      function Jp() {
        return new ka(this.value(), this.__chain__);
      }
      function mp() {
        this.__values__ === t && (this.__values__ = _d(this.value()));
        var g = this.__index__ >= this.__values__.length, w = g ? t : this.__values__[this.__index__++];
        return { done: g, value: w };
      }
      function mc() {
        return this;
      }
      function Aa(g) {
        for (var w, N = this; N instanceof Zs; ) {
          var Z = bv(N);
          Z.__index__ = 0, Z.__values__ = t, w ? ae.__wrapped__ = Z : w = Z;
          var ae = Z;
          N = N.__wrapped__;
        }
        return ae.__wrapped__ = g, w;
      }
      function vp() {
        var g = this.__wrapped__;
        if (g instanceof Hn) {
          var w = g;
          return this.__actions__.length && (w = new Hn(this)), w = w.reverse(), w.__actions__.push({
            func: _g,
            args: [Zo],
            thisArg: t
          }), new ka(w, this.__chain__);
        }
        return this.thru(Zo);
      }
      function Ts() {
        return Yl(this.__wrapped__, this.__actions__);
      }
      var bl = ii(function(g, w, N) {
        xi.call(g, N) ? ++g[N] : Us(g, N, 1);
      });
      function Dv(g, w, N) {
        var Z = ei(g) ? Zf : du;
        return N && Vi(g, w, N) && (w = t), Z(g, gr(w, 3));
      }
      function bg(g, w) {
        var N = ei(g) ? $o : bf;
        return N(g, gr(w, 3));
      }
      var Lv = H(Vm), On = H(vd);
      function Iu(g, w) {
        return Ks(gp(g, w), 1);
      }
      function Pv(g, w) {
        return Ks(gp(g, w), Be);
      }
      function Kp(g, w, N) {
        return N = N === t ? 1 : qr(N), Ks(gp(g, w), N);
      }
      function Ph(g, w) {
        var N = ei(g) ? va : Uu;
        return N(g, gr(w, 3));
      }
      function sa(g, w) {
        var N = ei(g) ? qs : Hp;
        return N(g, gr(w, 3));
      }
      var Cs = ii(function(g, w, N) {
        xi.call(g, N) ? g[N].push(w) : Us(g, N, [w]);
      });
      function Co(g, w, N, Z) {
        g = ll(g) ? g : $m(g), N = N && !Z ? qr(N) : 0;
        var ae = g.length;
        return N < 0 && (N = ds(ae + N, 0)), Oy(g) ? N <= ae && g.indexOf(w, N) > -1 : !!ae && $u(g, w, N) > -1;
      }
      var $p = Sr(function(g, w, N) {
        var Z = -1, ae = typeof w == "function", be = ll(g) ? pt(g.length) : [];
        return Uu(g, function(ke) {
          be[++Z] = ae ? Jr(w, ke, N) : Sa(ke, w, N);
        }), be;
      }), qm = ii(function(g, w, N) {
        Us(g, N, w);
      });
      function gp(g, w) {
        var N = ei(g) ? qi : Qd;
        return N(g, gr(w, 3));
      }
      function wg(g, w, N, Z) {
        return g == null ? [] : (ei(w) || (w = w == null ? [] : [w]), N = Z ? t : N, ei(N) || (N = N == null ? [] : [N]), Eh(g, w, N));
      }
      var u1 = ii(function(g, w, N) {
        g[N ? 0 : 1].push(w);
      }, function() {
        return [[], []];
      });
      function Wt(g, w, N) {
        var Z = ei(g) ? Up : pf, ae = arguments.length < 3;
        return Z(g, gr(w, 4), N, ae, Uu);
      }
      function Nf(g, w, N) {
        var Z = ei(g) ? cg : pf, ae = arguments.length < 3;
        return Z(g, gr(w, 4), N, ae, Hp);
      }
      function yd(g, w) {
        var N = ei(g) ? $o : bf;
        return N(g, gt(gr(w, 3)));
      }
      function c(g) {
        var w = ei(g) ? kl : Eo;
        return w(g);
      }
      function p(g, w, N) {
        (N ? Vi(g, w, N) : w === t) ? w = 1 : w = qr(w);
        var Z = ei(g) ? wo : Ai;
        return Z(g, w);
      }
      function E(g) {
        var w = ei(g) ? Nm : Fc;
        return w(g);
      }
      function O(g) {
        if (g == null)
          return 0;
        if (ll(g))
          return Oy(g) ? nc(g) : g.length;
        var w = rs(g);
        return w == mt || w == Mt ? g.size : il(g).length;
      }
      function G(g, w, N) {
        var Z = ei(g) ? Zh : jo;
        return N && Vi(g, w, N) && (w = t), Z(g, gr(w, 3));
      }
      var Q = Sr(function(g, w) {
        if (g == null)
          return [];
        var N = w.length;
        return N > 1 && Vi(g, w[0], w[1]) ? w = [] : N > 2 && Vi(w[0], w[1], w[2]) && (w = [w[0]]), Eh(g, Ks(w, 1), []);
      }), le = Ir || function() {
        return Ki.Date.now();
      };
      function Le(g, w) {
        if (typeof w != "function")
          throw new Io(l);
        return g = qr(g), function() {
          if (--g < 1)
            return w.apply(this, arguments);
        };
      }
      function Ve(g, w, N) {
        return w = N ? t : w, w = g && w == null ? g.length : w, dt(g, $, t, t, t, t, w);
      }
      function Ct(g, w) {
        var N;
        if (typeof w != "function")
          throw new Io(l);
        return g = qr(g), function() {
          return --g > 0 && (N = w.apply(this, arguments)), g <= 1 && (w = t), N;
        };
      }
      var un = Sr(function(g, w, N) {
        var Z = U;
        if (N.length) {
          var ae = Ss(N, np(un));
          Z |= X;
        }
        return dt(g, Z, w, N, ae);
      }), ln = Sr(function(g, w, N) {
        var Z = U | B;
        if (N.length) {
          var ae = Ss(N, np(ln));
          Z |= X;
        }
        return dt(w, Z, g, N, ae);
      });
      function nn(g, w, N) {
        w = N ? t : w;
        var Z = dt(g, V, t, t, t, t, t, w);
        return Z.placeholder = nn.placeholder, Z;
      }
      function kn(g, w, N) {
        w = N ? t : w;
        var Z = dt(g, I, t, t, t, t, t, w);
        return Z.placeholder = kn.placeholder, Z;
      }
      function qn(g, w, N) {
        var Z, ae, be, ke, We, ut, tn = 0, Kt = !1, sn = !1, Cn = !0;
        if (typeof g != "function")
          throw new Io(l);
        w = Yc(w) || 0, Hs(N) && (Kt = !!N.leading, sn = "maxWait" in N, be = sn ? ds(Yc(N.maxWait) || 0, w) : be, Cn = "trailing" in N ? !!N.trailing : Cn);
        function Ln(Gs) {
          var Jl = Z, Vu = ae;
          return Z = ae = t, tn = Gs, ke = g.apply(Vu, Jl), ke;
        }
        function dr(Gs) {
          return tn = Gs, We = xl(Fi, w), Kt ? Ln(Gs) : ke;
        }
        function gi(Gs) {
          var Jl = Gs - ut, Vu = Gs - tn, Gu = w - Jl;
          return sn ? Qs(Gu, be - Vu) : Gu;
        }
        function kr(Gs) {
          var Jl = Gs - ut, Vu = Gs - tn;
          return ut === t || Jl >= w || Jl < 0 || sn && Vu >= be;
        }
        function Fi() {
          var Gs = le();
          if (kr(Gs))
            return Ji(Gs);
          We = xl(Fi, gi(Gs));
        }
        function Ji(Gs) {
          return We = t, Cn && Z ? Ln(Gs) : (Z = ae = t, ke);
        }
        function Hu() {
          We !== t && hu(We), tn = 0, Z = ut = ae = We = t;
        }
        function Vs() {
          return We === t ? ke : Ji(le());
        }
        function gc() {
          var Gs = le(), Jl = kr(Gs);
          if (Z = arguments, ae = this, ut = Gs, Jl) {
            if (We === t)
              return dr(ut);
            if (sn)
              return hu(We), We = xl(Fi, w), Ln(ut);
          }
          return We === t && (We = xl(Fi, w)), ke;
        }
        return gc.cancel = Hu, gc.flush = Vs, gc;
      }
      var rr = Sr(function(g, w) {
        return zs(g, 1, w);
      }), Bs = Sr(function(g, w, N) {
        return zs(g, Yc(w) || 0, N);
      });
      function ht(g) {
        return dt(g, ee);
      }
      function Ze(g, w) {
        if (typeof g != "function" || w != null && typeof w != "function")
          throw new Io(l);
        var N = function() {
          var Z = arguments, ae = w ? w.apply(this, Z) : Z[0], be = N.cache;
          if (be.has(ae))
            return be.get(ae);
          var ke = g.apply(this, Z);
          return N.cache = be.set(ae, ke) || be, ke;
        };
        return N.cache = new (Ze.Cache || Ho)(), N;
      }
      Ze.Cache = Ho;
      function gt(g) {
        if (typeof g != "function")
          throw new Io(l);
        return function() {
          var w = arguments;
          switch (w.length) {
            case 0:
              return !g.call(this);
            case 1:
              return !g.call(this, w[0]);
            case 2:
              return !g.call(this, w[0], w[1]);
            case 3:
              return !g.call(this, w[0], w[1], w[2]);
          }
          return !g.apply(this, w);
        };
      }
      function xn(g) {
        return Ct(2, g);
      }
      var ar = Xl(function(g, w) {
        w = w.length == 1 && ei(w[0]) ? qi(w[0], Oi(gr())) : qi(Ks(w, 1), Oi(gr()));
        var N = w.length;
        return Sr(function(Z) {
          for (var ae = -1, be = Qs(Z.length, N); ++ae < be; )
            Z[ae] = w[ae].call(this, Z[ae]);
          return Jr(g, this, Z);
        });
      }), Qn = Sr(function(g, w) {
        var N = Ss(w, np(Qn));
        return dt(g, X, t, w, N);
      }), pr = Sr(function(g, w) {
        var N = Ss(w, np(pr));
        return dt(g, J, t, w, N);
      }), Lr = Ar(function(g, w) {
        return dt(g, W, t, t, t, w);
      });
      function ol(g, w) {
        if (typeof g != "function")
          throw new Io(l);
        return w = w === t ? w : qr(w), Sr(g, w);
      }
      function Zi(g, w) {
        if (typeof g != "function")
          throw new Io(l);
        return w = w == null ? 0 : ds(qr(w), 0), Sr(function(N) {
          var Z = N[w], ae = Ic(N, 0, w);
          return Z && Cu(ae, Z), Jr(g, this, ae);
        });
      }
      function Ff(g, w, N) {
        var Z = !0, ae = !0;
        if (typeof g != "function")
          throw new Io(l);
        return Hs(N) && (Z = "leading" in N ? !!N.leading : Z, ae = "trailing" in N ? !!N.trailing : ae), qn(g, w, {
          leading: Z,
          maxWait: w,
          trailing: ae
        });
      }
      function Eg(g) {
        return Ve(g, 1);
      }
      function k0(g, w) {
        return Qn(wi(w), g);
      }
      function Mg() {
        if (!arguments.length)
          return [];
        var g = arguments[0];
        return ei(g) ? g : [g];
      }
      function I0(g) {
        return Vo(g, C);
      }
      function B0(g, w) {
        return w = typeof w == "function" ? w : t, Vo(g, C, w);
      }
      function Ry(g) {
        return Vo(g, _ | C);
      }
      function Ay(g, w) {
        return w = typeof w == "function" ? w : t, Vo(g, _ | C, w);
      }
      function Ov(g, w) {
        return w == null || rl(g, w, Ql(w));
      }
      function Bu(g, w) {
        return g === w || g !== g && w !== w;
      }
      var c1 = ur(Wo), H0 = ur(function(g, w) {
        return g >= w;
      }), em = Kr(function() {
        return arguments;
      }()) ? Kr : function(g) {
        return io(g) && xi.call(g, "callee") && !So.call(g, "callee");
      }, ei = pt.isArray, KS = bc ? Oi(bc) : Ra;
      function ll(g) {
        return g != null && Cg(g.length) && !yp(g);
      }
      function Rs(g) {
        return io(g) && ll(g);
      }
      function Dy(g) {
        return g === !0 || g === !1 || io(g) && Go(g) == rt;
      }
      var xd = Du || qy, f1 = xo ? Oi(xo) : Ba;
      function V0(g) {
        return io(g) && g.nodeType === 1 && !Zm(g);
      }
      function G0(g) {
        if (g == null)
          return !0;
        if (ll(g) && (ei(g) || typeof g == "string" || typeof g.splice == "function" || xd(g) || nm(g) || em(g)))
          return !g.length;
        var w = rs(g);
        if (w == mt || w == Mt)
          return !g.size;
        if (jp(g))
          return !il(g).length;
        for (var N in g)
          if (xi.call(g, N))
            return !1;
        return !0;
      }
      function W0(g, w) {
        return ci(g, w);
      }
      function Tg(g, w, N) {
        N = typeof N == "function" ? N : t;
        var Z = N ? N(g, w) : t;
        return Z === t ? ci(g, w, t, N) : !!Z;
      }
      function tm(g) {
        if (!io(g))
          return !1;
        var w = Go(g);
        return w == Ot || w == Rt || typeof g.message == "string" && typeof g.name == "string" && !Zm(g);
      }
      function j0(g) {
        return typeof g == "number" && Cc(g);
      }
      function yp(g) {
        if (!Hs(g))
          return !1;
        var w = Go(g);
        return w == He || w == et || w == ot || w == Vt;
      }
      function Uv(g) {
        return typeof g == "number" && g == qr(g);
      }
      function Cg(g) {
        return typeof g == "number" && g > -1 && g % 1 == 0 && g <= he;
      }
      function Hs(g) {
        var w = typeof g;
        return g != null && (w == "object" || w == "function");
      }
      function io(g) {
        return g != null && typeof g == "object";
      }
      var d1 = Tu ? Oi(Tu) : od;
      function Y0(g, w) {
        return g === w || ws(g, w, km(w));
      }
      function Ly(g, w, N) {
        return N = typeof N == "function" ? N : t, ws(g, w, km(w), N);
      }
      function Qm(g) {
        return zv(g) && g != +g;
      }
      function yw(g) {
        if (z0(g))
          throw new Kn(o);
        return Xd(g);
      }
      function $S(g) {
        return g === null;
      }
      function e_(g) {
        return g == null;
      }
      function zv(g) {
        return typeof g == "number" || io(g) && Go(g) == vt;
      }
      function Zm(g) {
        if (!io(g) || Go(g) != Qt)
          return !1;
        var w = Br(g);
        if (w === null)
          return !0;
        var N = xi.call(w, "constructor") && w.constructor;
        return typeof N == "function" && N instanceof N && pl.call(N) == Ca;
      }
      var Py = Pl ? Oi(Pl) : zc;
      function X0(g) {
        return Uv(g) && g >= -he && g <= he;
      }
      var q0 = za ? Oi(za) : cc;
      function Oy(g) {
        return typeof g == "string" || !ei(g) && io(g) && Go(g) == Me;
      }
      function Ni(g) {
        return typeof g == "symbol" || io(g) && Go(g) == oe;
      }
      var nm = Xs ? Oi(Xs) : qd;
      function Sd(g) {
        return g === t;
      }
      function jc(g) {
        return io(g) && rs(g) == lt;
      }
      function Uy(g) {
        return io(g) && Go(g) == zt;
      }
      var Q0 = ur(Ef), Fr = ur(function(g, w) {
        return g <= w;
      });
      function _d(g) {
        if (!g)
          return [];
        if (ll(g))
          return Oy(g) ? Na(g) : Ms(g);
        if (ic && g[ic])
          return yh(g[ic]());
        var w = rs(g), N = w == mt ? Id : w == Mt ? tc : $m;
        return N(g);
      }
      function xp(g) {
        if (!g)
          return g === 0 ? g : 0;
        if (g = Yc(g), g === Be || g === -Be) {
          var w = g < 0 ? -1 : 1;
          return w * fe;
        }
        return g === g ? g : 0;
      }
      function qr(g) {
        var w = xp(g), N = w % 1;
        return w === w ? N ? w - N : w : 0;
      }
      function Oh(g) {
        return g ? Il(qr(g), 0, ye) : 0;
      }
      function Yc(g) {
        if (typeof g == "number")
          return g;
        if (Ni(g))
          return ue;
        if (Hs(g)) {
          var w = typeof g.valueOf == "function" ? g.valueOf() : g;
          g = Hs(w) ? w + "" : w;
        }
        if (typeof g != "string")
          return g === 0 ? g : +g;
        g = ec(g);
        var N = vn.test(g);
        return N || nr.test(g) ? qf(g.slice(2), N ? 2 : 8) : mn.test(g) ? ue : +g;
      }
      function zy(g) {
        return ks(g, Xc(g));
      }
      function Z0(g) {
        return g ? Il(qr(g), -he, he) : g === 0 ? g : 0;
      }
      function Da(g) {
        return g == null ? "" : ia(g);
      }
      var kf = Nu(function(g, w) {
        if (jp(w) || ll(w)) {
          ks(w, Ql(w), g);
          return;
        }
        for (var N in w)
          xi.call(w, N) && Ou(g, N, w[N]);
      }), Rg = Nu(function(g, w) {
        ks(w, Xc(w), g);
      }), Nv = Nu(function(g, w, N, Z) {
        ks(w, Xc(w), g, Z);
      }), rm = Nu(function(g, w, N, Z) {
        ks(w, Ql(w), g, Z);
      }), h1 = Ar(sd);
      function im(g, w) {
        var N = oc(g);
        return w == null ? N : ga(N, w);
      }
      var Jm = Sr(function(g, w) {
        g = $n(g);
        var N = -1, Z = w.length, ae = Z > 2 ? w[2] : t;
        for (ae && Vi(w[0], w[1], ae) && (Z = 1); ++N < Z; )
          for (var be = w[N], ke = Xc(be), We = -1, ut = ke.length; ++We < ut; ) {
            var tn = ke[We], Kt = g[tn];
            (Kt === t || Bu(Kt, Ul[tn]) && !xi.call(g, tn)) && (g[tn] = be[tn]);
          }
        return g;
      }), Fv = Sr(function(g) {
        return g.push(t, At), Jr(g1, t, g);
      });
      function If(g, w) {
        return Pm(g, gr(w, 3), Hi);
      }
      function Ag(g, w) {
        return Pm(g, gr(w, 3), wn);
      }
      function vc(g, w) {
        return g == null ? g : Yd(g, gr(w, 3), Xc);
      }
      function J0(g, w) {
        return g == null ? g : da(g, gr(w, 3), Xc);
      }
      function Dg(g, w) {
        return g && Hi(g, gr(w, 3));
      }
      function Ny(g, w) {
        return g && wn(g, gr(w, 3));
      }
      function t_(g) {
        return g == null ? [] : Qi(g, Ql(g));
      }
      function p1(g) {
        return g == null ? [] : Qi(g, Xc(g));
      }
      function m1(g, w, N) {
        var Z = g == null ? t : ya(g, w);
        return Z === t ? N : Z;
      }
      function Fy(g, w) {
        return g != null && pc(g, w, ts);
      }
      function Km(g, w) {
        return g != null && pc(g, w, An);
      }
      var v1 = Ae(function(g, w, N) {
        w != null && typeof w.toString != "function" && (w = ml.call(w)), g[w] = N;
      }, nx(Bf)), xw = Ae(function(g, w, N) {
        w != null && typeof w.toString != "function" && (w = ml.call(w)), xi.call(g, w) ? g[w].push(N) : g[w] = [N];
      }, gr), K0 = Sr(Sa);
      function Ql(g) {
        return ll(g) ? pn(g) : il(g);
      }
      function Xc(g) {
        return ll(g) ? pn(g, !0) : Fm(g);
      }
      function Sw(g, w) {
        var N = {};
        return w = gr(w, 3), Hi(g, function(Z, ae, be) {
          Us(N, w(Z, ae, be), Z);
        }), N;
      }
      function _w(g, w) {
        var N = {};
        return w = gr(w, 3), Hi(g, function(Z, ae, be) {
          Us(N, ae, w(Z, ae, be));
        }), N;
      }
      var Sp = Nu(function(g, w, N) {
        Gl(g, w, N);
      }), g1 = Nu(function(g, w, N, Z) {
        Gl(g, w, N, Z);
      }), n_ = Ar(function(g, w) {
        var N = {};
        if (g == null)
          return N;
        var Z = !1;
        w = qi(w, function(be) {
          return be = eo(be, g), Z || (Z = be.length > 1), be;
        }), ks(g, $r(g), N), Z && (N = Vo(N, _ | T | C, qt));
        for (var ae = w.length; ae--; )
          Af(N, w[ae]);
        return N;
      });
      function ky(g, w) {
        return By(g, gt(gr(w)));
      }
      var Iy = Ar(function(g, w) {
        return g == null ? {} : fc(g, w);
      });
      function By(g, w) {
        if (g == null)
          return {};
        var N = qi($r(g), function(Z) {
          return [Z];
        });
        return w = gr(w), hr(g, N, function(Z, ae) {
          return w(Z, ae[0]);
        });
      }
      function Lg(g, w, N) {
        w = eo(w, g);
        var Z = -1, ae = w.length;
        for (ae || (ae = 1, g = t); ++Z < ae; ) {
          var be = g == null ? t : g[ql(w[Z])];
          be === t && (Z = ae, be = N), g = yp(be) ? be.call(g) : be;
        }
        return g;
      }
      function $0(g, w, N) {
        return g == null ? g : Ht(g, w, N);
      }
      function kv(g, w, N, Z) {
        return Z = typeof Z == "function" ? Z : t, g == null ? g : Ht(g, w, N, Z);
      }
      var wl = ms(Ql), y1 = ms(Xc);
      function am(g, w, N) {
        var Z = ei(g), ae = Z || xd(g) || nm(g);
        if (w = gr(w, 4), N == null) {
          var be = g && g.constructor;
          ae ? N = Z ? new be() : [] : Hs(g) ? N = yp(be) ? oc(Br(g)) : {} : N = {};
        }
        return (ae ? va : Hi)(g, function(ke, We, ut) {
          return w(N, ke, We, ut);
        }), N;
      }
      function qc(g, w) {
        return g == null ? !0 : Af(g, w);
      }
      function x1(g, w, N) {
        return g == null ? g : Zd(g, w, wi(N));
      }
      function Pg(g, w, N, Z) {
        return Z = typeof Z == "function" ? Z : t, g == null ? g : Zd(g, w, wi(N), Z);
      }
      function $m(g) {
        return g == null ? [] : Za(g, Ql(g));
      }
      function S1(g) {
        return g == null ? [] : Za(g, Xc(g));
      }
      function ex(g, w, N) {
        return N === t && (N = w, w = t), N !== t && (N = Yc(N), N = N === N ? N : 0), w !== t && (w = Yc(w), w = w === w ? w : 0), Il(Yc(g), w, N);
      }
      function Iv(g, w, N) {
        return w = xp(w), N === t ? (N = w, w = 0) : N = xp(N), g = Yc(g), xa(g, w, N);
      }
      function _1(g, w, N) {
        if (N && typeof N != "boolean" && Vi(g, w, N) && (w = N = t), N === t && (typeof w == "boolean" ? (N = w, w = t) : typeof g == "boolean" && (N = g, g = t)), g === t && w === t ? (g = 0, w = 1) : (g = xp(g), w === t ? (w = g, g = 0) : w = xp(w)), g > w) {
          var Z = g;
          g = w, w = Z;
        }
        if (N || g % 1 || w % 1) {
          var ae = Vd();
          return Qs(g + ae * (w - g + Xf("1e-" + ((ae + "").length - 1))), w);
        }
        return Ns(g, w);
      }
      var Hy = y(function(g, w, N) {
        return w = w.toLowerCase(), g + (N ? Zl(w) : w);
      });
      function Zl(g) {
        return tx(Da(g).toLowerCase());
      }
      function Vy(g) {
        return g = Da(g), g && g.replace(Yi, Om).replace(mi, "");
      }
      function Gy(g, w, N) {
        g = Da(g), w = ia(w);
        var Z = g.length;
        N = N === t ? Z : Il(qr(N), 0, Z);
        var ae = N;
        return N -= w.length, N >= 0 && g.slice(N, ae) == w;
      }
      function Og(g) {
        return g = Da(g), g && Wr.test(g) ? g.replace(fn, Um) : g;
      }
      function Ug(g) {
        return g = Da(g), g && ni.test(g) ? g.replace(Wi, "\\$&") : g;
      }
      var r_ = y(function(g, w, N) {
        return g + (N ? "-" : "") + w.toLowerCase();
      }), b1 = y(function(g, w, N) {
        return g + (N ? " " : "") + w.toLowerCase();
      }), w1 = Vp("toLowerCase");
      function bw(g, w, N) {
        g = Da(g), w = qr(w);
        var Z = w ? nc(g) : 0;
        if (!w || Z >= w)
          return g;
        var ae = (w - Z) / 2;
        return cn(nl(ae), N) + g + cn(Bo(ae), N);
      }
      function i_(g, w, N) {
        g = Da(g), w = qr(w);
        var Z = w ? nc(g) : 0;
        return w && Z < w ? g + cn(w - Z, N) : g;
      }
      function a_(g, w, N) {
        g = Da(g), w = qr(w);
        var Z = w ? nc(g) : 0;
        return w && Z < w ? cn(w - Z, N) + g : g;
      }
      function s_(g, w, N) {
        return N || w == null ? w = 0 : w && (w = +w), Jh(Da(g).replace(ji, ""), w || 0);
      }
      function E1(g, w, N) {
        return (N ? Vi(g, w, N) : w === t) ? w = 1 : w = qr(w), Nc(Da(g), w);
      }
      function o_() {
        var g = arguments, w = Da(g[0]);
        return g.length < 3 ? w : w.replace(g[1], g[2]);
      }
      var ww = y(function(g, w, N) {
        return g + (N ? "_" : "") + w.toLowerCase();
      });
      function l_(g, w, N) {
        return N && typeof N != "number" && Vi(g, w, N) && (w = N = t), N = N === t ? ye : N >>> 0, N ? (g = Da(g), g && (typeof w == "string" || w != null && !Py(w)) && (w = ia(w), !w && kd(g)) ? Ic(Na(g), 0, N) : g.split(w, N)) : [];
      }
      var Ew = y(function(g, w, N) {
        return g + (N ? " " : "") + tx(w);
      });
      function M1(g, w, N) {
        return g = Da(g), N = N == null ? 0 : Il(qr(N), 0, g.length), w = ia(w), g.slice(N, N + w.length) == w;
      }
      function Mw(g, w, N) {
        var Z = ve.templateSettings;
        N && Vi(g, w, N) && (w = t), g = Da(g), w = Nv({}, w, Z, Qe);
        var ae = Nv({}, w.imports, Z.imports, Qe), be = Ql(ae), ke = Za(ae, be), We, ut, tn = 0, Kt = w.interpolate || La, sn = "__p += '", Cn = Ui(
          (w.escape || La).source + "|" + Kt.source + "|" + (Kt === Vn ? yn : La).source + "|" + (w.evaluate || La).source + "|$",
          "g"
        ), Ln = "//# sourceURL=" + (xi.call(w, "sourceURL") ? (w.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++su + "]") + `
`;
        g.replace(Cn, function(kr, Fi, Ji, Hu, Vs, gc) {
          return Ji || (Ji = Hu), sn += g.slice(tn, gc).replace(Ys, gh), Fi && (We = !0, sn += `' +
__e(` + Fi + `) +
'`), Vs && (ut = !0, sn += `';
` + Vs + `;
__p += '`), Ji && (sn += `' +
((__t = (` + Ji + `)) == null ? '' : __t) +
'`), tn = gc + kr.length, kr;
        }), sn += `';
`;
        var dr = xi.call(w, "variable") && w.variable;
        if (!dr)
          sn = `with (obj) {
` + sn + `
}
`;
        else if (qe.test(dr))
          throw new Kn(d);
        sn = (ut ? sn.replace(Tt, "") : sn).replace(Ne, "$1").replace(Gt, "$1;"), sn = "function(" + (dr || "obj") + `) {
` + (dr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (We ? ", __e = _.escape" : "") + (ut ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + sn + `return __p
}`;
        var gi = f_(function() {
          return or(be, Ln + "return " + sn).apply(t, ke);
        });
        if (gi.source = sn, tm(gi))
          throw gi;
        return gi;
      }
      function Tw(g) {
        return Da(g).toLowerCase();
      }
      function T1(g) {
        return Da(g).toUpperCase();
      }
      function C1(g, w, N) {
        if (g = Da(g), g && (N || w === t))
          return ec(g);
        if (!g || !(w = ia(w)))
          return g;
        var Z = Na(g), ae = Na(w), be = ca(Z, ae), ke = Fd(Z, ae) + 1;
        return Ic(Z, be, ke).join("");
      }
      function zg(g, w, N) {
        if (g = Da(g), g && (N || w === t))
          return g.slice(0, Bd(g) + 1);
        if (!g || !(w = ia(w)))
          return g;
        var Z = Na(g), ae = Fd(Z, Na(w)) + 1;
        return Ic(Z, 0, ae).join("");
      }
      function Wy(g, w, N) {
        if (g = Da(g), g && (N || w === t))
          return g.replace(ji, "");
        if (!g || !(w = ia(w)))
          return g;
        var Z = Na(g), ae = ca(Z, Na(w));
        return Ic(Z, ae).join("");
      }
      function u_(g, w) {
        var N = ie, Z = pe;
        if (Hs(w)) {
          var ae = "separator" in w ? w.separator : ae;
          N = "length" in w ? qr(w.length) : N, Z = "omission" in w ? ia(w.omission) : Z;
        }
        g = Da(g);
        var be = g.length;
        if (kd(g)) {
          var ke = Na(g);
          be = ke.length;
        }
        if (N >= be)
          return g;
        var We = N - nc(Z);
        if (We < 1)
          return Z;
        var ut = ke ? Ic(ke, 0, We).join("") : g.slice(0, We);
        if (ae === t)
          return ut + Z;
        if (ke && (We += ut.length - We), Py(ae)) {
          if (g.slice(We).search(ae)) {
            var tn, Kt = ut;
            for (ae.global || (ae = Ui(ae.source, Da(Rn.exec(ae)) + "g")), ae.lastIndex = 0; tn = ae.exec(Kt); )
              var sn = tn.index;
            ut = ut.slice(0, sn === t ? We : sn);
          }
        } else if (g.indexOf(ia(ae), We) != We) {
          var Cn = ut.lastIndexOf(ae);
          Cn > -1 && (ut = ut.slice(0, Cn));
        }
        return ut + Z;
      }
      function Cw(g) {
        return g = Da(g), g && Gr.test(g) ? g.replace(Pt, ed) : g;
      }
      var c_ = y(function(g, w, N) {
        return g + (N ? " " : "") + w.toUpperCase();
      }), tx = Vp("toUpperCase");
      function jy(g, w, N) {
        return g = Da(g), w = N ? t : w, w === t ? Np(g) ? xh(g) : Lm(g) : g.match(w) || [];
      }
      var f_ = Sr(function(g, w) {
        try {
          return Jr(g, t, w);
        } catch (N) {
          return tm(N) ? N : new Kn(N);
        }
      }), R1 = Ar(function(g, w) {
        return va(w, function(N) {
          N = ql(N), Us(g, N, un(g[N], g));
        }), g;
      });
      function d_(g) {
        var w = g == null ? 0 : g.length, N = gr();
        return g = w ? qi(g, function(Z) {
          if (typeof Z[1] != "function")
            throw new Io(l);
          return [N(Z[0]), Z[1]];
        }) : [], Sr(function(Z) {
          for (var ae = -1; ++ae < w; ) {
            var be = g[ae];
            if (Jr(be[0], this, Z))
              return Jr(be[1], this, Z);
          }
        });
      }
      function h_(g) {
        return jd(Vo(g, _));
      }
      function nx(g) {
        return function() {
          return g;
        };
      }
      function rx(g, w) {
        return g == null || g !== g ? w : g;
      }
      var Rw = q(), A1 = q(!0);
      function Bf(g) {
        return g;
      }
      function ix(g) {
        return ld(typeof g == "function" ? g : Vo(g, _));
      }
      function Aw(g) {
        return Mf(Vo(g, _));
      }
      function Dw(g, w) {
        return Vl(g, Vo(w, _));
      }
      var Lw = Sr(function(g, w) {
        return function(N) {
          return Sa(N, g, w);
        };
      }), Pw = Sr(function(g, w) {
        return function(N) {
          return Sa(g, N, w);
        };
      });
      function ax(g, w, N) {
        var Z = Ql(w), ae = Qi(w, Z);
        N == null && !(Hs(w) && (ae.length || !Z.length)) && (N = w, w = g, g = this, ae = Qi(w, Ql(w)));
        var be = !(Hs(N) && "chain" in N) || !!N.chain, ke = yp(g);
        return va(ae, function(We) {
          var ut = w[We];
          g[We] = ut, ke && (g.prototype[We] = function() {
            var tn = this.__chain__;
            if (be || tn) {
              var Kt = g(this.__wrapped__), sn = Kt.__actions__ = Ms(this.__actions__);
              return sn.push({ func: ut, args: arguments, thisArg: g }), Kt.__chain__ = tn, Kt;
            }
            return ut.apply(g, Cu([this.value()], arguments));
          });
        }), g;
      }
      function Ow() {
        return Ki._ === this && (Ki._ = Sh), this;
      }
      function Yy() {
      }
      function D1(g) {
        return g = qr(g), Sr(function(w) {
          return Wl(w, g);
        });
      }
      var L1 = kt(qi), p_ = kt(Zf), Uw = kt(Zh);
      function Ng(g) {
        return _v(g) ? hl(ql(g)) : Yr(g);
      }
      function Xy(g) {
        return function(w) {
          return g == null ? t : ya(g, w);
        };
      }
      var sx = wr(), sm = wr(!0);
      function P1() {
        return [];
      }
      function qy() {
        return !1;
      }
      function zw() {
        return {};
      }
      function m_() {
        return "";
      }
      function Nw() {
        return !0;
      }
      function O1(g, w) {
        if (g = qr(g), g < 1 || g > he)
          return [];
        var N = ye, Z = Qs(g, ye);
        w = gr(w), g -= ye;
        for (var ae = mf(Z, w); ++N < g; )
          w(N);
        return ae;
      }
      function v_(g) {
        return ei(g) ? qi(g, ql) : Ni(g) ? [g] : Ms(pg(Da(g)));
      }
      function g_(g) {
        var w = ++Ec;
        return Da(g) + w;
      }
      var U1 = Ke(function(g, w) {
        return g + w;
      }, 0), Fw = Tn("ceil"), Qy = Ke(function(g, w) {
        return g / w;
      }, 1), ox = Tn("floor");
      function kw(g) {
        return g && g.length ? Bl(g, Bf, Wo) : t;
      }
      function y_(g, w) {
        return g && g.length ? Bl(g, gr(w, 2), Wo) : t;
      }
      function Iw(g) {
        return zp(g, Bf);
      }
      function x_(g, w) {
        return zp(g, gr(w, 2));
      }
      function S_(g) {
        return g && g.length ? Bl(g, Bf, Ef) : t;
      }
      function lx(g, w) {
        return g && g.length ? Bl(g, gr(w, 2), Ef) : t;
      }
      var ev = Ke(function(g, w) {
        return g * w;
      }, 1), Bw = Tn("round"), In = Ke(function(g, w) {
        return g - w;
      }, 0);
      function Fg(g) {
        return g && g.length ? lu(g, Bf) : 0;
      }
      function Uh(g, w) {
        return g && g.length ? lu(g, gr(w, 2)) : 0;
      }
      return ve.after = Le, ve.ary = Ve, ve.assign = kf, ve.assignIn = Rg, ve.assignInWith = Nv, ve.assignWith = rm, ve.at = h1, ve.before = Ct, ve.bind = un, ve.bindAll = R1, ve.bindKey = ln, ve.castArray = Mg, ve.chain = _l, ve.chunk = mg, ve.compact = wv, ve.concat = Ch, ve.cond = d_, ve.conforms = h_, ve.constant = nx, ve.countBy = bl, ve.create = im, ve.curry = nn, ve.curryRight = kn, ve.debounce = qn, ve.defaults = Jm, ve.defaultsDeep = Fv, ve.defer = rr, ve.delay = Bs, ve.difference = aa, ve.differenceBy = Nr, ve.differenceWith = ea, ve.drop = Ga, ve.dropRight = vs, ve.dropRightWhile = Hc, ve.dropWhile = Hm, ve.fill = sl, ve.filter = bg, ve.flatMap = Iu, ve.flatMapDeep = Pv, ve.flatMapDepth = Kp, ve.flatten = Gm, ve.flattenDeep = sp, ve.flattenDepth = op, ve.flip = ht, ve.flow = Rw, ve.flowRight = A1, ve.fromPairs = gu, ve.functions = t_, ve.functionsIn = p1, ve.groupBy = Cs, ve.initial = gd, ve.intersection = vg, ve.intersectionBy = qp, ve.intersectionWith = Kd, ve.invert = v1, ve.invertBy = xw, ve.invokeMap = $p, ve.iteratee = ix, ve.keyBy = qm, ve.keys = Ql, ve.keysIn = Xc, ve.map = gp, ve.mapKeys = Sw, ve.mapValues = _w, ve.matches = Aw, ve.matchesProperty = Dw, ve.memoize = Ze, ve.merge = Sp, ve.mergeWith = g1, ve.method = Lw, ve.methodOf = Pw, ve.mixin = ax, ve.negate = gt, ve.nthArg = D1, ve.omit = n_, ve.omitBy = ky, ve.once = xn, ve.orderBy = wg, ve.over = L1, ve.overArgs = ar, ve.overEvery = p_, ve.overSome = Uw, ve.partial = Qn, ve.partialRight = pr, ve.partition = u1, ve.pick = Iy, ve.pickBy = By, ve.property = Ng, ve.propertyOf = Xy, ve.pull = Ev, ve.pullAll = Vc, ve.pullAllBy = fp, ve.pullAllWith = ha, ve.pullAt = ro, ve.range = sx, ve.rangeRight = sm, ve.rearg = Lr, ve.reject = yd, ve.remove = Sl, ve.rest = ol, ve.reverse = Zo, ve.sampleSize = p, ve.set = $0, ve.setWith = kv, ve.shuffle = E, ve.slice = dp, ve.sortBy = Q, ve.sortedUniq = Ah, ve.sortedUniqBy = yg, ve.split = l_, ve.spread = Zi, ve.tail = zf, ve.take = wy, ve.takeRight = xg, ve.takeRightWhile = Ey, ve.takeWhile = hp, ve.tap = Av, ve.throttle = Ff, ve.thru = _g, ve.toArray = _d, ve.toPairs = wl, ve.toPairsIn = y1, ve.toPath = v_, ve.toPlainObject = zy, ve.transform = am, ve.unary = Eg, ve.union = pp, ve.unionBy = Cv, ve.unionWith = Rv, ve.uniq = Ym, ve.uniqBy = Dh, ve.uniqWith = My, ve.unset = qc, ve.unzip = Gc, ve.unzipWith = Zp, ve.update = x1, ve.updateWith = Pg, ve.values = $m, ve.valuesIn = S1, ve.without = Is, ve.words = jy, ve.wrap = k0, ve.xor = Ty, ve.xorBy = Sg, ve.xorWith = N0, ve.zip = F0, ve.zipObject = Xm, ve.zipObjectDeep = Wc, ve.zipWith = Cy, ve.entries = wl, ve.entriesIn = y1, ve.extend = Rg, ve.extendWith = Nv, ax(ve, ve), ve.add = U1, ve.attempt = f_, ve.camelCase = Hy, ve.capitalize = Zl, ve.ceil = Fw, ve.clamp = ex, ve.clone = I0, ve.cloneDeep = Ry, ve.cloneDeepWith = Ay, ve.cloneWith = B0, ve.conformsTo = Ov, ve.deburr = Vy, ve.defaultTo = rx, ve.divide = Qy, ve.endsWith = Gy, ve.eq = Bu, ve.escape = Og, ve.escapeRegExp = Ug, ve.every = Dv, ve.find = Lv, ve.findIndex = Vm, ve.findKey = If, ve.findLast = On, ve.findLastIndex = vd, ve.findLastKey = Ag, ve.floor = ox, ve.forEach = Ph, ve.forEachRight = sa, ve.forIn = vc, ve.forInRight = J0, ve.forOwn = Dg, ve.forOwnRight = Ny, ve.get = m1, ve.gt = c1, ve.gte = H0, ve.has = Fy, ve.hasIn = Km, ve.head = Wm, ve.identity = Bf, ve.includes = Co, ve.indexOf = lp, ve.inRange = Iv, ve.invoke = K0, ve.isArguments = em, ve.isArray = ei, ve.isArrayBuffer = KS, ve.isArrayLike = ll, ve.isArrayLikeObject = Rs, ve.isBoolean = Dy, ve.isBuffer = xd, ve.isDate = f1, ve.isElement = V0, ve.isEmpty = G0, ve.isEqual = W0, ve.isEqualWith = Tg, ve.isError = tm, ve.isFinite = j0, ve.isFunction = yp, ve.isInteger = Uv, ve.isLength = Cg, ve.isMap = d1, ve.isMatch = Y0, ve.isMatchWith = Ly, ve.isNaN = Qm, ve.isNative = yw, ve.isNil = e_, ve.isNull = $S, ve.isNumber = zv, ve.isObject = Hs, ve.isObjectLike = io, ve.isPlainObject = Zm, ve.isRegExp = Py, ve.isSafeInteger = X0, ve.isSet = q0, ve.isString = Oy, ve.isSymbol = Ni, ve.isTypedArray = nm, ve.isUndefined = Sd, ve.isWeakMap = jc, ve.isWeakSet = Uy, ve.join = up, ve.kebabCase = r_, ve.last = Qo, ve.lastIndexOf = cp, ve.lowerCase = b1, ve.lowerFirst = w1, ve.lt = Q0, ve.lte = Fr, ve.max = kw, ve.maxBy = y_, ve.mean = Iw, ve.meanBy = x_, ve.min = S_, ve.minBy = lx, ve.stubArray = P1, ve.stubFalse = qy, ve.stubObject = zw, ve.stubString = m_, ve.stubTrue = Nw, ve.multiply = ev, ve.nth = jm, ve.noConflict = Ow, ve.noop = Yy, ve.now = le, ve.pad = bw, ve.padEnd = i_, ve.padStart = a_, ve.parseInt = s_, ve.random = _1, ve.reduce = Wt, ve.reduceRight = Nf, ve.repeat = E1, ve.replace = o_, ve.result = Lg, ve.round = Bw, ve.runInContext = Ye, ve.sample = c, ve.size = O, ve.snakeCase = ww, ve.some = G, ve.sortedIndex = Mv, ve.sortedIndexBy = Qp, ve.sortedIndexOf = gg, ve.sortedLastIndex = yu, ve.sortedLastIndexBy = Tv, ve.sortedLastIndexOf = Rh, ve.startCase = Ew, ve.startsWith = M1, ve.subtract = In, ve.sum = Fg, ve.sumBy = Uh, ve.template = Mw, ve.times = O1, ve.toFinite = xp, ve.toInteger = qr, ve.toLength = Oh, ve.toLower = Tw, ve.toNumber = Yc, ve.toSafeInteger = Z0, ve.toString = Da, ve.toUpper = T1, ve.trim = C1, ve.trimEnd = zg, ve.trimStart = Wy, ve.truncate = u_, ve.unescape = Cw, ve.uniqueId = g_, ve.upperCase = c_, ve.upperFirst = tx, ve.each = Ph, ve.eachRight = sa, ve.first = Wm, ax(ve, function() {
        var g = {};
        return Hi(ve, function(w, N) {
          xi.call(ve.prototype, N) || (g[N] = w);
        }), g;
      }(), { chain: !1 }), ve.VERSION = r, va(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(g) {
        ve[g].placeholder = ve;
      }), va(["drop", "take"], function(g, w) {
        Hn.prototype[g] = function(N) {
          N = N === t ? 1 : ds(qr(N), 0);
          var Z = this.__filtered__ && !w ? new Hn(this) : this.clone();
          return Z.__filtered__ ? Z.__takeCount__ = Qs(N, Z.__takeCount__) : Z.__views__.push({
            size: Qs(N, ye),
            type: g + (Z.__dir__ < 0 ? "Right" : "")
          }), Z;
        }, Hn.prototype[g + "Right"] = function(N) {
          return this.reverse()[g](N).reverse();
        };
      }), va(["filter", "map", "takeWhile"], function(g, w) {
        var N = w + 1, Z = N == de || N == Ce;
        Hn.prototype[g] = function(ae) {
          var be = this.clone();
          return be.__iteratees__.push({
            iteratee: gr(ae, 3),
            type: N
          }), be.__filtered__ = be.__filtered__ || Z, be;
        };
      }), va(["head", "last"], function(g, w) {
        var N = "take" + (w ? "Right" : "");
        Hn.prototype[g] = function() {
          return this[N](1).value()[0];
        };
      }), va(["initial", "tail"], function(g, w) {
        var N = "drop" + (w ? "" : "Right");
        Hn.prototype[g] = function() {
          return this.__filtered__ ? new Hn(this) : this[N](1);
        };
      }), Hn.prototype.compact = function() {
        return this.filter(Bf);
      }, Hn.prototype.find = function(g) {
        return this.filter(g).head();
      }, Hn.prototype.findLast = function(g) {
        return this.reverse().find(g);
      }, Hn.prototype.invokeMap = Sr(function(g, w) {
        return typeof g == "function" ? new Hn(this) : this.map(function(N) {
          return Sa(N, g, w);
        });
      }), Hn.prototype.reject = function(g) {
        return this.filter(gt(gr(g)));
      }, Hn.prototype.slice = function(g, w) {
        g = qr(g);
        var N = this;
        return N.__filtered__ && (g > 0 || w < 0) ? new Hn(N) : (g < 0 ? N = N.takeRight(-g) : g && (N = N.drop(g)), w !== t && (w = qr(w), N = w < 0 ? N.dropRight(-w) : N.take(w - g)), N);
      }, Hn.prototype.takeRightWhile = function(g) {
        return this.reverse().takeWhile(g).reverse();
      }, Hn.prototype.toArray = function() {
        return this.take(ye);
      }, Hi(Hn.prototype, function(g, w) {
        var N = /^(?:filter|find|map|reject)|While$/.test(w), Z = /^(?:head|last)$/.test(w), ae = ve[Z ? "take" + (w == "last" ? "Right" : "") : w], be = Z || /^find/.test(w);
        !ae || (ve.prototype[w] = function() {
          var ke = this.__wrapped__, We = Z ? [1] : arguments, ut = ke instanceof Hn, tn = We[0], Kt = ut || ei(ke), sn = function(Fi) {
            var Ji = ae.apply(ve, Cu([Fi], We));
            return Z && Cn ? Ji[0] : Ji;
          };
          Kt && N && typeof tn == "function" && tn.length != 1 && (ut = Kt = !1);
          var Cn = this.__chain__, Ln = !!this.__actions__.length, dr = be && !Cn, gi = ut && !Ln;
          if (!be && Kt) {
            ke = gi ? ke : new Hn(this);
            var kr = g.apply(ke, We);
            return kr.__actions__.push({ func: _g, args: [sn], thisArg: t }), new ka(kr, Cn);
          }
          return dr && gi ? g.apply(this, We) : (kr = this.thru(sn), dr ? Z ? kr.value()[0] : kr.value() : kr);
        });
      }), va(["pop", "push", "shift", "sort", "splice", "unshift"], function(g) {
        var w = fs[g], N = /^(?:push|sort|unshift)$/.test(g) ? "tap" : "thru", Z = /^(?:pop|shift)$/.test(g);
        ve.prototype[g] = function() {
          var ae = arguments;
          if (Z && !this.__chain__) {
            var be = this.value();
            return w.apply(ei(be) ? be : [], ae);
          }
          return this[N](function(ke) {
            return w.apply(ei(ke) ? ke : [], ae);
          });
        };
      }), Hi(Hn.prototype, function(g, w) {
        var N = ve[w];
        if (N) {
          var Z = N.name + "";
          xi.call(id, Z) || (id[Z] = []), id[Z].push({ name: w, func: N });
        }
      }), id[te(t, B).name] = [{
        name: "wrapper",
        func: t
      }], Hn.prototype.clone = vr, Hn.prototype.reverse = Bi, Hn.prototype.value = oi, ve.prototype.at = ku, ve.prototype.chain = Lh, ve.prototype.commit = Jp, ve.prototype.next = mp, ve.prototype.plant = Aa, ve.prototype.reverse = vp, ve.prototype.toJSON = ve.prototype.valueOf = ve.prototype.value = Ts, ve.prototype.first = ve.prototype.head, ic && (ve.prototype[ic] = mc), ve;
    }, ko = Ip();
    Oa ? ((Oa.exports = ko)._ = ko, Mu._ = ko) : Ki._ = ko;
  }).call(A0);
})(ly, ly.exports);
const EX = ly.exports, MX = (a) => (e, t, r) => a(
  (i, o) => {
    const l = typeof i == "function" ? _X(i) : i;
    return e(l, o);
  },
  t,
  r
), TX = (a, e) => ({
  clock: new bX(),
  items: {},
  tfs: {},
  hulls: {},
  lines: {},
  texts: {},
  onMove: (t, r, i, o) => a((l) => {
    console.log(o), l[r][t].position = { ...o.position }, l[r][t].rotation = o.quaternion, l[r][t].rotation.x = o.quaternion.x, l[r][t].rotation.y = o.quaternion.y, l[r][t].rotation.z = o.quaternion.z, l[r][t].rotation.w = o.quaternion.w, l[r][t].scale = { ...o.scale };
  }),
  onClick: (t, r, i) => {
    r || console.log(`id: ${t} clicked!`), e().items[t] && !r && i.stopPropagation();
  },
  onPointerOver: (t, r, i) => {
  },
  onPointerOut: (t, r, i) => {
  },
  pause: () => a((t) => {
    t.clock.setTimescale(0);
  }),
  play: (t) => a((r) => {
    r.clock.setTimescale(t || 1);
  }),
  reset: (t) => a((r) => {
    console.log(`setting time to ${t}`), r.clock._elapsed = t ? t * 1e3 : 0;
  }),
  clearItems: () => a((t) => ({ items: {} })),
  clearLines: () => a((t) => ({ lines: {} })),
  clearTfs: () => a((t) => ({ tfs: {} })),
  clearHulls: () => a((t) => ({ hulls: {} })),
  clearTexts: () => a((t) => ({ texts: {} })),
  setItems: (t) => a((r) => ({ items: t })),
  setLines: (t) => a((r) => ({ lines: t })),
  setTfs: (t) => a((r) => ({ tfs: t })),
  setHulls: (t) => a((r) => ({ hulls: t })),
  setTexts: (t) => a((r) => ({ texts: t })),
  removeItem: (t) => a((r) => {
    delete r.items[t];
  }),
  removeLine: (t) => a((r) => {
    delete r.lines[t];
  }),
  removeTf: (t) => a((r) => {
    delete r.tfs[t];
  }),
  removeHull: (t) => a((r) => {
    delete r.hulls[t];
  }),
  removeText: (t) => a((r) => {
    delete r.texts[t];
  }),
  setItem: (t, r) => a((i) => {
    i.items[t] = r;
  }),
  setLine: (t, r) => a((i) => {
    i.lines[t] = r;
  }),
  setTf: (t, r) => a((i) => {
    i.tfs[t] = r;
  }),
  setHull: (t, r) => a((i) => {
    i.hulls[t] = r;
  }),
  setText: (t, r) => a((i) => {
    i.texts[t] = r;
  }),
  setProperty: (t, r) => a((i) => {
    EX.set(i, t, r);
  })
}), CX = MX(oX(TX)), RX = aX(CX), lk = OC(), ho = (a, e) => {
  const t = MM(lk);
  return ak(t, a, e);
}, AX = ({
  store: a,
  children: e,
  debug: t = !1
}) => (t && console.log("SceneProvider regenerated"), /* @__PURE__ */ _n(lk.Provider, {
  value: a || RX,
  children: e
})), DX = hh.forwardRef((a, e) => /* @__PURE__ */ _n("ambientLight", {
  ref: e,
  ...a
}));
hh.forwardRef((a, e) => /* @__PURE__ */ _n("pointLight", {
  ref: e,
  ...a
}));
const LX = hh.forwardRef((a, e) => /* @__PURE__ */ _n("directionalLight", {
  ref: e,
  ...a
})), hy = (a, e, t, r) => {
  var i = new Pn();
  return i.setRGB(a / 255, e / 255, t / 255), r <= 0.99 ? new BM({
    color: i.getHex(),
    opacity: r + 0.1,
    transparent: !0,
    depthWrite: !0,
    blendSrc: UC,
    blendDst: zC,
    blendEquation: V3,
    blending: L0
  }) : new BM({
    color: i.getHex(),
    opacity: r,
    blending: L0
  });
}, xC = ly.exports.memoize((a) => {
  var e = new Pn(a), t = `
		varying vec3	vVertexWorldPosition;
		varying vec3	vVertexNormal;

		// varying vec4	vFragColor;

		void main(){
			vVertexNormal	= normalize(normalMatrix * normal);

			vVertexWorldPosition	= (modelMatrix * vec4(position, 1.0)).xyz;

			// set gl_Position
			gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}`, r = `
		uniform vec3	glowColor;
		uniform float	coeficient;
		uniform float	power;

		varying vec3	vVertexNormal;
		varying vec3	vVertexWorldPosition;

		// varying vec4	vFragColor;

		void main(){
			vec3 worldCameraToVertex= vVertexWorldPosition - cameraPosition;
			vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
			viewCameraToVertex	= normalize(viewCameraToVertex);
			float intensity		= pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);
			gl_FragColor		= vec4(glowColor, intensity);
		}`, i = new wu({
    uniforms: {
      coeficient: {
        type: "f",
        value: 1.2
      },
      power: {
        type: "f",
        value: 4
      },
      glowColor: {
        type: "c",
        value: e
      }
    },
    vertexShader: t,
    fragmentShader: r,
    blending: _C,
    transparent: !0,
    depthWrite: !1,
    depthTest: !1
  });
  return i;
});
function PX(a) {
  var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  a = a.replace(e, function(r, i, o, l) {
    return i + i + o + o + l + l;
  });
  var t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
  return t ? {
    r: parseInt(t[1], 16),
    g: parseInt(t[2], 16),
    b: parseInt(t[3], 16)
  } : null;
}
const wS = new _L(), Lp = new ge(), qx = new ge(), Cl = new Ko(), uN = {
  X: new ge(1, 0, 0),
  Y: new ge(0, 1, 0),
  Z: new ge(0, 0, 1)
}, UD = { type: "change" }, cN = { type: "mouseDown" }, fN = { type: "mouseUp", mode: null }, dN = { type: "objectChange" };
class OX extends Xa {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const r = new IX();
    this._gizmo = r, this.add(r);
    const i = new BX();
    this._plane = i, this.add(i);
    const o = this;
    function l(k, V) {
      let I = V;
      Object.defineProperty(o, k, {
        get: function() {
          return I !== void 0 ? I : V;
        },
        set: function(X) {
          I !== X && (I = X, i[k] = X, r[k] = X, o.dispatchEvent({ type: k + "-changed", value: X }), o.dispatchEvent(UD));
        }
      }), o[k] = V, i[k] = V, r[k] = V;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0);
    const d = new ge(), h = new ge(), m = new Ko(), S = new Ko(), _ = new ge(), T = new Ko(), C = new ge(), D = new ge(), P = new ge(), U = 0, B = new ge();
    l("worldPosition", d), l("worldPositionStart", h), l("worldQuaternion", m), l("worldQuaternionStart", S), l("cameraPosition", _), l("cameraQuaternion", T), l("pointStart", C), l("pointEnd", D), l("rotationAxis", P), l("rotationAngle", U), l("eye", B), this._offset = new ge(), this._startNorm = new ge(), this._endNorm = new ge(), this._cameraScale = new ge(), this._parentPosition = new ge(), this._parentQuaternion = new Ko(), this._parentQuaternionInv = new Ko(), this._parentScale = new ge(), this._worldScaleStart = new ge(), this._worldQuaternionInv = new Ko(), this._worldScale = new ge(), this._positionStart = new ge(), this._quaternionStart = new Ko(), this._scaleStart = new ge(), this._getPointer = UX.bind(this), this._onPointerDown = NX.bind(this), this._onPointerHover = zX.bind(this), this._onPointerMove = FX.bind(this), this._onPointerUp = kX.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    wS.setFromCamera(e, this.camera);
    const t = zD(this._gizmo.picker[this.mode], wS);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      wS.setFromCamera(e, this.camera);
      const t = zD(this._plane, wS, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, cN.mode = this.mode, this.dispatchEvent(cN);
    }
  }
  pointerMove(e) {
    const t = this.axis, r = this.mode, i = this.object;
    let o = this.space;
    if (r === "scale" ? o = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (o = "world"), i === void 0 || t === null || this.dragging === !1 || e.button !== -1)
      return;
    wS.setFromCamera(e, this.camera);
    const l = zD(this._plane, wS, !0);
    if (!!l) {
      if (this.pointEnd.copy(l.point).sub(this.worldPositionStart), r === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (i.position.applyQuaternion(Cl.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), o === "world" && (i.parent && i.position.add(Lp.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(Lp.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (r === "scale") {
        if (t.search("XYZ") !== -1) {
          let d = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (d *= -1), qx.set(d, d, d);
        } else
          Lp.copy(this.pointStart), qx.copy(this.pointEnd), Lp.applyQuaternion(this._worldQuaternionInv), qx.applyQuaternion(this._worldQuaternionInv), qx.divide(Lp), t.search("X") === -1 && (qx.x = 1), t.search("Y") === -1 && (qx.y = 1), t.search("Z") === -1 && (qx.z = 1);
        i.scale.copy(this._scaleStart).multiply(qx), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (r === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const d = 20 / this.worldPosition.distanceTo(Lp.setFromMatrixPosition(this.camera.matrixWorld));
        t === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Lp.copy(this.rotationAxis).cross(this.eye)) * d) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(uN[t]), Lp.copy(uN[t]), o === "local" && Lp.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(Lp.cross(this.eye).normalize()) * d), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(Cl.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(Cl.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(UD), this.dispatchEvent(dN);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (fN.mode = this.mode, this.dispatchEvent(fN)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    !this.enabled || this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(UD), this.dispatchEvent(dN), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return wS;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
  update() {
    console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
  }
}
function UX(a) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: a.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (a.clientX - e.left) / e.width * 2 - 1,
      y: -(a.clientY - e.top) / e.height * 2 + 1,
      button: a.button
    };
  }
}
function zX(a) {
  if (!!this.enabled)
    switch (a.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(a));
        break;
    }
}
function NX(a) {
  !this.enabled || (document.pointerLockElement || this.domElement.setPointerCapture(a.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(a)), this.pointerDown(this._getPointer(a)));
}
function FX(a) {
  !this.enabled || this.pointerMove(this._getPointer(a));
}
function kX(a) {
  !this.enabled || (this.domElement.releasePointerCapture(a.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(a)));
}
function zD(a, e, t) {
  const r = e.intersectObject(a, !0);
  for (let i = 0; i < r.length; i++)
    if (r[i].object.visible || t)
      return r[i];
  return !1;
}
const aC = new QS(), Lo = new ge(0, 1, 0), hN = new ge(0, 0, 0), pN = new si(), sC = new Ko(), SC = new Ko(), ay = new ge(), mN = new si(), vM = new ge(1, 0, 0), RS = new ge(0, 1, 0), gM = new ge(0, 0, 1), oC = new ge(), uM = new ge(), cM = new ge();
class IX extends Xa {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new og({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new ph({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), r = e.clone();
    r.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const l = e.clone();
    l.color.setHex(65280);
    const d = e.clone();
    d.color.setHex(255);
    const h = e.clone();
    h.color.setHex(16711680), h.opacity = 0.5;
    const m = e.clone();
    m.color.setHex(65280), m.opacity = 0.5;
    const S = e.clone();
    S.color.setHex(255), S.opacity = 0.5;
    const _ = e.clone();
    _.opacity = 0.25;
    const T = e.clone();
    T.color.setHex(16776960), T.opacity = 0.25, e.clone().color.setHex(16776960);
    const D = e.clone();
    D.color.setHex(7895160);
    const P = new Jo(0, 0.04, 0.1, 12);
    P.translate(0, 0.05, 0);
    const U = new cl(0.08, 0.08, 0.08);
    U.translate(0, 0.04, 0);
    const B = new ui();
    B.setAttribute("position", new sr([0, 0, 0, 1, 0, 0], 3));
    const k = new Jo(75e-4, 75e-4, 0.5, 3);
    k.translate(0, 0.25, 0);
    function V(Fe, Ce) {
      const Be = new tg(Fe, 75e-4, 3, 64, Ce * Math.PI * 2);
      return Be.rotateY(Math.PI / 2), Be.rotateX(Math.PI / 2), Be;
    }
    function I() {
      const Fe = new ui();
      return Fe.setAttribute("position", new sr([0, 0, 0, 1, 1, 1], 3)), Fe;
    }
    const X = {
      X: [
        [new zn(P, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new zn(P, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new zn(k, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new zn(P, l), [0, 0.5, 0]],
        [new zn(P, l), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new zn(k, l)]
      ],
      Z: [
        [new zn(P, d), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new zn(P, d), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new zn(k, d), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new zn(new ng(0.1, 0), _.clone()), [0, 0, 0]]
      ],
      XY: [
        [new zn(new cl(0.15, 0.15, 0.01), S.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new zn(new cl(0.15, 0.15, 0.01), h.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new zn(new cl(0.15, 0.15, 0.01), m.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, J = {
      X: [
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new zn(new ng(0.2, 0), r)]
      ],
      XY: [
        [new zn(new cl(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new zn(new cl(0.2, 0.2, 0.01), r), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new zn(new cl(0.2, 0.2, 0.01), r), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, $ = {
      START: [
        [new zn(new ng(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new zn(new ng(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new ch(I(), i), null, null, null, "helper"]
      ],
      X: [
        [new ch(B, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new ch(B, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new ch(B, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, W = {
      XYZE: [
        [new zn(V(0.5, 1), D), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new zn(V(0.5, 0.5), o)]
      ],
      Y: [
        [new zn(V(0.5, 0.5), l), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new zn(V(0.5, 0.5), d), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new zn(V(0.75, 1), T), null, [0, Math.PI / 2, 0]]
      ]
    }, ee = {
      AXIS: [
        [new ch(B, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, ie = {
      XYZE: [
        [new zn(new ag(0.25, 10, 8), r)]
      ],
      X: [
        [new zn(new tg(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new zn(new tg(0.5, 0.1, 4, 24), r), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new zn(new tg(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new zn(new tg(0.75, 0.1, 2, 24), r)]
      ]
    }, pe = {
      X: [
        [new zn(U, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new zn(k, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new zn(U, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new zn(U, l), [0, 0.5, 0]],
        [new zn(k, l)],
        [new zn(U, l), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new zn(U, d), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new zn(k, d), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new zn(U, d), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new zn(new cl(0.15, 0.15, 0.01), S), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new zn(new cl(0.15, 0.15, 0.01), h), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new zn(new cl(0.15, 0.15, 0.01), m), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new zn(new cl(0.1, 0.1, 0.1), _.clone())]
      ]
    }, ce = {
      X: [
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new zn(new Jo(0.2, 0, 0.6, 4), r), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new zn(new cl(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new zn(new cl(0.2, 0.2, 0.01), r), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new zn(new cl(0.2, 0.2, 0.01), r), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new zn(new cl(0.2, 0.2, 0.2), r), [0, 0, 0]]
      ]
    }, Ee = {
      X: [
        [new ch(B, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new ch(B, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new ch(B, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function de(Fe) {
      const Ce = new Xa();
      for (const Be in Fe)
        for (let he = Fe[Be].length; he--; ) {
          const fe = Fe[Be][he][0].clone(), ue = Fe[Be][he][1], ye = Fe[Be][he][2], we = Fe[Be][he][3], Xe = Fe[Be][he][4];
          fe.name = Be, fe.tag = Xe, ue && fe.position.set(ue[0], ue[1], ue[2]), ye && fe.rotation.set(ye[0], ye[1], ye[2]), we && fe.scale.set(we[0], we[1], we[2]), fe.updateMatrix();
          const Je = fe.geometry.clone();
          Je.applyMatrix4(fe.matrix), fe.geometry = Je, fe.renderOrder = 1 / 0, fe.position.set(0, 0, 0), fe.rotation.set(0, 0, 0), fe.scale.set(1, 1, 1), Ce.add(fe);
        }
      return Ce;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = de(X)), this.add(this.gizmo.rotate = de(W)), this.add(this.gizmo.scale = de(pe)), this.add(this.picker.translate = de(J)), this.add(this.picker.rotate = de(ie)), this.add(this.picker.scale = de(ce)), this.add(this.helper.translate = de($)), this.add(this.helper.rotate = de(ee)), this.add(this.helper.scale = de(Ee)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  updateMatrixWorld(e) {
    const r = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : SC;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let o = 0; o < i.length; o++) {
      const l = i[o];
      l.visible = !0, l.rotation.set(0, 0, 0), l.position.copy(this.worldPosition);
      let d;
      if (this.camera.isOrthographicCamera ? d = (this.camera.top - this.camera.bottom) / this.camera.zoom : d = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), l.scale.set(1, 1, 1).multiplyScalar(d * this.size / 4), l.tag === "helper") {
        l.visible = !1, l.name === "AXIS" ? (l.position.copy(this.worldPositionStart), l.visible = !!this.axis, this.axis === "X" && (Cl.setFromEuler(aC.set(0, 0, 0)), l.quaternion.copy(r).multiply(Cl), Math.abs(Lo.copy(vM).applyQuaternion(r).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "Y" && (Cl.setFromEuler(aC.set(0, 0, Math.PI / 2)), l.quaternion.copy(r).multiply(Cl), Math.abs(Lo.copy(RS).applyQuaternion(r).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "Z" && (Cl.setFromEuler(aC.set(0, Math.PI / 2, 0)), l.quaternion.copy(r).multiply(Cl), Math.abs(Lo.copy(gM).applyQuaternion(r).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "XYZE" && (Cl.setFromEuler(aC.set(0, Math.PI / 2, 0)), Lo.copy(this.rotationAxis), l.quaternion.setFromRotationMatrix(pN.lookAt(hN, Lo, RS)), l.quaternion.multiply(Cl), l.visible = this.dragging), this.axis === "E" && (l.visible = !1)) : l.name === "START" ? (l.position.copy(this.worldPositionStart), l.visible = this.dragging) : l.name === "END" ? (l.position.copy(this.worldPosition), l.visible = this.dragging) : l.name === "DELTA" ? (l.position.copy(this.worldPositionStart), l.quaternion.copy(this.worldQuaternionStart), Lp.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Lp.applyQuaternion(this.worldQuaternionStart.clone().invert()), l.scale.copy(Lp), l.visible = this.dragging) : (l.quaternion.copy(r), this.dragging ? l.position.copy(this.worldPositionStart) : l.position.copy(this.worldPosition), this.axis && (l.visible = this.axis.search(l.name) !== -1));
        continue;
      }
      l.quaternion.copy(r), this.mode === "translate" || this.mode === "scale" ? (l.name === "X" && Math.abs(Lo.copy(vM).applyQuaternion(r).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "Y" && Math.abs(Lo.copy(RS).applyQuaternion(r).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "Z" && Math.abs(Lo.copy(gM).applyQuaternion(r).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "XY" && Math.abs(Lo.copy(gM).applyQuaternion(r).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "YZ" && Math.abs(Lo.copy(vM).applyQuaternion(r).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "XZ" && Math.abs(Lo.copy(RS).applyQuaternion(r).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1)) : this.mode === "rotate" && (sC.copy(r), Lo.copy(this.eye).applyQuaternion(Cl.copy(r).invert()), l.name.search("E") !== -1 && l.quaternion.setFromRotationMatrix(pN.lookAt(this.eye, hN, RS)), l.name === "X" && (Cl.setFromAxisAngle(vM, Math.atan2(-Lo.y, Lo.z)), Cl.multiplyQuaternions(sC, Cl), l.quaternion.copy(Cl)), l.name === "Y" && (Cl.setFromAxisAngle(RS, Math.atan2(Lo.x, Lo.z)), Cl.multiplyQuaternions(sC, Cl), l.quaternion.copy(Cl)), l.name === "Z" && (Cl.setFromAxisAngle(gM, Math.atan2(Lo.y, Lo.x)), Cl.multiplyQuaternions(sC, Cl), l.quaternion.copy(Cl))), l.visible = l.visible && (l.name.indexOf("X") === -1 || this.showX), l.visible = l.visible && (l.name.indexOf("Y") === -1 || this.showY), l.visible = l.visible && (l.name.indexOf("Z") === -1 || this.showZ), l.visible = l.visible && (l.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), l.material._color = l.material._color || l.material.color.clone(), l.material._opacity = l.material._opacity || l.material.opacity, l.material.color.copy(l.material._color), l.material.opacity = l.material._opacity, this.enabled && this.axis && (l.name === this.axis || this.axis.split("").some(function(h) {
        return l.name === h;
      })) && (l.material.color.setHex(16776960), l.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class BX extends zn {
  constructor() {
    super(
      new ig(1e5, 1e5, 2, 2),
      new og({ visible: !1, wireframe: !0, side: Pp, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), oC.copy(vM).applyQuaternion(t === "local" ? this.worldQuaternion : SC), uM.copy(RS).applyQuaternion(t === "local" ? this.worldQuaternion : SC), cM.copy(gM).applyQuaternion(t === "local" ? this.worldQuaternion : SC), Lo.copy(uM), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Lo.copy(this.eye).cross(oC), ay.copy(oC).cross(Lo);
            break;
          case "Y":
            Lo.copy(this.eye).cross(uM), ay.copy(uM).cross(Lo);
            break;
          case "Z":
            Lo.copy(this.eye).cross(cM), ay.copy(cM).cross(Lo);
            break;
          case "XY":
            ay.copy(cM);
            break;
          case "YZ":
            ay.copy(oC);
            break;
          case "XZ":
            Lo.copy(cM), ay.copy(uM);
            break;
          case "XYZ":
          case "E":
            ay.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        ay.set(0, 0, 0);
    }
    ay.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (mN.lookAt(Lp.set(0, 0, 0), ay, Lo), this.quaternion.setFromRotationMatrix(mN)), super.updateMatrixWorld(e);
  }
}
const ND = 1, HX = (a) => {
  let { x: e, y: t, z: r } = a === void 0 ? {} : a;
  return e = e === void 0 ? ND : e, t = t === void 0 ? ND : t, r = r === void 0 ? ND : r, new Rj(e, t, r, 2, 0.05);
}, VX = 0.5, GX = (a) => {
  let { radius: e } = a === void 0 ? {} : a;
  return e = e === void 0 ? VX : e, new ag(e, 32, 32);
}, uk = 0.5, ck = 1, WX = (a) => {
  let { radius: e, height: t } = a === void 0 ? {} : a;
  return e = e === void 0 ? uk : e, t = t === void 0 ? ck : t, new Jo(e, e, t, 32, 1, !1);
}, jX = 0.4, YX = 0.05, XX = 0.2, qX = 0.6, eR = (a) => {
  let { length: e, radius: t } = a === void 0 ? {} : a;
  e = e === void 0 ? 1 : e, t = t === void 0 ? 1 : t;
  const r = jX * e, i = XX * 0.5 * t, o = new Jo(
    0,
    i,
    r,
    32,
    1
  ), l = qX * e, d = YX * 0.5 * t, h = new Jo(
    d,
    d,
    l,
    32,
    1
  );
  var m = new si();
  return m.setPosition(new ge(0, l * 0.5, 0)), h.applyMatrix4(m), m.setPosition(new ge(0, l + r * 0.5, 0)), o.applyMatrix4(m), W4([
    o,
    h
  ]);
}, QX = (a) => {
  let { radius: e, height: t } = a === void 0 ? {} : a;
  e = e === void 0 ? uk : e, t = t === void 0 ? ck : t;
  const r = new Jo(e, e, t, 32, 1, !0), i = new ag(e, 32, 32, Math.PI, Math.PI), o = new ag(e, 32, 32, Math.PI, Math.PI);
  var l = new si();
  l.makeRotationX(Math.PI / 2), l.setPosition(0, t / 2, 0);
  var d = new si();
  return d.makeRotationX(-Math.PI / 2), d.setPosition(0, -t / 2, 0), i.applyMatrix4(l), o.applyMatrix4(d), W4([
    r,
    i,
    o
  ]);
}, qM = (a, e, t) => {
  if (a.current && e) {
    const r = typeof e.r == "function" ? e.r(t) / 255 : e.r / 255, i = typeof e.g == "function" ? e.g(t) / 255 : e.g / 255, o = typeof e.b == "function" ? e.b(t) / 255 : e.b / 255, l = typeof e.a == "function" ? e.a(t) : e.a;
    a.current.material.color.setRGB(r, i, o), a.current.material.opacity = l, a.current.material.transparent = l !== 1;
  }
}, ZX = (a) => {
  let e = null;
  if (a.shape)
    a.shape === "cube" ? e = HX(a.shapeParams) : a.shape === "cylinder" ? e = WX(a.shapeParams) : a.shape === "sphere" ? e = GX(a.shapeParams) : a.shape === "capsule" ? e = QX(a.shapeParams) : a.shape === "arrow" && (e = eR(a.shapeParams));
  else
    return [];
  return [{ geometry: e, type: "part" }];
};
function sT(...a) {
  const e = uo();
  return fh(() => {
    a.forEach((t) => {
      !t || (typeof t == "function" ? t(e.current) : t.current = e.current);
    });
  }, [a]), e;
}
const JX = a1(({
  objectKey: a,
  displayTfs: e,
  position: t,
  rotation: r,
  scale: i,
  ghost: o,
  highlightColor: l,
  children: d
}, h) => {
  const m = uo(null), S = sT(h, m), _ = ho(Op((D) => D.tfs[a], [a])), T = ho((D) => D.clock);
  yy(Op(() => {
    const D = T.getElapsed() * 1e3;
    S.current && (S.current.position.set(t ? t.x : typeof _.position.x == "function" ? _.position.x(D) : _.position.x, t ? t.y : typeof _.position.y == "function" ? _.position.y(D) : _.position.y, t ? t.z : typeof _.position.z == "function" ? _.position.z(D) : _.position.z), S.current.quaternion.set(r ? r.x : typeof _.rotation.x == "function" ? _.rotation.x(D) : _.rotation.x, r ? r.y : typeof _.rotation.y == "function" ? _.rotation.y(D) : _.rotation.y, r ? r.z : typeof _.rotation.z == "function" ? _.rotation.z(D) : _.rotation.z, r ? r.w : typeof _.rotation.w == "function" ? _.rotation.w(D) : _.rotation.w), S.current.scale.set(i ? i.x : _.scale ? typeof _.scale.x == "function" ? _.scale.x(D) : _.scale.x : 0, i ? i.y : _.scale ? typeof _.scale.y == "function" ? _.scale.y(D) : _.scale.y : 0, i ? i.z : _.scale ? typeof _.scale.z == "function" ? _.scale.z(D) : _.scale.z : 0));
  }, [_, t, r, i, S, T]));
  const C = eR();
  return /* @__PURE__ */ dh("group", {
    ref: S,
    dispose: null,
    up: [0, 0, 1],
    children: [e && /* @__PURE__ */ dh(rT, {
      children: [/* @__PURE__ */ _n("axesHelper", {
        size: 1
      }), /* @__PURE__ */ _n("mesh", {
        geometry: C,
        material: o ? xC(l) : hy(255, 0, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, 0, -Math.PI / 2]
      }, `${a}ArrowX`), /* @__PURE__ */ _n("mesh", {
        geometry: C,
        material: o ? xC(l) : hy(0, 255, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, Math.PI / 2, 0]
      }, `${a}ArrowY`), /* @__PURE__ */ _n("mesh", {
        geometry: C,
        material: o ? xC(l) : hy(0, 0, 255, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [Math.PI / 2, 0, 0]
      }, `${a}ArrowZ`)]
    }), d]
  });
});
function KX({
  displayTfs: a,
  children: e
}) {
  const t = eR();
  return /* @__PURE__ */ dh("group", {
    dispose: null,
    up: [0, 0, 1],
    children: [a && /* @__PURE__ */ dh(rT, {
      children: [/* @__PURE__ */ _n("axesHelper", {
        size: 1
      }), /* @__PURE__ */ _n("mesh", {
        geometry: t,
        material: hy(255, 0, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, 0, -Math.PI / 2]
      }, "$WorldArrowX"), /* @__PURE__ */ _n("mesh", {
        geometry: t,
        material: hy(0, 255, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, Math.PI / 2, 0]
      }, "$WorldArrowY"), /* @__PURE__ */ _n("mesh", {
        geometry: t,
        material: hy(0, 0, 255, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [Math.PI / 2, 0, 0]
      }, "$WorldArrowZ")]
    }), e]
  });
}
function $X({
  displayTfs: a,
  children: e
}) {
  const t = eR();
  return /* @__PURE__ */ dh("group", {
    dispose: null,
    up: [0, 0, 1],
    children: [a && /* @__PURE__ */ dh(rT, {
      children: [/* @__PURE__ */ _n("axesHelper", {
        size: 1
      }), /* @__PURE__ */ _n("mesh", {
        geometry: t,
        material: hy(255, 0, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, 0, -Math.PI / 2]
      }, "$WorldArrowX"), /* @__PURE__ */ _n("mesh", {
        geometry: t,
        material: hy(0, 255, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, Math.PI / 2, 0]
      }, "$WorldArrowY"), /* @__PURE__ */ _n("mesh", {
        geometry: t,
        material: hy(0, 0, 255, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [Math.PI / 2, 0, 0]
      }, "$WorldArrowZ")]
    }), e]
  });
}
/**
 * postprocessing v6.28.7 build Wed Aug 31 2022
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2022 Raoul van Rüschen
 * @license Zlib
 */
var eq = `#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`, NL = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", tq = class extends wu {
  constructor() {
    super({
      name: "AdaptiveLuminanceMaterial",
      defines: {
        THREE_REVISION: U0.replace(/\D+/g, ""),
        MIP_LEVEL_1X1: "0.0"
      },
      uniforms: {
        luminanceBuffer0: new Bn(null),
        luminanceBuffer1: new Bn(null),
        minLuminance: new Bn(0.01),
        deltaTime: new Bn(0),
        tau: new Bn(1)
      },
      extensions: {
        shaderTextureLOD: !0
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: eq,
      vertexShader: NL
    }), this.toneMapped = !1;
  }
  set luminanceBuffer0(a) {
    this.uniforms.luminanceBuffer0.value = a;
  }
  setLuminanceBuffer0(a) {
    this.uniforms.luminanceBuffer0.value = a;
  }
  set luminanceBuffer1(a) {
    this.uniforms.luminanceBuffer1.value = a;
  }
  setLuminanceBuffer1(a) {
    this.uniforms.luminanceBuffer1.value = a;
  }
  set mipLevel1x1(a) {
    this.defines.MIP_LEVEL_1X1 = a.toFixed(1), this.needsUpdate = !0;
  }
  setMipLevel1x1(a) {
    this.mipLevel1x1 = a;
  }
  set deltaTime(a) {
    this.uniforms.deltaTime.value = a;
  }
  setDeltaTime(a) {
    this.uniforms.deltaTime.value = a;
  }
  get minLuminance() {
    return this.uniforms.minLuminance.value;
  }
  set minLuminance(a) {
    this.uniforms.minLuminance.value = a;
  }
  getMinLuminance() {
    return this.uniforms.minLuminance.value;
  }
  setMinLuminance(a) {
    this.uniforms.minLuminance.value = a;
  }
  get adaptationRate() {
    return this.uniforms.tau.value;
  }
  set adaptationRate(a) {
    this.uniforms.tau.value = a;
  }
  getAdaptationRate() {
    return this.uniforms.tau.value;
  }
  setAdaptationRate(a) {
    this.uniforms.tau.value = a;
  }
};
function vN(a, e) {
  let t = "texel";
  if (a !== null) {
    const r = Number.parseInt(U0);
    if (!(e && r >= 133 && r !== 135 && a.format === Sm && a.type === Gf && a.encoding === Mi))
      switch (a.encoding) {
        case Mi:
          t = "sRGBToLinear(texel)";
          break;
        case yv:
          t = "texel";
          break;
        default:
          throw new Error(`Unsupported encoding: ${a.encoding}`);
      }
  }
  return t;
}
var li = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
}, e1 = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
}, ss = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
}, tR = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
}, T0 = {
  REINHARD: 0,
  REINHARD2: 1,
  REINHARD2_ADAPTIVE: 2,
  OPTIMIZED_CINEON: 3,
  ACES_FILMIC: 4
}, lC = {
  DEFAULT: 0,
  ESKIL: 1
}, nq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`, rq = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", iq = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
], aq = class extends wu {
  constructor(a = new la()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Bn(null),
        texelSize: new Bn(new la()),
        scale: new Bn(1),
        kernel: new Bn(0)
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: nq,
      vertexShader: rq
    }), this.toneMapped = !1, this.setTexelSize(a.x, a.y), this.kernelSize = tR.MEDIUM;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.inputBuffer = a;
  }
  get kernelSequence() {
    return iq[this.kernelSize];
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(a) {
    this.uniforms.scale.value = a;
  }
  getScale() {
    return this.uniforms.scale.value;
  }
  setScale(a) {
    this.uniforms.scale.value = a;
  }
  getKernel() {
    return null;
  }
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(a) {
    this.uniforms.kernel.value = a;
  }
  setKernel(a) {
    this.kernel = a;
  }
  setTexelSize(a, e) {
    this.uniforms.texelSize.value.set(a, e, a * 0.5, e * 0.5);
  }
  setSize(a, e) {
    const t = 1 / a, r = 1 / e;
    this.uniforms.texelSize.value.set(t, r, t * 0.5, r * 0.5);
  }
}, sq = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`, fk = class extends wu {
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Bn(null),
        opacity: new Bn(1)
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: sq,
      vertexShader: NL
    }), this.toneMapped = !1;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  getOpacity(a) {
    return this.uniforms.opacity.value;
  }
  setOpacity(a) {
    this.uniforms.opacity.value = a;
  }
}, oq = `#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`, lq = `#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`, uq = class extends wu {
  constructor(a = null, e) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Bn(null),
        cameraNear: new Bn(0.3),
        cameraFar: new Bn(1e3)
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: oq,
      vertexShader: lq
    }), this.toneMapped = !1, this.depthBuffer = a, this.depthPacking = Zb, this.adoptCameraSettings(e);
  }
  set depthBuffer(a) {
    this.uniforms.depthBuffer.value = a;
  }
  set depthPacking(a) {
    this.defines.DEPTH_PACKING = a.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(a, e = Zb) {
    this.depthBuffer = a, this.depthPacking = e;
  }
  adoptCameraSettings(a) {
    a && (this.uniforms.cameraNear.value = a.near, this.uniforms.cameraFar.value = a.far, a instanceof fo ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
}, cq = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec2 uvs[4];uvs[0]=vUv0;uvs[1]=vUv1;uvs[2]=vUv2;uvs[3]=vUv3;vec3 n=texture2D(normalBuffer,uvs[index]).rgb;
#else
vec3 n=vec3(0.0);
#endif
gl_FragColor=vec4(n,d[index]);}`, fq = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}", dq = class extends wu {
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Bn(null),
        normalBuffer: new Bn(null),
        texelSize: new Bn(new Ft())
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: cq,
      vertexShader: fq
    }), this.toneMapped = !1;
  }
  set depthBuffer(a) {
    this.uniforms.depthBuffer.value = a;
  }
  set depthPacking(a) {
    this.defines.DEPTH_PACKING = a.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(a, e = o1) {
    this.depthBuffer = a, this.depthPacking = e;
  }
  set normalBuffer(a) {
    this.uniforms.normalBuffer.value = a, a !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS, this.needsUpdate = !0;
  }
  setNormalBuffer(a) {
    this.normalBuffer = a;
  }
  setTexelSize(a, e) {
    this.uniforms.texelSize.value.set(a, e);
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, hq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`, pq = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}", mq = class extends wu {
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Bn(null),
        texelSize: new Bn(new Ft())
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: hq,
      vertexShader: pq
    }), this.toneMapped = !1;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, vq = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`, gq = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", yq = class extends wu {
  constructor(a, e, t, r, i = !1) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: U0.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Bn(null),
        depthBuffer: new Bn(null),
        resolution: new Bn(new Ft()),
        texelSize: new Bn(new Ft()),
        cameraNear: new Bn(0.3),
        cameraFar: new Bn(1e3),
        aspect: new Bn(1),
        time: new Bn(0)
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      dithering: i
    }), this.toneMapped = !1, a && this.setShaderParts(a), e && this.setDefines(e), t && this.setUniforms(t), this.adoptCameraSettings(r);
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(a) {
    this.uniforms.depthBuffer.value = a;
  }
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(a) {
    this.defines.DEPTH_PACKING = a.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(a, e = o1) {
    this.depthBuffer = a, this.depthPacking = e;
  }
  setShaderData(a) {
    this.setShaderParts(a.shaderParts), this.setDefines(a.defines), this.setUniforms(a.uniforms), this.setExtensions(a.extensions);
  }
  setShaderParts(a) {
    var e, t, r, i, o;
    return this.fragmentShader = vq.replace(ss.FRAGMENT_HEAD, (e = a.get(ss.FRAGMENT_HEAD)) != null ? e : "").replace(ss.FRAGMENT_MAIN_UV, (t = a.get(ss.FRAGMENT_MAIN_UV)) != null ? t : "").replace(ss.FRAGMENT_MAIN_IMAGE, (r = a.get(ss.FRAGMENT_MAIN_IMAGE)) != null ? r : ""), this.vertexShader = gq.replace(ss.VERTEX_HEAD, (i = a.get(ss.VERTEX_HEAD)) != null ? i : "").replace(ss.VERTEX_MAIN_SUPPORT, (o = a.get(ss.VERTEX_MAIN_SUPPORT)) != null ? o : ""), this.needsUpdate = !0, this;
  }
  setDefines(a) {
    for (const e of a.entries())
      this.defines[e[0]] = e[1];
    return this.needsUpdate = !0, this;
  }
  setUniforms(a) {
    for (const e of a.entries())
      this.uniforms[e[0]] = e[1];
    return this;
  }
  setExtensions(a) {
    this.extensions = {};
    for (const e of a)
      this.extensions[e] = !0;
    return this;
  }
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(a) {
    this.encodeOutput !== a && (a ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0);
  }
  isOutputEncodingEnabled(a) {
    return this.encodeOutput;
  }
  setOutputEncodingEnabled(a) {
    this.encodeOutput = a;
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(a) {
    this.uniforms.time.value = a;
  }
  setDeltaTime(a) {
    this.uniforms.time.value += a;
  }
  adoptCameraSettings(a) {
    a && (this.uniforms.cameraNear.value = a.near, this.uniforms.cameraFar.value = a.far, a instanceof fo ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  setSize(a, e) {
    const t = this.uniforms;
    t.resolution.value.set(a, e), t.texelSize.value.set(1 / a, 1 / e), t.aspect.value = a / e;
  }
  static get Section() {
    return ss;
  }
}, xq = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`, Sq = class extends wu {
  constructor(a = !1, e = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: U0.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Bn(null),
        threshold: new Bn(0),
        smoothing: new Bn(1),
        range: new Bn(null)
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: xq,
      vertexShader: NL
    }), this.toneMapped = !1, this.colorOutput = a, this.luminanceRange = e;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(a) {
    this.smoothing > 0 || a > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = a;
  }
  getThreshold() {
    return this.threshold;
  }
  setThreshold(a) {
    this.threshold = a;
  }
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(a) {
    this.threshold > 0 || a > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = a;
  }
  getSmoothingFactor() {
    return this.smoothing;
  }
  setSmoothingFactor(a) {
    this.smoothing = a;
  }
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(a) {
  }
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(a) {
    a ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0;
  }
  isColorOutputEnabled(a) {
    return this.colorOutput;
  }
  setColorOutputEnabled(a) {
    this.colorOutput = a;
  }
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(a) {
    this.luminanceRange = null;
  }
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(a) {
    a !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = a, this.needsUpdate = !0;
  }
  getLuminanceRange() {
    return this.luminanceRange;
  }
  setLuminanceRange(a) {
    this.luminanceRange = a;
  }
}, _q = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}", bq = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}", wq = class extends wu {
  constructor(a = new Ft()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Bn(null),
        texelSize: new Bn(new Ft())
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: _q,
      vertexShader: bq
    }), this.toneMapped = !1, this.setTexelSize(a.x, a.y), this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setTexelSize(a, e) {
    this.uniforms.texelSize.value.set(a, e);
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, Eq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`, Mq = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}", Tq = class extends wu {
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Bn(null),
        supportBuffer: new Bn(null),
        texelSize: new Bn(new Ft()),
        radius: new Bn(0.85)
      },
      blending: cf,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: Eq,
      vertexShader: Mq
    }), this.toneMapped = !1;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  set supportBuffer(a) {
    this.uniforms.supportBuffer.value = a;
  }
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(a) {
    this.uniforms.radius.value = a;
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, Cq = new hw(), Qx = null;
function Rq() {
  if (Qx === null) {
    const a = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e = new Float32Array([0, 0, 2, 0, 0, 2]);
    Qx = new ui(), Qx.setAttribute !== void 0 ? (Qx.setAttribute("position", new os(a, 3)), Qx.setAttribute("uv", new os(e, 2))) : (Qx.addAttribute("position", new os(a, 3)), Qx.addAttribute("uv", new os(e, 2)));
  }
  return Qx;
}
var mh = class {
  constructor(a = "Pass", e = new zM(), t = Cq) {
    this.name = a, this.renderer = null, this.scene = e, this.camera = t, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0;
  }
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(a) {
    if (this.rtt === a) {
      const e = this.fullscreenMaterial;
      e !== null && (e.needsUpdate = !0), this.rtt = !a;
    }
  }
  setRenderer(a) {
    this.renderer = a;
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(a) {
    this.enabled = a;
  }
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(a) {
    let e = this.screen;
    e !== null ? e.material = a : (e = new zn(Rq(), a), e.frustumCulled = !1, this.scene === null && (this.scene = new zM()), this.scene.add(e), this.screen = e);
  }
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  setFullscreenMaterial(a) {
    this.fullscreenMaterial = a;
  }
  getDepthTexture() {
    return null;
  }
  setDepthTexture(a, e = o1) {
  }
  render(a, e, t, r, i) {
    throw new Error("Render method not implemented!");
  }
  setSize(a, e) {
  }
  initialize(a, e, t) {
  }
  dispose() {
    for (const a of Object.keys(this)) {
      const e = this[a];
      (e instanceof po || e instanceof ff || e instanceof iu || e instanceof mh) && this[a].dispose();
    }
  }
}, dk = class extends mh {
  constructor(a, e = !0) {
    super("CopyPass"), this.fullscreenMaterial = new fk(), this.needsSwap = !1, this.renderTarget = a, a === void 0 && (this.renderTarget = new po(1, 1, {
      minFilter: Po,
      magFilter: Po,
      stencilBuffer: !1,
      depthBuffer: !1
    }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e;
  }
  get resize() {
    return this.autoResize;
  }
  set resize(a) {
    this.autoResize = a;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  setAutoResizeEnabled(a) {
    this.autoResize = a;
  }
  render(a, e, t, r, i) {
    this.fullscreenMaterial.inputBuffer = e.texture, a.setRenderTarget(this.renderToScreen ? null : this.renderTarget), a.render(this.scene, this.camera);
  }
  setSize(a, e) {
    this.autoResize && this.renderTarget.setSize(a, e);
  }
  initialize(a, e, t) {
    t !== void 0 && (this.renderTarget.texture.type = t, t !== Gf ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : a.outputEncoding === Mi && (this.renderTarget.texture.encoding = Mi));
  }
}, Aq = class extends mh {
  constructor(a, { minLuminance: e = 0.01, adaptationRate: t = 1 } = {}) {
    super("AdaptiveLuminancePass"), this.fullscreenMaterial = new tq(), this.needsSwap = !1, this.renderTargetPrevious = new po(1, 1, {
      minFilter: co,
      magFilter: co,
      depthBuffer: !1
    }), this.renderTargetPrevious.texture.name = "Luminance.Previous";
    const r = this.fullscreenMaterial;
    r.luminanceBuffer0 = this.renderTargetPrevious.texture, r.luminanceBuffer1 = a, r.minLuminance = e, r.adaptationRate = t, this.renderTargetAdapted = this.renderTargetPrevious.clone(), this.renderTargetAdapted.texture.name = "Luminance.Adapted", this.copyPass = new dk(this.renderTargetPrevious, !1);
  }
  get texture() {
    return this.renderTargetAdapted.texture;
  }
  getTexture() {
    return this.renderTargetAdapted.texture;
  }
  set mipLevel1x1(a) {
    this.fullscreenMaterial.mipLevel1x1 = a;
  }
  get adaptationRate() {
    return this.fullscreenMaterial.adaptationRate;
  }
  set adaptationRate(a) {
    this.fullscreenMaterial.adaptationRate = a;
  }
  render(a, e, t, r, i) {
    this.fullscreenMaterial.deltaTime = r, a.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted), a.render(this.scene, this.camera), this.copyPass.render(a, this.renderTargetAdapted);
  }
}, Dq = class extends mh {
  constructor() {
    super("ClearMaskPass", null, null), this.needsSwap = !1;
  }
  render(a, e, t, r, i) {
    const o = a.state.buffers.stencil;
    o.setLocked(!1), o.setTest(!1);
  }
}, FD = new Pn(), FL = class extends mh {
  constructor(a = !0, e = !0, t = !1) {
    super("ClearPass", null, null), this.needsSwap = !1, this.color = a, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1;
  }
  setClearFlags(a, e, t) {
    this.color = a, this.depth = e, this.stencil = t;
  }
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  setOverrideClearColor(a) {
    this.overrideClearColor = a;
  }
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  setOverrideClearAlpha(a) {
    this.overrideClearAlpha = a;
  }
  render(a, e, t, r, i) {
    const o = this.overrideClearColor, l = this.overrideClearAlpha, d = a.getClearAlpha(), h = o !== null, m = l >= 0;
    h ? (FD.copy(a.getClearColor(FD)), a.setClearColor(o, m ? l : d)) : m && a.setClearAlpha(l), a.setRenderTarget(this.renderToScreen ? null : e), a.clear(this.color, this.depth, this.stencil), h ? a.setClearColor(FD, d) : m && a.setClearAlpha(d);
  }
}, Zx = -1, Zu = class extends Mm {
  constructor(a, e = Zx, t = Zx, r = 1) {
    super(), this.resizable = a, this.baseSize = new Ft(1, 1), this.preferredSize = new Ft(e, t), this.target = this.preferredSize, this.s = r, this.effectiveSize = new Ft(), this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize();
  }
  updateEffectiveSize() {
    const a = this.baseSize, e = this.preferredSize, t = this.effectiveSize, r = this.scale;
    e.width !== Zx ? t.width = e.width : e.height !== Zx ? t.width = Math.round(e.height * (a.width / Math.max(a.height, 1))) : t.width = Math.round(a.width * r), e.height !== Zx ? t.height = e.height : e.width !== Zx ? t.height = Math.round(e.width / Math.max(a.width / Math.max(a.height, 1), 1)) : t.height = Math.round(a.height * r);
  }
  get width() {
    return this.effectiveSize.width;
  }
  set width(a) {
    this.preferredWidth = a;
  }
  get height() {
    return this.effectiveSize.height;
  }
  set height(a) {
    this.preferredHeight = a;
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  get scale() {
    return this.s;
  }
  set scale(a) {
    this.s !== a && (this.s = a, this.preferredSize.setScalar(Zx), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getScale() {
    return this.scale;
  }
  setScale(a) {
    this.scale = a;
  }
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(a) {
    this.baseSize.width !== a && (this.baseSize.width = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseWidth() {
    return this.baseWidth;
  }
  setBaseWidth(a) {
    this.baseWidth = a;
  }
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(a) {
    this.baseSize.height !== a && (this.baseSize.height = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseHeight() {
    return this.baseHeight;
  }
  setBaseHeight(a) {
    this.baseHeight = a;
  }
  setBaseSize(a, e) {
    (this.baseSize.width !== a || this.baseSize.height !== e) && (this.baseSize.set(a, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(a) {
    this.preferredSize.width !== a && (this.preferredSize.width = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredWidth() {
    return this.preferredWidth;
  }
  setPreferredWidth(a) {
    this.preferredWidth = a;
  }
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(a) {
    this.preferredSize.height !== a && (this.preferredSize.height = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredHeight() {
    return this.preferredHeight;
  }
  setPreferredHeight(a) {
    this.preferredHeight = a;
  }
  setPreferredSize(a, e) {
    (this.preferredSize.width !== a || this.preferredSize.height !== e) && (this.preferredSize.set(a, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  copy(a) {
    this.s = a.scale, this.baseSize.set(a.getBaseWidth(), a.getBaseHeight()), this.preferredSize.set(a.getPreferredWidth(), a.getPreferredHeight()), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  static get AUTO_SIZE() {
    return Zx;
  }
}, kD = !1, gN = class {
  constructor(a = null) {
    this.originalMaterials = /* @__PURE__ */ new Map(), this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(a), this.meshCount = 0, this.replaceMaterial = (e) => {
      if (e.isMesh) {
        let t;
        if (e.material.flatShading)
          switch (e.material.side) {
            case Pp:
              t = this.materialsFlatShadedDoubleSide;
              break;
            case uf:
              t = this.materialsFlatShadedBackSide;
              break;
            default:
              t = this.materialsFlatShaded;
              break;
          }
        else
          switch (e.material.side) {
            case Pp:
              t = this.materialsDoubleSide;
              break;
            case uf:
              t = this.materialsBackSide;
              break;
            default:
              t = this.materials;
              break;
          }
        this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount;
      }
    };
  }
  setMaterial(a) {
    if (this.disposeMaterials(), this.material = a, a !== null) {
      const e = this.materials = [
        a.clone(),
        a.clone(),
        a.clone()
      ];
      for (const t of e)
        t.uniforms = Object.assign({}, a.uniforms), t.side = py;
      e[2].skinning = !0, this.materialsBackSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.side = uf, r;
      }), this.materialsDoubleSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.side = Pp, r;
      }), this.materialsFlatShaded = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.flatShading = !0, r;
      }), this.materialsFlatShadedBackSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.flatShading = !0, r.side = uf, r;
      }), this.materialsFlatShadedDoubleSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.flatShading = !0, r.side = Pp, r;
      });
    }
  }
  render(a, e, t) {
    const r = a.shadowMap.enabled;
    if (a.shadowMap.enabled = !1, kD) {
      const i = this.originalMaterials;
      this.meshCount = 0, e.traverse(this.replaceMaterial), a.render(e, t);
      for (const o of i)
        o[0].material = o[1];
      this.meshCount !== i.size && i.clear();
    } else {
      const i = e.overrideMaterial;
      e.overrideMaterial = this.material, a.render(e, t), e.overrideMaterial = i;
    }
    a.shadowMap.enabled = r;
  }
  disposeMaterials() {
    if (this.material !== null) {
      const a = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const e of a)
        e.dispose();
    }
  }
  dispose() {
    this.originalMaterials.clear(), this.disposeMaterials();
  }
  static get workaroundEnabled() {
    return kD;
  }
  static set workaroundEnabled(a) {
    kD = a;
  }
}, nR = class extends mh {
  constructor(a, e, t = null) {
    super("RenderPass", a, e), this.needsSwap = !1, this.clearPass = new FL(), this.overrideMaterialManager = t === null ? null : new gN(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(a) {
    super.renderToScreen = a, this.clearPass.renderToScreen = a;
  }
  get overrideMaterial() {
    const a = this.overrideMaterialManager;
    return a !== null ? a.material : null;
  }
  set overrideMaterial(a) {
    const e = this.overrideMaterialManager;
    a !== null ? e !== null ? e.setMaterial(a) : this.overrideMaterialManager = new gN(a) : e !== null && (e.dispose(), this.overrideMaterialManager = null);
  }
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  setOverrideMaterial(a) {
    this.overrideMaterial = a;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(a) {
    this.clearPass.enabled = a;
  }
  getSelection() {
    return this.selection;
  }
  setSelection(a) {
    this.selection = a;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(a) {
    this.ignoreBackground = a;
  }
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  setShadowMapDisabled(a) {
    this.skipShadowMapUpdate = a;
  }
  getClearPass() {
    return this.clearPass;
  }
  render(a, e, t, r, i) {
    const o = this.scene, l = this.camera, d = this.selection, h = l.layers.mask, m = o.background, S = a.shadowMap.autoUpdate, _ = this.renderToScreen ? null : e;
    d !== null && l.layers.set(d.getLayer()), this.skipShadowMapUpdate && (a.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (o.background = null), this.clearPass.enabled && this.clearPass.render(a, e), a.setRenderTarget(_), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(a, o, l) : a.render(o, l), l.layers.mask = h, o.background = m, a.shadowMap.autoUpdate = S;
  }
}, Lq = class extends mh {
  constructor(a, e, {
    renderTarget: t,
    resolutionScale: r = 1,
    width: i = Zu.AUTO_SIZE,
    height: o = Zu.AUTO_SIZE,
    resolutionX: l = i,
    resolutionY: d = o
  } = {}) {
    super("DepthPass"), this.needsSwap = !1, this.renderPass = new nR(a, e, new tT({
      depthPacking: Zb
    }));
    const h = this.renderPass;
    h.skipShadowMapUpdate = !0, h.ignoreBackground = !0;
    const m = h.getClearPass();
    m.overrideClearColor = new Pn(16777215), m.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new po(1, 1, {
      minFilter: co,
      magFilter: co
    }), this.renderTarget.texture.name = "DepthPass.Target");
    const S = this.resolution = new Zu(this, l, d, r);
    S.addEventListener("change", (_) => this.setSize(S.baseWidth, S.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  render(a, e, t, r, i) {
    const o = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(a, o);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
}, Pq = class extends mh {
  constructor({
    normalBuffer: a = null,
    resolutionScale: e = 0.5,
    width: t = Zu.AUTO_SIZE,
    height: r = Zu.AUTO_SIZE,
    resolutionX: i = t,
    resolutionY: o = r
  } = {}) {
    super("DepthDownsamplingPass");
    const l = new dq();
    l.normalBuffer = a, this.fullscreenMaterial = l, this.needsDepthTexture = !0, this.needsSwap = !1, this.renderTarget = new po(1, 1, {
      minFilter: co,
      magFilter: co,
      depthBuffer: !1,
      type: uy
    }), this.renderTarget.texture.name = "DepthDownsamplingPass.Target", this.renderTarget.texture.generateMipmaps = !1;
    const d = this.resolution = new Zu(this, i, o, e);
    d.addEventListener("change", (h) => this.setSize(d.baseWidth, d.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  setDepthTexture(a, e = o1) {
    this.fullscreenMaterial.depthBuffer = a, this.fullscreenMaterial.depthPacking = e;
  }
  render(a, e, t, r, i) {
    a.setRenderTarget(this.renderToScreen ? null : this.renderTarget), a.render(this.scene, this.camera);
  }
  setSize(a, e) {
    this.fullscreenMaterial.setSize(a, e);
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
  initialize(a, e, t) {
    if (!a.capabilities.isWebGL2)
      throw new Error("The DepthDownsamplingPass requires WebGL 2");
  }
};
function yN(a, e, t) {
  for (const r of e) {
    const i = "$1" + a + r.charAt(0).toUpperCase() + r.slice(1), o = new RegExp("([^\\.])(\\b" + r + "\\b)", "g");
    for (const l of t.entries())
      l[1] !== null && t.set(l[0], l[1].replace(o, i));
  }
}
function Oq(a, e, t) {
  var r, i, o, l, d;
  let h = e.getFragmentShader(), m = e.getVertexShader();
  const S = h !== void 0 && /mainImage/.test(h), _ = h !== void 0 && /mainUv/.test(h);
  if (t.attributes |= e.getAttributes(), h === void 0)
    throw new Error(`Missing fragment shader (${e.name})`);
  if (_ && (t.attributes & e1.CONVOLUTION) !== 0)
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
  if (!S && !_)
    throw new Error(`Could not find mainImage or mainUv function (${e.name})`);
  {
    const T = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, C = t.shaderParts;
    let D = (r = C.get(ss.FRAGMENT_HEAD)) != null ? r : "", P = (i = C.get(ss.FRAGMENT_MAIN_UV)) != null ? i : "", U = (o = C.get(ss.FRAGMENT_MAIN_IMAGE)) != null ? o : "", B = (l = C.get(ss.VERTEX_HEAD)) != null ? l : "", k = (d = C.get(ss.VERTEX_MAIN_SUPPORT)) != null ? d : "";
    const V = /* @__PURE__ */ new Set(), I = /* @__PURE__ */ new Set();
    if (_ && (P += `	${a}MainUv(UV);
`, t.uvTransformation = !0), m !== null && /mainSupport/.test(m)) {
      const $ = /mainSupport *\([\w\s]*?uv\s*?\)/.test(m);
      k += `	${a}MainSupport(`, k += $ ? `vUv);
` : `);
`;
      for (const W of m.matchAll(/(?:varying\s+\w+\s+(\w*))/g))
        t.varyings.add(W[1]), V.add(W[1]), I.add(W[1]);
      for (const W of m.matchAll(T))
        I.add(W[1]);
    }
    for (const $ of h.matchAll(T))
      I.add($[1]);
    for (const $ of e.defines.keys())
      I.add($.replace(/\([\w\s,]*\)/g, ""));
    for (const $ of e.uniforms.keys())
      I.add($);
    I.delete("while"), I.delete("for"), I.delete("if"), e.uniforms.forEach(($, W) => t.uniforms.set(a + W.charAt(0).toUpperCase() + W.slice(1), $)), e.defines.forEach(($, W) => t.defines.set(a + W.charAt(0).toUpperCase() + W.slice(1), $));
    const X = /* @__PURE__ */ new Map([["fragment", h], ["vertex", m]]);
    yN(a, I, t.defines), yN(a, I, X), h = X.get("fragment"), m = X.get("vertex");
    const J = e.blendMode;
    if (t.blendModes.set(J.blendFunction, J), S) {
      e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (U += e.inputColorSpace === Mi ? `color0 = LinearTosRGB(color0);
	` : `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== null ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
      const $ = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      U += `${a}MainImage(color0, UV, `, (t.attributes & e1.DEPTH) !== 0 && $.test(h) && (U += "depth, ", t.readDepth = !0), U += `color1);
	`;
      const W = a + "BlendOpacity";
      t.uniforms.set(W, J.opacity), U += `color0 = blend${J.blendFunction}(color0, color1, ${W});

	`, D += `uniform float ${W};

`;
    }
    if (D += h + `
`, m !== null && (B += m + `
`), C.set(ss.FRAGMENT_HEAD, D), C.set(ss.FRAGMENT_MAIN_UV, P), C.set(ss.FRAGMENT_MAIN_IMAGE, U), C.set(ss.VERTEX_HEAD, B), C.set(ss.VERTEX_MAIN_SUPPORT, k), e.extensions !== null)
      for (const $ of e.extensions)
        t.extensions.add($);
  }
}
var Uq = class extends mh {
  constructor(a, ...e) {
    super("EffectPass"), this.fullscreenMaterial = new yq(null, null, null, a), this.listener = (t) => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY;
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(a) {
    this.fullscreenMaterial.encodeOutput = a;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(a) {
    const e = this.fullscreenMaterial;
    e.dithering = a, e.needsUpdate = !0;
  }
  setEffects(a) {
    for (const e of this.effects)
      e.removeEventListener("change", this.listener);
    this.effects = a.sort((e, t) => t.attributes - e.attributes);
    for (const e of this.effects)
      e.addEventListener("change", this.listener);
  }
  updateMaterial() {
    const a = new Vq();
    let e = 0;
    for (const l of this.effects)
      if (l.blendMode.blendFunction === li.DST)
        a.attributes |= l.getAttributes() & e1.DEPTH;
      else {
        if ((a.attributes & l.getAttributes() & e1.CONVOLUTION) !== 0)
          throw new Error(`Convolution effects cannot be merged (${l.name})`);
        Oq("e" + e++, l, a);
      }
    let t = a.shaderParts.get(ss.FRAGMENT_HEAD), r = a.shaderParts.get(ss.FRAGMENT_MAIN_IMAGE), i = a.shaderParts.get(ss.FRAGMENT_MAIN_UV);
    const o = /\bblend\b/g;
    for (const l of a.blendModes.values())
      t += l.getShaderCode().replace(o, `blend${l.blendFunction}`) + `
`;
    (a.attributes & e1.DEPTH) !== 0 ? (a.readDepth && (r = `float depth = readDepth(UV);

	` + r), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, a.colorSpace === Mi && (r += `color0 = sRGBToLinear(color0);
	`), a.uvTransformation ? (i = `vec2 transformedUv = vUv;
` + i, a.defines.set("UV", "transformedUv")) : a.defines.set("UV", "vUv"), a.shaderParts.set(ss.FRAGMENT_HEAD, t), a.shaderParts.set(ss.FRAGMENT_MAIN_IMAGE, r), a.shaderParts.set(ss.FRAGMENT_MAIN_UV, i), a.shaderParts.forEach((l, d, h) => h.set(d, l == null ? void 0 : l.trim().replace(/^#/, `
#`))), this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(a);
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(a, e = o1) {
    this.fullscreenMaterial.depthBuffer = a, this.fullscreenMaterial.depthPacking = e;
    for (const t of this.effects)
      t.setDepthTexture(a, e);
  }
  render(a, e, t, r, i) {
    for (const o of this.effects)
      o.update(a, e, r);
    if (!this.skipRendering || this.renderToScreen) {
      const o = this.fullscreenMaterial;
      o.inputBuffer = e.texture, o.time += r, a.setRenderTarget(this.renderToScreen ? null : t), a.render(this.scene, this.camera);
    }
  }
  setSize(a, e) {
    this.fullscreenMaterial.setSize(a, e);
    for (const t of this.effects)
      t.setSize(a, e);
  }
  initialize(a, e, t) {
    this.renderer = a;
    for (const r of this.effects)
      r.initialize(a, e, t);
    this.updateMaterial(), t !== void 0 && t !== Gf && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
  dispose() {
    super.dispose();
    for (const a of this.effects)
      a.removeEventListener("change", this.listener), a.dispose();
  }
  handleEvent(a) {
    switch (a.type) {
      case "change":
        this.recompile();
        break;
    }
  }
}, hk = class extends mh {
  constructor({
    kernelSize: a = tR.MEDIUM,
    resolutionScale: e = 0.5,
    width: t = Zu.AUTO_SIZE,
    height: r = Zu.AUTO_SIZE,
    resolutionX: i = t,
    resolutionY: o = r
  } = {}) {
    super("KawaseBlurPass"), this.renderTargetA = new po(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
    const l = this.resolution = new Zu(this, i, o, e);
    l.addEventListener("change", (d) => this.setSize(l.baseWidth, l.baseHeight)), this.blurMaterial = new aq(), this.copyMaterial = new fk();
  }
  getResolution() {
    return this.resolution;
  }
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(a) {
    this.copyMaterial.dithering = a;
  }
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(a) {
    this.blurMaterial.kernelSize = a;
  }
  get width() {
    return this.resolution.width;
  }
  set width(a) {
    this.resolution.preferredWidth = a;
  }
  get height() {
    return this.resolution.height;
  }
  set height(a) {
    this.resolution.preferredHeight = a;
  }
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(a) {
    this.blurMaterial.scale = a;
  }
  getScale() {
    return this.blurMaterial.scale;
  }
  setScale(a) {
    this.blurMaterial.scale = a;
  }
  getKernelSize() {
    return this.kernelSize;
  }
  setKernelSize(a) {
    this.kernelSize = a;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  render(a, e, t, r, i) {
    const o = this.scene, l = this.camera, d = this.renderTargetA, h = this.renderTargetB, m = this.blurMaterial, S = m.kernelSequence;
    let _ = e;
    this.fullscreenMaterial = m;
    for (let T = 0, C = S.length; T < C; ++T) {
      const D = (T & 1) === 0 ? d : h;
      m.kernel = S[T], m.inputBuffer = _.texture, a.setRenderTarget(D), a.render(o, l), _ = D;
    }
    this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = _.texture, a.setRenderTarget(this.renderToScreen ? null : t), a.render(o, l);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e);
    const r = t.width, i = t.height;
    this.renderTargetA.setSize(r, i), this.renderTargetB.setSize(r, i), this.blurMaterial.setSize(a, e);
  }
  initialize(a, e, t) {
    t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== Gf ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : a.outputEncoding === Mi && (this.renderTargetA.texture.encoding = Mi, this.renderTargetB.texture.encoding = Mi));
  }
  static get AUTO_SIZE() {
    return Zu.AUTO_SIZE;
  }
}, pk = class extends mh {
  constructor({
    renderTarget: a,
    luminanceRange: e,
    colorOutput: t,
    resolutionScale: r = 1,
    width: i = Zu.AUTO_SIZE,
    height: o = Zu.AUTO_SIZE,
    resolutionX: l = i,
    resolutionY: d = o
  } = {}) {
    super("LuminancePass"), this.fullscreenMaterial = new Sq(t, e), this.needsSwap = !1, this.renderTarget = a, this.renderTarget === void 0 && (this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target");
    const h = this.resolution = new Zu(this, l, d, r);
    h.addEventListener("change", (m) => this.setSize(h.baseWidth, h.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  render(a, e, t, r, i) {
    const o = this.fullscreenMaterial;
    o.inputBuffer = e.texture, a.setRenderTarget(this.renderToScreen ? null : this.renderTarget), a.render(this.scene, this.camera);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
  initialize(a, e, t) {
    t !== void 0 && t !== Gf && (this.renderTarget.texture.type = t, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
}, zq = class extends mh {
  constructor(a, e) {
    super("MaskPass", a, e), this.needsSwap = !1, this.clearPass = new FL(!1, !1, !0), this.inverse = !1;
  }
  get inverted() {
    return this.inverse;
  }
  set inverted(a) {
    this.inverse = a;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(a) {
    this.clearPass.enabled = a;
  }
  getClearPass() {
    return this.clearPass;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(a) {
    this.inverted = a;
  }
  render(a, e, t, r, i) {
    const o = a.getContext(), l = a.state.buffers, d = this.scene, h = this.camera, m = this.clearPass, S = this.inverted ? 0 : 1, _ = 1 - S;
    l.color.setMask(!1), l.depth.setMask(!1), l.color.setLocked(!0), l.depth.setLocked(!0), l.stencil.setTest(!0), l.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), l.stencil.setFunc(o.ALWAYS, S, 4294967295), l.stencil.setClear(_), l.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? m.render(a, null) : (m.render(a, e), m.render(a, t))), this.renderToScreen ? (a.setRenderTarget(null), a.render(d, h)) : (a.setRenderTarget(e), a.render(d, h), a.setRenderTarget(t), a.render(d, h)), l.color.setLocked(!1), l.depth.setLocked(!1), l.stencil.setLocked(!1), l.stencil.setFunc(o.EQUAL, 1, 4294967295), l.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), l.stencil.setLocked(!0);
  }
}, Nq = class extends mh {
  constructor() {
    super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new mq(), this.upsamplingMaterial = new Tq(), this.resolution = new Ft();
  }
  get texture() {
    return this.renderTarget.texture;
  }
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(a) {
    if (this.levels !== a) {
      const e = this.renderTarget;
      this.dispose();
      for (let t = 0; t < a; ++t) {
        const r = e.clone();
        r.texture.name = "Downsampling.Mipmap" + t, this.downsamplingMipmaps.push(r);
      }
      this.upsamplingMipmaps.push(e);
      for (let t = 1, r = a - 1; t < r; ++t) {
        const i = e.clone();
        i.texture.name = "Upsampling.Mipmap" + t, this.upsamplingMipmaps.push(i);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(a) {
    this.upsamplingMaterial.radius = a;
  }
  render(a, e, t, r, i) {
    const { scene: o, camera: l } = this, { downsamplingMaterial: d, upsamplingMaterial: h } = this, { downsamplingMipmaps: m, upsamplingMipmaps: S } = this;
    let _ = e;
    this.fullscreenMaterial = d;
    for (let T = 0, C = m.length; T < C; ++T) {
      const D = m[T];
      d.setSize(_.width, _.height), d.inputBuffer = _.texture, a.setRenderTarget(D), a.render(o, l), _ = D;
    }
    this.fullscreenMaterial = h;
    for (let T = S.length - 1; T >= 0; --T) {
      const C = S[T];
      h.setSize(_.width, _.height), h.inputBuffer = _.texture, h.supportBuffer = m[T].texture, a.setRenderTarget(C), a.render(o, l), _ = C;
    }
  }
  setSize(a, e) {
    const t = this.resolution;
    t.set(a, e);
    let r = t.width, i = t.height;
    for (let o = 0, l = this.downsamplingMipmaps.length; o < l; ++o)
      r = Math.round(r * 0.5), i = Math.round(i * 0.5), this.downsamplingMipmaps[o].setSize(r, i), o < this.upsamplingMipmaps.length && this.upsamplingMipmaps[o].setSize(r, i);
  }
  initialize(a, e, t) {
    if (t !== void 0) {
      const r = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const i of r)
        i.texture.type = t;
      if (t !== Gf)
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      else if (a.outputEncoding === Mi)
        for (const i of r)
          i.texture.encoding = Mi;
    }
  }
  dispose() {
    super.dispose();
    for (const a of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
      a.dispose();
  }
}, Fq = class extends mh {
  constructor(a, e, {
    renderTarget: t,
    resolutionScale: r = 1,
    width: i = Zu.AUTO_SIZE,
    height: o = Zu.AUTO_SIZE,
    resolutionX: l = i,
    resolutionY: d = o
  } = {}) {
    super("NormalPass"), this.needsSwap = !1, this.renderPass = new nR(a, e, new cL());
    const h = this.renderPass;
    h.setBackgroundDisabled(!0), h.setShadowMapDisabled(!0);
    const m = h.getClearPass();
    m.setOverrideClearColor(new Pn(7829503)), m.setOverrideClearAlpha(1), this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new po(1, 1, {
      minFilter: co,
      magFilter: co
    }), this.renderTarget.texture.name = "NormalPass.Target");
    const S = this.resolution = new Zu(this, l, d, r);
    S.addEventListener("change", (_) => this.setSize(S.baseWidth, S.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  render(a, e, t, r, i) {
    const o = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(a, o, o);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
}, kq = class extends mh {
  constructor(a, e = "inputBuffer") {
    super("ShaderPass"), this.fullscreenMaterial = a, this.input = e;
  }
  setInput(a) {
  }
  render(a, e, t, r, i) {
    const o = this.fullscreenMaterial.uniforms;
    e !== null && o !== void 0 && o[this.input] !== void 0 && (o[this.input].value = e.texture), a.setRenderTarget(this.renderToScreen ? null : t), a.render(this.scene, this.camera);
  }
  initialize(a, e, t) {
    t !== void 0 && t !== Gf && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
}, ID = 1 / 1e3, Iq = 1e3, Bq = class {
  constructor() {
    this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1, this.autoReset = !1;
  }
  setFixedDeltaEnabled(a) {
    return this.fixedDeltaEnabled = a, this;
  }
  isAutoResetEnabled(a) {
    return this.autoReset;
  }
  setAutoResetEnabled(a) {
    return typeof document < "u" && document.hidden !== void 0 && (a ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this.autoReset = a), this;
  }
  getDelta() {
    return this.delta * ID;
  }
  getFixedDelta() {
    return this.fixedDelta * ID;
  }
  setFixedDelta(a) {
    return this.fixedDelta = a * Iq, this;
  }
  getElapsed() {
    return this.elapsed * ID;
  }
  getTimescale() {
    return this.timescale;
  }
  setTimescale(a) {
    return this.timescale = a, this;
  }
  update(a) {
    return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = a !== void 0 ? a : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.delta, this;
  }
  reset() {
    return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this;
  }
  handleEvent(a) {
    document.hidden || (this.currentTime = performance.now());
  }
  dispose() {
    this.setAutoResetEnabled(!1);
  }
}, Hq = class {
  constructor(a = null, {
    depthBuffer: e = !0,
    stencilBuffer: t = !1,
    multisampling: r = 0,
    frameBufferType: i
  } = {}) {
    this.renderer = null, this.inputBuffer = this.createBuffer(e, t, i, r), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new dk(), this.depthTexture = null, this.passes = [], this.timer = new Bq(), this.autoRenderToScreen = !0, this.setRenderer(a);
  }
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  set multisampling(a) {
    const e = this.inputBuffer, t = this.multisampling;
    t > 0 && a > 0 ? (this.inputBuffer.samples = a, this.outputBuffer.samples = a, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : t !== a && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(
      e.depthBuffer,
      e.stencilBuffer,
      e.texture.type,
      a
    ), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone());
  }
  getTimer() {
    return this.timer;
  }
  getRenderer() {
    return this.renderer;
  }
  setRenderer(a) {
    if (this.renderer = a, a !== null) {
      const e = a.getSize(new Ft()), t = a.getContext().getContextAttributes().alpha, r = this.inputBuffer.texture.type;
      r === Gf && a.outputEncoding === Mi && (this.inputBuffer.texture.encoding = Mi, this.outputBuffer.texture.encoding = Mi, this.inputBuffer.dispose(), this.outputBuffer.dispose()), a.autoClear = !1, this.setSize(e.width, e.height);
      for (const i of this.passes)
        i.initialize(a, t, r);
    }
  }
  replaceRenderer(a, e = !0) {
    const t = this.renderer, r = t.domElement.parentNode;
    return this.setRenderer(a), e && r !== null && (r.removeChild(t.domElement), r.appendChild(a.domElement)), t;
  }
  createDepthTexture() {
    const a = this.depthTexture = new K3();
    return this.inputBuffer.depthTexture = a, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (a.format = r1, a.type = Kx) : a.type = D0, a;
  }
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
      for (const a of this.passes)
        a.setDepthTexture(null);
    }
  }
  createBuffer(a, e, t, r) {
    const i = this.renderer, o = i === null ? new Ft() : i.getDrawingBufferSize(new Ft()), l = {
      minFilter: Po,
      magFilter: Po,
      stencilBuffer: e,
      depthBuffer: a,
      type: t
    };
    let d;
    return r > 0 ? (d = Number(U0.replace(/\D+/g, "")) < 138 ? new g4(o.width, o.height, l) : new po(o.width, o.height, l), d.ignoreDepthForMultisampleCopy = !1, d.samples = r) : d = new po(o.width, o.height, l), t === Gf && i !== null && i.outputEncoding === Mi && (d.texture.encoding = Mi), d.texture.name = "EffectComposer.Buffer", d.texture.generateMipmaps = !1, d;
  }
  addPass(a, e) {
    const t = this.passes, r = this.renderer, i = r.getDrawingBufferSize(new Ft()), o = r.getContext().getContextAttributes().alpha, l = this.inputBuffer.texture.type;
    if (a.setRenderer(r), a.setSize(i.width, i.height), a.initialize(r, o, l), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), a.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, a) : t.push(a), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), a.needsDepthTexture || this.depthTexture !== null)
      if (this.depthTexture === null) {
        const d = this.createDepthTexture();
        for (a of t)
          a.setDepthTexture(d);
      } else
        a.setDepthTexture(this.depthTexture);
  }
  removePass(a) {
    const e = this.passes, t = e.indexOf(a);
    if (t !== -1 && e.splice(t, 1).length > 0) {
      if (this.depthTexture !== null) {
        const o = (d, h) => d || h.needsDepthTexture;
        e.reduce(o, !1) || (a.getDepthTexture() === this.depthTexture && a.setDepthTexture(null), this.deleteDepthTexture());
      }
      this.autoRenderToScreen && t === e.length && (a.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0));
    }
  }
  removeAllPasses() {
    const a = this.passes;
    this.deleteDepthTexture(), a.length > 0 && (this.autoRenderToScreen && (a[a.length - 1].renderToScreen = !1), this.passes = []);
  }
  render(a) {
    const e = this.renderer, t = this.copyPass;
    let r = this.inputBuffer, i = this.outputBuffer, o = !1, l, d, h;
    a === void 0 && (a = this.timer.update().getDelta());
    for (const m of this.passes)
      m.enabled && (m.render(e, r, i, a, o), m.needsSwap && (o && (t.renderToScreen = m.renderToScreen, l = e.getContext(), d = e.state.buffers.stencil, d.setFunc(l.NOTEQUAL, 1, 4294967295), t.render(e, r, i, a, o), d.setFunc(l.EQUAL, 1, 4294967295)), h = r, r = i, i = h), m instanceof zq ? o = !0 : m instanceof Dq && (o = !1));
  }
  setSize(a, e, t) {
    const r = this.renderer;
    if (a === void 0 || e === void 0) {
      const o = r.getSize(new Ft());
      a = o.width, e = o.height;
    }
    r.setSize(a, e, t);
    const i = r.getDrawingBufferSize(new Ft());
    this.inputBuffer.setSize(i.width, i.height), this.outputBuffer.setSize(i.width, i.height);
    for (const o of this.passes)
      o.setSize(i.width, i.height);
  }
  reset() {
    const a = this.timer.isAutoResetEnabled();
    this.dispose(), this.autoRenderToScreen = !0, this.timer.setAutoResetEnabled(a);
  }
  dispose() {
    for (const a of this.passes)
      a.dispose();
    this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose();
  }
}, Vq = class {
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [ss.FRAGMENT_HEAD, null],
      [ss.FRAGMENT_MAIN_UV, null],
      [ss.FRAGMENT_MAIN_IMAGE, null],
      [ss.VERTEX_HEAD, null],
      [ss.VERTEX_MAIN_SUPPORT, null]
    ]), this.defines = /* @__PURE__ */ new Map(), this.uniforms = /* @__PURE__ */ new Map(), this.blendModes = /* @__PURE__ */ new Map(), this.extensions = /* @__PURE__ */ new Set(), this.attributes = e1.NONE, this.varyings = /* @__PURE__ */ new Set(), this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = yv;
  }
}, Gq = class extends Set {
  constructor(a, e = 10) {
    super(), this.l = e, this.exclusive = !1, a !== void 0 && this.set(a);
  }
  get layer() {
    return this.l;
  }
  set layer(a) {
    const e = this.l;
    for (const t of this)
      t.layers.disable(e), t.layers.enable(a);
    this.l = a;
  }
  getLayer() {
    return this.layer;
  }
  setLayer(a) {
    this.layer = a;
  }
  isExclusive() {
    return this.exclusive;
  }
  setExclusive(a) {
    this.exclusive = a;
  }
  clear() {
    const a = this.layer;
    for (const e of this)
      e.layers.disable(a);
    return super.clear();
  }
  set(a) {
    this.clear();
    for (const e of a)
      this.add(e);
    return this;
  }
  indexOf(a) {
    return this.has(a) ? 0 : -1;
  }
  add(a) {
    return this.exclusive ? a.layers.set(this.layer) : a.layers.enable(this.layer), super.add(a);
  }
  delete(a) {
    return this.has(a) && a.layers.disable(this.layer), super.delete(a);
  }
  toggle(a) {
    let e;
    return this.has(a) ? (this.delete(a), e = !1) : (this.add(a), e = !0), e;
  }
  setVisible(a) {
    for (const e of this)
      a ? e.layers.enable(0) : e.layers.disable(0);
    return this;
  }
}, Wq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}", jq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}", Yq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}", Xq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", qq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}", Qq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}", Zq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}", Jq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}", Kq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}", $q = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}", eQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}", tQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}", nQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}", rQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}", iQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}", aQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}", sQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}", oQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}", lQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}", uQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", cQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}", fQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}", dQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}", hQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}", pQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}", mQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}", vQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", gQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}", yQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}", xQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}", SQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}", _Q = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}", bQ = /* @__PURE__ */ new Map([
  [li.ADD, Wq],
  [li.ALPHA, jq],
  [li.AVERAGE, Yq],
  [li.COLOR, Xq],
  [li.COLOR_BURN, qq],
  [li.COLOR_DODGE, Qq],
  [li.DARKEN, Zq],
  [li.DIFFERENCE, Jq],
  [li.DIVIDE, Kq],
  [li.DST, null],
  [li.EXCLUSION, $q],
  [li.HARD_LIGHT, eQ],
  [li.HARD_MIX, tQ],
  [li.HUE, nQ],
  [li.INVERT, rQ],
  [li.INVERT_RGB, iQ],
  [li.LIGHTEN, aQ],
  [li.LINEAR_BURN, sQ],
  [li.LINEAR_DODGE, oQ],
  [li.LINEAR_LIGHT, lQ],
  [li.LUMINOSITY, uQ],
  [li.MULTIPLY, cQ],
  [li.NEGATION, fQ],
  [li.NORMAL, dQ],
  [li.OVERLAY, hQ],
  [li.PIN_LIGHT, pQ],
  [li.REFLECT, mQ],
  [li.SATURATION, vQ],
  [li.SCREEN, gQ],
  [li.SOFT_LIGHT, yQ],
  [li.SRC, xQ],
  [li.SUBTRACT, SQ],
  [li.VIVID_LIGHT, _Q]
]), wQ = class extends Mm {
  constructor(a, e = 1) {
    super(), this._blendFunction = a, this.opacity = new Bn(e);
  }
  getOpacity() {
    return this.opacity.value;
  }
  setOpacity(a) {
    this.opacity.value = a;
  }
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(a) {
    this._blendFunction = a, this.dispatchEvent({ type: "change" });
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(a) {
    this.blendFunction = a;
  }
  getShaderCode() {
    return bQ.get(this.blendFunction);
  }
}, Cm = class extends Mm {
  constructor(a, e, {
    attributes: t = e1.NONE,
    blendFunction: r = li.NORMAL,
    defines: i = /* @__PURE__ */ new Map(),
    uniforms: o = /* @__PURE__ */ new Map(),
    extensions: l = null,
    vertexShader: d = null
  } = {}) {
    super(), this.name = a, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = d, this.defines = i, this.uniforms = o, this.extensions = l, this.blendMode = new wQ(r), this.blendMode.addEventListener("change", (h) => this.setChanged()), this._inputColorSpace = yv, this._outputColorSpace = null;
  }
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  set inputColorSpace(a) {
    this._inputColorSpace = a, this.setChanged();
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(a) {
    this._outputColorSpace = a, this.setChanged();
  }
  getName() {
    return this.name;
  }
  setRenderer(a) {
    this.renderer = a;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getExtensions() {
    return this.extensions;
  }
  getBlendMode() {
    return this.blendMode;
  }
  getAttributes() {
    return this.attributes;
  }
  setAttributes(a) {
    this.attributes = a, this.setChanged();
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  setFragmentShader(a) {
    this.fragmentShader = a, this.setChanged();
  }
  getVertexShader() {
    return this.vertexShader;
  }
  setVertexShader(a) {
    this.vertexShader = a, this.setChanged();
  }
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  setDepthTexture(a, e = o1) {
  }
  update(a, e, t) {
  }
  setSize(a, e) {
  }
  initialize(a, e, t) {
  }
  dispose() {
    for (const a of Object.keys(this)) {
      const e = this[a];
      (e instanceof po || e instanceof ff || e instanceof iu || e instanceof mh) && this[a].dispose();
    }
  }
}, EQ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`, MQ = class extends Cm {
  constructor({
    blendFunction: a = li.SCREEN,
    luminanceThreshold: e = 0.9,
    luminanceSmoothing: t = 0.025,
    mipmapBlur: r = !1,
    intensity: i = 1,
    radius: o = 0.85,
    levels: l = 8,
    kernelSize: d = tR.LARGE,
    resolutionScale: h = 0.5,
    width: m = Zu.AUTO_SIZE,
    height: S = Zu.AUTO_SIZE,
    resolutionX: _ = m,
    resolutionY: T = S
  } = {}) {
    super("BloomEffect", EQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Bn(null)],
        ["intensity", new Bn(i)]
      ])
    }), this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new hk({ kernelSize: d }), this.luminancePass = new pk({ colorOutput: !0 }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = t, this.mipmapBlurPass = new Nq(), this.mipmapBlurPass.enabled = r, this.mipmapBlurPass.radius = o, this.mipmapBlurPass.levels = l, this.uniforms.get("map").value = r ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const C = this.resolution = new Zu(this, _, T, h);
    C.addEventListener("change", (D) => this.setSize(C.baseWidth, C.baseHeight));
  }
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  getTexture() {
    return this.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getLuminancePass() {
    return this.luminancePass;
  }
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  get width() {
    return this.resolution.width;
  }
  set width(a) {
    this.resolution.preferredWidth = a;
  }
  get height() {
    return this.resolution.height;
  }
  set height(a) {
    this.resolution.preferredHeight = a;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(a) {
    this.blurPass.dithering = a;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(a) {
    this.blurPass.kernelSize = a;
  }
  get distinction() {
    return console.warn(this.name, "distinction was removed"), 1;
  }
  set distinction(a) {
    console.warn(this.name, "distinction was removed");
  }
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(a) {
    this.uniforms.get("intensity").value = a;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(a) {
    this.intensity = a;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  update(a, e, t) {
    const r = this.renderTarget, i = this.luminancePass;
    i.enabled ? (i.render(a, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(a, i.renderTarget) : this.blurPass.render(a, i.renderTarget, r)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(a, e) : this.blurPass.render(a, e, r);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t), this.luminancePass.setSize(a, e), this.mipmapBlurPass.setSize(a, e);
  }
  initialize(a, e, t) {
    this.blurPass.initialize(a, e, t), this.luminancePass.initialize(a, e, t), this.mipmapBlurPass.initialize(a, e, t), t !== void 0 && (this.renderTarget.texture.type = t, a.outputEncoding === Mi && (this.renderTarget.texture.encoding = Mi));
  }
}, TQ = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}", CQ = class extends Cm {
  constructor({ blendFunction: a = li.SRC, brightness: e = 0, contrast: t = 0 } = {}) {
    super("BrightnessContrastEffect", TQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["brightness", new Bn(e)],
        ["contrast", new Bn(t)]
      ])
    }), this.inputColorSpace = Mi;
  }
  get brightness() {
    return this.uniforms.get("brightness").value;
  }
  set brightness(a) {
    this.uniforms.get("brightness").value = a;
  }
  getBrightness(a) {
    return this.brightness;
  }
  setBrightness(a) {
    this.brightness = a;
  }
  get contrast() {
    return this.uniforms.get("contrast").value;
  }
  set contrast(a) {
    this.uniforms.get("contrast").value = a;
  }
  getContrast(a) {
    return this.contrast;
  }
  setContrast(a) {
    this.contrast = a;
  }
}, RQ = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}", AQ = class extends Cm {
  constructor({ blendFunction: a, bits: e = 16 } = {}) {
    super("ColorDepthEffect", RQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["factor", new Bn(1)]
      ])
    }), this.bits = 0, this.bitDepth = e;
  }
  get bitDepth() {
    return this.bits;
  }
  set bitDepth(a) {
    this.bits = a, this.uniforms.get("factor").value = Math.pow(2, a / 3);
  }
  getBitDepth() {
    return this.bitDepth;
  }
  setBitDepth(a) {
    this.bitDepth = a;
  }
}, DQ = `void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){
#ifdef INVERTED
vec3 color=vec3(1.0-depth);
#else
vec3 color=vec3(depth);
#endif
outputColor=vec4(color,inputColor.a);}`, LQ = class extends Cm {
  constructor({ blendFunction: a = li.SRC, inverted: e = !1 } = {}) {
    super("DepthEffect", DQ, {
      blendFunction: a,
      attributes: e1.DEPTH
    }), this.inverted = e;
  }
  get inverted() {
    return this.defines.has("INVERTED");
  }
  set inverted(a) {
    this.inverted !== a && (a ? this.defines.set("INVERTED", "1") : this.defines.delete("INVERTED"), this.setChanged());
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(a) {
    this.inverted = a;
  }
}, PQ = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}", OQ = class extends Cm {
  constructor({ blendFunction: a, angle: e = Math.PI * 0.5, scale: t = 1 } = {}) {
    super("DotScreenEffect", PQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["angle", new Bn(new Ft())],
        ["scale", new Bn(t)]
      ])
    }), this.angle = e;
  }
  get angle() {
    return Math.acos(this.uniforms.get("angle").value.y);
  }
  set angle(a) {
    this.uniforms.get("angle").value.set(Math.sin(a), Math.cos(a));
  }
  getAngle() {
    return this.angle;
  }
  setAngle(a) {
    this.angle = a;
  }
  get scale() {
    return this.uniforms.get("scale").value;
  }
  set scale(a) {
    this.uniforms.get("scale").value = a;
  }
};
new ge();
new si();
var UQ = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", zQ = class extends Cm {
  constructor({ blendFunction: a = li.SRC, hue: e = 0, saturation: t = 0 } = {}) {
    super("HueSaturationEffect", UQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["hue", new Bn(new ge())],
        ["saturation", new Bn(t)]
      ])
    }), this.hue = e;
  }
  get saturation() {
    return this.uniforms.get("saturation").value;
  }
  set saturation(a) {
    this.uniforms.get("saturation").value = a;
  }
  getSaturation() {
    return this.saturation;
  }
  setSaturation(a) {
    this.saturation = a;
  }
  get hue() {
    const a = this.uniforms.get("hue").value;
    return Math.acos((a.x * 3 - 1) / 2);
  }
  set hue(a) {
    const e = Math.sin(a), t = Math.cos(a);
    this.uniforms.get("hue").value.set(
      (2 * t + 1) / 3,
      (-Math.sqrt(3) * e - t + 1) / 3,
      (Math.sqrt(3) * e - t + 1) / 3
    );
  }
  getHue() {
    return this.hue;
  }
  setHue(a) {
    this.hue = a;
  }
};
new Pn();
var NQ = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`, FQ = class extends Cm {
  constructor({ blendFunction: a = li.SCREEN, premultiply: e = !1 } = {}) {
    super("NoiseEffect", NQ, { blendFunction: a }), this.premultiply = e;
  }
  get premultiply() {
    return this.defines.has("PREMULTIPLY");
  }
  set premultiply(a) {
    this.premultiply !== a && (a ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged());
  }
  isPremultiplied() {
    return this.premultiply;
  }
  setPremultiplied(a) {
    this.premultiply = a;
  }
}, kQ = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`, IQ = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}", BQ = class extends Cm {
  constructor(a, e, {
    blendFunction: t = li.SCREEN,
    patternTexture: r = null,
    patternScale: i = 1,
    edgeStrength: o = 1,
    pulseSpeed: l = 0,
    visibleEdgeColor: d = 16777215,
    hiddenEdgeColor: h = 2230538,
    kernelSize: m = tR.VERY_SMALL,
    blur: S = !1,
    xRay: _ = !0,
    multisampling: T = 0,
    resolutionScale: C = 0.5,
    width: D = Zu.AUTO_SIZE,
    height: P = Zu.AUTO_SIZE,
    resolutionX: U = D,
    resolutionY: B = P
  } = {}) {
    super("OutlineEffect", kQ, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new Bn(null)],
        ["edgeTexture", new Bn(null)],
        ["edgeStrength", new Bn(o)],
        ["visibleEdgeColor", new Bn(new Pn(d))],
        ["hiddenEdgeColor", new Bn(new Pn(h))],
        ["pulse", new Bn(1)],
        ["patternScale", new Bn(i)],
        ["patternTexture", new Bn(null)]
      ])
    }), this.blendMode.addEventListener("change", (X) => {
      this.blendMode.getBlendFunction() === li.ALPHA ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"), this.setChanged();
    }), this.blendMode.setBlendFunction(t), this.patternTexture = r, this.xRay = _, this.scene = a, this.camera = e, this.renderTargetMask = new po(1, 1), this.renderTargetMask.samples = T, this.renderTargetMask.texture.name = "Outline.Mask", this.uniforms.get("maskTexture").value = this.renderTargetMask.texture, this.renderTargetOutline = new po(1, 1, { depthBuffer: !1 }), this.renderTargetOutline.texture.name = "Outline.Edges", this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture, this.clearPass = new FL(), this.clearPass.overrideClearColor = new Pn(0), this.clearPass.overrideClearAlpha = 1, this.depthPass = new Lq(a, e), this.maskPass = new nR(a, e, new uq(this.depthPass.texture, e));
    const k = this.maskPass.clearPass;
    k.overrideClearColor = new Pn(16777215), k.overrideClearAlpha = 1, this.blurPass = new hk({ resolutionScale: C, resolutionX: U, resolutionY: B, kernelSize: m }), this.blurPass.enabled = S;
    const V = this.blurPass.resolution;
    V.addEventListener("change", (X) => this.setSize(V.baseWidth, V.baseHeight)), this.outlinePass = new kq(new wq());
    const I = this.outlinePass.fullscreenMaterial;
    I.inputBuffer = this.renderTargetMask.texture, this.time = 0, this.selection = new Gq(), this.selection.layer = 10, this.pulseSpeed = l;
  }
  get resolution() {
    return this.blurPass.resolution;
  }
  getResolution() {
    return this.blurPass.getResolution();
  }
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(a) {
    this.renderTargetMask.samples = a, this.renderTargetMask.dispose();
  }
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(a) {
    this.uniforms.get("patternScale").value = a;
  }
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(a) {
    this.uniforms.get("edgeStrength").value = a;
  }
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(a) {
    this.uniforms.get("visibleEdgeColor").value = a;
  }
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(a) {
    this.uniforms.get("hiddenEdgeColor").value = a;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getSelection() {
    return this.selection;
  }
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  setPulseSpeed(a) {
    this.pulseSpeed = a;
  }
  get width() {
    return this.resolution.width;
  }
  set width(a) {
    this.resolution.preferredWidth = a;
  }
  get height() {
    return this.resolution.height;
  }
  set height(a) {
    this.resolution.preferredHeight = a;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(a) {
    this.selection.layer = a;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(a) {
    this.blurPass.dithering = a;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(a) {
    this.blurPass.kernelSize = a;
  }
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(a) {
    this.blurPass.enabled = a;
  }
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(a) {
    this.xRay !== a && (a ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"), this.setChanged());
  }
  isXRayEnabled() {
    return this.xRay;
  }
  setXRayEnabled(a) {
    this.xRay = a;
  }
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(a) {
    if (a !== null ? (a.wrapS = a.wrapT = Qb, this.defines.set("USE_PATTERN", "1"), this.setVertexShader(IQ)) : (this.defines.delete("USE_PATTERN"), this.setVertexShader(null)), this.renderer !== null) {
      const e = vN(a, this.renderer.capabilities.isWebGL2);
      this.defines.set("texelToLinear(texel)", e);
    }
    this.uniforms.get("patternTexture").value = a, this.setChanged();
  }
  setPatternTexture(a) {
    this.patternTexture = a;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  setSelection(a) {
    return this.selection.set(a), this;
  }
  clearSelection() {
    return this.selection.clear(), this;
  }
  selectObject(a) {
    return this.selection.add(a), this;
  }
  deselectObject(a) {
    return this.selection.delete(a), this;
  }
  update(a, e, t) {
    const r = this.scene, i = this.camera, o = this.selection, d = this.uniforms.get("pulse"), h = r.background, m = i.layers.mask;
    o.size > 0 ? (r.background = null, d.value = 1, this.pulseSpeed > 0 && (d.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625), this.time += t, o.setVisible(!1), this.depthPass.render(a), o.setVisible(!0), i.layers.set(o.layer), this.maskPass.render(a, this.renderTargetMask), i.layers.mask = m, r.background = h, this.outlinePass.render(a, null, this.renderTargetOutline), this.blurPass.enabled && this.blurPass.render(a, this.renderTargetOutline, this.renderTargetOutline)) : this.time > 0 && (this.clearPass.render(a, this.renderTargetOutline), this.time = 0);
  }
  setSize(a, e) {
    this.blurPass.setSize(a, e), this.renderTargetMask.setSize(a, e);
    const t = this.resolution;
    t.setBaseSize(a, e);
    const r = t.width, i = t.height;
    this.depthPass.setSize(r, i), this.renderTargetOutline.setSize(r, i), this.outlinePass.fullscreenMaterial.setSize(r, i);
  }
  initialize(a, e, t) {
    const r = this.patternTexture, i = vN(r, a.capabilities.isWebGL2);
    this.defines.set("texelToLinear(texel)", i), this.blurPass.initialize(a, e, Gf), t !== void 0 && (this.depthPass.initialize(a, e, t), this.maskPass.initialize(a, e, t), this.outlinePass.initialize(a, e, t));
  }
}, HQ = `uniform float count;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;
#ifdef SCROLL
y+=time*scrollSpeed;
#endif
vec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`, VQ = class extends Cm {
  constructor({ blendFunction: a = li.OVERLAY, density: e = 1.25, scrollSpeed: t = 0 } = {}) {
    super("ScanlineEffect", HQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["count", new Bn(0)],
        ["scrollSpeed", new Bn(0)]
      ])
    }), this.resolution = new Ft(), this.d = e, this.scrollSpeed = t;
  }
  get density() {
    return this.d;
  }
  set density(a) {
    this.d = a, this.setSize(this.resolution.width, this.resolution.height);
  }
  getDensity() {
    return this.density;
  }
  setDensity(a) {
    this.density = a;
  }
  get scrollSpeed() {
    return this.uniforms.get("scrollSpeed").value;
  }
  set scrollSpeed(a) {
    this.uniforms.get("scrollSpeed").value = a, a === 0 ? this.defines.delete("SCROLL") && this.setChanged() : this.defines.has("SCROLL") || (this.defines.set("SCROLL", "1"), this.setChanged());
  }
  setSize(a, e) {
    this.resolution.set(a, e), this.uniforms.get("count").value = Math.round(e * this.density);
  }
}, GQ = "uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}", WQ = "uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}", jQ = Math.PI * 0.5, fM = new ge(), xN = new ge(), YQ = class extends Cm {
  constructor(a, e = new ge(), {
    speed: t = 2,
    maxRadius: r = 1,
    waveSize: i = 0.2,
    amplitude: o = 0.05
  } = {}) {
    super("ShockWaveEffect", GQ, {
      vertexShader: WQ,
      uniforms: /* @__PURE__ */ new Map([
        ["active", new Bn(!1)],
        ["center", new Bn(new Ft(0.5, 0.5))],
        ["cameraDistance", new Bn(1)],
        ["size", new Bn(1)],
        ["radius", new Bn(-i)],
        ["maxRadius", new Bn(r)],
        ["waveSize", new Bn(i)],
        ["amplitude", new Bn(o)]
      ])
    }), this.position = e, this.speed = t, this.camera = a, this.screenPosition = this.uniforms.get("center").value, this.time = 0, this.active = !1;
  }
  get amplitude() {
    return this.uniforms.get("amplitude").value;
  }
  set amplitude(a) {
    this.uniforms.get("amplitude").value = a;
  }
  get waveSize() {
    return this.uniforms.get("waveSize").value;
  }
  set waveSize(a) {
    this.uniforms.get("waveSize").value = a;
  }
  get maxRadius() {
    return this.uniforms.get("maxRadius").value;
  }
  set maxRadius(a) {
    this.uniforms.get("maxRadius").value = a;
  }
  get epicenter() {
    return this.position;
  }
  set epicenter(a) {
    this.position = a;
  }
  getPosition() {
    return this.position;
  }
  setPosition(a) {
    this.position = a;
  }
  getSpeed() {
    return this.speed;
  }
  setSpeed(a) {
    this.speed = a;
  }
  explode() {
    this.time = 0, this.active = !0, this.uniforms.get("active").value = !0;
  }
  update(a, e, t) {
    const r = this.position, i = this.camera, o = this.uniforms, l = o.get("active");
    if (this.active) {
      const d = o.get("waveSize").value;
      i.getWorldDirection(fM), xN.copy(i.position).sub(r), l.value = fM.angleTo(xN) > jQ, l.value && (o.get("cameraDistance").value = i.position.distanceTo(r), fM.copy(r).project(i), this.screenPosition.set((fM.x + 1) * 0.5, (fM.y + 1) * 0.5)), this.time += t * this.speed;
      const h = this.time - d;
      o.get("radius").value = h, h >= (o.get("maxRadius").value + d) * 2 && (this.active = !1, l.value = !1);
    }
  }
}, XQ = "uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}", qQ = class extends Cm {
  constructor({ blendFunction: a, intensity: e = 1 } = {}) {
    super("SepiaEffect", XQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["weightsR", new Bn(new ge(0.393, 0.769, 0.189))],
        ["weightsG", new Bn(new ge(0.349, 0.686, 0.168))],
        ["weightsB", new Bn(new ge(0.272, 0.534, 0.131))]
      ])
    });
  }
  get intensity() {
    return this.blendMode.opacity.value;
  }
  set intensity(a) {
    this.blendMode.opacity.value = a;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(a) {
    this.intensity = a;
  }
  get weightsR() {
    return this.uniforms.get("weightsR").value;
  }
  get weightsG() {
    return this.uniforms.get("weightsG").value;
  }
  get weightsB() {
    return this.uniforms.get("weightsB").value;
  }
}, QQ = `#include <tonemapping_pars_fragment>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
uniform lowp sampler2D luminanceBuffer;uniform float whitePoint;uniform float middleGrey;
#if TONE_MAPPING_MODE != 2
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 2
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`, ZQ = class extends Cm {
  constructor({
    blendFunction: a = li.SRC,
    adaptive: e = !0,
    mode: t = e ? T0.REINHARD2_ADAPTIVE : T0.REINHARD2,
    resolution: r = 256,
    maxLuminance: i = 16,
    whitePoint: o = i,
    middleGrey: l = 0.6,
    minLuminance: d = 0.01,
    averageLuminance: h = 1,
    adaptationRate: m = 1
  } = {}) {
    super("ToneMappingEffect", QQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["luminanceBuffer", new Bn(null)],
        ["maxLuminance", new Bn(i)],
        ["whitePoint", new Bn(o)],
        ["middleGrey", new Bn(l)],
        ["averageLuminance", new Bn(h)]
      ])
    }), this.renderTargetLuminance = new po(1, 1, {
      minFilter: s1,
      depthBuffer: !1
    }), this.renderTargetLuminance.texture.generateMipmaps = !0, this.renderTargetLuminance.texture.name = "Luminance", this.luminancePass = new pk({
      renderTarget: this.renderTargetLuminance
    }), this.adaptiveLuminancePass = new Aq(this.luminancePass.texture, {
      minLuminance: d,
      adaptationRate: m
    }), this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture, this.resolution = r, this.mode = t;
  }
  get mode() {
    return Number(this.defines.get("TONE_MAPPING_MODE"));
  }
  set mode(a) {
    if (this.mode !== a) {
      switch (this.defines.clear(), this.defines.set("TONE_MAPPING_MODE", a.toFixed(0)), a) {
        case T0.REINHARD:
          this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
          break;
        case T0.OPTIMIZED_CINEON:
          this.defines.set("toneMapping(texel)", "OptimizedCineonToneMapping(texel)");
          break;
        case T0.ACES_FILMIC:
          this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
          break;
        default:
          this.defines.set("toneMapping(texel)", "texel");
          break;
      }
      this.adaptiveLuminancePass.enabled = a === T0.REINHARD2_ADAPTIVE, this.setChanged();
    }
  }
  getMode() {
    return this.mode;
  }
  setMode(a) {
    this.mode = a;
  }
  get whitePoint() {
    return this.uniforms.get("whitePoint").value;
  }
  set whitePoint(a) {
    this.uniforms.get("whitePoint").value = a;
  }
  get middleGrey() {
    return this.uniforms.get("middleGrey").value;
  }
  set middleGrey(a) {
    this.uniforms.get("middleGrey").value = a;
  }
  get averageLuminance() {
    return this.uniforms.get("averageLuminance").value;
  }
  set averageLuminance(a) {
    this.uniforms.get("averageLuminance").value = a;
  }
  get adaptiveLuminanceMaterial() {
    return this.adaptiveLuminancePass.fullscreenMaterial;
  }
  getAdaptiveLuminanceMaterial() {
    return this.adaptiveLuminanceMaterial;
  }
  get resolution() {
    return this.luminancePass.resolution.width;
  }
  set resolution(a) {
    const e = Math.max(0, Math.ceil(Math.log2(a))), t = Math.pow(2, e);
    this.luminancePass.resolution.setPreferredSize(t, t), this.adaptiveLuminanceMaterial.mipLevel1x1 = e;
  }
  getResolution() {
    return this.resolution;
  }
  setResolution(a) {
    this.resolution = a;
  }
  get adaptive() {
    return this.mode === T0.REINHARD2_ADAPTIVE;
  }
  set adaptive(a) {
    this.mode = a ? T0.REINHARD2_ADAPTIVE : T0.REINHARD2;
  }
  get adaptationRate() {
    return this.adaptiveLuminanceMaterial.adaptationRate;
  }
  set adaptationRate(a) {
    this.adaptiveLuminanceMaterial.adaptationRate = a;
  }
  get distinction() {
    return console.warn(this.name, "distinction was removed."), 1;
  }
  set distinction(a) {
    console.warn(this.name, "distinction was removed.");
  }
  update(a, e, t) {
    this.adaptiveLuminancePass.enabled && (this.luminancePass.render(a, e), this.adaptiveLuminancePass.render(a, null, null, t));
  }
  initialize(a, e, t) {
    this.adaptiveLuminancePass.initialize(a, e, t);
  }
}, JQ = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`, KQ = class extends Cm {
  constructor({
    blendFunction: a,
    technique: e = lC.DEFAULT,
    eskil: t = !1,
    offset: r = 0.5,
    darkness: i = 0.5
  } = {}) {
    super("VignetteEffect", JQ, {
      blendFunction: a,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", e.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Bn(r)],
        ["darkness", new Bn(i)]
      ])
    });
  }
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(a) {
    this.technique !== a && (this.defines.set("VIGNETTE_TECHNIQUE", a.toFixed(0)), this.setChanged());
  }
  get eskil() {
    return this.technique === lC.ESKIL;
  }
  set eskil(a) {
    this.technique = a ? lC.ESKIL : lC.DEFAULT;
  }
  getTechnique() {
    return this.technique;
  }
  setTechnique(a) {
    this.technique = a;
  }
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(a) {
    this.uniforms.get("offset").value = a;
  }
  getOffset() {
    return this.offset;
  }
  setOffset(a) {
    this.offset = a;
  }
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(a) {
    this.uniforms.get("darkness").value = a;
  }
  getDarkness() {
    return this.darkness;
  }
  setDarkness(a) {
    this.darkness = a;
  }
};
let dM;
function $Q() {
  if (dM !== void 0)
    return dM;
  try {
    var a;
    let e;
    const t = document.createElement("canvas");
    return dM = !!(window.WebGL2RenderingContext && (e = t.getContext("webgl2"))), e && ((a = e.getExtension("WEBGL_lose_context")) === null || a === void 0 || a.loseContext()), dM;
  } catch {
    return dM = !1;
  }
}
const eZ = (a) => !!a.current, SN = (a) => eZ(a) ? a.current : a, xv = function(a, e) {
  return e === void 0 && (e = li.NORMAL), /* @__PURE__ */ a1(function(r, i) {
    let {
      blendFunction: o,
      opacity: l,
      ...d
    } = r;
    const h = Od((S) => S.invalidate), m = qb(() => new a(d), [d]);
    return I3(() => {
      m.blendMode.blendFunction = !o && o !== 0 ? e : o, l !== void 0 && (m.blendMode.opacity.value = l), h();
    }, [o, m.blendMode, l]), /* @__PURE__ */ _n("primitive", {
      ref: i,
      object: m,
      dispose: null
    });
  });
};
xv(MQ, li.ADD);
xv(CQ);
xv(AQ);
xv(LQ);
const mk = /* @__PURE__ */ OC(null), tZ = /* @__PURE__ */ hh.memo(/* @__PURE__ */ a1((a, e) => {
  let {
    children: t,
    camera: r,
    scene: i,
    resolutionScale: o,
    enabled: l = !0,
    renderPriority: d = 1,
    autoClear: h = !0,
    depthBuffer: m,
    disableNormalPass: S,
    stencilBuffer: _,
    multisampling: T = 8,
    frameBufferType: C = GS
  } = a;
  const {
    gl: D,
    scene: P,
    camera: U,
    size: B
  } = Od();
  i = i || P, r = r || U;
  const [k, V, I] = qb(() => {
    const $ = $Q(), W = new Hq(D, {
      depthBuffer: m,
      stencilBuffer: _,
      multisampling: T > 0 && $ ? T : 0,
      frameBufferType: C
    });
    W.addPass(new nR(i, r));
    let ee = null, ie = null;
    return S || (ie = new Fq(i, r), ie.enabled = !1, W.addPass(ie), o !== void 0 && $ && (ee = new Pq({
      normalBuffer: ie.texture,
      resolutionScale: o
    }), ee.enabled = !1, W.addPass(ee))), [W, ie, ee];
  }, [r, D, m, _, T, C, i, S, o]);
  fh(() => k == null ? void 0 : k.setSize(B.width, B.height), [k, B]), yy(($, W) => {
    l && (D.autoClear = h, k.render(W));
  }, l ? d : 0);
  const X = uo(null);
  I3(() => {
    let $;
    return X.current && X.current.__r3f && k && ($ = new Uq(r, ...X.current.__r3f.objects), $.renderToScreen = !0, k.addPass($), V && (V.enabled = !0), I && (I.enabled = !0)), () => {
      $ && (k == null || k.removePass($)), V && (V.enabled = !1), I && (I.enabled = !1);
    };
  }, [k, t, r, V, I]);
  const J = qb(() => ({
    composer: k,
    normalPass: V,
    downSamplingPass: I,
    resolutionScale: o,
    camera: r,
    scene: i
  }), [k, V, I, o, r, i]);
  return g5(e, () => k, [k]), /* @__PURE__ */ _n(mk.Provider, {
    value: J,
    children: /* @__PURE__ */ _n("group", {
      ref: X,
      children: t
    })
  });
}));
xv(OQ);
xv(zQ);
xv(FQ, li.COLOR_DODGE);
const kL = /* @__PURE__ */ OC(null);
function nZ(a) {
  let {
    children: e,
    enabled: t = !0
  } = a;
  const [r, i] = kb([]), o = qb(() => ({
    selected: r,
    select: i,
    enabled: t
  }), [r, i, t]);
  return /* @__PURE__ */ hh.createElement(kL.Provider, {
    value: o
  }, e);
}
function vk(a) {
  let {
    enabled: e = !1,
    children: t,
    ...r
  } = a;
  const i = uo(null), o = MM(kL);
  return fh(() => {
    if (o && e) {
      let l = !1;
      const d = [];
      if (i.current.traverse((h) => {
        h.type === "Mesh" && d.push(h), o.selected.indexOf(h) === -1 && (l = !0);
      }), l)
        return o.select((h) => [...h, ...d]), () => {
          o.select((h) => h.filter((m) => !d.includes(m)));
        };
    }
  }, [e, t]), /* @__PURE__ */ _n("group", {
    ref: i,
    ...r,
    children: t
  });
}
const rZ = /* @__PURE__ */ a1(function(e, t) {
  let {
    selection: r = [],
    selectionLayer: i = 10,
    blendFunction: o,
    patternTexture: l,
    edgeStrength: d,
    pulseSpeed: h,
    visibleEdgeColor: m,
    hiddenEdgeColor: S,
    width: _,
    height: T,
    kernelSize: C,
    blur: D,
    xRay: P,
    ...U
  } = e;
  const B = Od((J) => J.invalidate), {
    scene: k,
    camera: V
  } = MM(mk), I = qb(() => new BQ(k, V, {
    blendFunction: o,
    patternTexture: l,
    edgeStrength: d,
    pulseSpeed: h,
    visibleEdgeColor: m,
    hiddenEdgeColor: S,
    width: _,
    height: T,
    kernelSize: C,
    blur: D,
    xRay: P,
    ...U
  }), [o, D, V, d, T, S, C, l, h, k, m, _, P]), X = MM(kL);
  return fh(() => {
    if (!X && r)
      return I.selection.set(Array.isArray(r) ? r.map(SN) : [SN(r)]), B(), () => {
        I.selection.clear(), B();
      };
  }, [I, r, X]), fh(() => {
    I.selectionLayer = i, B();
  }, [I, i]), uo(), fh(() => {
    if (X && X.enabled) {
      var J;
      if ((J = X.selected) != null && J.length)
        return I.selection.set(X.selected), B(), () => {
          I.selection.clear(), B();
        };
    }
  }, [X]), /* @__PURE__ */ _n("primitive", {
    ref: t,
    object: I
  });
});
xv(VQ, li.OVERLAY);
xv(qQ);
xv(ZQ);
xv(KQ);
xv(YQ);
const iZ = ["cube", "cylinder", "sphere", "capsule", "arrow"], gk = OC(), aZ = (a) => {
  const t = MM(gk)[a.shape];
  return iZ.includes(a.shape) ? ZX(a) : t && typeof t == "function" ? t() : (console.warn(`Shape not loaded: ${a.shape} (reading property 'shape' of item)`, a), []);
}, sZ = ({
  meshes: a,
  children: e
}) => /* @__PURE__ */ _n(gk.Provider, {
  value: a,
  children: e
}), oZ = QM(a1(({
  objectKey: a,
  highlightColor: e,
  position: t,
  rotation: r,
  scale: i,
  ghost: o
}, l) => {
  const d = uo(null), h = sT(l, d), m = ho((P) => P.onClick), S = ho((P) => P.onPointerOver), _ = ho((P) => P.onPointerOut), T = ho((P) => P.clock), C = ho(Op((P) => P.items[a], [a])), D = aZ(C);
  return yy(Op(() => {
    const P = T.getElapsed() * 1e3;
    h.current && (h.current.position.set(t ? t.x : typeof C.position.x == "function" ? C.position.x(P) : C.position.x, t ? t.y : typeof C.position.y == "function" ? C.position.y(P) : C.position.y, t ? t.z : typeof C.position.z == "function" ? C.position.z(P) : C.position.z), h.current.quaternion.set(r ? r.x : typeof C.rotation.x == "function" ? C.rotation.x(P) : C.rotation.x, r ? r.y : typeof C.rotation.y == "function" ? C.rotation.y(P) : C.rotation.y, r ? r.z : typeof C.rotation.z == "function" ? C.rotation.z(P) : C.rotation.z, r ? r.w : typeof C.rotation.w == "function" ? C.rotation.w(P) : C.rotation.w), h.current.scale.set(i ? i.x : typeof C.scale.x == "function" ? C.scale.x(P) : C.scale.x, i ? i.y : typeof C.scale.y == "function" ? C.scale.y(P) : C.scale.y, i ? i.z : typeof C.scale.z == "function" ? C.scale.z(P) : C.scale.z), h.current.visible = typeof C.hidden == "function" ? !C.hidden(P) : !C.hidden);
  }, [C, t, r, i, h, T])), /* @__PURE__ */ _n(vk, {
    enabled: C.highlighted,
    children: /* @__PURE__ */ dh("group", {
      ref: h,
      up: [0, 0, 1],
      children: [/* @__PURE__ */ _n("group", {
        up: [0, 0, 1],
        rotation: [Math.PI / 2, 0, 0],
        onPointerDown: (P) => {
          m(a, !h.current.visible, P);
        },
        onPointerOver: (P) => {
          S(a, !h.current.visible, P);
        },
        onPointerOut: (P) => {
          _(a, !h.current.visible, P);
        },
        children: D.map((P, U) => /* @__PURE__ */ _n(yk, {
          idx: U,
          groupOrPart: P,
          objectKey: a,
          ghost: o,
          highlightColor: e
        }, U))
      }), C.showName && /* @__PURE__ */ _n(G4, {
        distanceFactor: 3,
        position: [0, 0, 0.2],
        children: /* @__PURE__ */ _n("div", {
          style: {
            opacity: 0.75,
            borderRadius: 2,
            backgroundColor: "lightgrey",
            padding: 5,
            userSelect: "none"
          },
          children: C.name
        })
      })]
    })
  });
})), lZ = QM(({
  part: a,
  objectKey: e,
  ghost: t,
  highlightColor: r
}) => {
  const i = ho(Op((S) => S.items[e].wireframe, [e])), o = ho(Op((S) => S.items[e].color, [e])), l = o !== void 0, d = uo(), h = uo(), m = ho((S) => S.clock);
  return yy(Op(() => {
    const S = m.getElapsed() * 1e3;
    t || (qM(h, o, S), qM(d, o, S));
  }, [t, d, h, m, o])), t ? /* @__PURE__ */ _n("mesh", {
    ref: h,
    geometry: a.geometry,
    material: xC(r),
    scale: a.scale,
    castShadow: !1,
    receiveShadow: !1
  }, "B") : l ? /* @__PURE__ */ dh("group", {
    up: [0, 0, 1],
    children: [/* @__PURE__ */ _n("mesh", {
      ref: h,
      geometry: a.geometry,
      scale: a.scale,
      castShadow: !1,
      receiveShadow: !1,
      children: /* @__PURE__ */ _n("meshLambertMaterial", {
        transparent: !0,
        wireframe: i,
        attach: "material",
        opacity: 1,
        side: uf
      })
    }, "B"), /* @__PURE__ */ _n("mesh", {
      ref: d,
      geometry: a.geometry,
      scale: a.scale,
      castShadow: !1,
      receiveShadow: !1,
      children: /* @__PURE__ */ _n("meshLambertMaterial", {
        transparent: !0,
        attach: "material",
        wireframe: i,
        opacity: 1,
        side: py
      })
    }, "F")]
  }) : /* @__PURE__ */ _n(rT, {
    children: /* @__PURE__ */ _n("mesh", {
      ref: d,
      geometry: a.geometry,
      material: a.material,
      scale: a.scale,
      castShadow: !0,
      receiveShadow: !0,
      wireframe: i
    }, "I")
  });
}), yk = QM(({
  idx: a,
  groupOrPart: e,
  ghost: t,
  objectKey: r,
  highlightColor: i
}) => e.type === "group" ? /* @__PURE__ */ _n("group", {
  up: [0, 0, 1],
  position: e.position,
  rotation: e.rotation,
  scale: e.scale,
  children: e.children.map((o, l) => /* @__PURE__ */ _n(yk, {
    idx: l,
    groupOrPart: o,
    objectKey: r,
    ghost: t,
    highlightColor: i
  }, l))
}, a) : /* @__PURE__ */ _n(lZ, {
  part: e,
  objectKey: r,
  highlightColor: i,
  ghost: t
}, a)), uZ = a1(({
  objectKey: a
}, e) => {
  const t = uo(null), r = sT(e, t), {
    vertices: i,
    width: o,
    hidden: l
  } = ho(Op((d) => ({
    vertices: d.lines[a].vertices,
    width: d.lines[a].width,
    hidden: d.lines[a].hidden
  }), [a]));
  return i.length <= 1 ? null : /* @__PURE__ */ _n(Uj, {
    ref: r,
    visible: !l,
    points: i.map((d) => [d.position.x, d.position.y, d.position.z]),
    color: "white",
    vertexColors: i.map((d) => [d.color.r / 255, d.color.g / 255, d.color.b / 255]),
    lineWidth: o
  });
});
function EM(a, e) {
  if (Object.is(a, e))
    return !0;
  if (typeof a != "object" || a === null || typeof e != "object" || e === null)
    return !1;
  const t = Object.keys(a);
  if (t.length !== Object.keys(e).length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!Object.prototype.hasOwnProperty.call(e, t[r]) || !Object.is(a[t[r]], e[t[r]]))
      return !1;
  return !0;
}
const cZ = a1(({
  objectKey: a
}, e) => {
  const t = uo(null), r = sT(e, t), i = ho((D) => D.onClick), o = ho((D) => D.onPointerOver), l = ho((D) => D.onPointerOut), d = ho(Op((D) => D.hulls[a], [a]), EM), h = ho(Op((D) => D.hulls[a].vertices, [a])), m = ho((D) => D.clock), S = uo(), _ = uo(), T = typeof h == "function" ? h(0) : h, C = new Az(T.map((D) => new ge(D.x, D.y, D.z)));
  return yy(Op(() => {
    const D = m.getElapsed() * 1e3;
    qM(_, d.color, D), qM(S, d.color, D);
    const P = typeof h == "function" ? h(D) : h;
    if (P !== T) {
      const B = new Az(P.map((k) => new ge(k.x, k.y, k.z)));
      S.current.geometry = B, _.current.geometry = B;
    }
    const U = typeof d.hidden == "function" ? !d.hidden(D) : !d.hidden;
    S.current.visible = U, _.current.visible = U;
  }, [S, _, T, d, m, h])), /* @__PURE__ */ _n(vk, {
    enabled: d.highlighted,
    children: /* @__PURE__ */ dh("group", {
      ref: r,
      up: [0, 0, 1],
      children: [/* @__PURE__ */ dh("group", {
        up: [0, 0, 1],
        onPointerDown: (D) => {
          i(a, S.current.visible, D);
        },
        onPointerOver: (D) => {
          o(a, S.current.visible, D);
        },
        onPointerOut: (D) => {
          l(a, S.current.visible, D);
        },
        children: [/* @__PURE__ */ _n("mesh", {
          ref: _,
          geometry: C,
          castShadow: !1,
          receiveShadow: !1,
          children: /* @__PURE__ */ _n("meshLambertMaterial", {
            transparent: !0,
            wireframe: d.wireframe,
            attach: "material",
            side: uf
          })
        }, `${a}B`), /* @__PURE__ */ _n("mesh", {
          ref: S,
          geometry: C,
          castShadow: !1,
          receiveShadow: !1,
          children: /* @__PURE__ */ _n("meshLambertMaterial", {
            transparent: !0,
            attach: "material",
            wireframe: d.wireframe,
            side: py
          })
        }, `${a}F`)]
      }), d.showName && /* @__PURE__ */ _n(G4, {
        distanceFactor: 2,
        position: [0, 0, 0.5],
        children: /* @__PURE__ */ _n("div", {
          style: {
            opacity: 0.75,
            borderRadius: 2,
            backgroundColor: "lightgrey"
          },
          className: "disable-text-selection",
          children: d.name
        })
      })]
    })
  });
}), fZ = a1(({
  objectKey: a
}, e) => {
  const t = uo(null), r = sT(e, t), i = uo(), o = ho((d) => d.clock), l = ho(Op((d) => d.texts[a], [a]));
  return yy(Op(() => {
    const d = o.getElapsed() * 1e3;
    r.current && (r.current.position.set(typeof l.position.x == "function" ? l.position.x(d) : l.position.x, typeof l.position.y == "function" ? l.position.y(d) : l.position.y, typeof l.position.z == "function" ? l.position.z(d) : l.position.z), r.current.visible = typeof l.hidden == "function" ? !l.hidden(d) : !l.hidden), i.current && qM(i, l.color, d);
  }, [l, r, o])), /* @__PURE__ */ _n("group", {
    ref: r,
    children: /* @__PURE__ */ _n(Oj, {
      follow: !0,
      children: /* @__PURE__ */ _n(xY, {
        ref: i,
        depthOffset: 2,
        children: l.value
      })
    })
  });
}), IL = QM(({
  activeTf: a,
  displayTfs: e,
  allTfs: t,
  allItems: r,
  allLines: i,
  allHulls: o,
  allTexts: l,
  highlightColor: d,
  ghosts: h,
  targetRef: m,
  targetId: S,
  targetSource: _,
  filterActive: T,
  tfFilter: C,
  customProps: D
}) => {
  const P = a === "world" ? KX : a === "gizmo" ? $X : JX, U = a === S ? D : {}, B = T ? t.filter((V) => C.includes(V.key)) : t, k = T && a !== m;
  return /* @__PURE__ */ dh(P, {
    objectKey: a,
    displayTfs: e,
    ref: S === a ? m : null,
    ...U,
    ghost: h,
    highlightColor: d,
    children: [B.filter((V) => V.frame === a || a === "world" && !V.frame).map((V) => /* @__PURE__ */ _n(IL, {
      activeTf: V.key,
      displayTfs: e,
      allTfs: t,
      allItems: r,
      allLines: i,
      allHulls: o,
      allTexts: l,
      highlightColor: d,
      ghosts: h,
      targetRef: m,
      targetSource: _,
      targetId: S,
      filterActive: k,
      tfFilter: C,
      customProps: D
    }, V.key)), r.filter((V) => V.frame === a || a === "world" && !V.frame).map((V) => {
      const I = V.key === S && _ === "items" ? D : {};
      return !T || V.key === S || a === S ? /* @__PURE__ */ _n(oZ, {
        objectKey: V.key,
        highlightColor: d,
        ghost: h,
        ref: V.key === S ? m : null,
        ...I
      }, V.key) : null;
    }), i.filter((V) => V.frame === a || a === "world" && !V.frame).map((V) => {
      const I = V.key === S && _ === "lines" ? D : {};
      return !T || V.key === S || a === S ? /* @__PURE__ */ _n(uZ, {
        objectKey: V.key,
        ref: V.lineKey === S ? m : null,
        ...I
      }, V.key) : null;
    }), o.filter((V) => V.frame === a || a === "world" && !V.frame).map((V) => {
      const I = V.key === S && _ === "hulls" ? D : {};
      return !T || V.key === S || a === S ? /* @__PURE__ */ _n(cZ, {
        objectKey: V.key,
        highlightColor: d,
        ghost: h,
        ref: V.key === S ? m : null,
        ...I
      }, V.key) : null;
    }), l.filter((V) => V.frame === a || a === "world" && !V.frame).map((V) => {
      const I = V.key === S && _ === "texts" ? D : {};
      return !T || V.key === S || a === S ? /* @__PURE__ */ _n(fZ, {
        objectKey: V.key,
        highlightColor: d,
        ref: V.key === S ? m : null,
        ...I
      }, V.key) : null;
    })]
  });
}), dZ = ["enabled", "axis", "translationSnap", "rotationSnap", "scaleSnap", "space", "size"], hZ = ["displayTfs", "allTfs", "allItems", "allLines", "allHulls", "allTexts", "highlightColor"], pZ = QM(({
  camera: a,
  objectInfo: e,
  highlightColor: t,
  translateSnap: r,
  rotateSnap: i,
  scaleSnap: o,
  onDragStart: l,
  onDragEnd: d,
  mode: h,
  ...m
}) => {
  const S = ED(m, dZ), _ = ED(m, hZ), T = ho(Op((ce) => {
    let Ee = [];
    e.source === "tfs" && Ee.push(e.key);
    let de = ce[e.source][e.key].frame;
    for (; de && de !== "world" && de !== "gizmo"; ) {
      let Fe = ce.tfs[de];
      Ee.push(de), de = Fe.frame;
    }
    return Ee;
  }, [e]), EM), C = uo(), D = uo(), P = ho((ce) => ED(ce[e.source][e.key], ["position", "rotation", "scale"]), EM), U = Od(({
    gl: ce
  }) => ce), B = Od(({
    camera: ce
  }) => ce), k = Od(({
    invalidate: ce
  }) => ce), V = a || B, [I] = kb(() => new OX(V, U.domElement));
  I.translationSnap = r, I.rotationSnap = i, I.scaleSnap = o, h != null && h.includes("translate") ? I.mode = "translate" : h != null && h.includes("rotate") ? I.mode = "rotate" : h != null && h.includes("scale") && (I.mode = "scale"), h != null && h.includes("-x") ? (I.showY = !1, I.showZ = !1) : h != null && h.includes("-y") ? (I.showX = !1, I.showZ = !1) : h != null && h.includes("-z") && (I.showX = !1, I.showY = !1);
  const [X, J] = kb(!1), [$, W] = kb(P), [ee, ie] = kb(!1);
  fh(() => {
    console.log("refreshing transform"), W(P);
  }, [P, ee]);
  const pe = ho((ce) => ce.onMove, EM);
  return fh(() => {
    const ce = (Ee) => {
      var Be, he, fe;
      const de = (Be = D == null ? void 0 : D.current) == null ? void 0 : Be.position, Fe = (he = D == null ? void 0 : D.current) == null ? void 0 : he.quaternion, Ce = (fe = D == null ? void 0 : D.current) == null ? void 0 : fe.scale;
      Ee.value && !X ? (console.log("starting transform"), J(!0), W({
        position: de,
        rotation: Fe,
        scale: Ce
      }), l && l()) : !Ee.value && X && (console.log("stopping transform"), J(!1), d && d(), pe(e.key, e.source, {
        position: I.worldPosition,
        quaternion: I.worldQuaternion,
        scale: I._worldScale
      }, {
        position: de ? {
          x: de.x,
          y: de.y,
          z: de.z
        } : null,
        quaternion: Fe ? {
          x: Fe.x,
          y: Fe.y,
          z: Fe.z,
          w: Fe.w
        } : null,
        scale: Ce ? {
          x: Ce.x,
          y: Ce.y,
          z: Ce.z
        } : null
      }), ie(!ee));
    };
    return I && I.addEventListener("dragging-changed", ce), () => {
      I.removeEventListener("dragging-changed", ce);
    };
  }, [P, X, e]), fh(() => void (I == null ? void 0 : I.attach(D.current)), [D, I]), fh(() => (I && I.addEventListener("change", k), () => {
    var ce;
    return (ce = I == null ? void 0 : I.removeEventListener) == null ? void 0 : ce.call(I, "change", k);
  }), [I, k]), I ? /* @__PURE__ */ dh(rT, {
    children: [/* @__PURE__ */ _n("primitive", {
      ref: C,
      object: I,
      ...S
    }), /* @__PURE__ */ _n(IL, {
      ..._,
      activeTf: "world",
      tfFilter: T,
      ghosts: !0,
      targetRef: D,
      targetSource: e.source,
      targetId: e.key,
      filterActive: !0,
      customProps: {
        ...$
      }
    })]
  }) : null;
}), hM = (a, e) => a.length !== e.length ? !1 : !a.some((t, r) => !ly.exports.isEqual(e[r], t));
function mZ({
  displayTfs: a = !1,
  displayGrid: e = !0,
  isPolar: t = !1,
  backgroundColor: r = "#d0d0d0",
  planeColor: i = "#a8a8a8",
  highlightColor: o = "#00ffff",
  plane: l = 0,
  translateSnap: d = 0,
  rotateSnap: h = 0,
  scaleSnap: m = 0,
  debug: S = !1
}) {
  S && console.log("content rerender");
  const _ = Od((ee) => ee.camera), T = ho((ee) => ee.clock, EM);
  yy(() => {
    T.update();
  });
  const C = ho((ee) => ly.exports.sortBy(Object.entries(ee.tfs).map(([ie, pe]) => ({
    key: ie,
    frame: pe.frame,
    transformMode: pe.transformMode,
    source: "tfs"
  })), (ie) => ie.key), hM), D = ho((ee) => ly.exports.sortBy(Object.entries(ee.items).map(([ie, pe]) => ({
    key: ie,
    frame: pe.frame,
    transformMode: pe.transformMode,
    source: "items"
  })), (ie) => ie.key), hM), P = ho((ee) => ly.exports.sortBy(Object.entries(ee.lines).map(([ie, pe]) => ({
    key: ie,
    frame: pe.frame,
    source: "lines"
  })), (ie) => ie.key), hM), U = ho((ee) => ly.exports.sortBy(Object.entries(ee.hulls).map(([ie, pe]) => ({
    key: ie,
    frame: pe.frame,
    source: "hulls"
  })), (ie) => ie.key), hM), B = ho((ee) => ly.exports.sortBy(Object.entries(ee.texts).map(([ie, pe]) => ({
    key: ie,
    frame: pe.frame,
    source: "texts"
  })), (ie) => ie.key), hM), k = [...D, ...C].filter((ee) => ["translate", "rotate", "scale", "translate-x", "translate-y", "translate-z", "rotate-x", "rotate-y", "rotate-z", "scale-x", "scale-y", "scale-z"].includes(ee.transformMode)), V = uo(), I = uo(), X = uo(), J = uo(), $ = PX(i), W = [$.r, $.g, $.b, 0.5];
  return /* @__PURE__ */ dh(hh.Fragment, {
    children: [/* @__PURE__ */ _n(qY, {
      ref: J,
      makeDefault: !0,
      camera: _
    }), /* @__PURE__ */ _n("pointLight", {
      ref: I,
      intensity: 0.5,
      position: [-1, -3, 3],
      color: "#FFFAEE"
    }), /* @__PURE__ */ _n(DX, {
      ref: V,
      intensity: 0.7,
      color: "white"
    }), /* @__PURE__ */ _n(LX, {
      ref: X,
      castShadow: !0,
      position: [5, 15, 15],
      intensity: 0.6,
      color: "#FFFAEE"
    }), /* @__PURE__ */ _n("spotLight", {
      penumbra: 1,
      position: [-1, -1, 4],
      intensity: 0.3,
      castShadow: !0,
      color: "#FFFAEE"
    }), /* @__PURE__ */ _n("color", {
      attach: "background",
      args: [r]
    }), /* @__PURE__ */ _n("fogExp2", {
      attach: "fog",
      args: [r, 0.01]
    }), /* @__PURE__ */ _n(ZY, {
      receiveShadow: !0,
      scale: 1e3,
      position: [0, 0, l - 0.01],
      material: hy(...W)
    }), /* @__PURE__ */ dh(nZ, {
      children: [/* @__PURE__ */ _n(tZ, {
        autoClear: !1,
        children: /* @__PURE__ */ _n(rZ, {
          visibleEdgeColor: o,
          hiddenEdgeColor: o,
          blur: !0,
          kernelSize: 1,
          edgeStrength: 50,
          pulseSpeed: 0.25,
          xRay: !0
        })
      }), /* @__PURE__ */ _n(IL, {
        activeTf: "world",
        displayTfs: a,
        allTfs: C,
        allItems: D,
        allLines: P,
        allHulls: U,
        allTexts: B,
        highlightColor: o
      })]
    }), /* @__PURE__ */ _n("group", {
      position: [0, 0, l],
      rotation: [Math.PI / 2, 0, 0],
      up: [0, 0, 1],
      children: e && (t ? /* @__PURE__ */ _n("polarGridHelper", {
        args: [10, 16, 8, 64, "white", "gray"]
      }) : /* @__PURE__ */ _n("gridHelper", {
        args: [20, 20, "white", "gray"]
      }))
    }), k.map((ee) => /* @__PURE__ */ _n(pZ, {
      objectInfo: ee,
      mode: ee.transformMode,
      displayTfs: a,
      allTfs: C,
      allItems: D,
      allLines: P,
      allHulls: U,
      allTexts: B,
      translateSnap: d,
      rotateSnap: h,
      scaleSnap: m,
      highlightColor: o,
      onDragEnd: () => {
        J.current && (J.current.enabled = !0);
      },
      onDragStart: () => {
        J.current && (J.current.enabled = !1);
      }
    }, `movableObjectTransform-${ee.key}`))]
  });
}
Xa.DefaultUp.set(0, 0, 1);
const yZ = ({
  onPointerMissed: a = () => {
  },
  backgroundColor: e = "#d0d0d0",
  fov: t = 60,
  children: r
}) => /* @__PURE__ */ _n(P4, {
  camera: {
    up: [0, 0, 1],
    fov: t,
    position: [0, -3, 3]
  },
  shadows: !0,
  style: {
    background: e
  },
  resize: {
    polyfill: I4
  },
  onPointerMissed: a,
  children: r
});
function xZ({
  backgroundColor: a = "#d0d0d0",
  store: e,
  fov: t = 60,
  onPointerMissed: r = () => {
  },
  meshLookup: i = {},
  debug: o = !1,
  ...l
}) {
  return o && console.log("Scene rerender"), /* @__PURE__ */ _n(P4, {
    camera: {
      up: [0, 0, 1],
      fov: t,
      position: [0, -3, 3]
    },
    shadows: !0,
    style: {
      background: a || "#d0d0d0"
    },
    resize: {
      polyfill: I4
    },
    onPointerMissed: r || (() => {
    }),
    children: /* @__PURE__ */ _n(AX, {
      store: e,
      debug: o,
      children: /* @__PURE__ */ _n(sZ, {
        meshes: i,
        children: /* @__PURE__ */ _n(y5, {
          children: /* @__PURE__ */ _n(mZ, {
            ...l,
            backgroundColor: a,
            debug: o
          })
        })
      })
    })
  });
}
export {
  mZ as Content,
  CX as ImmerSceneSlice,
  sZ as MeshProvider,
  yZ as RobotCanvas,
  xZ as Scene,
  AX as SceneProvider,
  TX as SceneSlice,
  ho as innerUseSceneStore,
  RX as useSceneStore
};
